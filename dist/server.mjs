var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// config/base.ts
import * as dotenv from "dotenv";
function getRequiredEnvString(key) {
  const value = process.env[key];
  if (!value || typeof value !== "string") {
    throw new Error(`Environment variable ${key} is required and must be a string`);
  }
  return value;
}
function getEmailStrategy() {
  const val = process.env.EMAIL_STRATEGY;
  if (val !== "smtp-first" && val !== "sendgrid-first") {
    throw new Error(`EMAIL_STRATEGY must be either 'smtp-first' or 'sendgrid-first'`);
  }
  return val;
}
function requireEnv(key) {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Missing required environment variable: ${key}`);
  }
  return value.trim();
}
var requiredEnvVars, missingVars, baseConfig, base_default;
var init_base = __esm({
  "config/base.ts"() {
    dotenv.config();
    requiredEnvVars = [
      "JWT_SECRET",
      "JWT_REFRESH_SECRET",
      "DATABASE_URL"
    ];
    missingVars = requiredEnvVars.filter((varName) => !process.env[varName]);
    if (missingVars.length > 0) {
      console.error(`Variables d'environnement manquantes: ${missingVars.join(", ")}`);
      process.exit(1);
    }
    baseConfig = {
      app: {
        name: "easyrent",
        port: parseInt(process.env.PORT || "3000", 10),
        env: process.env.NODE_ENV || "development",
        frontendUrl: process.env.FRONTEND_URL || "http://192.168.1.66:3000",
        host: process.env.HOST || "localhost"
      },
      network: {
        host: "192.168.1.66"
      },
      auth: {
        jwtSecret: getRequiredEnvString("JWT_SECRET"),
        jwtRefreshSecret: getRequiredEnvString("JWT_REFRESH_SECRET"),
        jwtExpiresIn: process.env.NODE_ENV === "development" ? process.env.JWT_EXPIRES_IN || "2h" : process.env.JWT_EXPIRES_IN || "15m",
        // Court en production
        jwtRefreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || "7d",
        passwordSaltRounds: parseInt(process.env.PASSWORD_SALT_ROUNDS || "10", 10),
        mfaEnabled: process.env.MFA_ENABLED === "true",
        tokenCleanupInterval: process.env.TOKEN_CLEANUP_INTERVAL || "1h",
        maxRefreshTokensPerUser: parseInt(process.env.MAX_REFRESH_TOKENS_PER_USER || "5", 10)
      },
      database: {
        url: getRequiredEnvString("DATABASE_URL"),
        options: {
          useNewUrlParser: true,
          useUnifiedTopology: true
        }
      },
      redis: {
        url: requireEnv("REDIS_URL"),
        maxRetries: parseInt(process.env.REDIS_MAX_RETRIES || "10", 10),
        retryDelay: parseInt(process.env.REDIS_RETRY_DELAY || "1000", 10),
        commandTimeout: parseInt(process.env.REDIS_COMMAND_TIMEOUT || "5000", 10)
      },
      storage: {
        provider: process.env.STORAGE_PROVIDER || "local",
        bucketName: process.env.STORAGE_BUCKET || "easyrent-local"
      },
      // ✅ Configuration email corrigée
      email: {
        strategy: getEmailStrategy(),
        host: process.env.SMTP_HOST,
        port: process.env.SMTP_PORT ? parseInt(process.env.SMTP_PORT, 10) : 587,
        secure: process.env.SMTP_SECURE === "true",
        user: process.env.SMTP_USER,
        password: process.env.SMTP_PASS,
        fromAddress: process.env.SMTP_FROM || "noreply@easyrent.com",
        timeout: parseInt(process.env.SMTP_TIMEOUT || "15000", 10),
        pool: process.env.SMTP_POOL === "true",
        maxConnections: parseInt(process.env.SMTP_MAX_CONNECTIONS || "5", 10),
        enabled: process.env.SMTP_ENABLED !== "false" && !!(process.env.SMTP_HOST && process.env.SMTP_USER && process.env.SMTP_PASS && process.env.SMTP_PORT)
      },
      sendgrid: {
        apiKey: process.env.SENDGRID_API_KEY,
        enabled: process.env.SENDGRID_ENABLED === "true",
        fromAddress: process.env.SENDGRID_FROM_EMAIL || "noreply@easyrent.com"
      },
      webpush: {
        enabled: process.env.WEBPUSH_ENABLED === "true",
        vapidSubject: process.env.VAPID_SUBJECT,
        vapidPublicKey: process.env.VAPID_PUBLIC_KEY,
        vapidPrivateKey: process.env.VAPID_PRIVATE_KEY
      },
      firebase: {
        enabled: process.env.FIREBASE_ENABLED === "true",
        projectId: process.env.FIREBASE_PROJECT_ID,
        serviceAccount: {
          type: process.env.FIREBASE_TYPE,
          project_id: process.env.FIREBASE_PROJECT_ID,
          private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
          private_key: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n"),
          client_email: process.env.FIREBASE_CLIENT_EMAIL,
          client_id: process.env.FIREBASE_CLIENT_ID,
          auth_uri: process.env.FIREBASE_AUTH_URI,
          token_uri: process.env.FIREBASE_TOKEN_URI,
          auth_provider_x509_cert_url: process.env.FIREBASE_AUTH_PROVIDER_X509_CERT_URL,
          client_x509_cert_url: process.env.FIREBASE_CLIENT_X509_CERT_URL,
          univers_domain: process.env.UNIVERSE_DOMAIN
        }
      },
      security: {
        level: process.env.SECURITY_LEVEL || "adaptive",
        rateLimit: {
          windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || "900000", 10),
          max: parseInt(process.env.RATE_LIMIT_MAX || "100", 10)
        }
      },
      logging: {
        level: process.env.LOG_LEVEL || "info",
        format: process.env.LOG_FORMAT || "combined"
      },
      cors: {
        origin: (process.env.CORS_ORIGIN || "http://localhost:3000,http://192.168.1.66:3000").split(",").map((o) => o.trim()),
        methods: ["GET", "POST", "HEAD", "PUT", "PATCH", "DELETE"]
      },
      rateLimit: {
        max: parseInt(process.env.RATE_LIMIT_MAX || "100")
      },
      messageMaxLength: parseInt(process.env.CHAT_MESSAGE_MAX_LENGTH || "10000", 10),
      typingTimeout: parseInt(process.env.TYPING_TIMEOUT || "10000", 10),
      cacheTTL: {
        conversation: 3600,
        userConversations: 300,
        searchIndex: 3600 * 24 * 7,
        patterns: 3600 * 12,
        reactions: 3600 * 24 * 30
      },
      pagination: {
        defaultLimit: 20,
        maxLimit: 100
      },
      encryption: {
        algorithm: "aes-256-gcm",
        ivLength: 16,
        secretKey: Buffer.from(process.env.ENCRYPTION_KEY || "", "hex")
      },
      imageVariants: {
        thumbnail: { width: 150, height: 150, quality: 60 },
        medium: { width: 800, height: 600, quality: 80 },
        large: { width: 1920, height: 1080, quality: 90 }
      }
    };
    base_default = baseConfig;
  }
});

// config/env/developpment.ts
var devConfig, developpment_default;
var init_developpment = __esm({
  "config/env/developpment.ts"() {
    init_base();
    devConfig = {
      app: {
        ...base_default.app,
        frontendUrl: "http://localhost:3000"
      },
      database: {
        ...base_default.database
      },
      security: {
        level: "low",
        rateLimit: {
          windowMs: 15 * 60 * 1e3,
          // 15 minutes
          max: 1e3
          // Limite plus permissive en développement
        }
      },
      logging: {
        level: "debug",
        format: "dev"
      }
    };
    developpment_default = devConfig;
  }
});

// config/env/production.ts
var prodConfig, production_default;
var init_production = __esm({
  "config/env/production.ts"() {
    init_base();
    prodConfig = {
      app: {
        ...base_default.app,
        frontendUrl: process.env.FRONTEND_URL
      },
      database: {
        url: process.env.DATABASE_URL
      },
      security: {
        level: "high",
        rateLimit: {
          windowMs: 15 * 60 * 1e3,
          // 15 minutes
          max: 100
          // Limite plus stricte en production
        }
      },
      logging: {
        level: "warn",
        format: "combined"
      }
    };
    production_default = prodConfig;
  }
});

// config/index.ts
var env, envConfigs, config2, config_default;
var init_config = __esm({
  "config/index.ts"() {
    init_base();
    init_developpment();
    init_production();
    env = process.env.NODE_ENV || "development";
    envConfigs = {
      development: developpment_default,
      production: production_default
    };
    config2 = {
      ...base_default,
      ...envConfigs[env] || {}
    };
    config_default = config2;
  }
});

// src/utils/logger/logger.ts
import * as winston from "winston";
import * as path from "path";
import * as fs from "fs";
import DailyRotateFile from "winston-daily-rotate-file";
var levels, colors, level, customPrintf, consoleFormat, fileFormat, maskSensitiveData, logDir, dailyRotateFileTransport, logger, createLogger2, logger_default;
var init_logger = __esm({
  "src/utils/logger/logger.ts"() {
    levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      debug: 4
    };
    colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "magenta",
      debug: "blue"
    };
    winston.addColors(colors);
    level = () => {
      const env2 = process.env.NODE_ENV || "development";
      return env2 === "development" ? "debug" : "info";
    };
    customPrintf = winston.format.printf((info) => {
      const { timestamp, level: level2, message, ...meta } = info;
      const metaString = Object.keys(meta).length ? `
${JSON.stringify(meta, null, 2)}` : "";
      return `${timestamp} ${level2}: ${message}${metaString}`;
    });
    consoleFormat = winston.format.combine(
      winston.format.colorize({ all: true }),
      winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss:ms" }),
      winston.format.errors({ stack: true }),
      customPrintf
    );
    fileFormat = winston.format.combine(
      winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss:ms" }),
      winston.format.errors({ stack: true }),
      customPrintf
    );
    maskSensitiveData = winston.format((info) => {
      if (typeof info.message === "string") {
        info.message = info.message.replace(/("password"\s*:\s*")([^"]+)(")/g, "$1********$3");
        info.message = info.message.replace(/(Bearer\s+)[^\s]+/g, "$1********");
        info.message = info.message.replace(/(\d{4})[- ]?(\d{4})[- ]?(\d{4})[- ]?(\d{4})/g, "****-****-****-$4");
      }
      return info;
    });
    logDir = "logs";
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir);
    }
    dailyRotateFileTransport = new DailyRotateFile({
      filename: path.join(logDir, "%DATE%-app.log"),
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
      level: "info"
    });
    logger = winston.createLogger({
      level: level(),
      levels,
      format: winston.format.combine(
        maskSensitiveData(),
        fileFormat
      ),
      transports: [
        new winston.transports.Console({ format: consoleFormat }),
        dailyRotateFileTransport,
        new winston.transports.File({ filename: path.join(logDir, "error.log"), level: "error" })
      ],
      exceptionHandlers: [
        new winston.transports.File({ filename: path.join(logDir, "exceptions.log") })
      ],
      rejectionHandlers: [
        new winston.transports.File({ filename: path.join(logDir, "rejections.log") })
      ]
    });
    createLogger2 = (module) => {
      return {
        error: (message, meta) => {
          logger.error(`[${module}] ${message}`, meta);
        },
        warn: (message, meta) => {
          logger.warn(`[${module}] ${message}`, meta);
        },
        info: (message, meta) => {
          logger.info(`[${module}] ${message}`, meta);
        },
        http: (message, meta) => {
          logger.http(`[${module}] ${message}`, meta);
        },
        debug: (message, meta) => {
          logger.debug(`[${module}] ${message}`, meta);
        }
      };
    };
    logger_default = logger;
  }
});

// src/users/types/presenceType.ts
var PresenceStatus;
var init_presenceType = __esm({
  "src/users/types/presenceType.ts"() {
    PresenceStatus = /* @__PURE__ */ ((PresenceStatus2) => {
      PresenceStatus2["ONLINE"] = "online";
      PresenceStatus2["AWAY"] = "away";
      PresenceStatus2["OFFLINE"] = "offline";
      return PresenceStatus2;
    })(PresenceStatus || {});
  }
});

// src/services/appCacheAndPresence.ts
import Redis from "ioredis";
import NodeCache from "node-cache";
var logger2, UserPresenceService, appCacheAndPresence_default;
var init_appCacheAndPresence = __esm({
  "src/services/appCacheAndPresence.ts"() {
    init_logger();
    init_config();
    init_presenceType();
    logger2 = createLogger2("AppCacheAndPresenceService");
    UserPresenceService = class {
      // 10 minutes par défaut pour le cache générique
      constructor() {
        __publicField(this, "redisClient", null);
        __publicField(this, "memoryCache");
        __publicField(this, "redisConnected", false);
        __publicField(this, "connectionAttempts", 0);
        __publicField(this, "maxConnectionAttempts", 5);
        __publicField(this, "reconnectTimeout", null);
        __publicField(this, "isReconnecting", false);
        // Configurations spécifiques à la présence
        __publicField(this, "PRESENCE_REDIS_PREFIX", "user:presence:");
        __publicField(this, "AWAY_TIMEOUT", 120);
        // 2 minutes (au lieu de 5, pour une réactivité mobile)
        __publicField(this, "OFFLINE_TIMEOUT", 900);
        // 15 minutes
        __publicField(this, "PRESENCE_TTL", 86400);
        // 24 heures pour les entrées de présence
        // Configurations spécifiques au cache générique
        __publicField(this, "CACHE_REDIS_PREFIX", "app_cache:");
        __publicField(this, "DEFAULT_CACHE_TTL", 600);
        this.initRedisClient();
        this.memoryCache = new NodeCache({
          stdTTL: this.DEFAULT_CACHE_TTL,
          // TTL par défaut pour le cache mémoire
          checkperiod: 60,
          maxKeys: 1e5,
          // Augmenter le nombre de clés pour un gros projet
          deleteOnExpire: true
        });
        this.memoryCache.on("expired", (key, value) => {
          logger2.debug(`Memory cache key expired: ${key}`);
        });
      }
      /**
       * Initialise la connexion Redis avec ioredis.
       * Gère les reconnexions et le statut de connexion.
      //  */
      getRedisClient() {
        return this.redisClient;
      }
      /**
        * Initialise la connexion Redis avec ioredis.
        */
      initRedisClient() {
        if (!config_default.redis?.url) {
          logger2.warn("Redis URL not configured, using memory cache only for cache operations.");
          this.redisConnected = false;
          return;
        }
        if (this.redisClient) {
          logger2.warn("Redis client already initialized");
          return;
        }
        try {
          this.redisClient = new Redis(config_default.redis.url, {
            connectTimeout: 15e3,
            lazyConnect: true,
            // Don't connect immediately
            enableReadyCheck: true,
            maxRetriesPerRequest: 3,
            // Réduit pour éviter les boucles
            enableOfflineQueue: false,
            // Désactiver la queue en mode offline
            keepAlive: 3e4,
            family: 4,
            retryStrategy: (times) => {
              logger2.warn(`Redis connection attempt ${times} failed, NOT retrying automatically`);
              this.redisConnected = false;
              return null;
            },
            reconnectOnError: () => {
              return false;
            },
            tls: config_default.redis.url.startsWith("rediss://") ? {
              rejectUnauthorized: false
            } : void 0,
            commandTimeout: 5e3
          });
          this.setupRedisEventHandlers();
          this.connectToRedis().catch((err) => {
            logger2.error("Error in initial Redis connection", {
              error: err instanceof Error ? err.message : "Unknown error"
            });
          });
        } catch (error2) {
          logger2.error("Error initializing Redis client", {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          this.redisConnected = false;
        }
      }
      /**
       * Configure les gestionnaires d'événements Redis
       */
      setupRedisEventHandlers() {
        if (!this.redisClient) return;
        this.redisClient.on("connect", () => {
          logger2.info("Redis client connected successfully");
          this.redisConnected = true;
          this.connectionAttempts = 0;
          this.isReconnecting = false;
          this.clearReconnectionTimeout();
        });
        this.redisClient.on("ready", () => {
          logger2.info("Redis client ready");
          this.redisConnected = true;
          this.connectionAttempts = 0;
        });
        this.redisClient.on("error", (err) => {
          logger2.error("Redis client error", {
            error: err.message,
            type: err.name,
            code: err.code
          });
          this.redisConnected = false;
        });
        this.redisClient.on("close", () => {
          logger2.warn("Redis client connection closed");
          this.redisConnected = false;
        });
        this.redisClient.on("reconnecting", (delay) => {
          this.connectionAttempts++;
          this.isReconnecting = true;
          logger2.info(`Redis client reconnecting... (attempt ${this.connectionAttempts}, delay: ${delay}ms)`);
        });
        this.redisClient.on("end", () => {
          logger2.warn("Redis client connection ended");
          this.redisConnected = false;
        });
      }
      isTemporaryError(err) {
        const temporaryErrors = ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EHOSTUNREACH"];
        return temporaryErrors.some(
          (errorType) => err.message.includes(errorType) || err.code === errorType
        );
      }
      /**
      * Programme une reconnexion différée
      */
      scheduleReconnection() {
        if (this.reconnectTimeout || this.isReconnecting) {
          return;
        }
        const delay = Math.min(this.connectionAttempts * 2e3, 3e4);
        logger2.info(`Scheduling Redis reconnection in ${delay}ms`);
        this.reconnectTimeout = setTimeout(() => {
          this.reconnectTimeout = null;
          this.attemptReconnection();
        }, delay);
      }
      /**
       * Tente une reconnexion manuelle
       */
      async attemptReconnection() {
        if (this.isReconnecting || this.redisConnected) {
          return;
        }
        if (this.connectionAttempts >= this.maxConnectionAttempts) {
          logger2.error("Max reconnection attempts reached, giving up");
          return;
        }
        this.isReconnecting = true;
        logger2.info("Attempting manual Redis reconnection...");
        try {
          if (this.redisClient) {
            this.redisClient.removeAllListeners();
            await this.redisClient.disconnect();
          }
          this.redisClient = null;
          this.initRedisClient();
        } catch (error2) {
          logger2.error("Manual reconnection failed", {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          this.isReconnecting = false;
        }
      }
      /**
       * Nettoie le timeout de reconnexion
       */
      clearReconnectionTimeout() {
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
      }
      /**
       * Connecte à Redis de manière asynchrone
       */
      async connectToRedis() {
        if (!this.redisClient) return;
        try {
          if (this.redisClient.status === "end" || this.redisClient.status === "close") {
            logger2.warn("Redis client already closed, skipping connection attempt");
            this.redisConnected = false;
            return;
          }
          await this.redisClient.connect();
          logger2.info("Redis connection established successfully");
          this.redisConnected = true;
        } catch (error2) {
          logger2.error("Failed to connect to Redis during initial connection", {
            error: error2 instanceof Error ? error2.message : "Unknown error",
            attempts: this.connectionAttempts,
            status: this.redisClient?.status
          });
          this.redisConnected = false;
        }
      }
      /**
       * Exécute une opération Redis avec retry automatique
       */
      async executeRedisOperation(operation, fallback, operationName = "Redis operation") {
        if (!this.isRedisConnected() || !this.redisClient) {
          if (fallback) {
            logger2.debug(`${operationName}: Redis not available, using fallback`);
            return fallback();
          }
          return null;
        }
        try {
          return await operation();
        } catch (error2) {
          logger2.error(`${operationName} failed`, {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          if (this.isConnectionError(error2)) {
            this.redisConnected = false;
          }
          if (fallback) {
            logger2.debug(`Using fallback for ${operationName}`);
            return fallback();
          }
          return null;
        }
      }
      /**
        * Vérifie si l'erreur est liée à la connexion
        */
      isConnectionError(error2) {
        const connectionErrors = [
          "ECONNRESET",
          "ETIMEDOUT",
          "ENOTFOUND",
          "EHOSTUNREACH",
          "Connection is closed",
          "Connection timeout"
        ];
        return connectionErrors.some(
          (errorType) => error2.message?.includes(errorType) || error2.code === errorType
        );
      }
      /**
       * Met à jour le statut de présence d'un utilisateur.
       * Utilise Redis pour la persistance.
       * @param userId - ID de l'utilisateur
       * @param status - Nouveau statut (optionnel, par défaut ONLINE)
       * @param deviceInfo - Informations sur l'appareil
       */
      // async updatePresence(
      //   userId: string,
      //   status: PresenceStatus = PresenceStatus.ONLINE,
      //   deviceInfo?: { ip?: string; userAgent?: string; deviceId?: string }
      // ): Promise<void> {
      //   if (!userId) {
      //     logger.warn('Cannot update presence for undefined userId');
      //     return;
      //   }
      //   const presenceKey = `${this.PRESENCE_REDIS_PREFIX}${userId}`;
      //   const now = new Date();
      //   const presenceData: UserPresence = {
      //     userId,
      //     status,
      //     lastActive: now, // Stockage comme Date object
      //     deviceInfo
      //   };
      //   const serializedData = JSON.stringify({
      //     ...presenceData,
      //     lastActive: presenceData.lastActive.toISOString()
      //   });
      //   try {
      //     if (this.isRedisConnected() && this.redisClient) {
      //       await this.redisClient.setex(
      //         presenceKey,
      //         this.PRESENCE_TTL,
      //         serializedData
      //       );
      //       logger.debug('User presence updated in Redis', { userId, status });
      //     } else {
      //       // En cas de déconnexion Redis, stocker aussi dans le cache mémoire pour un fallback très court terme
      //       this.memoryCache.set(presenceKey,serializedData, this.PRESENCE_TTL);
      //       logger.warn('Redis disconnected, user presence updated in memory cache (non-persistent)', { userId, status });
      //     }
      //   } catch (error) {
      //     logger.error('Error updating user presence in Redis', {
      //       userId,
      //       error: error instanceof Error ? error.message : 'Unknown error'
      //     });
      //     // Fallback vers le cache mémoire en cas d'erreur Redis pendant l'opération
      //     this.memoryCache.set(presenceKey, serializedData, this.PRESENCE_TTL);
      //   }
      // }
      async updatePresence(userId, status = "online" /* ONLINE */, deviceInfo) {
        if (!userId) {
          logger2.warn("Cannot update presence for undefined userId");
          return;
        }
        const presenceKey = `${this.PRESENCE_REDIS_PREFIX}${userId}`;
        const now = /* @__PURE__ */ new Date();
        const presenceData = {
          userId,
          status,
          lastActive: now,
          deviceInfo
        };
        const serializedData = JSON.stringify({
          ...presenceData,
          lastActive: presenceData.lastActive.toISOString()
        });
        await this.executeRedisOperation(
          async () => {
            await this.redisClient.setex(presenceKey, this.PRESENCE_TTL, serializedData);
            logger2.debug("User presence updated in Redis", { userId, status });
          },
          () => {
            this.memoryCache.set(presenceKey, serializedData, this.PRESENCE_TTL);
            logger2.warn("Redis unavailable, user presence updated in memory cache", { userId, status });
          },
          "updatePresence"
        );
      }
      /**
       * Récupère les informations de présence d'un utilisateur.
       * Vérifie d'abord Redis, puis le cache mémoire.
       * @param userId - ID de l'utilisateur
       * @returns Informations de présence ou null si non trouvées
       */
      async getUserPresence(userId) {
        if (!userId) {
          logger2.warn("Cannot get presence for undefined userId");
          return null;
        }
        const presenceKey = `${this.PRESENCE_REDIS_PREFIX}${userId}`;
        let presenceData = null;
        try {
          if (this.isRedisConnected() && this.redisClient) {
            presenceData = await this.redisClient.get(presenceKey);
            if (presenceData) {
              logger2.debug("User presence retrieved from Redis", { userId });
            }
          }
        } catch (error2) {
          logger2.error("Error getting user presence from Redis, trying memory cache", {
            userId,
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
        }
        if (!presenceData) {
          presenceData = this.memoryCache.get(presenceKey);
          if (presenceData) {
            logger2.debug("User presence retrieved from memory cache", { userId });
          }
        }
        if (!presenceData) {
          return null;
        }
        try {
          const parsedData = JSON.parse(presenceData);
          const presence = {
            ...parsedData,
            lastActive: new Date(parsedData.lastActive)
            // Convertir en Date object
          };
          return this.calculateCurrentStatus(presence);
          ;
        } catch (parseError) {
          logger2.error("Error parsing user presence data", {
            userId,
            data: presenceData,
            error: parseError instanceof Error ? parseError.message : "Unknown parse error"
          });
          return null;
        }
      }
      /**
       * Vérifie si un utilisateur est en ligne.
       * MISSING METHOD - This is what was causing the error
       */
      async isUserOnline(userId) {
        try {
          const presence = await this.getUserPresence(userId);
          return presence?.status === "online" /* ONLINE */ || presence?.status === "away" /* AWAY */;
        } catch (error2) {
          logger2.error("Error checking if user is online", {
            userId,
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          return false;
        }
      }
      /**
       * Version synchrone pour vérifier si un utilisateur est en ligne (utilise le cache mémoire uniquement)
       */
      isUserOnlineSync(userId) {
        try {
          const presenceKey = `${this.PRESENCE_REDIS_PREFIX}${userId}`;
          const presenceData = this.memoryCache.get(presenceKey);
          if (!presenceData) return false;
          const parsedData = JSON.parse(presenceData);
          const presence = {
            ...parsedData,
            lastActive: new Date(parsedData.lastActive)
          };
          const updatedPresence = this.calculateCurrentStatus(presence);
          return updatedPresence.status === "online" /* ONLINE */ || updatedPresence.status === "away" /* AWAY */;
        } catch (error2) {
          logger2.error("Error checking if user is online (sync)", {
            userId,
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          return false;
        }
      }
      /**
       * Marque un utilisateur comme hors ligne.
       * @param userId - ID de l'utilisateur
       */
      async setUserOffline(userId) {
        try {
          await this.updatePresence(userId, "offline" /* OFFLINE */);
          logger2.info("User marked as offline", { userId });
        } catch (error2) {
          logger2.error("Error setting user offline", {
            userId,
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
        }
      }
      /**
       * Récupère les utilisateurs en ligne (et potentiellement "away").
       * @param userIds - Liste d'IDs d'utilisateurs à vérifier (optionnel)
       * @returns Map d'utilisateurs avec leur statut de présence
       */
      async getOnlineUsers(userIds) {
        const onlineUsers = /* @__PURE__ */ new Map();
        try {
          if (userIds && userIds.length > 0) {
            const presenceKeys = userIds.map((id) => `${this.PRESENCE_REDIS_PREFIX}${id}`);
            let values = [];
            if (this.isRedisConnected() && this.redisClient) {
              values = await this.redisClient.mget(...presenceKeys);
              logger2.debug(`Retrieved ${values.length} user presences from Redis (mget)`);
            } else {
              values = presenceKeys.map((key) => this.memoryCache.get(key));
              logger2.warn("Redis disconnected, retrieving specific user presences from memory cache");
            }
            userIds.forEach((id, index) => {
              const presenceData = values[index];
              if (presenceData) {
                try {
                  const parsedData = JSON.parse(presenceData);
                  const presence = {
                    ...parsedData,
                    lastActive: new Date(parsedData.lastActive)
                  };
                  const updatedPresence = this.calculateCurrentStatus(presence);
                  if (updatedPresence.status !== "offline" /* OFFLINE */) {
                    onlineUsers.set(updatedPresence.userId, updatedPresence);
                  }
                } catch (parseError) {
                  logger2.error("Error parsing presence data for online users", {
                    userId: id,
                    data: presenceData,
                    error: parseError instanceof Error ? parseError.message : "Unknown parse error"
                  });
                }
              }
            });
          } else {
            let keys = [];
            if (this.isRedisConnected() && this.redisClient) {
              keys = await this.redisClient.keys(`${this.PRESENCE_REDIS_PREFIX}*`);
              logger2.debug(`Found ${keys.length} presence keys in Redis`);
            } else {
              keys = this.memoryCache.keys().filter((key) => key.startsWith(this.PRESENCE_REDIS_PREFIX));
              logger2.warn("Redis disconnected, cannot get all online users from Redis. Limited to memory cache.");
            }
            if (keys.length > 0) {
              let values = [];
              if (this.isRedisConnected() && this.redisClient) {
                values = await this.redisClient.mget(...keys);
              } else {
                values = keys.map((key) => this.memoryCache.get(key));
              }
              keys.forEach((key, index) => {
                if (values[index]) {
                  try {
                    const parsedData = JSON.parse(values[index]);
                    const presence = {
                      ...parsedData,
                      lastActive: new Date(parsedData.lastActive)
                    };
                    const updatedPresence = this.calculateCurrentStatus(presence);
                    if (updatedPresence.status !== "offline" /* OFFLINE */) {
                      onlineUsers.set(updatedPresence.userId, updatedPresence);
                    }
                  } catch (parseError) {
                    logger2.error("Error parsing presence data for all users", {
                      key,
                      data: values[index],
                      error: parseError instanceof Error ? parseError.message : "Unknown parse error"
                    });
                  }
                }
              });
            }
          }
          return onlineUsers;
        } catch (error2) {
          logger2.error("Error getting online users", {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
          return onlineUsers;
        }
      }
      /**
       * Calcule le statut actuel en fonction du temps d'inactivité.
       * @param presence - Informations de présence enregistrées
       * @returns Informations de présence mises à jour
       */
      calculateCurrentStatus(presence) {
        const now = /* @__PURE__ */ new Date();
        const lastActive = presence.lastActive;
        const inactiveSeconds = Math.floor((now.getTime() - lastActive.getTime()) / 1e3);
        if (presence.status === "offline" /* OFFLINE */) {
          return presence;
        }
        if (inactiveSeconds > this.OFFLINE_TIMEOUT) {
          presence.status = "offline" /* OFFLINE */;
        } else if (inactiveSeconds > this.AWAY_TIMEOUT) {
          presence.status = "away" /* AWAY */;
        }
        return presence;
      }
      // --- Méthodes de Gestion du Cache Générique ---
      /**
       * Construit la clé de cache avec le préfixe.
       */
      getCacheKey(key) {
        return `${this.CACHE_REDIS_PREFIX}${key}`;
      }
      /**
       * Stocke une valeur dans le cache (Redis > NodeCache).
       * @param key - Clé de cache
       * @param value - Valeur à stocker
       * @param ttl - Durée de vie en secondes (par défaut: DEFAULT_CACHE_TTL)
       */
      async set(key, value, ttl = this.DEFAULT_CACHE_TTL) {
        const prefixedKey = this.getCacheKey(key);
        const serializedValue = JSON.stringify(value);
        try {
          if (this.isRedisConnected() && this.redisClient) {
            await this.redisClient.setex(prefixedKey, ttl, serializedValue);
            logger2.debug(`Cache set in Redis: ${key}`);
            return true;
          } else {
            this.memoryCache.set(prefixedKey, serializedValue, ttl);
            logger2.warn(`Redis disconnected, cache set in memory: ${key}`);
            return false;
          }
        } catch (error2) {
          logger2.error(`Error setting cache for ${key}`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
          this.memoryCache.set(prefixedKey, serializedValue, ttl);
          return false;
        }
      }
      /**
       * Récupère une valeur du cache (Redis > NodeCache).
       * @param key - Clé de cache
       * @returns Valeur ou null si non trouvée
       */
      async get(key) {
        const prefixedKey = this.getCacheKey(key);
        let value = null;
        try {
          if (this.isRedisConnected() && this.redisClient) {
            value = await this.redisClient.get(prefixedKey);
            if (value) {
              logger2.debug(`Cache retrieved from Redis: ${key}`);
            }
          }
        } catch (error2) {
          logger2.error(`Error getting cache from Redis for ${key}, trying memory cache`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
        }
        if (!value) {
          value = this.memoryCache.get(prefixedKey);
          if (value) {
            logger2.debug(`Cache retrieved from memory: ${key}`);
          }
        }
        return value ? JSON.parse(value) : null;
      }
      /**
       * Supprime une clé du cache.
       * @param key - Clé à supprimer
       */
      async delete(key) {
        const prefixedKey = this.getCacheKey(key);
        let success = false;
        try {
          if (this.redisConnected && this.redisClient) {
            await this.redisClient.del(prefixedKey);
            success = true;
            logger2.debug(`Cache deleted from Redis: ${key}`);
          }
        } catch (error2) {
          logger2.error(`Error deleting cache for ${key}`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
        }
        this.memoryCache.del(prefixedKey);
        logger2.debug(`Cache deleted from memory: ${key}`);
        return success;
      }
      /**
       * Supprime plusieurs clés du cache selon un pattern.
       * @param pattern - Pattern de clés (ex: 'user:*')
       */
      async deletePattern(pattern) {
        const prefixedPattern = `${this.CACHE_REDIS_PREFIX}${pattern}`;
        let totalDeletedKeys = 0;
        try {
          if (this.redisConnected && this.redisClient) {
            let cursor = "0";
            const batchSize = 100;
            const deleteBatchSize = 50;
            let keysBuffer = [];
            do {
              const scanResult = await this.redisClient.scan(
                cursor,
                "MATCH",
                prefixedPattern,
                "COUNT",
                batchSize
              );
              cursor = scanResult[0];
              const matchedKeys = scanResult[1];
              if (matchedKeys && matchedKeys.length > 0) {
                keysBuffer.push(...matchedKeys);
                while (keysBuffer.length >= deleteBatchSize) {
                  const batchToDelete = keysBuffer.splice(0, deleteBatchSize);
                  const deletedCount = await this.redisClient.del(...batchToDelete);
                  totalDeletedKeys += deletedCount;
                  logger2.debug(`Deleted batch: ${deletedCount}/${batchToDelete.length} keys from Redis`);
                }
              }
              if (cursor !== "0") {
                await new Promise((resolve) => setTimeout(resolve, 1));
              }
            } while (cursor !== "0");
            if (keysBuffer.length > 0) {
              const deletedCount = await this.redisClient.del(...keysBuffer);
              totalDeletedKeys += deletedCount;
              logger2.debug(`Deleted final batch: ${deletedCount}/${keysBuffer.length} keys from Redis`);
            }
            logger2.info(`Successfully deleted ${totalDeletedKeys} keys from Redis matching pattern: ${pattern}`);
          } else {
            logger2.warn("Redis disconnected, only processing memory cache.");
          }
          try {
            const memKeys = this.memoryCache.keys();
            const regex = new RegExp(prefixedPattern.replace(/\*/g, ".*").replace(/\?/g, "."));
            const matchingMemKeys = memKeys.filter((k) => regex.test(k));
            matchingMemKeys.forEach((k) => this.memoryCache.del(k));
            logger2.info(`Cache cleanup completed - Redis: ${totalDeletedKeys} keys, Memory: ${matchingMemKeys.length} keys for pattern: ${pattern}`);
          } catch (memError) {
            logger2.warn("Error cleaning memory cache, continuing...", { error: memError });
          }
          return true;
        } catch (error2) {
          logger2.error(`Error deleting cache by pattern ${pattern}`, {
            error: error2 instanceof Error ? error2.message : "Unknown error",
            deletedSoFar: totalDeletedKeys
          });
          return false;
        }
      }
      /**
       * Vérifie si une clé existe.
       * @param key - Clé à vérifier
       */
      async exists(key) {
        const prefixedKey = this.getCacheKey(key);
        try {
          if (this.isRedisConnected() && this.redisClient) {
            const exists = await this.redisClient.exists(prefixedKey);
            return exists === 1;
          }
          return this.memoryCache.has(prefixedKey);
        } catch (error2) {
          logger2.error(`Error checking existence for ${key}`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return this.memoryCache.has(prefixedKey);
        }
      }
      /**
       * Incrémente une valeur numérique.
       * @param key - Clé numérique
       * @param value - Valeur à incrémenter (par défaut: 1)
       * @param ttl - Durée de vie en secondes (par défaut: DEFAULT_CACHE_TTL)
       * @returns Nouvelle valeur ou null en cas d'erreur
       */
      async increment(key, value = 1, ttl = this.DEFAULT_CACHE_TTL) {
        const prefixedKey = this.getCacheKey(key);
        try {
          if (this.redisConnected && this.redisClient) {
            const result = await this.redisClient.incrby(prefixedKey, value);
            if (ttl) {
              await this.redisClient.expire(prefixedKey, ttl);
            }
            return result;
          } else {
            let current = this.memoryCache.get(prefixedKey) || "0";
            if (typeof current === "string") {
              current = parseInt(current, 10);
            }
            const newValue = current + value;
            this.memoryCache.set(prefixedKey, newValue.toString(), ttl);
            return newValue;
          }
        } catch (error2) {
          logger2.error(`Error incrementing ${key}`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return null;
        }
      }
      /**
       * Récupère ou définit une valeur avec un callback de génération.
       * @param key - Clé de cache
       * @param generator - Fonction asynchrone pour générer la valeur si elle n'existe pas
       * @param ttl - Durée de vie en secondes
       * @returns Valeur récupérée ou générée
       */
      async getOrSet(key, generator, ttl = this.DEFAULT_CACHE_TTL) {
        try {
          const existing = await this.get(key);
          if (existing !== null) {
            return existing;
          }
          const value = await generator();
          await this.set(key, value, ttl);
          return value;
        } catch (error2) {
          logger2.error(`Error in getOrSet for ${key}`, { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return null;
        }
      }
      /**
       * Stockage en lot (batch) pour plusieurs clés.
       * @param keyValuePairs - Objet de paires clé-valeur
       * @param ttl - Durée de vie en secondes
       */
      async mSet(keyValuePairs, ttl = this.DEFAULT_CACHE_TTL) {
        try {
          if (this.redisConnected && this.redisClient) {
            const pipeline = this.redisClient.pipeline();
            for (const [key, value] of Object.entries(keyValuePairs)) {
              const prefixedKey = this.getCacheKey(key);
              const serializedValue = JSON.stringify(value);
              pipeline.setex(prefixedKey, ttl, serializedValue);
            }
            await pipeline.exec();
            logger2.debug(`Batch set in Redis for ${Object.keys(keyValuePairs).length} keys`);
          } else {
            for (const [key, value] of Object.entries(keyValuePairs)) {
              const prefixedKey = this.getCacheKey(key);
              const serializedValue = JSON.stringify(value);
              this.memoryCache.set(prefixedKey, serializedValue, ttl);
            }
            logger2.warn(`Redis disconnected, batch set in memory for ${Object.keys(keyValuePairs).length} keys`);
          }
          return true;
        } catch (error2) {
          logger2.error("Error during batch set", { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return false;
        }
      }
      /**
       * Récupération en lot (batch) pour plusieurs clés.
       * @param keys - Tableau de clés à récupérer
       */
      async mGet(keys) {
        const result = {};
        const prefixedKeys = keys.map((key) => this.getCacheKey(key));
        try {
          let values = [];
          if (this.redisConnected && this.redisClient) {
            values = await this.redisClient.mget(...prefixedKeys);
            logger2.debug(`Batch get from Redis for ${keys.length} keys`);
          } else {
            values = prefixedKeys.map((key) => this.memoryCache.get(key));
            logger2.warn(`Redis disconnected, batch get from memory for ${keys.length} keys`);
          }
          keys.forEach((originalKey, index) => {
            const value = values[index];
            result[originalKey] = value ? JSON.parse(value) : null;
          });
          return result;
        } catch (error2) {
          logger2.error("Error during batch get", { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return {};
        }
      }
      /**
       * Ferme les connexions Redis et le cache mémoire.
       */
      async close() {
        try {
          this.clearReconnectionTimeout();
          if (this.redisClient) {
            this.redisClient.removeAllListeners();
            await this.redisClient.quit();
            logger2.info("Redis client connection closed");
          }
          if (this.memoryCache) {
            this.memoryCache.close();
            logger2.info("Memory cache closed");
          }
        } catch (error2) {
          logger2.error("Error closing cache connections", {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
        }
      }
      /**
       * Supprime une valeur du cache.
       */
      async del(key) {
        const prefixedKey = this.getCacheKey(key);
        let success = false;
        try {
          if (this.isRedisConnected() && this.redisClient) {
            await this.redisClient.del(prefixedKey);
            success = true;
            logger2.debug(`Cache deleted from Redis: ${key}`);
          }
        } catch (error2) {
          logger2.error(`Error deleting cache from Redis for ${key}`, {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
        }
        this.memoryCache.del(prefixedKey);
        return success;
      }
      /**
       * Vérifie le statut de connexion Redis.
       */
      isRedisConnected() {
        return this.redisConnected && this.redisClient?.status === "ready" && !this.isReconnecting;
      }
      /**
       * Obtient des statistiques de connexion Redis
       */
      getRedisStats() {
        return {
          connected: this.redisConnected,
          status: this.redisClient?.status || "not_initialized",
          connectionAttempts: this.connectionAttempts,
          isReconnecting: this.isReconnecting
        };
      }
      /**
       * Force une reconnexion Redis
       */
      async forceReconnect() {
        logger2.info("Forcing Redis reconnection...");
        this.connectionAttempts = 0;
        await this.attemptReconnection();
        return this.isRedisConnected();
      }
    };
    appCacheAndPresence_default = UserPresenceService;
  }
});

// src/services/redisInstance.ts
var appCacheAndPresenceService, redisInstance_default;
var init_redisInstance = __esm({
  "src/services/redisInstance.ts"() {
    init_appCacheAndPresence();
    appCacheAndPresenceService = new appCacheAndPresence_default();
    redisInstance_default = appCacheAndPresenceService;
  }
});

// src/users/types/userTypes.ts
var UserRole, VerificationStatus;
var init_userTypes = __esm({
  "src/users/types/userTypes.ts"() {
    UserRole = /* @__PURE__ */ ((UserRole2) => {
      UserRole2["CLIENT"] = "client";
      UserRole2["AGENT"] = "agent";
      UserRole2["ADMIN"] = "admin";
      UserRole2["SUPER_ADMIN"] = "super_admin";
      return UserRole2;
    })(UserRole || {});
    VerificationStatus = /* @__PURE__ */ ((VerificationStatus2) => {
      VerificationStatus2["UNVERIFIED"] = "unverified";
      VerificationStatus2["PENDING"] = "pending";
      VerificationStatus2["VERIFIED"] = "verified";
      VerificationStatus2["REJECTED"] = "rejected";
      return VerificationStatus2;
    })(VerificationStatus || {});
  }
});

// src/users/models/agentDetailsSchema.ts
import { Schema } from "mongoose";
var AgentDetailsSchema, agentDetailsSchema_default;
var init_agentDetailsSchema = __esm({
  "src/users/models/agentDetailsSchema.ts"() {
    init_userTypes();
    AgentDetailsSchema = new Schema({
      licenseNumber: {
        type: String,
        required: true
      },
      licenseExpiryDate: {
        type: Date,
        required: true
      },
      agency: {
        type: String,
        required: true
      },
      specializations: [{
        type: String
      }],
      yearsOfExperience: {
        type: Number,
        default: 0
      },
      verificationStatus: {
        type: String,
        enum: Object.values(VerificationStatus),
        default: "unverified" /* UNVERIFIED */
      },
      verificationDocuments: [{
        type: String
      }],
      verificationDate: {
        type: Date
      },
      rating: {
        type: Number,
        min: 0,
        max: 5
      },
      reviewCount: {
        type: Number,
        default: 0
      }
    });
    agentDetailsSchema_default = AgentDetailsSchema;
  }
});

// src/users/models/userPreferenceSchema.ts
import { Schema as Schema2 } from "mongoose";
var UserPreferencesSchema, userPreferenceSchema_default;
var init_userPreferenceSchema = __esm({
  "src/users/models/userPreferenceSchema.ts"() {
    UserPreferencesSchema = new Schema2({
      theme: {
        type: String,
        enum: ["light", "dark", "system"],
        default: "system"
      },
      language: {
        type: String,
        default: "fr"
      },
      emailNotifications: {
        type: Boolean,
        default: true
      },
      pushNotifications: {
        type: Boolean,
        default: false
      },
      smsNotifications: {
        type: Boolean,
        default: false
      },
      twoFactorEnabled: {
        type: Boolean,
        default: false
      },
      marketingCommunications: {
        type: Boolean,
        default: false
      }
    });
    userPreferenceSchema_default = UserPreferencesSchema;
  }
});

// src/users/models/loginHistorySchema.ts
import { Schema as Schema3 } from "mongoose";
var LoginHistorySchema, loginHistorySchema_default;
var init_loginHistorySchema = __esm({
  "src/users/models/loginHistorySchema.ts"() {
    LoginHistorySchema = new Schema3({
      timestamp: {
        type: Date,
        default: Date.now
      },
      ipAddress: {
        type: String,
        required: true
      },
      userAgent: {
        type: String,
        required: true
      },
      location: String,
      deviceId: String,
      successful: {
        type: Boolean,
        required: true
      }
    });
    loginHistorySchema_default = LoginHistorySchema;
  }
});

// src/users/utils/comparePassword.ts
import bcrypt from "bcrypt";
var logger4, PasswordUtils;
var init_comparePassword = __esm({
  "src/users/utils/comparePassword.ts"() {
    init_logger();
    logger4 = createLogger2("PasswordUtils");
    PasswordUtils = class {
      /**
       * Compare un mot de passe avec son hash
       * @param candidatePassword - Mot de passe en clair
       * @param hashedPassword - Hash du mot de passe
       * @returns Promise<boolean>
       */
      static async comparePassword(candidatePassword, hashedPassword) {
        try {
          console.log("le mot de  pass en realiter  dans  la base de donner  est :", candidatePassword);
          console.log("voicie  le mot de  passse  hasher  :", hashedPassword);
          if (!candidatePassword || typeof candidatePassword !== "string") {
            logger4.warn("Mot de passe candidat invalide ou manquant");
            return false;
          }
          if (!hashedPassword || typeof hashedPassword !== "string") {
            logger4.warn("Hash de mot de passe invalide ou manquant");
            return false;
          }
          const test2 = await bcrypt.compare("MotDePasse123!", "$2b$12$tA90TrjJ4Ympkp5B20y9jeiZDNxY1arR0N/pw5nuRgcredXLIFdQG");
          console.log("my compare password  test is  :", test2);
          if (!hashedPassword.startsWith("$2b$") && !hashedPassword.startsWith("$2a$")) {
            logger4.error("Format de hash bcrypt invalide");
            return false;
          }
          logger4.debug("Comparaison mot de passe", {
            candidateLength: candidatePassword.length,
            hashLength: hashedPassword.length,
            hashPrefix: hashedPassword.substring(0, 7)
          });
          this.runAllTests();
          const isMatch = await bcrypt.compare(candidatePassword, hashedPassword);
          console.log("user  password comparison", isMatch);
          logger4.info("R\xE9sultat comparaison mot de passe", {
            success: isMatch,
            candidateLength: candidatePassword.length
          });
          return isMatch;
        } catch (error2) {
          logger4.error("Erreur lors de la comparaison des mots de passe", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            stack: error2 instanceof Error ? error2.stack : void 0
          });
          return false;
        }
      }
      /**
       * Hash un mot de passe
       * @param password - Mot de passe en clair
       * @param saltRounds - Nombre de rounds de salt (défaut: 12)
       * @returns Promise<string>
       */
      static async hashPassword(password) {
        try {
          if (!password || typeof password !== "string") {
            throw new Error("Mot de passe invalide");
          }
          const salt = await bcrypt.genSalt(12);
          return await bcrypt.hash(password, salt);
        } catch (error2) {
          logger4.error("Erreur lors du hashage du mot de passe", { error: error2 });
          throw new Error("Impossible de hasher le mot de passe");
        }
      }
      static async testExactPassword() {
        const plainPassword = "MotDePasse123!";
        const storedHash = "$2b$12$tA90TrjJ4Ympkp5B20y9jeiZDNxY1arR0N/pw5nuRgcredXLIFdQG";
        console.log("=== TEST BCRYPT ===");
        console.log("Mot de passe:", plainPassword);
        console.log("Hash stock\xE9:", storedHash);
        console.log("Longueur mot de passe:", plainPassword.length);
        console.log("Longueur hash:", storedHash.length);
        try {
          console.log("\n--- Test bcrypt.compare ---");
          const result1 = await bcrypt.compare(plainPassword, storedHash);
          console.log("R\xE9sultat bcrypt.compare:", result1);
          console.log("\n--- Test nouveau hash ---");
          const newHash = await bcrypt.hash(plainPassword, 12);
          console.log("Nouveau hash:", newHash);
          const result2 = await bcrypt.compare(plainPassword, newHash);
          console.log("R\xE9sultat avec nouveau hash:", result2);
          console.log("\n--- Analyse caract\xE8re par caract\xE8re ---");
          console.log("Premiers caract\xE8res du mot de passe:");
          for (let i = 0; i < Math.min(plainPassword.length, 10); i++) {
            console.log(`  [${i}]: "${plainPassword[i]}" (code: ${plainPassword.charCodeAt(i)})`);
          }
          console.log("\n--- Test avec trim ---");
          const trimmedPassword = plainPassword.trim();
          console.log("Mot de passe trim\xE9:", `"${trimmedPassword}"`);
          const result3 = await bcrypt.compare(trimmedPassword, storedHash);
          console.log("R\xE9sultat avec trim:", result3);
          console.log("\n--- Test encodage ---");
          const buffer = Buffer.from(plainPassword, "utf8");
          const passwordFromBuffer = buffer.toString("utf8");
          console.log("Password depuis buffer:", passwordFromBuffer);
          const result4 = await bcrypt.compare(passwordFromBuffer, storedHash);
          console.log("R\xE9sultat depuis buffer:", result4);
        } catch (error2) {
          console.error("Erreur lors du test:", error2);
        }
      }
      // Test avec différents mots de passe pour vérifier
      static async testMultiplePasswords() {
        const storedHash = "$2b$12$tA90TrjJ4Ympkp5B20y9jeiZDNxY1arR0N/pw5nuRgcredXLIFdQG";
        const testPasswords = [
          "MotDePasse123!",
          "motdepasse123!",
          "MotDePasse123",
          "MotDePasse123! ",
          " MotDePasse123!"
        ];
        console.log("\n=== TEST MULTIPLES MOTS DE PASSE ===");
        for (const pwd of testPasswords) {
          try {
            const result = await bcrypt.compare(pwd, storedHash);
            console.log(`"${pwd}" (longueur: ${pwd.length}) -> ${result}`);
          } catch (error2) {
            console.log(`"${pwd}" -> ERREUR: ${error2.message}`);
          }
        }
      }
      // Exécution des tests
      static async runAllTests() {
        await this.testExactPassword();
        await this.testMultiplePasswords();
      }
    };
  }
});

// src/users/utils/generatePasswordResetToken.ts
import { v4 as uuidv4 } from "uuid";
async function generatePasswordResetToken() {
  const token = uuidv4();
  this.passwordResetToken = token;
  this.passwordResetExpires = new Date(Date.now() + 36e5);
  await this.save();
  return token;
}
var init_generatePasswordResetToken = __esm({
  "src/users/utils/generatePasswordResetToken.ts"() {
  }
});

// src/users/utils/generateVerificationToken.ts
import { v4 as uuidv42 } from "uuid";
function generateVerificationToken() {
  const token = uuidv42();
  this.verificationToken = token;
  return token;
}
var init_generateVerificationToken = __esm({
  "src/users/utils/generateVerificationToken.ts"() {
  }
});

// src/users/utils/isPasswordResetTokenValid.ts
function isPasswordResetTokenValid(token) {
  return this.passwordResetToken === token && this.passwordResetExpires > /* @__PURE__ */ new Date();
}
var init_isPasswordResetTokenValid = __esm({
  "src/users/utils/isPasswordResetTokenValid.ts"() {
  }
});

// src/users/utils/recordLoginAttempt.ts
function recordLoginAttempt(data) {
  this.loginHistory.push({
    timestamp: /* @__PURE__ */ new Date(),
    ...data
  });
  if (this.loginHistory.length > 50) {
    this.loginHistory = this.loginHistory.slice(-50);
  }
}
var init_recordLoginAttempt = __esm({
  "src/users/utils/recordLoginAttempt.ts"() {
  }
});

// src/users/utils/updateLastLogin.ts
function updateLastLogin(ipAddress, userAgent) {
  this.lastLogin = /* @__PURE__ */ new Date();
  this.recordLoginAttempt({
    ipAddress,
    userAgent,
    successful: true
  });
}
var init_updateLastLogin = __esm({
  "src/users/utils/updateLastLogin.ts"() {
  }
});

// src/users/utils/ipValidation.ts
function validateIP(ip) {
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  const ipv6Regex = /^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$|^::1$|^::$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  if (ip === "127.0.0.1" || ip === "::1" || ip === "localhost") {
    return true;
  }
  return ipv4Regex.test(ip) || ipv6Regex.test(ip);
}
var init_ipValidation = __esm({
  "src/users/utils/ipValidation.ts"() {
  }
});

// src/users/models/RefreshTokenSchema .ts
import { Schema as Schema4 } from "mongoose";
var logger5, RefreshTokenSchema, RefreshTokenSchema_default;
var init_RefreshTokenSchema = __esm({
  "src/users/models/RefreshTokenSchema .ts"() {
    init_logger();
    init_ipValidation();
    logger5 = createLogger2("RefreshTokenModel");
    RefreshTokenSchema = new Schema4({
      tokenId: {
        type: String,
        required: true,
        unique: true
      },
      token: {
        type: String,
        required: true,
        unique: true,
        index: true
        // Index pour les recherches rapides
      },
      hashedToken: {
        type: String,
        required: true,
        unique: true
        // Stocker le hash du token pour plus de sécurité
      },
      device: {
        type: String,
        maxlength: 200,
        trim: true
      },
      userAgent: {
        type: String,
        maxlength: 500
        // Info complète du navigateur/app
      },
      ip: {
        type: String,
        required: true,
        validate: {
          validator: validateIP,
          message: "Format IP invalide"
        }
      },
      ipAddress: {
        type: String,
        required: true,
        validate: {
          validator: validateIP,
          message: "Format IP invalide"
        }
      },
      location: {
        country: String,
        city: String,
        coordinates: {
          lat: Number,
          lng: Number
        }
      },
      user: {
        type: Schema4.Types.ObjectId,
        ref: "User",
        required: true,
        index: true
        // Index pour les requêtes par utilisateur
      },
      isActive: {
        type: Boolean,
        default: true,
        index: true
      },
      lastUsedAt: {
        type: Date,
        default: Date.now
      },
      createdAt: {
        type: Date,
        default: Date.now,
        immutable: true
        // Empêche la modification
      },
      expiresAt: {
        type: Date,
        required: true,
        index: { expireAfterSeconds: 0 }
        // TTL index correct
      },
      revokedAt: {
        type: Date,
        default: null
      },
      sessionId: {
        type: String,
        index: true
        // Pour lier plusieurs tokens à une même session
      }
    }, {
      timestamps: false,
      // On gère manuellement createdAt/updatedAt
      collection: "refreshTokens",
      toJSON: {
        transform: (_, ret) => {
          delete ret.token;
          delete ret.__v;
          return ret;
        }
      }
    });
    RefreshTokenSchema.pre("save", async function(next) {
      try {
        if (this.isModified("token")) {
          const crypto7 = __require("crypto");
          this.hashedToken = crypto7.createHash("sha256").update(this.token).digest("hex");
          logger5.debug("Token hash\xE9 pour l'utilisateur", {
            userId: this.user?.toString(),
            sessionId: this.sessionId
          });
        }
        next();
      } catch (error2) {
        logger5.error("Erreur lors du hashage du token de rafra\xEEchissement", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue",
          userId: this.user?.toString()
        });
        next(error2 instanceof Error ? error2 : new Error("Erreur de hashage du token"));
      }
    });
    RefreshTokenSchema.pre("deleteOne", async function(next) {
      try {
        const docToDelete = await this.model.findOne(this.getFilter());
        if (docToDelete) {
          const User2 = (init_userModel(), __toCommonJS(userModel_exports)).default;
          await User2.updateOne(
            { _id: docToDelete.user },
            { $pull: { refreshTokens: docToDelete._id } }
          );
        }
        next();
      } catch (error2) {
        logger5.error("Erreur lors du nettoyage des r\xE9f\xE9rences utilisateur", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue"
        });
        next();
      }
    });
    RefreshTokenSchema.pre("findOneAndDelete", async function(next) {
      try {
        const docToDelete = await this.model.findOne(this.getFilter());
        if (docToDelete) {
          const User2 = (init_userModel(), __toCommonJS(userModel_exports)).default;
          await User2.updateOne(
            { _id: docToDelete.user },
            { $pull: { refreshTokens: docToDelete._id } }
          );
        }
        next();
      } catch (error2) {
        logger5.error("Erreur lors du nettoyage des r\xE9f\xE9rences utilisateur (findOneAndDelete)", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue"
        });
        next();
      }
    });
    RefreshTokenSchema.methods.isExpired = function() {
      return /* @__PURE__ */ new Date() > this.expiresAt;
    };
    RefreshTokenSchema.methods.revoke = async function() {
      try {
        this.isActive = false;
        this.revokedAt = /* @__PURE__ */ new Date();
        logger5.info("Token de rafra\xEEchissement r\xE9voqu\xE9", {
          tokenId: this._id?.toString(),
          userId: this.user?.toString(),
          sessionId: this.sessionId
        });
        return await this.save();
      } catch (error2) {
        logger5.error("Erreur lors de la r\xE9vocation du token", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue",
          tokenId: this._id?.toString()
        });
        throw error2;
      }
    };
    RefreshTokenSchema.methods.updateLastUsed = async function() {
      try {
        this.lastUsedAt = /* @__PURE__ */ new Date();
        logger5.debug("Derni\xE8re utilisation du token mise \xE0 jour", {
          tokenId: this._id?.toString(),
          userId: this.user?.toString()
        });
        return await this.save();
      } catch (error2) {
        logger5.error("Erreur lors de la mise \xE0 jour du token", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue",
          tokenId: this._id?.toString()
        });
        throw error2;
      }
    };
    RefreshTokenSchema.statics.revokeAllForUser = function(userId) {
      logger5.info("R\xE9vocation de tous les tokens pour l'utilisateur", { userId });
      return this.updateMany(
        { user: userId, isActive: true },
        { isActive: false, revokedAt: /* @__PURE__ */ new Date() }
      );
    };
    RefreshTokenSchema.statics.findActiveByUser = function(userId) {
      return this.find({
        user: userId,
        isActive: true,
        expiresAt: { $gt: /* @__PURE__ */ new Date() }
      }).sort({ createdAt: -1 });
    };
    RefreshTokenSchema.statics.cleanupExpired = function() {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
      logger5.info("Nettoyage des tokens expir\xE9s");
      return this.deleteMany({
        $or: [
          { expiresAt: { $lt: /* @__PURE__ */ new Date() } },
          { isActive: false, revokedAt: { $lt: thirtyDaysAgo } }
        ]
      });
    };
    RefreshTokenSchema.statics.findByHashedToken = function(hashedToken) {
      return this.findOne({
        hashedToken,
        isActive: true,
        expiresAt: { $gt: /* @__PURE__ */ new Date() }
      }).populate("user", "email firstName lastName role isActive");
    };
    RefreshTokenSchema.statics.countActiveByUser = function(userId) {
      return this.countDocuments({
        user: userId,
        isActive: true,
        expiresAt: { $gt: /* @__PURE__ */ new Date() }
      });
    };
    RefreshTokenSchema.statics.revokeBySessionId = function(sessionId) {
      logger5.info("R\xE9vocation des tokens par session", { sessionId });
      return this.updateMany(
        { sessionId, isActive: true },
        { isActive: false, revokedAt: /* @__PURE__ */ new Date() }
      );
    };
    RefreshTokenSchema.statics.getTokenStats = async function(userId) {
      const matchStage = userId ? { user: __require("mongoose").Types.ObjectId(userId) } : {};
      const stats = await this.aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: null,
            totalTokens: { $sum: 1 },
            activeTokens: {
              $sum: {
                $cond: [
                  {
                    $and: [
                      { $eq: ["$isActive", true] },
                      { $gt: ["$expiresAt", /* @__PURE__ */ new Date()] }
                    ]
                  },
                  1,
                  0
                ]
              }
            },
            expiredTokens: {
              $sum: {
                $cond: [{ $lt: ["$expiresAt", /* @__PURE__ */ new Date()] }, 1, 0]
              }
            },
            revokedTokens: {
              $sum: {
                $cond: [{ $eq: ["$isActive", false] }, 1, 0]
              }
            }
          }
        }
      ]);
      return stats[0] || {
        totalTokens: 0,
        activeTokens: 0,
        expiredTokens: 0,
        revokedTokens: 0
      };
    };
    RefreshTokenSchema_default = RefreshTokenSchema;
  }
});

// src/users/models/securitydetailsSchema.ts
import { Schema as Schema5 } from "mongoose";
var SecurityDetailsSchema, securitydetailsSchema_default;
var init_securitydetailsSchema = __esm({
  "src/users/models/securitydetailsSchema.ts"() {
    SecurityDetailsSchema = new Schema5({
      question: String,
      answer: String,
      backupCodes: [{
        code: String,
        used: { type: Boolean, default: false },
        usedAt: Date,
        createdAt: { type: Date, default: Date.now }
      }],
      accountLocked: { type: Boolean, default: false },
      lockExpiresAt: Date,
      recoveryCodes: [{
        code: String,
        used: { type: Boolean, default: false },
        usedAt: Date,
        createdAt: { type: Date, default: Date.now }
      }],
      trustedDevices: [{
        deviceId: String,
        name: String,
        userAgent: String,
        ipAddress: String,
        addedAt: { type: Date, default: Date.now },
        lastUsed: { type: Date, default: Date.now }
      }],
      twoFactorSecret: String,
      tempTwoFactorSecret: String,
      tempTwoFactorSecretExpires: Date
    });
    securitydetailsSchema_default = SecurityDetailsSchema;
  }
});

// src/users/models/notificationSchema.ts
import { Schema as Schema6 } from "mongoose";
var UserNotificationSchema, notificationSchema_default;
var init_notificationSchema = __esm({
  "src/users/models/notificationSchema.ts"() {
    UserNotificationSchema = new Schema6({
      title: {
        type: String,
        required: true
      },
      message: {
        type: String,
        required: true
      },
      type: {
        type: String,
        enum: ["info", "warning", "error", "success"],
        default: "info"
      },
      read: {
        type: Boolean,
        default: false
      },
      readAt: Date,
      link: String,
      metadata: Schema6.Types.Mixed
    }, {
      timestamps: true
    });
    notificationSchema_default = UserNotificationSchema;
  }
});

// src/users/models/userModel.ts
var userModel_exports = {};
__export(userModel_exports, {
  default: () => userModel_default
});
import { Schema as Schema7, model as model2 } from "mongoose";
import validator from "validator";
var logger6, UserSchema, User, userModel_default;
var init_userModel = __esm({
  "src/users/models/userModel.ts"() {
    init_userTypes();
    init_agentDetailsSchema();
    init_userPreferenceSchema();
    init_loginHistorySchema();
    init_comparePassword();
    init_generatePasswordResetToken();
    init_generateVerificationToken();
    init_isPasswordResetTokenValid();
    init_recordLoginAttempt();
    init_updateLastLogin();
    init_logger();
    init_RefreshTokenSchema();
    init_securitydetailsSchema();
    init_notificationSchema();
    logger6 = createLogger2("models");
    UserSchema = new Schema7(
      {
        firstName: {
          type: String,
          required: [true, "Le pr\xE9nom est obligatoire"],
          trim: true,
          minlength: [2, "Le pr\xE9nom doit contenir au moins 2 caract\xE8res"],
          maxlength: [50, "Le pr\xE9nom ne peut pas d\xE9passer 50 caract\xE8res"]
        },
        lastName: {
          type: String,
          required: [true, "Le nom est obligatoire"],
          trim: true,
          minlength: [2, "Le nom doit contenir au moins 2 caract\xE8res"],
          maxlength: [50, "Le nom ne peut pas d\xE9passer 50 caract\xE8res"]
        },
        username: {
          type: String,
          required: [true, "Le nom d'utilisateur est obligatoire"],
          trim: true,
          unique: true,
          lowercase: true,
          minlength: [3, "Le nom d'utilisateur doit contenir au moins 3 caract\xE8res"],
          maxlength: [30, "Le nom d'utilisateur ne peut pas d\xE9passer 30 caract\xE8res"],
          validate: {
            validator: (val) => /^[a-z0-9_.-]+$/.test(val),
            message: "Le nom d'utilisateur ne peut contenir que des lettres minuscules, chiffres, tirets et points"
          }
        },
        email: {
          type: String,
          required: [true, "L'email est obligatoire"],
          trim: true,
          unique: true,
          lowercase: true,
          validate: {
            validator: (email) => validator.isEmail(email),
            message: "Veuillez fournir un email valide"
          }
        },
        password: {
          type: String,
          required: [true, "Le mot de passe est obligatoire"],
          minlength: [8, "Le mot de passe doit contenir au moins 8 caract\xE8res"],
          select: false,
          validate: {
            validator: function(password) {
              return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/.test(password);
            },
            message: "Le mot de passe doit contenir au moins une lettre majuscule, une minuscule et un chiffre"
          }
        },
        // Rôle et statuts
        role: {
          type: String,
          enum: Object.values(UserRole),
          default: "client" /* CLIENT */,
          index: true
        },
        isActive: {
          type: Boolean,
          default: true,
          index: true
        },
        isDeleted: {
          type: Boolean,
          default: false,
          index: true
        },
        deletedAt: Date,
        deletedBy: {
          type: Schema7.Types.ObjectId,
          ref: "User"
        },
        // Vérification email
        isEmailVerified: {
          type: Boolean,
          default: false,
          index: true
        },
        verificationToken: String,
        emailVerificationToken: String,
        emailVerificationTokenExpires: Date,
        emailVerificationCode: String,
        emailVerificationCodeExpires: Date,
        // Réinitialisation du mot de passe
        passwordResetToken: String,
        resetPasswordToken: String,
        passwordResetExpires: Date,
        resetPasswordExpires: Date,
        passwordChangedAt: Date,
        // Informations de contact
        phoneNumber: {
          type: String,
          unique: true,
          sparse: true,
          validate: {
            validator: function(phone) {
              return !phone || validator.isMobilePhone(phone, "any");
            },
            message: "Num\xE9ro de t\xE9l\xE9phone invalide"
          }
        },
        profilePicture: {
          type: String,
          default: "https://cdn.monsite.com/images/avatar-blanc.png",
          validate: {
            validator: function(url2) {
              return !url2 || validator.isURL(url2);
            },
            message: "URL de photo de profil invalide"
          }
        },
        // avatarUrl: String, // Alias pour profilePicture
        // Activité et présence
        lastLogin: Date,
        // lastLoginAt: Date, // Alias pour lastLogin
        lastActive: {
          type: Date,
          default: Date.now,
          index: true
        },
        lastIp: String,
        lastUserAgent: String,
        presenceStatus: {
          type: String,
          enum: ["online", "away", "offline"],
          default: "offline",
          index: true
        },
        // Sécurité et authentification
        refreshTokens: [RefreshTokenSchema_default],
        loginHistory: [loginHistorySchema_default],
        loginAttempts: [loginHistorySchema_default],
        security: {
          type: securitydetailsSchema_default,
          default: () => ({})
        },
        // Préférences et données utilisateur
        preferences: {
          type: userPreferenceSchema_default,
          default: () => ({
            theme: "system",
            language: "fr",
            twoFactorEnabled: false,
            marketingCommunications: false,
            notifications: {
              email: true,
              push: true,
              sms: false
            }
          })
        },
        preferencesHistory: [{
          preferences: userPreferenceSchema_default,
          timestamp: { type: Date, default: Date.now }
        }],
        // Détails d'agent (pour les utilisateurs avec rôle AGENT)
        agentDetails: {
          type: agentDetailsSchema_default,
          validate: {
            validator: function() {
              return this.role !== "agent" /* AGENT */ || !!this.agentDetails;
            },
            message: "Les d\xE9tails d'agent sont obligatoires pour le r\xF4le AGENT"
          }
        },
        // Notifications
        notifications: [notificationSchema_default],
        email_activate: {
          type: Boolean,
          default: true
        },
        push_activate: {
          type: Boolean,
          default: true
        }
      },
      {
        timestamps: true,
        toJSON: {
          virtuals: true,
          transform: (_, ret) => {
            delete ret.password;
            delete ret.passwordResetToken;
            delete ret.resetPasswordToken;
            delete ret.emailVerificationToken;
            delete ret.verificationToken;
            delete ret.refreshTokens;
            delete ret.__v;
            delete ret.security?.twoFactorSecret;
            delete ret.security?.tempTwoFactorSecret;
            return ret;
          }
        },
        toObject: {
          virtuals: true
        }
      }
    );
    UserSchema.index({
      firstName: "text",
      lastName: "text",
      email: "text",
      username: "text",
      phoneNumber: "text",
      "address.city": "text",
      "address.country": "text"
    }, {
      weights: {
        firstName: 10,
        lastName: 10,
        email: 8,
        username: 8,
        phoneNumber: 5,
        "address.city": 3,
        "address.country": 3
      }
    });
    UserSchema.index({ "address.coordinates": "2dsphere" });
    UserSchema.virtual("fullName").get(function() {
      return `${this.firstName} ${this.lastName}`.trim();
    });
    UserSchema.index({ firstName: 1 });
    UserSchema.pre("save", async function(next) {
      try {
        if (this.isModified("password")) {
          if (typeof this.password !== "string") {
            throw new Error("Le mot de passe n'est pas une cha\xEEne valide.");
          }
          const isAlreadyHashed = this.password.startsWith("$2b$") || this.password.startsWith("$2a$");
          if (!isAlreadyHashed) {
            logger6.info("Hashage du mot de passe pour l'utilisateur", {
              userId: this._id?.toString(),
              email: this.email
            });
            this.password = await PasswordUtils.hashPassword(this.password);
            this.passwordChangedAt = /* @__PURE__ */ new Date();
          } else {
            logger6.info("Mot de passe d\xE9j\xE0 hash\xE9, pas de re-hashage", {
              userId: this._id?.toString(),
              email: this.email
            });
            if (this.isNew) {
              this.passwordChangedAt = /* @__PURE__ */ new Date();
            }
          }
        }
        if (this.isModified("presenceStatus") && this.presenceStatus === "online") {
          this.lastActive = /* @__PURE__ */ new Date();
        }
        if (this.role === "agent" /* AGENT */ && !this.agentDetails) {
          throw new Error("Les d\xE9tails d'agent sont obligatoires pour le r\xF4le AGENT");
        }
        if (this.role !== "agent" /* AGENT */ && this.agentDetails) {
          this.agentDetails = void 0;
        }
        next();
      } catch (error2) {
        logger6.error("Erreur dans le pre-save du mod\xE8le utilisateur", { error: error2 });
        next(error2 instanceof Error ? error2 : new Error("Erreur lors de la sauvegarde de l'utilisateur."));
      }
    });
    UserSchema.pre("save", function(next) {
      if (this.isModified("isDeleted") && this.isDeleted) {
        this.deletedAt = /* @__PURE__ */ new Date();
        this.isActive = false;
      }
      next();
    });
    UserSchema.methods.comparePassword = async function(candidatePassword) {
      try {
        if (!this.password) {
          logger6.error("Aucun mot de passe trouv\xE9 pour l'utilisateur", {
            userId: this._id?.toString()
          });
          return false;
        }
        logger6.debug("Comparaison mot de passe", {
          userId: this._id?.toString(),
          email: this.email,
          hasPassword: !!this.password
        });
        return await PasswordUtils.comparePassword(candidatePassword, this.password);
      } catch (error2) {
        logger6.error("Erreur dans comparePassword", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue",
          userId: this._id?.toString()
        });
        return false;
      }
    };
    UserSchema.methods.updatePresenceStatus = function(status) {
      if (["online", "away", "offline"].includes(status)) {
        this.presenceStatus = status;
        if (status === "online") {
          this.lastActive = /* @__PURE__ */ new Date();
        }
      }
    };
    UserSchema.methods.comparePassword = async function(candidatePassword) {
      try {
        if (!this.password) {
          logger6.error("[model] Aucun mot de passe trouv\xE9 pour l'utilisateur", {
            userId: this._id?.toString()
          });
          return false;
        }
        logger6.debug("Comparaison mot de passe pour utilisateur", {
          userId: this._id?.toString(),
          email: this.email,
          hasPassword: !!this.password,
          passwordHashLength: this.password?.length || 0
        });
        console.log("voicie  les mots  de  passe  necessaire  ");
        console.log(candidatePassword);
        console.log(this.password);
        return await PasswordUtils.comparePassword(candidatePassword, this.password);
      } catch (error2) {
        logger6.error("Erreur dans comparePassword", {
          error: error2 instanceof Error ? error2.message : "Erreur inconnue",
          userId: this._id?.toString()
        });
        return false;
      }
    };
    UserSchema.methods.generateVerificationToken = generateVerificationToken;
    UserSchema.methods.generatePasswordResetToken = generatePasswordResetToken;
    UserSchema.methods.isPasswordResetTokenValid = isPasswordResetTokenValid;
    UserSchema.methods.recordLoginAttempt = recordLoginAttempt;
    UserSchema.methods.updateLastLogin = updateLastLogin;
    UserSchema.methods.updatePresenceStatus = function(status) {
      if (["online", "away", "offline"].includes(status)) {
        this.presenceStatus = status;
        if (status === "online") {
          this.lastActive = /* @__PURE__ */ new Date();
        }
      }
    };
    User = model2("User", UserSchema);
    UserSchema.methods.addBackupCodes = function(codes) {
      if (!this.security) {
        this.security = {};
      }
      if (!this.security.backupCodes) {
        this.security.backupCodes = [];
      }
      const backupCodes = codes.map((code) => ({
        code,
        used: false,
        createdAt: /* @__PURE__ */ new Date()
      }));
      this.security.backupCodes = backupCodes;
      return this.save();
    };
    UserSchema.methods.useBackupCode = function(code) {
      if (!this.security || !this.security.backupCodes) {
        return false;
      }
      const backupCode = this.security.backupCodes.find(
        (bc) => bc.code === code && !bc.used
      );
      if (backupCode) {
        backupCode.used = true;
        backupCode.usedAt = /* @__PURE__ */ new Date();
        return this.save().then(() => true);
      }
      return false;
    };
    UserSchema.methods.isValidBackupCode = function(code) {
      if (!this.security || !this.security.backupCodes) {
        return false;
      }
      return this.security.backupCodes.some(
        (bc) => bc.code === code && !bc.used
      );
    };
    UserSchema.methods.getRemainingBackupCodes = function() {
      if (!this.security || !this.security.backupCodes) {
        return 0;
      }
      return this.security.backupCodes.filter((bc) => !bc.used).length;
    };
    UserSchema.pre("save", function(next) {
      if (!this.security) {
        this.security = {};
      }
      next();
    });
    userModel_default = User;
  }
});

// src/services/notificationServices.ts
import nodemailer from "nodemailer";
import sgMail from "@sendgrid/mail";
import webpush from "web-push";
import * as admin from "firebase-admin";
var logger7, NotificationService;
var init_notificationServices = __esm({
  "src/services/notificationServices.ts"() {
    init_logger();
    init_userTypes();
    init_config();
    logger7 = createLogger2("NotificationService");
    NotificationService = class {
      constructor() {
        __publicField(this, "transporter");
        __publicField(this, "fromEmail");
        __publicField(this, "isSendGridEnabled");
        __publicField(this, "isSMTPEnabled");
        __publicField(this, "isWebPushEnabled");
        __publicField(this, "isFirebaseEnabled");
        __publicField(this, "emailStrategy");
        __publicField(this, "emailQueue", []);
        __publicField(this, "isProcessingQueue", false);
        __publicField(this, "rateLimiter", {
          sendgrid: {
            requests: 0,
            resetTime: Date.now() + 6e4,
            // Reset every minute
            limit: 100
            // SendGrid allows 100 emails per minute on free tier
          },
          smtp: {
            requests: 0,
            resetTime: Date.now() + 6e4,
            limit: 60
          },
          firebase: {
            requests: 0,
            resetTime: Date.now() + 6e4,
            limit: 1e3
          },
          webpush: {
            requests: 0,
            resetTime: Date.now() + 6e4,
            limit: 500
          }
        });
        this.fromEmail = config_default.sendgrid?.fromAddress || config_default.email.fromAddress || "noreply@easyrent.com";
        this.emailStrategy = config_default.email.strategy;
        this.isSendGridEnabled = this.initializeSendGrid();
        this.isSMTPEnabled = this.initializeSMTP();
        this.isWebPushEnabled = this.initializeWebPush();
        this.isFirebaseEnabled = this.initializeFirebase();
        this.logServicesStatus();
      }
      logServicesStatus() {
        const availableServices = [];
        if (this.isSendGridEnabled) availableServices.push("SendGrid");
        if (this.isSMTPEnabled) availableServices.push("SMTP");
        if (this.isWebPushEnabled) availableServices.push("WebPush");
        if (this.isFirebaseEnabled) availableServices.push("Firebase");
        if (availableServices.length === 0) {
          logger7.error("Aucun service de notification configur\xE9 !");
        } else {
          logger7.info("Services de notification initialis\xE9s", {
            services: availableServices,
            emailStrategy: this.emailStrategy,
            primaryEmailService: this.getPrimaryService(),
            pushServices: {
              webPush: this.isWebPushEnabled,
              firebase: this.isFirebaseEnabled
            }
          });
        }
      }
      getPrimaryService() {
        if (this.emailStrategy === "smtp-first" && this.isSMTPEnabled) return "SMTP";
        if (this.emailStrategy === "sendgrid-first" && this.isSendGridEnabled) return "SendGrid";
        if (this.isSendGridEnabled) return "SendGrid";
        if (this.isSMTPEnabled) return "SMTP";
        return "None";
      }
      /**
       * Initialise SendGrid
       */
      initializeSendGrid() {
        if (!config_default.sendgrid?.enabled || !config_default.sendgrid?.apiKey) {
          logger7.warn("SendGrid non configur\xE9", {
            enabled: config_default.sendgrid?.enabled,
            hasApiKey: !!config_default.sendgrid?.apiKey
          });
          return false;
        }
        try {
          sgMail.setApiKey(config_default.sendgrid.apiKey);
          logger7.info("SendGrid initialis\xE9 avec succ\xE8s");
          return true;
        } catch (error2) {
          logger7.error("Erreur lors de l'initialisation de SendGrid", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Initialise SMTP
       */
      initializeSMTP() {
        if (!config_default.email.enabled || !config_default.email.host || !config_default.email.user || !config_default.email.password) {
          logger7.warn("SMTP not configured - missing required settings", {
            enabled: config_default.email.enabled,
            hasHost: !!config_default.email.host,
            hasUser: !!config_default.email.user,
            hasPassword: !!config_default.email.password
          });
          return false;
        }
        try {
          this.transporter = nodemailer.createTransport({
            host: config_default.email.host,
            port: config_default.email.port,
            secure: config_default.email.secure,
            auth: {
              user: config_default.email.user,
              pass: config_default.email.password
            },
            // Options pour améliorer la fiabilité
            pool: config_default.email.pool || true,
            maxConnections: config_default.email.maxConnections || 5,
            maxMessages: 100,
            rateDelta: 2e4,
            rateLimit: 5,
            // Options de timeout
            connectionTimeout: config_default.email.timeout || 15e3,
            greetingTimeout: 1e4,
            socketTimeout: 3e4,
            // Options TLS
            tls: {
              rejectUnauthorized: config_default.app.env === "production",
              minVersion: "TLSv1.2"
            },
            // Debug en développement
            debug: config_default.app.env === "development",
            logger: config_default.app.env === "development"
          });
          this.verifyConnectionAsync();
          logger7.info("SMTP initialis\xE9 avec succ\xE8s", {
            host: config_default.email.host,
            port: config_default.email.port,
            secure: config_default.email.secure
          });
          return true;
        } catch (error2) {
          logger7.error("Erreur lors de l'initialisation SMTP", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      initializeWebPush() {
        if (!config_default.webpush?.enabled || !config_default.webpush.vapidPublicKey || !config_default.webpush.vapidPrivateKey) {
          logger7.warn("Web Push non configur\xE9", {
            enabled: config_default.webpush?.enabled,
            hasPublicKey: !!config_default.webpush?.vapidPublicKey,
            hasPrivateKey: !!config_default.webpush?.vapidPrivateKey
          });
          return false;
        }
        try {
          webpush.setVapidDetails(
            config_default.webpush.vapidSubject || "mailto:noreply@easyrent.com",
            config_default.webpush.vapidPublicKey,
            config_default.webpush.vapidPrivateKey
          );
          logger7.info("Web Push initialis\xE9 avec succ\xE8s");
          return true;
        } catch (error2) {
          logger7.error("Erreur lors de l'initialisation Web Push", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Initialise Firebase Admin
       */
      initializeFirebase() {
        if (!config_default.firebase?.enabled || !config_default.firebase.serviceAccount) {
          logger7.warn("Firebase non configur\xE9", {
            enabled: config_default.firebase?.enabled,
            hasServiceAccount: !!config_default.firebase?.serviceAccount
          });
          return false;
        }
        try {
          if (!admin.apps.length) {
            admin.initializeApp({
              credential: admin.credential.cert(config_default.firebase.serviceAccount),
              projectId: config_default.firebase.projectId
            });
          }
          logger7.info("Firebase Admin initialis\xE9 avec succ\xE8s");
          return true;
        } catch (error2) {
          logger7.error("Erreur lors de l'initialisation Firebase", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Vérification de connexion SMTP asynchrone
       */
      async verifyConnectionAsync() {
        if (!this.transporter) return;
        try {
          await Promise.race([
            this.transporter.verify(),
            new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Connection verification timeout")), 1e4)
            )
          ]);
          logger7.info("Connexion SMTP v\xE9rifi\xE9e avec succ\xE8s");
        } catch (error2) {
          logger7.error("\xC9chec de la v\xE9rification SMTP", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            host: config_default.email.host,
            port: config_default.email.port
          });
        }
      }
      /**
       * Envoie une notification push via Firebase Cloud Messaging
       */
      async sendFCMPushNotification(tokens, notification) {
        if (!this.isFirebaseEnabled) {
          logger7.warn("Firebase non disponible pour l'envoi de push notifications");
          return false;
        }
        if (!this.canSendPush("firebase")) {
          logger7.warn("Limite de taux Firebase atteinte");
          return false;
        }
        try {
          const tokensArray = Array.isArray(tokens) ? tokens : [tokens];
          const validTokens = tokensArray.filter((token) => token && token.trim() !== "");
          if (validTokens.length === 0) {
            logger7.warn("Aucun token FCM valide fourni");
            return false;
          }
          const message = {
            notification: {
              title: notification.title,
              body: notification.body,
              imageUrl: notification.icon
            },
            data: {
              ...notification.data,
              click_action: "FLUTTER_NOTIFICATION_CLICK",
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            },
            android: {
              notification: {
                channelId: notification.androidChannelId || "default",
                priority: "high",
                defaultSound: true,
                defaultVibrateTimings: true,
                icon: notification.androidIcon || "ic_notification",
                color: notification.androidColor || "#4A90E2"
              }
            },
            apns: {
              payload: {
                aps: {
                  alert: {
                    title: notification.title,
                    body: notification.body
                  },
                  badge: notification.badge || 1,
                  sound: notification.sound || "default",
                  category: notification.category || "DEFAULT"
                }
              }
            },
            tokens: validTokens
          };
          const response = await admin.messaging().sendMulticast(message);
          this.updateRateLimit("firebase");
          if (response.failureCount > 0) {
            await this.cleanupInvalidFCMTokens(validTokens, response.responses);
          }
          logger7.info("Notification FCM envoy\xE9e", {
            successCount: response.successCount,
            failureCount: response.failureCount,
            tokens: validTokens.length
          });
          return response.successCount > 0;
        } catch (error2) {
          logger7.error("Erreur lors de l'envoi FCM", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            tokens: Array.isArray(tokens) ? tokens.length : 1
          });
          return false;
        }
      }
      /**
       * Envoie une notification Web Push
       */
      async sendWebPushNotification(subscriptions, notification) {
        if (!this.isWebPushEnabled) {
          logger7.warn("Web Push non disponible");
          return false;
        }
        if (!this.canSendPush("webpush")) {
          logger7.warn("Limite de taux Web Push atteinte");
          return false;
        }
        try {
          const subscriptionsArray = Array.isArray(subscriptions) ? subscriptions : [subscriptions];
          const validSubscriptions = subscriptionsArray.filter(
            (sub) => sub && sub.endpoint && sub.keys && sub.keys.p256dh && sub.keys.auth
          );
          if (validSubscriptions.length === 0) {
            logger7.warn("Aucune subscription Web Push valide fournie");
            return false;
          }
          const payload = JSON.stringify({
            title: notification.title,
            body: notification.body,
            icon: notification.icon,
            badge: notification.badge || "/notification-badge.png",
            data: {
              ...notification.data,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            },
            actions: notification.actions || [],
            requireInteraction: notification.requireInteraction || false,
            silent: notification.silent || false,
            tag: notification.tag || "default",
            renotify: notification.renotify || false
          });
          const promises = validSubscriptions.map(async (subscription, index) => {
            try {
              const result = await webpush.sendNotification(subscription, payload, {
                TTL: notification.ttl || 86400,
                // 24 heures par défaut
                urgency: notification.urgency || "normal",
                topic: notification.topic
              });
              return { success: true, index, result };
            } catch (error2) {
              if (error2.statusCode === 410 || error2.statusCode === 404) {
                await this.removeExpiredWebPushSubscription(subscription);
              }
              return { success: false, index, error: error2 };
            }
          });
          const results = await Promise.allSettled(promises);
          this.updateRateLimit("webpush");
          const successCount = results.filter(
            (r) => r.status === "fulfilled" && r.value.success
          ).length;
          logger7.info("Notifications Web Push envoy\xE9es", {
            total: validSubscriptions.length,
            success: successCount,
            failed: validSubscriptions.length - successCount
          });
          return successCount > 0;
        } catch (error2) {
          logger7.error("Erreur lors de l'envoi Web Push", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Validate email address format
       */
      isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      /**
       * Envoie un email via SendGrid
       */
      async sendWithSendGrid(mailOptions) {
        if (!this.isSendGridEnabled) {
          logger7.debug("SendGrid not enabled, skipping");
          return false;
        }
        if (!this.isValidEmail(mailOptions.to)) {
          logger7.error("Invalid email address for SendGrid", { to: this.maskEmail(mailOptions.to) });
          return false;
        }
        if (!config_default.sendgrid?.apiKey) {
          logger7.error("SendGrid API key not configured");
          return false;
        }
        try {
          const msg = {
            to: mailOptions.to,
            from: {
              email: this.fromEmail,
              name: "EasyRent"
            },
            subject: mailOptions.subject,
            html: mailOptions.html,
            text: mailOptions.text || this.stripHtml(mailOptions.html),
            tracking_settings: {
              click_tracking: { enable: false },
              open_tracking: { enable: false }
            }
          };
          logger7.debug("Sending email via SendGrid", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            fromEmail: this.fromEmail
          });
          const response = await sgMail.send(msg);
          logger7.info("Email envoy\xE9 avec SendGrid", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            messageId: response[0].headers["x-message-id"],
            statusCode: response[0].statusCode
          });
          return true;
        } catch (error2) {
          logger7.error("Erreur SendGrid", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            error: error2.message || "Erreur inconnue",
            code: error2.code,
            statusCode: error2.response?.status,
            errorBody: error2.response?.body,
            stack: error2.stack
          });
          return false;
        }
      }
      /**
       * Envoie un email via SMTP
       */
      async sendWithSMTP(mailOptions) {
        if (!this.isSMTPEnabled || !this.transporter) {
          logger7.debug("SMTP not enabled or transporter not available, skipping");
          return false;
        }
        if (!this.isValidEmail(mailOptions.to)) {
          logger7.error("Invalid email address for SMTP", { to: this.maskEmail(mailOptions.to) });
          return false;
        }
        try {
          const smtpOptions = {
            from: {
              name: "EasyRent",
              address: this.fromEmail
            },
            to: mailOptions.to,
            subject: mailOptions.subject,
            html: mailOptions.html,
            text: mailOptions.text || this.stripHtml(mailOptions.html)
          };
          logger7.debug("Sending email via SMTP", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            fromEmail: this.fromEmail
          });
          const result = await Promise.race([
            this.transporter.sendMail(smtpOptions),
            new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Email send timeout after 30 seconds")), 3e4)
            )
          ]);
          if (config_default.app.env === "development" && result.message) {
            logger7.info("Development email content:", {
              to: this.maskEmail(mailOptions.to),
              subject: mailOptions.subject,
              content: result.message.toString().substring(0, 200) + "..."
            });
          }
          logger7.info("Email envoy\xE9 avec SMTP", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            messageId: result.messageId || "dev-mode"
          });
          return true;
        } catch (error2) {
          logger7.error("Erreur SMTP", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Méthode unifiée pour envoyer des notifications
       */
      async sendNotification(options) {
        const results = { email: false, push: false };
        try {
          if (options.type === "email" || options.type === "both") {
            if (options.email) {
              if (options.priority === "high") {
                results.email = await this.sendUrgentEmail(options.email);
              } else {
                results.email = await this.sendEmailSafely(options.email);
              }
            }
          }
          if (options.type === "push" || options.type === "both") {
            if (options.push) {
              const pushPromises = [];
              if (options.push.fcmTokens && options.push.fcmTokens.length > 0) {
                pushPromises.push(
                  this.sendFCMPushNotification(options.push.fcmTokens, options.push.notification)
                );
              }
              if (options.push.webpushSubscriptions && options.push.webpushSubscriptions.length > 0) {
                pushPromises.push(
                  this.sendWebPushNotification(options.push.webpushSubscriptions, options.push.notification)
                );
              }
              if (pushPromises.length > 0) {
                const pushResults = await Promise.all(pushPromises);
                results.push = pushResults.some((result) => result);
              }
            }
          }
          return results;
        } catch (error2) {
          logger7.error("Erreur lors de l'envoi de notification unifi\xE9e", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            type: options.type
          });
          return results;
        }
      }
      /**
       * Nettoie les tokens FCM invalides
       */
      // private async cleanupInvalidFCMTokens(tokens: string[], responses: any[]): Promise<void> {
      //   const invalidTokens: string[] = [];
      //   responses.forEach((response, index) => {
      //     if (!response.success && response.error) {
      //       const errorCode = response.error.code;
      //       if (errorCode === 'messaging/invalid-registration-token' || 
      //           errorCode === 'messaging/registration-token-not-registered') {
      //         invalidTokens.push(tokens[index]);
      //       }
      //     }
      //   });
      //   if (invalidTokens.length > 0) {
      //     logger.info('Nettoyage des tokens FCM invalides', { count: invalidTokens.length });
      //     // Ici vous pouvez ajouter la logique pour supprimer les tokens de votre base de données
      //     // await User.updateMany(...);
      //   }
      // }
      async cleanupInvalidFCMTokens(tokens, responses) {
        const invalidTokens = tokens.filter((_, index) => {
          const response = responses[index];
          return !response.success && response.error && (response.error.code === "messaging/invalid-registration-token" || response.error.code === "messaging/registration-token-not-registered");
        });
        if (invalidTokens.length > 0) {
          logger7.info("Nettoyage des tokens FCM invalides", { count: invalidTokens.length });
        }
      }
      /**
       * Supprime une subscription Web Push expirée
       */
      async removeExpiredWebPushSubscription(subscription) {
        try {
          logger7.info("Suppression d'une subscription Web Push expir\xE9e", {
            endpoint: subscription.endpoint
          });
        } catch (error2) {
          logger7.error("Erreur lors de la suppression de la subscription expir\xE9e", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
      /**
         * Masque l'email pour les logs
         */
      maskEmail(email) {
        if (!email || email.length < 3) return "***";
        const [local, domain] = email.split("@");
        if (!domain) return email.substring(0, 3) + "***";
        return local.substring(0, Math.min(3, local.length)) + "***@" + domain;
      }
      /**
       * Vérifie si on peut envoyer des push notifications
       */
      canSendPush(service) {
        const now = Date.now();
        if (now > this.rateLimiter[service].resetTime) {
          this.rateLimiter[service].requests = 0;
          this.rateLimiter[service].resetTime = now + 6e4;
        }
        return this.rateLimiter[service].requests < this.rateLimiter[service].limit;
      }
      /**
      *  email sending method that respects the configured strategy
      */
      async sendEmailSafely(mailOptions) {
        if (!this.isSendGridEnabled && !this.isSMTPEnabled) {
          logger7.error("Aucun service email disponible", {
            to: this.maskEmail(mailOptions.to),
            subject: mailOptions.subject
          });
          return false;
        }
        const services = this.getServicesInOrder();
        for (const service of services) {
          try {
            let success = false;
            if (service === "sendgrid" && this.isSendGridEnabled) {
              logger7.debug("Tentative d'envoi via SendGrid...");
              success = await this.sendWithSendGrid(mailOptions);
            } else if (service === "smtp" && this.isSMTPEnabled) {
              logger7.debug("Tentative d'envoi via SMTP...");
              success = await this.sendWithSMTP(mailOptions);
            }
            if (success) {
              return true;
            }
            logger7.warn(`${service.toUpperCase()} a \xE9chou\xE9, tentative avec le service suivant...`);
          } catch (error2) {
            logger7.error(`Erreur lors de l'envoi avec ${service}`, {
              error: error2 instanceof Error ? error2.message : "Erreur inconnue",
              to: this.maskEmail(mailOptions.to)
            });
          }
        }
        logger7.error("\xC9chec de tous les services email", {
          to: this.maskEmail(mailOptions.to),
          subject: mailOptions.subject,
          strategy: this.emailStrategy,
          sendgridEnabled: this.isSendGridEnabled,
          smtpEnabled: this.isSMTPEnabled
        });
        return false;
      }
      async sendemail(mailoption) {
        if (!mailoption.to || !mailoption.subject || !mailoption.html) {
          return;
        }
        return this.sendEmailSafely(mailoption);
      }
      /**
       * Strip HTML tags for plain text version
       */
      stripHtml(html) {
        return html.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
      }
      /**
       * Get services in the correct order based on strategy
       */
      getServicesInOrder() {
        switch (this.emailStrategy) {
          case "sendgrid-first":
            return ["sendgrid", "smtp"];
          case "smtp-first":
            return ["smtp", "sendgrid"];
          default:
            return this.isSendGridEnabled ? ["sendgrid", "smtp"] : ["smtp", "sendgrid"];
        }
      }
      async queueEmail(mailOptions, priority = "normal", maxAttempts = 3) {
        const queuedEmail = {
          ...mailOptions,
          id: `email_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          priority,
          attempts: 0,
          maxAttempts,
          scheduledAt: /* @__PURE__ */ new Date()
        };
        if (priority === "high") {
          this.emailQueue.unshift(queuedEmail);
        } else {
          this.emailQueue.push(queuedEmail);
        }
        logger7.info("Email ajout\xE9 \xE0 la queue", {
          id: queuedEmail.id,
          to: this.maskEmail(mailOptions.to),
          priority,
          queueLength: this.emailQueue.length
        });
        if (!this.isProcessingQueue) {
          this.processEmailQueue();
        }
        return queuedEmail.id;
      }
      /**
       * Process email queue with rate limiting
       */
      async processEmailQueue() {
        if (this.isProcessingQueue || this.emailQueue.length === 0) {
          return;
        }
        this.isProcessingQueue = true;
        logger7.debug("D\xE9but du traitement de la queue email");
        while (this.emailQueue.length > 0) {
          const email = this.emailQueue.shift();
          try {
            if (!this.canSendEmail()) {
              this.emailQueue.unshift(email);
              logger7.debug("Rate limit atteint, pause de 10 secondes");
              await this.delay(1e4);
              continue;
            }
            const success = await this.sendEmailSafely(email);
            if (success) {
              logger7.info("Email envoy\xE9 avec succ\xE8s depuis la queue", {
                id: email.id,
                to: this.maskEmail(email.to),
                attempts: email.attempts + 1
              });
            } else {
              email.attempts++;
              if (email.attempts < email.maxAttempts) {
                email.scheduledAt = new Date(Date.now() + email.attempts * 3e4);
                this.emailQueue.push(email);
                logger7.warn("Email \xE9chou\xE9, re-ajout\xE9 \xE0 la queue", {
                  id: email.id,
                  attempts: email.attempts,
                  maxAttempts: email.maxAttempts
                });
              } else {
                logger7.error("Email d\xE9finitivement \xE9chou\xE9 apr\xE8s tous les essais", {
                  id: email.id,
                  to: this.maskEmail(email.to),
                  attempts: email.attempts
                });
              }
            }
            await this.delay(1e3);
          } catch (error2) {
            logger7.error("Erreur lors du traitement de la queue", {
              emailId: email.id,
              error: error2 instanceof Error ? error2.message : "Erreur inconnue"
            });
            if (email.attempts < email.maxAttempts) {
              email.attempts++;
              this.emailQueue.push(email);
            }
          }
        }
        this.isProcessingQueue = false;
        logger7.debug("Fin du traitement de la queue email");
      }
      /**
       * Check if we can send email based on rate limits
       */
      canSendEmail() {
        const now = Date.now();
        if (now > this.rateLimiter.sendgrid.resetTime) {
          this.rateLimiter.sendgrid.requests = 0;
          this.rateLimiter.sendgrid.resetTime = now + 6e4;
        }
        if (now > this.rateLimiter.smtp.resetTime) {
          this.rateLimiter.smtp.requests = 0;
          this.rateLimiter.smtp.resetTime = now + 6e4;
        }
        const canUseSendGrid = this.isSendGridEnabled && this.rateLimiter.sendgrid.requests < this.rateLimiter.sendgrid.limit;
        const canUseSMTP = this.isSMTPEnabled && this.rateLimiter.smtp.requests < this.rateLimiter.smtp.limit;
        return canUseSendGrid || canUseSMTP;
      }
      /**
       * Update rate limiter after sending
       */
      updateRateLimit(service) {
        if (this.rateLimiter[service]) {
          this.rateLimiter[service].requests++;
        }
      }
      /**
       * Utility method for delays
       */
      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      /**
       * Public method to send high priority emails immediately
       */
      async sendUrgentEmail(mailOptions) {
        const success = await this.sendEmailSafely(mailOptions);
        if (!success) {
          await this.queueEmail(mailOptions, "high", 5);
          return false;
        }
        return true;
      }
      /**
       * Obtient le statut de tous les services
       */
      getServicesStatus() {
        return {
          email: {
            sendgrid: this.isSendGridEnabled,
            smtp: this.isSMTPEnabled,
            primary: this.getPrimaryService()
          },
          push: {
            firebase: this.isFirebaseEnabled,
            webpush: this.isWebPushEnabled
          }
        };
      }
      /**
       * Test de la configuration email
       */
      async testEmailConfiguration() {
        const testResults = {
          sendgrid: false,
          smtp: false,
          overall: false
        };
        if (this.isSendGridEnabled) {
          try {
            testResults.sendgrid = true;
            logger7.info("SendGrid configur\xE9 et pr\xEAt");
          } catch (error2) {
            logger7.error("Test SendGrid \xE9chou\xE9", { error: error2 });
          }
        }
        if (this.isSMTPEnabled && this.transporter) {
          try {
            await Promise.race([
              this.transporter.verify(),
              new Promise(
                (_, reject) => setTimeout(() => reject(new Error("SMTP test timeout")), 1e4)
              )
            ]);
            testResults.smtp = true;
            logger7.info("SMTP configured and ready");
          } catch (error2) {
            logger7.error("SMTP test failed", { error: error2 });
          }
        }
        testResults.overall = testResults.sendgrid || testResults.smtp;
        logger7.info("R\xE9sultats des tests email", testResults);
        return testResults;
      }
      /**
       *  send account reactivation  email
       */
      async sendAccountReactivationEmail(email, firstName) {
        const mailOptions = {
          to: email,
          subject: "Votre compte a \xE9t\xE9 r\xE9activ\xE9 - EasyRent",
          html: this.getAccountReactivationTemplate(firstName)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async debugVerificationEmail(email, firstName, token) {
        const verificationUrl = `${config_default.app.frontendUrl}/verify-account?token=${token}`;
        console.log("\u{1F50D} DEBUG EMAIL VERIFICATION:");
        console.log("Email:", email);
        console.log("FirstName:", firstName);
        console.log("Token:", token);
        console.log("Frontend URL:", config_default.app.frontendUrl);
        console.log("Full Verification URL:", verificationUrl);
        console.log("Token length:", token?.length);
        console.log("Token type:", typeof token);
      }
      /**
       * send  email  verification
       */
      async sendVerificationEmail(email, firstName, code) {
        if (!code) {
          logger7.error("Verification code is missing", { email: this.maskEmail(email) });
          return false;
        }
        logger7.info("Email service status check", {
          sendgridEnabled: this.isSendGridEnabled,
          smtpEnabled: this.isSMTPEnabled,
          emailStrategy: this.emailStrategy,
          hasApiKey: !!config_default.sendgrid?.apiKey,
          hasSmtpConfig: !!(config_default.email.host && config_default.email.user && config_default.email.password)
        });
        logger7.info("Sending verification code email", {
          email: this.maskEmail(email),
          firstName,
          code: code.substring(0, 3) + "***"
        });
        const mailOptions = {
          to: email,
          subject: "Code de v\xE9rification - EasyRent",
          html: this.getVerificationCodeTemplate(firstName, code),
          text: `Bonjour ${firstName}, votre code de v\xE9rification est : ${code}`
        };
        const result = await this.sendEmailSafely(mailOptions);
        logger7.info("Email send result", { success: result, to: this.maskEmail(email) });
        return result;
      }
      async sendWelcomeEmail(email, firstName) {
        this.debugVerificationEmail(email, firstName);
        const mailOptions = {
          to: email,
          subject: "Bienvenue sur EasyRent !",
          html: this.getWelcomeEmailTemplate(firstName)
        };
        return this.sendEmailSafely(mailOptions);
      }
      /**
       * password reset email
       */
      async sendPasswordResetEmail(email, resetLink, firstName) {
        if (!resetLink) {
          logger7.error("Reset link is missing", { email: this.maskEmail(email) });
          return false;
        }
        this.debugVerificationEmail(email, firstName);
        logger7.info("Password reset link provided", {
          resetLink: resetLink.substring(0, 50) + "...",
          email: this.maskEmail(email)
        });
        const mailOptions = {
          to: email,
          subject: "R\xE9initialisation de votre mot de passe - EasyRent",
          html: this.getPasswordResetEmailTemplate(firstName, resetLink)
        };
        return this.sendEmailSafely(mailOptions);
      }
      /**
       * send  password change  confirmation email
       */
      async sendPasswordChangeConfirmationEmail(email, firstName) {
        const mailOptions = {
          to: email,
          subject: "Confirmation de changement de mot de passe - EasyRent",
          html: this.getPasswordChangeConfirmationTemplate(firstName)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAgentVerificationStatusEmail(email, firstName, status, comment) {
        let subject;
        switch (status) {
          case "verified" /* VERIFIED */:
            subject = "Votre compte agent a \xE9t\xE9 v\xE9rifi\xE9 - EasyRent";
            break;
          case "rejected" /* REJECTED */:
            subject = "Votre demande de v\xE9rification a \xE9t\xE9 rejet\xE9e - EasyRent";
            break;
          case "pending" /* PENDING */:
            subject = "Votre demande de v\xE9rification est en cours - EasyRent";
            break;
          default:
            subject = "Mise \xE0 jour de votre compte agent - EasyRent";
        }
        const mailOptions = {
          to: email,
          subject,
          html: this.getAgentVerificationStatusTemplate(firstName, status, comment)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendSecurityNotification(email, firstName, comment, alertType = "other") {
        let subject;
        let alertMessage;
        switch (alertType) {
          case "login_attempt":
            subject = "Alerte de s\xE9curit\xE9: Tentative de connexion suspecte - EasyRent";
            break;
          case "password_changed":
            subject = "Alerte de s\xE9curit\xE9: Modification de votre mot de passe - EasyRent";
            break;
          case "account_accessed":
            subject = "Alerte de s\xE9curit\xE9: Acc\xE8s \xE0 votre compte - EasyRent";
            break;
          case "information_changed":
            subject = "Alerte de s\xE9curit\xE9: Modification de vos informations - EasyRent";
            break;
          default:
            subject = "Alerte de s\xE9curit\xE9 sur votre compte - EasyRent";
        }
        const mailOptions = {
          to: email,
          subject,
          html: this.getSecurityAlertEmailTemplate(firstName, alertType, comment)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAccountDeactivationEmail(email, firstName) {
        const mailOptions = {
          to: email,
          subject: "Votre compte a \xE9t\xE9 d\xE9sactiv\xE9 - EasyRent",
          html: this.getAccountDeactivationTemplate(firstName)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAccountLockedEmail(email, firstName, reason, lockDuration) {
        const mailOptions = {
          to: email,
          subject: "\u{1F512} Votre compte a \xE9t\xE9 temporairement verrouill\xE9 - EasyRent",
          html: this.getAccountLockedEmailTemplate(firstName, reason, lockDuration)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAccountDeletedEmail(email, firstName, comment) {
        const mailOptions = {
          to: email,
          subject: "Confirmation de suppression de votre compte - EasyRent",
          html: this.getAccountDeletedTemplate(firstName, comment)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAccountRestoredEmail(email, firstName, comment) {
        const mailOptions = {
          to: email,
          subject: "\u2705 Votre compte a \xE9t\xE9 restaur\xE9 - EasyRent",
          html: this.getAccountRestoredEmailTemplate(firstName, comment)
        };
        return this.sendEmailSafely(mailOptions);
      }
      async sendAccountStatusNotification(email, firstName, status, comment) {
        let subject;
        let statusColor;
        let statusMessage;
        switch (status) {
          case "activated":
            subject = "Votre compte a \xE9t\xE9 activ\xE9 - EasyRent";
            statusColor = "#28a745";
            statusMessage = "Votre compte EasyRent a \xE9t\xE9 activ\xE9 avec succ\xE8s. Vous pouvez maintenant acc\xE9der \xE0 tous nos services.";
            break;
          case "deactivated":
            subject = "Votre compte a \xE9t\xE9 d\xE9sactiv\xE9 - EasyRent";
            statusColor = "#ffc107";
            statusMessage = "Votre compte EasyRent a \xE9t\xE9 temporairement d\xE9sactiv\xE9.";
            break;
          case "locked":
            subject = "\u{1F512} Votre compte a \xE9t\xE9 verrouill\xE9 - EasyRent";
            statusColor = "#dc3545";
            statusMessage = "Votre compte a \xE9t\xE9 temporairement verrouill\xE9 pour des raisons de s\xE9curit\xE9.";
            break;
          case "unlocked":
            subject = "\u{1F513} Votre compte a \xE9t\xE9 d\xE9verrouill\xE9 - EasyRent";
            statusColor = "#28a745";
            statusMessage = "Votre compte a \xE9t\xE9 d\xE9verrouill\xE9 et est maintenant accessible.";
            break;
          case "verified":
            subject = "\u2705 Votre compte a \xE9t\xE9 v\xE9rifi\xE9 - EasyRent";
            statusColor = "#28a745";
            statusMessage = "Votre compte a \xE9t\xE9 v\xE9rifi\xE9 avec succ\xE8s. Vous avez maintenant acc\xE8s \xE0 toutes les fonctionnalit\xE9s.";
            break;
          case "suspended":
            subject = "\u26A0\uFE0F Votre compte a \xE9t\xE9 suspendu - EasyRent";
            statusColor = "#dc3545";
            statusMessage = "Votre compte a \xE9t\xE9 suspendu en raison d'une violation de nos conditions d'utilisation.";
            break;
          case "restored":
            subject = "\u2705 Votre compte a \xE9t\xE9 restaur\xE9 - EasyRent";
            statusColor = "#28a745";
            statusMessage = "Votre compte a \xE9t\xE9 restaur\xE9 et est maintenant pleinement fonctionnel.";
            break;
          default:
            subject = "Mise \xE0 jour de votre compte - EasyRent";
            statusColor = "#007bff";
            statusMessage = "Le statut de votre compte a \xE9t\xE9 mis \xE0 jour.";
        }
        const mailOptions = {
          to: email,
          subject,
          html: this.getAccountStatusNotificationTemplate(firstName, status, statusMessage, statusColor, comment)
        };
        return this.sendEmailSafely(mailOptions);
      }
      getAccountStatusNotificationTemplate(firstName, status, statusMessage, statusColor, comment) {
        return `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
      <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid ${statusColor};">
        <h1 style="color: ${statusColor};">Bonjour ${firstName},</h1>
        
        <p style="font-size: 16px; margin-bottom: 20px;">
          ${statusMessage}
        </p>
        
        ${comment ? `
          <div style="background-color: #e9ecef; border: 1px solid #dee2e6; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #495057;">
              <strong>Information compl\xE9mentaire :</strong> ${comment}
            </p>
          </div>
        ` : ""}
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="${config_default.app.frontendUrl}/dashboard" 
             style="background-color: ${statusColor}; color: white; padding: 15px 30px; text-decoration: none; 
                    border-radius: 5px; display: inline-block; font-weight: bold; margin: 5px;">
            Acc\xE9der \xE0 mon compte
          </a>
          <a href="${config_default.app.frontendUrl}/contact-support" 
             style="background-color: #6c757d; color: white; padding: 12px 24px; text-decoration: none; 
                    border-radius: 4px; display: inline-block; margin: 5px;">
            Contacter le support
          </a>
        </div>
        
        <p style="font-size: 14px; color: #666; margin-top: 20px;">
          Si vous avez des questions concernant cette notification, n'h\xE9sitez pas \xE0 contacter notre \xE9quipe de support.
        </p>
        
        <p style="font-weight: bold; margin-top: 20px;">
          L'\xE9quipe EasyRent
        </p>
      </div>
    </div>
  `;
      }
      getVerificationCodeTemplate(firstName, code) {
        return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code de v\xE9rification - EasyRent</title>
      </head>
      <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center;">
          <h1 style="color: #007bff; margin-bottom: 30px;">Bienvenue sur EasyRent, ${firstName}!</h1>
          
          <p style="font-size: 16px; margin-bottom: 20px;">
            Merci de vous \xEAtre inscrit sur EasyRent. Pour finaliser votre inscription et activer votre compte, 
            veuillez saisir le code de v\xE9rification ci-dessous :
          </p>
          
          <div style="background-color: #007bff; color: white; padding: 20px; border-radius: 8px; margin: 30px 0;">
            <h2 style="margin: 0; font-size: 32px; letter-spacing: 8px;">${code}</h2>
          </div>
          
          <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #856404;">
              <strong>\u23F0 Important :</strong> Ce code est valide pendant 15 minutes seulement.
            </p>
          </div>
          
          <p style="color: #666; font-size: 14px; margin-top: 30px;">
            Si vous n'avez pas cr\xE9\xE9 de compte, vous pouvez ignorer cet email en toute s\xE9curit\xE9.
          </p>
        </div>
      </body>
      </html>
    `;
      }
      getWelcomeEmailTemplate(firstName) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center;">
          <h1 style="color: #28a745; margin-bottom: 20px;">\u{1F389} Bienvenue sur EasyRent, ${firstName}!</h1>
          <p style="font-size: 16px; margin-bottom: 20px;">
            Votre compte a \xE9t\xE9 v\xE9rifi\xE9 avec succ\xE8s. Vous pouvez maintenant profiter de tous les services de notre plateforme de location.
          </p>
          <div style="margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/dashboard" 
               style="background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none; 
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              \u{1F680} Acc\xE9der \xE0 mon tableau de bord
            </a>
          </div>
        </div>
      </div>
    `;
      }
      getPasswordResetEmailTemplate(firstName, resetUrl) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
          <h1 style="color: #dc3545;">R\xE9initialisation de mot de passe</h1>
          <p>Bonjour ${firstName},</p>
          <p>Vous avez demand\xE9 la r\xE9initialisation de votre mot de passe EasyRent. Cliquez sur le bouton ci-dessous pour cr\xE9er un nouveau mot de passe :</p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${resetUrl}" 
               style="background-color: #dc3545; color: white; padding: 15px 30px; text-decoration: none; 
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              \u{1F511} R\xE9initialiser mon mot de passe
            </a>
          </div>
          
          <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px;">
            <p style="margin: 0; color: #856404;">
              <strong>\u23F0 Important :</strong> Ce lien expire dans 1 heure.
            </p>
          </div>
          
          <p style="margin-top: 20px;">Si vous n'avez pas demand\xE9 cette r\xE9initialisation, vous pouvez ignorer cet email.</p>
        </div>
      </div>
    `;
      }
      getAccountReactivationTemplate(firstName) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #28a745;">
          <h1 style="color: #28a745;">\u2705 Compte R\xE9activ\xE9</h1>
          <p>Bonjour ${firstName},</p>
          <p>Votre compte EasyRent a \xE9t\xE9 r\xE9activ\xE9 avec succ\xE8s.</p>
          <p>Vous pouvez maintenant vous connecter et utiliser \xE0 nouveau tous nos services.</p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/login" 
               style="background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none; 
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              Se connecter
            </a>
          </div>
        </div>
      </div>
    `;
      }
      getAccountDeactivationTemplate(firstName) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #ffc107;">
          <h1 style="color: #ffc107;">\u26A0\uFE0F Compte D\xE9sactiv\xE9</h1>
          <p>Bonjour ${firstName},</p>
          <p style="font-size: 16px; font-weight: bold; color: #856404;">
            Votre compte EasyRent a \xE9t\xE9 temporairement d\xE9sactiv\xE9.
          </p>
          
          <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #856404;">
              <strong>Que signifie cela ?</strong>
            </p>
            <ul style="color: #856404; margin: 10px 0;">
              <li>Vous ne pouvez plus vous connecter \xE0 votre compte</li>
              <li>Vos annonces ne sont plus visibles</li>
              <li>Vous ne pouvez pas effectuer de nouvelles actions</li>
            </ul>
          </div>
          
          <p style="color: #333;">
            Cette mesure est g\xE9n\xE9ralement temporaire. Pour r\xE9activer votre compte ou obtenir plus d'informations, 
            veuillez contacter notre \xE9quipe de support.
          </p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/contact-support" 
               style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; 
                      border-radius: 4px; display: inline-block; margin: 5px;">
              Contacter le support
            </a>
          </div>
          
          <p style="font-size: 14px; color: #666;">
            Nous nous effor\xE7ons de maintenir un environnement s\xFBr pour tous nos utilisateurs.
          </p>
          <p style="font-weight: bold;">L'\xE9quipe EasyRent</p>
        </div>
      </div>
    `;
      }
      getAccountDeletedTemplate(firstName, comment) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #dc3545;">
          <h1 style="color: #dc3545;">\u274C Compte Supprim\xE9</h1>
          <p>Bonjour ${firstName},</p>
          <p style="font-size: 16px; font-weight: bold; color: #dc3545;">
            Votre compte EasyRent a \xE9t\xE9 d\xE9finitivement supprim\xE9.
          </p>
          
          ${comment ? `
            <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 4px; margin: 20px 0;">
              <p style="margin: 0; color: #721c24;">
                <strong>Raison :</strong> ${comment}
              </p>
            </div>
          ` : ""}
          
          <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #0c5460;">
              <strong>Cons\xE9quences de la suppression :</strong>
            </p>
            <ul style="color: #0c5460; margin: 10px 0;">
              <li>Toutes vos donn\xE9es personnelles ont \xE9t\xE9 supprim\xE9es</li>
              <li>Vos annonces ne sont plus accessibles</li>
              <li>Votre historique de transactions est archiv\xE9 selon nos obligations l\xE9gales</li>
              <li>Vous ne pouvez plus acc\xE9der \xE0 votre compte</li>
            </ul>
          </div>
          
          <p style="color: #333;">
            Si vous pensez que cette suppression est une erreur, ou si vous souhaitez cr\xE9er un nouveau compte, 
            vous pouvez contacter notre \xE9quipe de support.
          </p>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/contact-support" 
               style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; 
                      border-radius: 4px; display: inline-block; margin: 5px;">
              Contacter le support
            </a>
            <a href="${config_default.app.frontendUrl}/register" 
               style="background-color: #28a745; color: white; padding: 12px 24px; text-decoration: none; 
                      border-radius: 4px; display: inline-block; margin: 5px;">
              Cr\xE9er un nouveau compte
            </a>
          </div>
          
          <p style="font-size: 14px; color: #666;">
            Merci d'avoir utilis\xE9 EasyRent. Nous esp\xE9rons vous revoir bient\xF4t.
          </p>
          <p style="font-weight: bold;">L'\xE9quipe EasyRent</p>
        </div>
      </div>
    `;
      }
      getAccountLockedEmailTemplate(firstName, reason, lockDuration) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #dc3545;">
          <h1 style="color: #dc3545;">\u{1F512} Compte Temporairement Verrouill\xE9</h1>
          <p>Bonjour ${firstName},</p>
          <p style="font-size: 16px; font-weight: bold; color: #dc3545;">
            Votre compte a \xE9t\xE9 temporairement verrouill\xE9 pour des raisons de s\xE9curit\xE9.
          </p>
          
          ${reason ? `
            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; margin: 20px 0;">
              <p style="margin: 0; color: #856404;">
                <strong>Raison :</strong> ${reason}
              </p>
            </div>
          ` : ""}
          
          ${lockDuration ? `
            <p style="color: #333;">
              <strong>Dur\xE9e du verrouillage :</strong> ${lockDuration}
            </p>
          ` : ""}
          
          <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #0c5460;">
              <strong>Que faire maintenant ?</strong>
            </p>
            <ul style="color: #0c5460; margin: 10px 0;">
              <li>Attendez la fin de la p\xE9riode de verrouillage</li>
              <li>Contactez notre support si vous pensez qu'il s'agit d'une erreur</li>
              <li>V\xE9rifiez la s\xE9curit\xE9 de votre compte</li>
            </ul>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/contact-support" 
               style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; 
                      border-radius: 4px; display: inline-block; margin: 5px;">
              Contacter le support
            </a>
          </div>
          
          <p style="font-size: 14px; color: #666;">
            Cette mesure de s\xE9curit\xE9 nous aide \xE0 prot\xE9ger votre compte et nos services.
          </p>
          <p style="font-weight: bold;">L'\xE9quipe de s\xE9curit\xE9</p>
        </div>
      </div>
    `;
      }
      getAccountRestoredEmailTemplate(firstName, comment) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #28a745;">
          <h1 style="color: #28a745;">\u2705 Compte Restaur\xE9 avec Succ\xE8s</h1>
          <p>Bonjour ${firstName},</p>
          <p style="font-size: 16px; font-weight: bold; color: #28a745;">
            Bonne nouvelle ! Votre compte a \xE9t\xE9 restaur\xE9 et est maintenant accessible.
          </p>
          
          ${comment ? `
            <div style="background-color: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 4px; margin: 20px 0;">
              <p style="margin: 0; color: #155724;">
                <strong>Note :</strong> ${comment}
              </p>
            </div>
          ` : ""}
          
          <div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #0c5460;">
              <strong>Recommandations de s\xE9curit\xE9 :</strong>
            </p>
            <ul style="color: #0c5460; margin: 10px 0;">
              <li>Changez votre mot de passe si n\xE9cessaire</li>
              <li>Activez l'authentification \xE0 deux facteurs</li>
              <li>V\xE9rifiez vos param\xE8tres de s\xE9curit\xE9</li>
              <li>Surveillez l'activit\xE9 de votre compte</li>
            </ul>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${config_default.app.frontendUrl}/login" 
               style="background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none; 
                      border-radius: 5px; display: inline-block; font-weight: bold; margin: 5px;">
              Se connecter
            </a>
            <a href="${config_default.app.frontendUrl}/security-settings" 
               style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; 
                      border-radius: 4px; display: inline-block; margin: 5px;">
              Param\xE8tres s\xE9curit\xE9
            </a>
          </div>
          
          <p style="font-size: 14px; color: #666;">
            Merci pour votre patience. Nous nous effor\xE7ons de maintenir la s\xE9curit\xE9 de tous nos utilisateurs.
          </p>
          <p style="font-weight: bold;">L'\xE9quipe de support</p>
        </div>
      </div>
    `;
      }
      getPasswordChangeConfirmationTemplate(firstName) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
          <h1 style="color: #28a745;">Confirmation de changement de mot de passe</h1>
          <p>Bonjour ${firstName},</p>
          <p>Votre mot de passe EasyRent a \xE9t\xE9 modifi\xE9 avec succ\xE8s.</p>
          <p>Si vous n'avez pas effectu\xE9 cette modification, veuillez contacter imm\xE9diatement notre support.</p>
          
          <div style="text-align: center; margin: 20px 0;">
            <a href="${config_default.app.frontendUrl}/contact-support" 
               style="background-color: #dc3545; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
              Contacter le support
            </a>
          </div>
        </div>
      </div>
    `;
      }
      getAgentVerificationStatusTemplate(firstName, status, comment) {
        let statusMessage;
        let statusColor;
        switch (status) {
          case "verified" /* VERIFIED */:
            statusMessage = "Votre compte agent a \xE9t\xE9 v\xE9rifi\xE9 avec succ\xE8s. Vous pouvez maintenant acc\xE9der \xE0 toutes les fonctionnalit\xE9s d'agent sur EasyRent.";
            statusColor = "#28a745";
            break;
          case "rejected" /* REJECTED */:
            statusMessage = "Nous sommes d\xE9sol\xE9s de vous informer que votre demande de v\xE9rification d'agent a \xE9t\xE9 rejet\xE9e.";
            statusColor = "#dc3545";
            break;
          case "pending" /* PENDING */:
            statusMessage = "Votre demande de v\xE9rification d'agent est en cours d'examen par notre \xE9quipe.";
            statusColor = "#ffc107";
            break;
          default:
            statusMessage = "Le statut de votre compte agent a \xE9t\xE9 mis \xE0 jour.";
            statusColor = "#007bff";
        }
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <h1 style="color: ${statusColor};">Bonjour ${firstName},</h1>
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid ${statusColor};">
          <p style="margin: 0; font-size: 16px;">${statusMessage}</p>
          ${comment ? `<p style="margin-top: 15px; font-style: italic; color: #666;">Commentaire: ${comment}</p>` : ""}
        </div>
        <p style="margin-top: 20px;">Si vous avez des questions, n'h\xE9sitez pas \xE0 contacter notre support.</p>
        <div style="text-align: center; margin: 20px 0;">
          <a href="${config_default.app.frontendUrl}/contact-support" 
             style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
            Contacter le support
          </a>
        </div>
      </div>
    `;
      }
      getSecurityAlertEmailTemplate(firstName, alertType, comment) {
        let alertMessage;
        let alertIcon;
        switch (alertType) {
          case "login_attempt":
            alertMessage = "Une tentative de connexion suspecte a \xE9t\xE9 d\xE9tect\xE9e sur votre compte.";
            alertIcon = "\u{1F510}";
            break;
          case "password_changed":
            alertMessage = "Votre mot de passe a \xE9t\xE9 modifi\xE9.";
            alertIcon = "\u{1F511}";
            break;
          case "account_accessed":
            alertMessage = "Votre compte a \xE9t\xE9 acc\xE9d\xE9 depuis un nouvel appareil ou emplacement.";
            alertIcon = "\u{1F4F1}";
            break;
          case "information_changed":
            alertMessage = "Vos informations personnelles ont \xE9t\xE9 modifi\xE9es.";
            alertIcon = "\u270F\uFE0F";
            break;
          default:
            alertMessage = "Une activit\xE9 de s\xE9curit\xE9 importante a \xE9t\xE9 d\xE9tect\xE9e sur votre compte.";
            alertIcon = "\u26A0\uFE0F";
        }
        return `
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
      <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #dc3545;">
        <h1 style="color: #dc3545;">\u{1F6A8} Alerte de S\xE9curit\xE9</h1>
        <p>Bonjour ${firstName},</p>
        <p style="font-size: 16px; font-weight: bold; color: #dc3545;">
          ${alertIcon} ${alertMessage}
        </p>
        
        ${comment ? `
          <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 4px; margin: 20px 0;">
            <p style="margin: 0; color: #721c24;">
              <strong>D\xE9tails :</strong> ${comment}
            </p>
          </div>
        ` : ""}
        
        <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; margin: 20px 0;">
          <p style="margin: 0; color: #856404;">
            <strong>Si cette activit\xE9 ne provient pas de vous, veuillez imm\xE9diatement :</strong>
          </p>
        </div>
        
        <ol style="color: #333;">
          <li>Changer votre mot de passe</li>
          <li>Activer l'authentification \xE0 deux facteurs si ce n'est pas d\xE9j\xE0 fait</li>
          <li>Contacter notre \xE9quipe de support</li>
        </ol>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="${config_default.app.frontendUrl}/change-password" 
             style="background-color: #dc3545; color: white; padding: 12px 24px; text-decoration: none; 
                    border-radius: 4px; display: inline-block; margin: 5px;">
            Changer mot de passe
          </a>
          <a href="${config_default.app.frontendUrl}/security-settings" 
             style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; 
                    border-radius: 4px; display: inline-block; margin: 5px;">
            Param\xE8tres s\xE9curit\xE9
          </a>
        </div>
        
        <p style="font-size: 14px; color: #666;">
          Si cette activit\xE9 provient de vous, vous pouvez ignorer cet email.
        </p>
        <p style="font-weight: bold;">L'\xE9quipe de s\xE9curit\xE9 EasyRent</p>
      </div>
    </div>
  `;
      }
    };
  }
});

// src/auth/utils/AppError.ts
var AppError;
var init_AppError = __esm({
  "src/auth/utils/AppError.ts"() {
    AppError = class extends Error {
      constructor(message, statusCode = 500) {
        super(message);
        __publicField(this, "statusCode");
        this.statusCode = statusCode;
        Error.captureStackTrace(this, this.constructor);
      }
    };
  }
});

// src/users/services/userService.ts
import bcrypt2 from "bcrypt";
import * as crypto2 from "crypto";
import mongoose from "mongoose";
var logger8, UserService;
var init_userService = __esm({
  "src/users/services/userService.ts"() {
    init_userModel();
    init_userTypes();
    init_userTypes();
    init_notificationServices();
    init_logger();
    init_AppError();
    logger8 = createLogger2("UserService");
    UserService = class {
      // private securityAuditService: SecurityAuditService;
      constructor() {
        __publicField(this, "notificationService");
        this.notificationService = new NotificationService();
      }
      /**
       * Crée un nouvel utilisateur
       */
      async createUser(userData, sendVerificationEmail = false) {
        try {
          logger8.info("Creating new user", {
            email: userData.email?.substring(0, 5) + "***",
            sendVerificationEmail
          });
          return await this.createUserWithRawPassword(userData, sendVerificationEmail);
        } catch (error2) {
          logger8.error("Error creating user", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            email: userData.email?.substring(0, 5) + "***"
          });
          throw error2;
        }
      }
      async createUserWithHashedPassword(userData, sendVerificationEmail = false) {
        try {
          const userDataWithFlag = {
            ...userData,
            _passwordAlreadyHashed: true
          };
          return await this.createUserInternal(userDataWithFlag, sendVerificationEmail);
        } catch (error2) {
          logger8.error("Error creating user with hashed password", { error: error2 });
          throw error2;
        }
      }
      async createUserWithRawPassword(userData, sendVerificationEmail = false) {
        return await this.createUserInternal(userData, sendVerificationEmail);
      }
      async createUserInternal(userData, sendVerificationEmail) {
        if (sendVerificationEmail) {
          userData.emailVerificationToken = crypto2.randomBytes(32).toString("hex");
          userData.emailVerificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1e3);
        }
        const user = await userModel_default.create(userData);
        if (sendVerificationEmail && userData.emailVerificationToken && user.email && user.firstName) {
          try {
            await this.notificationService.sendVerificationEmail(
              user.email,
              user.firstName,
              userData.emailVerificationToken
            );
            logger8.info("Email de v\xE9rification envoy\xE9", {
              userId: user.id.toString(),
              email: user.email.substring(0, 5) + "***"
            });
          } catch (emailError) {
            logger8.warn("Erreur lors de l'envoi de l'email", {
              error: emailError instanceof Error ? emailError.message : "Erreur inconnue",
              userId: user.id.toString()
            });
          }
        }
        logger8.info("User created successfully", {
          userId: user.id.toString(),
          emailSentFromCreate: sendVerificationEmail
        });
        return user;
      }
      // Dans votre UserService, ajoutez cette méthode :
      async getUserByEmailWithRefreshTokens(email) {
        try {
          const user = await userModel_default.findOne({
            email: email.toLowerCase(),
            isActive: true,
            isDeleted: false
          }).populate("refreshTokens").exec();
          if (!user) {
            logger8.warn("Utilisateur non trouv\xE9 avec refresh tokens", {
              email: email.substring(0, 5) + "***"
            });
            return null;
          }
          logger8.info("Utilisateur r\xE9cup\xE9r\xE9 avec refresh tokens", {
            userId: user._id?.toString(),
            refreshTokensCount: user.refreshTokens?.length || 0
          });
          return user;
        } catch (error2) {
          logger8.error("Erreur lors de la r\xE9cup\xE9ration utilisateur avec refresh tokens", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            email: email.substring(0, 5) + "***"
          });
          throw error2;
        }
      }
      /**
       * Retrouve un utilisateur par son ID
       */
      async getUserById(id) {
        if (!mongoose.Types.ObjectId.isValid(id)) {
          logger8.warn("Invalid user ID format", { id });
          return null;
        }
        try {
          return await userModel_default.findById(id).select("-password -resetPasswordToken -emailVerificationToken");
        } catch (error2) {
          logger8.error("Error fetching user by ID", { error: error2, id });
          throw error2;
        }
      }
      /**
       * get   user  by   email  and  password
       */
      async getUserByEmailWithPassword(email) {
        try {
          if (!email || typeof email !== "string") {
            logger8.warn("email  invamide  fournis ", { email });
            return null;
          }
          const normalizedEmail = email.toLowerCase().trim();
          logger8.debug("Recherche utilisateur", { email: normalizedEmail });
          const user = await userModel_default.findOne({
            email: normalizedEmail,
            isDeleted: { $ne: true }
          }).select("+password");
          if (user) {
            logger8.info("Utilisateur trouv\xE9", {
              userId: user._id?.toString(),
              email: user.email,
              isActive: user.isActive,
              hasPassword: !!user.password,
              passwordLength: user.password?.length || 0
            });
          } else {
            logger8.warn("Aucun utilisateur trouv\xE9", { email: normalizedEmail });
          }
          return user;
        } catch (error2) {
          logger8.error("Erreur lors de la r\xE9cup\xE9ration de l'utilisateur", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            email
          });
          throw new Error("Erreur lors de la r\xE9cup\xE9ration de l'utilisateur");
        }
      }
      /**
       * Retrouve un utilisateur par son email
       */
      async getUserByEmail(email) {
        try {
          const normalizeEmail = email.toLowerCase().trim();
          return await userModel_default.findOne({
            email: normalizeEmail,
            isDeleted: { $ne: true }
            // Also check if user is not deleted
          });
        } catch (error2) {
          logger8.error("Error fetching user by email", { error: error2, email });
          throw error2;
        }
      }
      async debugUser(email) {
        try {
          const userWithoutPassword = await userModel_default.findOne({ email: email.toLowerCase() });
          const userWithPassword = await userModel_default.findOne({ email: email.toLowerCase() }).select("+password");
          console.log("User without password select:", {
            email: userWithoutPassword?.email,
            hasPassword: !!userWithoutPassword?.password
          });
          console.log("User with password select:", {
            email: userWithPassword?.email,
            hasPassword: !!userWithPassword?.password,
            passwordLength: userWithPassword?.password?.length
          });
        } catch (error2) {
          console.error("Debug error:", error2);
        }
      }
      /**
      * Retrouve un utilisateur par son email
      */
      async getUserByUsername(username) {
        try {
          return await userModel_default.findOne({ username: username.toLowerCase() }).select("-resetPasswordToken -emailVerificationToken");
        } catch (error2) {
          logger8.error("Error fetching user by username", { error: error2, username });
          throw error2;
        }
      }
      /**
       * Obtenir la liste des utilisateurs avec pagination et filtres
       */
      async getUsers(options) {
        try {
          const {
            page = 1,
            limit = 10,
            sortBy = "createdAt",
            sortOrder = "desc",
            isActive,
            role,
            ...otherFilters
          } = options;
          const filters = {
            isDeleted: { $ne: true },
            ...otherFilters
          };
          if (isActive !== void 0) {
            filters.isActive = isActive;
          }
          if (role) {
            filters.role = role;
          }
          const sort = {
            [sortBy]: sortOrder === "asc" ? 1 : -1
          };
          const users = await userModel_default.find(filters).select("-password -resetPasswordToken -emailVerificationToken").sort(sort).skip((page - 1) * limit).limit(limit);
          const total = await userModel_default.countDocuments(filters);
          return {
            data: users,
            total,
            page,
            limit
          };
        } catch (error2) {
          logger8.error("Erreur lors de la r\xE9cup\xE9ration des utilisateurs", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            options
          });
          throw error2;
        }
      }
      /**
       * Recherche avancée d'utilisateurs
       */
      async searchUsers(options) {
        try {
          const {
            query: query2,
            fields = ["firstName", "lastName", "email"],
            page = 1,
            limit = 10,
            filters = {},
            sortBy = "createdAt",
            sortOrder = "desc"
          } = options;
          const searchCriteria = {
            isDeleted: { $ne: true },
            ...filters
          };
          if (query2) {
            const orConditions = fields.map((field) => ({
              [field]: { $regex: query2, $options: "i" }
            }));
            searchCriteria.$or = orConditions;
          }
          const sort = {
            [sortBy]: sortOrder === "asc" ? 1 : -1
          };
          const users = await userModel_default.find(searchCriteria).select("-password -resetPasswordToken -emailVerificationToken").sort(sort).skip((page - 1) * limit).limit(limit);
          const total = await userModel_default.countDocuments(searchCriteria);
          return {
            data: users,
            total,
            page,
            limit
          };
        } catch (error2) {
          logger8.error("Erreur lors de la recherche d'utilisateurs", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            query: options.query
          });
          throw error2;
        }
      }
      async updateUserLoginInfo(user, loginDetails, successful) {
        try {
          if (typeof user.recordLoginAttempt === "function") {
            user.recordLoginAttempt({
              ...loginDetails,
              successful
            });
          }
          if (successful && typeof user.updateLastLogin === "function") {
            user.updateLastLogin(loginDetails.ipAddress, loginDetails.userAgent);
          }
          if (typeof user.save === "function") {
            await user.save();
          }
        } catch (error2) {
          logger8.warn("Failed to update user login info", { error: error2 });
        }
      }
      /**
       * Met à jour un utilisateur existant
        */
      async updateUser(id, updateData) {
        try {
          logger8.info("Updating user process start", { id });
          const { password, email, isDeleted, ...safeUpdateData } = updateData;
          let updateObject = { ...safeUpdateData };
          if (password) {
            updateObject.password = await bcrypt2.hash(password, 12);
          }
          if (email) {
            const existingUser = await userModel_default.findOne({ email, _id: { $ne: id } });
            if (existingUser) {
              throw new AppError("Cet email est d\xE9j\xE0 utilis\xE9 par un autre compte", 409);
            }
            updateObject.email = email;
            updateObject.isEmailVerified = false;
            updateObject.emailVerificationToken = crypto2.randomBytes(32).toString("hex");
            updateObject.emailVerificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1e3);
            try {
              await this.notificationService.sendVerificationEmail(
                email,
                updateObject.firstName || "",
                updateObject.emailVerificationToken
              );
              logger8.info("Email de v\xE9rification envoy\xE9 lors de la mise \xE0 jour", {
                userId: id,
                newEmail: email.substring(0, 5) + "***"
              });
            } catch (emailError) {
              logger8.warn("Erreur lors de l'envoi de l'email de v\xE9rification", {
                error: emailError instanceof Error ? emailError.message : "Erreur inconnue",
                userId: id
              });
            }
          }
          const user = await userModel_default.findByIdAndUpdate(
            id,
            {
              $set: updateObject,
              $currentDate: { updatedAt: true }
              // FIXED: Removed duplicate updateData parameter
            },
            { new: true, runValidators: true }
          ).select("-password -resetPasswordToken -emailVerificationToken");
          if (!user) {
            logger8.warn("User not found for update", { id });
            throw new AppError("Utilisateur non trouv\xE9", 404);
          } else {
            logger8.info("User updated successfully", { id });
          }
          return user;
        } catch (error2) {
          logger8.error("Error updating user", { error: error2, id, updateData });
          throw error2;
        }
      }
      async configureNotification(userId, notification) {
        const user = await this.getUserById(userId);
        if (!user?.email_activate || !user.push_activate) {
          logger8.warn("user is not  found");
          return null;
        }
        if (notification.email_activate !== void 0) {
          user.email_activate = notification.email_activate;
        }
        if (notification.push_activate !== void 0) {
          user.push_activate = notification.push_activate;
        }
        await user.save();
        logger8.info(`User ${userId} notification config updated`);
        return user;
      }
      // Méthode pour mettre à jour spécifiquement les secrets 2FA
      async updateTwoFactorSecrets(userId, secrets) {
        try {
          const updateData = {};
          if (secrets.tempTwoFactorSecret !== void 0) {
            updateData["security.tempTwoFactorSecret"] = secrets.tempTwoFactorSecret;
          }
          if (secrets.tempTwoFactorSecretExpires !== void 0) {
            updateData["security.tempTwoFactorSecretExpires"] = secrets.tempTwoFactorSecretExpires;
          }
          if (secrets.twoFactorSecret !== void 0) {
            updateData["security.twoFactorSecret"] = secrets.twoFactorSecret;
          }
          return await this.updateUser(userId, updateData);
        } catch (error2) {
          logger8.error("Error updating 2FA secrets", { userId, error: error2.message });
          throw error2;
        }
      }
      // // Méthode pour mettre à jour les codes de sauvegarde
      // async updateBackupCodes(userId: string, backupCodes: Array<{
      //   code: string;
      //   used: boolean;
      //   createdAt: Date;
      //   usedAt?: Date;
      // }>): Promise<IUser | null> {
      //   try {
      //     const updateData: MongoUpdateUserDto = {
      //       'security.backupCodes': backupCodes
      //     };
      //     return await this.updateUser(userId, updateData);
      //   } catch (error: any) {
      //     logger.error('Error updating backup codes', { userId, error: error.message });
      //     throw error;
      //   }
      // }
      // Méthode pour obtenir les détails de sécurité
      async getSecurityDetails(userId) {
        try {
          const user = await userModel_default.findById(userId).select("security");
          return user?.security || null;
        } catch (error2) {
          logger8.error("Error getting security details", { userId, error: error2.message });
          throw error2;
        }
      }
      // Méthode pour obtenir les codes de sauvegarde non utilisés
      async getAvailableBackupCodes(userId) {
        try {
          const user = await userModel_default.findById(userId).select("security.backupCodes");
          if (!user?.security?.backupCodes) {
            return [];
          }
          return user.security.backupCodes.filter((code) => !code.used).map((code) => code.code);
        } catch (error2) {
          logger8.error("Error getting available backup codes", { userId, error: error2.message });
          return [];
        }
      }
      /**
       * Désactive un compte utilisateur
       */
      async deactivateUser(id) {
        try {
          logger8.info("Deactivating user", { id });
          const user = await userModel_default.findByIdAndUpdate(
            id,
            { $set: { isActive: false } },
            { new: true }
          );
          if (user) {
            await this.notificationService.sendAccountDeactivationEmail(user.email, user.firstName);
            logger8.info("User deactivated successfully", { id });
          } else {
            logger8.warn("User not found for deactivation", { id });
          }
          return user;
        } catch (error2) {
          logger8.error("Error deactivating user", { error: error2, id });
          throw error2;
        }
      }
      /**
       * Réactive un compte utilisateur
       */
      async reactivateUser(id) {
        try {
          logger8.info("Reactivating user", { id });
          const user = await userModel_default.findByIdAndUpdate(
            id,
            { $set: { isActive: true } },
            { new: true }
          );
          if (user) {
            await this.notificationService.sendAccountReactivationEmail(user.email, user.firstName);
            logger8.info("User reactivated successfully", { id });
          } else {
            logger8.warn("User not found for reactivation", { id });
          }
          return user;
        } catch (error2) {
          logger8.error("Error reactivating user", { error: error2, id });
          throw error2;
        }
      }
      /**
       * Vérifie un compte utilisateur avec token
       */
      async verifyUser(verificationToken) {
        try {
          logger8.info("Verifying user account");
          const user = await userModel_default.findOne({ emailVerificationToken: verificationToken });
          if (!user) {
            logger8.warn("Invalid verification token", { verificationToken });
            return {
              success: false,
              message: "Token invalide ou expir\xE9"
            };
          }
          user.isEmailVerified = true;
          user.emailVerificationToken = void 0;
          user.emailVerificationTokenExpires = void 0;
          user.isActive = true;
          await user.save();
          if (user.role === "agent" /* AGENT */ && user.agentDetails) {
            user.agentDetails.verificationStatus = "pending" /* PENDING */;
            await user.save();
          }
          logger8.info("User verified successfully", { id: user.id });
          await this.notificationService.sendWelcomeEmail(user.email, user.firstName);
          return {
            success: true,
            userId: user.id
          };
        } catch (error2) {
          logger8.error("Error verifying user", { error: error2, verificationToken });
          throw error2;
        }
      }
      /**
       * Retrouve un utilisateur par son token de vérification
       */
      async getUserByVerificationToken(verificationToken) {
        try {
          logger8.info("Fetching user by verification token");
          const user = await userModel_default.findOne({
            emailVerificationToken: verificationToken,
            emailVerificationTokenExpires: { $gt: /* @__PURE__ */ new Date() }
            // Vérifier que le token n'est pas expiré
          }).select("-password -resetPasswordToken");
          if (!user) {
            logger8.warn("User not found or token expired", { verificationToken });
            return null;
          }
          logger8.info("User found by verification token", { userId: user.id });
          return user;
        } catch (error2) {
          logger8.error("Error fetching user by verification token", { error: error2, verificationToken });
          throw error2;
        }
      }
      /**
       * Met à jour le token de vérification d'un utilisateur
       */
      async updateVerificationToken(userId, sendNewEmail = true) {
        try {
          logger8.info("Updating verification token", { userId });
          const user = await userModel_default.findById(userId);
          if (!user) {
            logger8.warn("User not found for verification token update", { userId });
            return {
              success: false,
              message: "Utilisateur non trouv\xE9"
            };
          }
          const newVerificationToken = crypto2.randomBytes(32).toString("hex");
          const tokenExpiration = new Date(Date.now() + 24 * 60 * 60 * 1e3);
          user.emailVerificationToken = newVerificationToken;
          user.emailVerificationTokenExpires = tokenExpiration;
          await user.save();
          if (sendNewEmail) {
            await this.notificationService.sendVerificationEmail(
              user.email,
              user.firstName,
              // ✅ firstName en 2ème position
              newVerificationToken
              // ✅ token en 3ème position
            );
            logger8.info("New verification email sent", { userId, email: user.email });
          }
          logger8.info("Verification token updated successfully", { userId });
          return {
            success: true,
            verificationToken: newVerificationToken
          };
        } catch (error2) {
          logger8.error("Error updating verification token", { error: error2, userId });
          throw error2;
        }
      }
      /**
        * Vérifie si le mot de passe fourni est correct pour l'utilisateur donné
       */
      // async verifyPassword(userId: string, password: string): Promise<boolean> {
      //   try {
      //     logger.info('Vérification du mot de passe en cours', { userId });
      //     logger.info('mot de passe', { password });
      //     // Detailed debugging
      //     logger.debug('User ID debug info:', {
      //       userId,
      //       type: typeof userId,
      //       length: userId.length,
      //       isString: typeof userId === 'string',
      //       trimmed: userId.trim(),
      //       isValidObjectId: mongoose.Types.ObjectId.isValid(userId)
      //     });
      //     // Try different approaches
      //     let user: IUser | null = null;
      //     // Approach 1: Direct findById with string
      //     try {
      //       user = await User.findById(userId).select('+password') as IUser | null;
      //       logger.debug('Approach 1 (direct string):', { found: !!user });
      //     } catch (error) {
      //       const err = error as Error;
      //       logger.debug('Approach 1 failed:', { error: err.message });
      //     }
      //     // Approach 2: Convert to ObjectId explicitly
      //     if (!user && mongoose.Types.ObjectId.isValid(userId)) {
      //       try {
      //         const objectId = new mongoose.Types.ObjectId(userId);
      //         user = await User.findById(objectId).select('+password') as IUser | null;
      //         logger.debug('Approach 2 (explicit ObjectId):', { found: !!user });
      //       } catch (error) {
      //         const err = error as Error;
      //         logger.debug('Approach 2 failed:', { error: err.message });
      //       }
      //     }
      //     // Approach 3: Use findOne with _id
      //     if (!user) {
      //       try {
      //         user = await User.findOne({ _id: userId }).select('+password') as IUser | null;
      //         logger.debug('Approach 3 (findOne):', { found: !!user });
      //       } catch (error) {
      //         const err = error as Error;
      //         logger.debug('Approach 3 failed:', { error: err.message });
      //       }
      //     }
      //     // Approach 4: Search and debug database content
      //     if (!user) {
      //       try {
      //         const allUsers = await User.find({}).limit(5).select('_id email') as IUser[];
      //         logger.debug('Sample users in database:', { 
      //           count: allUsers.length,
      //           sampleIds: allUsers.map(u => ({ 
      //             id: u.id.toString(), 
      //             email: u.email 
      //           }))
      //         });
      //         // Try to find user by converted ID
      //         user = await User.findOne({ 
      //           $or: [
      //             { _id: userId },
      //             ...(mongoose.Types.ObjectId.isValid(userId) ? [{ _id: new mongoose.Types.ObjectId(userId) }] : [])
      //           ]
      //         }).select('+password') as IUser | null;
      //         logger.debug('Approach 4 ($or query):', { found: !!user });
      //       } catch (error) {
      //         const err = error as Error;
      //         logger.debug('Approach 4 failed:', { error: err.message });
      //       }
      //     }
      //     if (!user) {
      //       logger.warn('Utilisateur non trouvé avec toutes les approches', { userId });
      //       return false;
      //     }
      //     logger.info('User found successfully', { 
      //       userId, 
      //       userIdFromDb: user.id.toString(),
      //       hasPassword: !!user.password 
      //     });
      //     if (!user.password) {
      //       logger.warn('User found but no password field', { userId });
      //       return false;
      //     }
      //     const isMatch = await bcrypt.compare(password, user.password);
      //     if (!isMatch) {
      //       logger.warn('Mot de passe incorrect', { userId });
      //       return false;
      //     }
      //     logger.info('Mot de passe valide', { userId });
      //     return true;
      //   } catch (error) {
      //     const err = error as Error;
      //     logger.error('Erreur lors de la vérification du mot de passe', { 
      //       error: err.message, 
      //       stack: err.stack,
      //       userId 
      //     });
      //     throw error;
      //   }
      // }
      async verifyPassword(userId, password) {
        try {
          logger8.info("V\xE9rification du mot de passe en cours", { userId });
          logger8.info("mot de passe", { password });
          if (!userId) {
            logger8.warn("User ID is undefined or null");
            return false;
          }
          if (!mongoose.Types.ObjectId.isValid(userId)) {
            logger8.warn("Invalid user ID format", { userId });
            return false;
          }
          const user = await userModel_default.findById(userId).select("+password");
          logger8.info("user is", { found: !!user });
          if (!user) {
            logger8.warn("Utilisateur non trouv\xE9 lors de la v\xE9rification du mot de passe", { userId });
            return false;
          }
          if (!user.password) {
            logger8.warn("User found but no password field", { userId });
            return false;
          }
          const isMatch = await bcrypt2.compare(password, user.password);
          if (!isMatch) {
            logger8.warn("Mot de passe incorrect", { userId });
            return false;
          }
          logger8.info("Mot de passe valide", { userId });
          return true;
        } catch (error2) {
          logger8.error("Erreur lors de la v\xE9rification du mot de passe", {
            error: error2.message,
            userId
          });
          throw error2;
        }
      }
      // async verifyPassword(userId: string, password: string): Promise<boolean> {
      //   try {
      //     logger.info('Vérification du mot de passe en cours', { userId });
      //     logger.info(' mot de  passe ', {password});
      //     const user = await User.findById(userId).select('+password');
      //     // const  user   =  await  this.getUserById(userId)
      //     logger.info('user  is  ',  {user})
      //     if (!user) {
      //       logger.warn('Utilisateur non trouvé lors de la vérification du mot de passe', { userId });
      //       return false;
      //     }
      //     const   userpassword =  user.password
      //     logger.debug("le  mot de passe  de  l utilisateur  est   ", {userpassword})
      //     const isMatch = await bcrypt.compare(password, user.password);
      //     // logger.debug('the password is  :', {user.password})
      //     if (!isMatch) {
      //       logger.warn('Mot de passe incorrect', { userId });
      //       return false;
      //     }
      //     logger.info('Mot de passe valide', { userId });
      //     return true;
      //   } catch (error) {
      //     logger.error('Erreur lors de la vérification du mot de passe', { error, userId });
      //     throw error;
      //   }
      // }
      /**
       * Initialise le processus de réinitialisation de mot de passe
       */
      async initiatePasswordReset(email, redirectUrl) {
        try {
          logger8.info("Initiating password reset", { email });
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user) {
            logger8.warn("User not found for password reset", { email });
            return false;
          }
          const resetToken = crypto2.randomBytes(32).toString("hex");
          user.resetPasswordToken = crypto2.createHash("sha256").update(resetToken).digest("hex");
          user.resetPasswordExpires = new Date(Date.now() + 60 * 60 * 1e3);
          await user.save();
          const resetLink = `${redirectUrl}?token=${resetToken}&email=${encodeURIComponent(email)}`;
          logger8.debug("user  information", {
            email,
            firstname: user.firstName,
            resetLink
          });
          await this.notificationService.sendPasswordResetEmail(email, resetLink, user.firstName || "");
          logger8.info("Password reset initiated successfully", { email });
          return true;
        } catch (error2) {
          logger8.error("Error initiating password reset", { error: error2, email });
          throw error2;
        }
      }
      /**
       * Réinitialise le mot de passe avec un jeton
       */
      async resetPassword(token, newPassword) {
        console.log("call fo resetpassword");
        try {
          logger8.info("Resetting password");
          const hashedToken = crypto2.createHash("sha256").update(token).digest("hex");
          const user = await userModel_default.findOne({
            resetPasswordToken: hashedToken,
            resetPasswordExpires: { $gt: Date.now() }
          });
          if (!user) {
            logger8.warn("Invalid or expired password reset token", { token });
            return {
              success: false,
              message: "Token de r\xE9initialisation invalide ou expir\xE9"
            };
          }
          user.password = await bcrypt2.hash(newPassword, 12);
          user.resetPasswordToken = void 0;
          user.resetPasswordExpires = void 0;
          user.passwordChangedAt = /* @__PURE__ */ new Date();
          user.refreshTokens = [];
          await user.save();
          logger8.info("Password reset successfully", { id: user.id });
          logger8.debug("user  information", {
            email: user.email,
            firstname: user.firstName
          });
          await this.notificationService.sendPasswordChangeConfirmationEmail(user.email, user.firstName);
          return {
            success: true,
            userId: user.id.toString()
          };
        } catch (error2) {
          logger8.error("Error resetting password", { error: error2, token });
          throw error2;
        }
      }
      /**
       * Change le mot de passe d'un utilisateur
       */
      async changePassword(id, currentPassword, newPassword) {
        try {
          logger8.info("Changing password", { id });
          if (!mongoose.Types.ObjectId.isValid(id)) {
            logger8.warn("Invalid user ID format for password change", { id });
            return false;
          }
          const user = await userModel_default.findById(new mongoose.Types.ObjectId(id)).select("+password");
          if (!user) {
            logger8.warn("User not found for password change", { id });
            return false;
          }
          const isPasswordValid = await bcrypt2.compare(currentPassword, user.password);
          if (!isPasswordValid) {
            logger8.warn("Invalid current password", { id });
            return false;
          }
          user.password = await bcrypt2.hash(newPassword, 12);
          user.passwordChangedAt = /* @__PURE__ */ new Date();
          await user.save();
          const latestToken = user.refreshTokens?.pop();
          user.refreshTokens = latestToken ? [latestToken] : [];
          await user.save();
          logger8.info("Password changed successfully", { id });
          await this.notificationService.sendPasswordChangeConfirmationEmail(user.email, user.firstName);
          return true;
        } catch (error2) {
          logger8.error("Error changing password", { error: error2, id });
          throw error2;
        }
      }
      /**
       * Recherche avancée d'utilisateurs avec paramètres spécifiques
       */
      async searchUsersParams(params) {
        try {
          const {
            query: query2,
            role,
            isActive,
            city,
            country,
            page = 1,
            limit = 10,
            sortBy = "createdAt",
            sortDirection = "desc"
          } = params;
          const filter2 = {};
          if (role) {
            filter2.role = role;
          }
          if (isActive !== void 0) {
            filter2.isActive = isActive;
          }
          if (city) {
            filter2["address.city"] = new RegExp(city, "i");
          }
          if (country) {
            filter2["address.country"] = new RegExp(country, "i");
          }
          if (query2) {
            filter2.$text = { $search: query2 };
          }
          const total = await userModel_default.countDocuments(filter2);
          const users = await userModel_default.find(filter2).sort({ [sortBy]: sortDirection === "asc" ? 1 : -1 }).skip((page - 1) * limit).limit(limit);
          return { users, total };
        } catch (error2) {
          logger8.error("Error searching users", { error: error2, params });
          throw error2;
        }
      }
      /**
       * Active l'authentification à deux facteurs
       */
      async enableTwoFactorAuth(userId) {
        try {
          await userModel_default.findByIdAndUpdate(userId, {
            "preferences.twoFactorEnabled": true
          });
          return {
            secret: "GENERATED_SECRET",
            qrCodeUrl: "URL_TO_QR_CODE"
          };
        } catch (error2) {
          logger8.error("Error enabling 2FA", { error: error2, userId });
          throw error2;
        }
      }
      //verify hastwo factor  code  
      async hasTwoFactorEnabled(userId) {
        const user = await userModel_default.findById(userId);
        if (!user) {
          logger8.warn("user  is  not  found");
          return false;
        }
        const twofactorenable = user.preferences.twoFactorEnabled;
        if (twofactorenable) {
          logger8.info("two  facto  is  enable  for  the  user  ");
          return true;
        } else {
          logger8.warn("two facto  is  off  for this  user ");
          return false;
        }
      }
      /**
       * Désactive l'authentification à deux facteurs
       */
      async disableTwoFactorAuth(userId) {
        try {
          const result = await userModel_default.findByIdAndUpdate(userId, {
            "preferences.twoFactorEnabled": false
          });
          return !!result;
        } catch (error2) {
          logger8.error("Error disabling 2FA", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Met à jour le statut de vérification d'un agent
       */
      async updateAgentVerificationStatus(agentId, status, comment) {
        try {
          const agent = await userModel_default.findOne({
            _id: agentId,
            role: "agent" /* AGENT */
          });
          if (!agent || !agent.agentDetails) {
            return null;
          }
          agent.agentDetails.verificationStatus = status;
          if (status === "verified" /* VERIFIED */) {
            agent.agentDetails.verificationDate = /* @__PURE__ */ new Date();
          }
          await agent.save();
          await this.notificationService.sendAgentVerificationStatusEmail(
            agent.email,
            agent.firstName,
            status,
            comment
          );
          return agent;
        } catch (error2) {
          logger8.error("Error updating agent verification status", { error: error2, agentId, status });
          throw error2;
        }
      }
      /**
       * Stocke temporairement le secret 2FA avant confirmation
       */
      async storeTempTwoFactorSecret(userId, secret) {
        try {
          logger8.info("Storing temporary 2FA secret", { userId });
          const result = await userModel_default.findByIdAndUpdate(userId, {
            "security.tempTwoFactorSecret": secret,
            "security.tempTwoFactorSecretExpires": new Date(Date.now() + 10 * 60 * 1e3)
            // 10 minutes
          });
          return !!result;
        } catch (error2) {
          logger8.error("Error storing temp 2FA secret", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Stocke le code de vérification email
       */
      async storeVerificationCode(userId, code) {
        try {
          logger8.info("Storing verification code", { userId });
          const result = await userModel_default.findByIdAndUpdate(userId, {
            emailVerificationCode: code,
            emailVerificationCodeExpires: new Date(Date.now() + 10 * 60 * 1e3)
            // 10 minutes
          });
          return !!result;
        } catch (error2) {
          logger8.error("Error storing verification code", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Vérifie l'email avec le code
       */
      async verifyUserWithCode(email, code) {
        try {
          logger8.info("Verifying email with code", { email: email.substring(0, 5) + "***" });
          const user = await userModel_default.findOne({
            email: email.toLowerCase(),
            emailVerificationToken: code,
            emailVerificationTokenExpires: { $gt: /* @__PURE__ */ new Date() }
          });
          if (!user) {
            logger8.warn("Invalid or expired verification code", { email: email.substring(0, 5) + "***" });
            return {
              success: false,
              message: "Code invalide ou expir\xE9"
            };
          }
          user.isEmailVerified = true;
          user.emailVerificationToken = void 0;
          user.emailVerificationTokenExpires = void 0;
          user.isActive = true;
          await user.save();
          logger8.info("Email verified successfully with code", { userId: user.id });
          await this.notificationService.sendWelcomeEmail(user.email, user.firstName);
          return {
            success: true,
            userId: user.id
          };
        } catch (error2) {
          logger8.error("Error verifying email with code", { error: error2, email: email.substring(0, 5) + "***" });
          throw error2;
        }
      }
      /**
       * Alias pour enableTwoFactorAuth pour compatibilité
       */
      async enableTwoFactor(userId) {
        return this.enableTwoFactorAuth(userId);
      }
      /**
       * Alias pour disableTwoFactorAuth pour compatibilité
       */
      async disableTwoFactor(userId) {
        return this.disableTwoFactorAuth(userId);
      }
      /**
       * Met à jour les codes de sauvegarde 2FA
       */
      async updateBackupCodes(userId, backupCodes) {
        try {
          logger8.info("Updating backup codes", { userId });
          const result = await userModel_default.findByIdAndUpdate(userId, {
            "security.backupCodes": backupCodes.map((code) => ({
              code,
              used: false,
              createdAt: /* @__PURE__ */ new Date()
            }))
          });
          return !!result;
        } catch (error2) {
          logger8.error("Error updating backup codes", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Vérifie et consomme un code de sauvegarde 2FA
       */
      async verifyAndConsumeBackupCode(userId, backupCode) {
        try {
          logger8.info("Verifying backup code", { userId });
          const user = await userModel_default.findById(userId);
          if (!user || !user.security?.backupCodes) {
            return false;
          }
          const backupCodeIndex = user.security.backupCodes.findIndex(
            (bc) => bc.code === backupCode && !bc.used
          );
          if (backupCodeIndex === -1) {
            logger8.warn("Invalid or used backup code", { userId });
            return false;
          }
          user.security.backupCodes[backupCodeIndex].used = true;
          user.security.backupCodes[backupCodeIndex].usedAt = /* @__PURE__ */ new Date();
          await user.save();
          logger8.info("Backup code consumed successfully", { userId });
          return true;
        } catch (error2) {
          logger8.error("Error verifying backup code", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Récupère les sessions actives d'un utilisateur
       */
      async getActiveSessions(userId) {
        try {
          const user = await userModel_default.findById(userId);
          if (!user) {
            return [];
          }
          const currentTime = /* @__PURE__ */ new Date();
          const activeSessions = user.refreshTokens?.filter(
            (token) => token.expiresAt > currentTime
          ) || [];
          return activeSessions.map((session) => ({
            id: session.tokenId,
            device: session.device || "Unknown device",
            ipAddress: session.ipAddress || "Unknown IP",
            lastActive: session.lastUsedAt || session.createdAt,
            createdAt: session.createdAt
          }));
        } catch (error2) {
          logger8.error("Error getting active sessions", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Révoque une session spécifique
       */
      async revokeSession(userId, sessionId) {
        try {
          logger8.info("Revoking session", { userId, sessionId });
          const user = await userModel_default.findById(userId);
          if (!user) {
            return false;
          }
          const initialLength = user.refreshTokens?.length || 0;
          if (user.refreshTokens) {
            user.refreshTokens = user.refreshTokens.filter((token) => token.tokenId !== sessionId);
          }
          await user.save();
          const wasRevoked = (user.refreshTokens?.length || 0) < initialLength;
          if (wasRevoked) {
            logger8.info("Session revoked successfully", { userId, sessionId });
          } else {
            logger8.warn("Session not found", { userId, sessionId });
          }
          return wasRevoked;
        } catch (error2) {
          logger8.error("Error revoking session", { error: error2, userId, sessionId });
          throw error2;
        }
      }
      /**
       * Révoque toutes les sessions sauf celle en cours
       */
      async revokeAllSessionsExceptCurrent(userId, currentSessionId) {
        try {
          logger8.info("Revoking all sessions except current", { userId, currentSessionId });
          const user = await userModel_default.findById(userId);
          if (!user) return 0;
          const originalCount = user.refreshTokens?.length || 0;
          const currentSession = user.refreshTokens?.find((token) => token.tokenId === currentSessionId);
          user.refreshTokens = currentSession ? [currentSession] : [];
          await user.save();
          const revokedCount = originalCount - user.refreshTokens.length;
          logger8.info("All sessions revoked except current", { userId, revokedCount });
          return revokedCount;
        } catch (error2) {
          logger8.error("Error revoking all sessions except current", { error: error2, userId, currentSessionId });
          throw error2;
        }
      }
      /**
       * Compte les tentatives de connexion récentes
       */
      async getRecentLoginAttemptsCount(email, timeWindow = 15) {
        try {
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user || !user.security?.loginAttempts) {
            return 0;
          }
          const cutoffTime = new Date(Date.now() - timeWindow * 60 * 1e3);
          const recentAttempts = user.security.loginAttempts.filter(
            (attempt) => attempt.timestamp > cutoffTime
          );
          return recentAttempts.length;
        } catch (error2) {
          logger8.error("Error getting recent login attempts count", { error: error2, email });
          throw error2;
        }
      }
      /**
       * Compte les sessions actives d'un utilisateur
       */
      async getActiveSessionsCount(userId) {
        try {
          const activeSessions = await this.getActiveSessions(userId);
          return activeSessions.length;
        } catch (error2) {
          logger8.error("Error getting active sessions count", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Invalide toutes les sessions d'un utilisateur
       */
      async invalidateAllUserSessions(userId) {
        try {
          logger8.info("Invalidating all user sessions", { userId });
          const result = await userModel_default.findByIdAndUpdate(userId, {
            $set: { refreshTokens: [] }
          });
          if (result) {
            logger8.info("All user sessions invalidated successfully", { userId });
            await this.notificationService.sendSecurityNotification(
              result.email,
              result.firstName,
              "Toutes vos sessions ont \xE9t\xE9 invalid\xE9es"
            );
          }
          return !!result;
        } catch (error2) {
          logger8.error("Error invalidating all user sessions", { error: error2, userId });
          throw error2;
        }
      }
      /**
      * Enregistre une tentative de connexion
      */
      async recordLoginAttempt(email, success, ipAddress, userAgent) {
        try {
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user) {
            return;
          }
          if (!user.security) {
            user.security = {};
          }
          if (!user.security.loginAttempts) {
            user.security.loginAttempts = [];
          }
          user.security.loginAttempts.push({
            timestamp: /* @__PURE__ */ new Date(),
            success,
            ipAddress: ipAddress || "Unknown",
            userAgent: userAgent || "Unknown"
          });
          if (user.security.loginAttempts.length > 50) {
            user.security.loginAttempts = user.security.loginAttempts.slice(-50);
          }
          await user.save();
        } catch (error2) {
          logger8.error("Error recording login attempt", { error: error2, email });
        }
      }
      /**
       * Vérifie si le compte est verrouillé
       */
      async isAccountLocked(email) {
        try {
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user) {
            return false;
          }
          if (user.security?.accountLocked) {
            if (user.security.lockExpiresAt && user.security.lockExpiresAt < /* @__PURE__ */ new Date()) {
              await this.unlockAccount(email);
              return false;
            }
            return true;
          }
          const maxAttempts = 5;
          const recentFailedAttempts = await this.getRecentFailedLoginAttemptsCount(email);
          if (recentFailedAttempts >= maxAttempts) {
            await this.lockAccount(email);
            return true;
          }
          return false;
        } catch (error2) {
          logger8.error("Error checking if account is locked", { error: error2, email });
          return false;
        }
      }
      /**
       * Obtient le nombre de tentatives échouées récentes
       */
      async getRecentFailedLoginAttemptsCount(email, timeWindow = 15) {
        try {
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user || !user.security?.loginAttempts) {
            return 0;
          }
          const cutoffTime = new Date(Date.now() - timeWindow * 60 * 1e3);
          const recentFailedAttempts = user.security.loginAttempts.filter(
            (attempt) => attempt.timestamp > cutoffTime && !attempt.success
          );
          return recentFailedAttempts.length;
        } catch (error2) {
          logger8.error("Error getting recent failed login attempts count", { error: error2, email });
          return 0;
        }
      }
      /**
       * Verrouille un compte utilisateur
       */
      async lockAccount(email, duration = 30) {
        try {
          logger8.info("Locking account", { email });
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user) {
            return false;
          }
          if (!user.security) {
            user.security = {};
          }
          user.security.accountLocked = true;
          user.security.lockExpiresAt = new Date(Date.now() + duration * 60 * 1e3);
          await user.save();
          await this.notificationService.sendAccountLockedEmail(
            user.email,
            user.firstName
            // duration
          );
          logger8.info("Account locked successfully", { email });
          return true;
        } catch (error2) {
          logger8.error("Error locking account", { error: error2, email });
          return false;
        }
      }
      /**
       * Déverrouille un compte utilisateur
       */
      async unlockAccount(email) {
        try {
          logger8.info("Unlocking account", { email });
          const user = await userModel_default.findOne({ email: email.toLowerCase() });
          if (!user) {
            return false;
          }
          if (!user.security) {
            return true;
          }
          user.security.accountLocked = false;
          user.security.lockExpiresAt = void 0;
          await user.save();
          logger8.info("Account unlocked successfully", { email });
          return true;
        } catch (error2) {
          logger8.error("Error unlocking account", { error: error2, email });
          return false;
        }
      }
      /**
       * Vérifie si un compte est marqué comme supprimé
       */
      async isAccountDeleted(id) {
        try {
          const user = await userModel_default.findById(id);
          return !!user?.isDeleted;
        } catch (error2) {
          logger8.error("Error checking if account is deleted", { error: error2, id });
          return false;
        }
      }
      /**
       * Suppression logique d'un utilisateur
       */
      /**
       * Restaure un utilisateur supprimé logiquement
       */
      async restoreDeletedUser(id, email) {
        try {
          logger8.info("Restoring deleted user", { id });
          const existingUser = await userModel_default.findOne({ email, _id: { $ne: id } });
          if (existingUser) {
            logger8.warn("Email already in use", { email });
            throw new AppError("Cet email est d\xE9j\xE0 utilis\xE9 par un autre compte", 409);
          }
          const user = await userModel_default.findByIdAndUpdate(
            id,
            {
              $set: {
                isDeleted: false,
                email,
                deletedAt: void 0
              }
            },
            { new: true }
          );
          if (!user) {
            logger8.warn("User not found for restoration", { id });
            return null;
          }
          logger8.info("User restored successfully", { id });
          await this.notificationService.sendAccountRestoredEmail(
            email,
            user.firstName
          );
          return user;
        } catch (error2) {
          logger8.error("Error restoring deleted user", { error: error2, id });
          throw error2;
        }
      }
      /**
       * Enregistre l'historique des préférences utilisateur
       */
      async updateUserPreferences(id, preferences) {
        try {
          logger8.info("Updating user preferences", { id });
          const user = await userModel_default.findById(id);
          if (!user) {
            logger8.warn("User not found for preference update", { id });
            return null;
          }
          if (!user.preferencesHistory) {
            user.preferencesHistory = [];
          }
          if (user.preferences) {
            user.preferencesHistory.push({
              preferences: { ...user.preferences },
              timestamp: /* @__PURE__ */ new Date()
            });
          }
          if (user.preferencesHistory.length > 10) {
            user.preferencesHistory = user.preferencesHistory.slice(-10);
          }
          user.preferences = {
            ...user.preferences,
            ...preferences,
            updatedAt: /* @__PURE__ */ new Date()
          };
          await user.save();
          logger8.info("User preferences updated successfully", { id });
          return user;
        } catch (error2) {
          logger8.error("Error updating preferences", { error: error2, id });
          throw error2;
        }
      }
      /**
       * Génère de nouveaux codes de récupération
       */
      async generateRecoveryCodes(userId) {
        try {
          logger8.info("Generating recovery codes", { userId });
          const recoveryCodes = [];
          for (let i = 0; i < 10; i++) {
            recoveryCodes.push(crypto2.randomBytes(5).toString("hex"));
          }
          const hashedCodes = await Promise.all(
            recoveryCodes.map(async (code) => ({
              code: await bcrypt2.hash(code, 8),
              used: false,
              createdAt: /* @__PURE__ */ new Date()
            }))
          );
          const user = await userModel_default.findById(userId);
          if (!user) {
            throw new Error("User not found");
          }
          if (!user.security) {
            user.security = { recoveryCodes: hashedCodes };
          } else {
            user.security.recoveryCodes = hashedCodes;
          }
          await user.save();
          logger8.info("Recovery codes generated successfully", { userId });
          return recoveryCodes;
        } catch (error2) {
          logger8.error("Error generating recovery codes", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Vérifie et utilise un code de récupération
       */
      async verifyRecoveryCode(userId, code) {
        try {
          logger8.info("Verifying recovery code", { userId });
          const user = await userModel_default.findById(userId);
          if (!user || !user.security?.recoveryCodes || user.security.recoveryCodes.length === 0) {
            logger8.warn("No recovery codes found", { userId });
            return false;
          }
          let codeIndex = -1;
          for (let i = 0; i < user.security.recoveryCodes.length; i++) {
            const storedCode = user.security.recoveryCodes[i];
            if (!storedCode.used && await bcrypt2.compare(code, storedCode.code)) {
              codeIndex = i;
              break;
            }
          }
          if (codeIndex === -1) {
            logger8.warn("Invalid recovery code", { userId });
            return false;
          }
          user.security.recoveryCodes[codeIndex].used = true;
          user.security.recoveryCodes[codeIndex].usedAt = /* @__PURE__ */ new Date();
          await user.save();
          logger8.info("Recovery code verified successfully", { userId });
          return true;
        } catch (error2) {
          logger8.error("Error verifying recovery code", { error: error2, userId });
          return false;
        }
      }
      /**
       * Ajoute un appareil de confiance
       */
      async addTrustedDevice(userId, deviceInfo) {
        try {
          logger8.info("Adding trusted device", { userId });
          const user = await userModel_default.findById(userId);
          if (!user) {
            return false;
          }
          if (!user.security) {
            user.security = {};
          }
          if (!user.security?.trustedDevices) {
            user.security?.trustedDevices;
          }
          user.security?.trustedDevices?.push({
            ...deviceInfo,
            deviceId: crypto2.randomBytes(16).toString("hex"),
            addedAt: /* @__PURE__ */ new Date(),
            lastUsed: /* @__PURE__ */ new Date()
          });
          await user.save();
          logger8.info("Trusted device added successfully", { userId });
          return true;
        } catch (error2) {
          logger8.error("Error adding trusted device", { error: error2, userId });
          return false;
        }
      }
      /**
       * Supprime un appareil de confiance
       */
      async removeTrustedDevice(userId, deviceId) {
        try {
          logger8.info("Removing trusted device", { userId, deviceId });
          const user = await userModel_default.findById(userId);
          if (!user || !user.security?.trustedDevices) {
            return false;
          }
          const initialLength = user.security.trustedDevices.length;
          user.security.trustedDevices = user.security.trustedDevices.filter(
            (device) => device.deviceId !== deviceId
          );
          if (user.security.trustedDevices.length === initialLength) {
            logger8.warn("Device not found", { userId, deviceId });
            return false;
          }
          await user.save();
          logger8.info("Trusted device removed successfully", { userId, deviceId });
          return true;
        } catch (error2) {
          logger8.error("Error removing trusted device", { error: error2, userId, deviceId });
          return false;
        }
      }
      /**
       * Vérifie si un appareil est de confiance
       */
      async isTrustedDevice(userId, deviceId) {
        try {
          const user = await userModel_default.findById(userId);
          if (!user || !user.security?.trustedDevices) {
            return false;
          }
          const device = user.security.trustedDevices.find((d) => d.deviceId === deviceId);
          if (device) {
            device.lastUsed = /* @__PURE__ */ new Date();
            await user.save();
            return true;
          }
          return false;
        } catch (error2) {
          logger8.error("Error checking trusted device", { error: error2, userId, deviceId });
          return false;
        }
      }
      /**
       * Exporte les données utilisateur (conformité RGPD)
       */
      async exportUserData(userId) {
        try {
          logger8.info("Exporting user data (GDPR)", { userId });
          const user = await userModel_default.findById(userId);
          if (!user) {
            throw new AppError("Utilisateur non trouv\xE9", 404);
          }
          const userData = {
            personalInfo: {
              id: user.id.toString(),
              firstName: user.firstName,
              lastName: user.lastName,
              email: user.email,
              phone: user.phone,
              dateOfBirth: user.dateOfBirth,
              address: user.address,
              createdAt: user.createdAt,
              updatedAt: user.updatedAt
            },
            accountInfo: {
              role: user.role,
              isActive: user.isActive,
              isEmailVerified: user.isEmailVerified,
              preferences: user.preferences
            },
            agentDetails: user.agentDetails,
            securityInfo: {
              passwordLastChanged: user.passwordChangedAt,
              twoFactorEnabled: user.preferences?.twoFactorEnabled
            },
            sessions: user.refreshTokens?.map((session) => ({
              device: session.device,
              ipAddress: session.ipAddress,
              createdAt: session.createdAt,
              lastUsed: session.lastUsedAt
            }))
          };
          return userData;
        } catch (error2) {
          logger8.error("Error exporting user data", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Met à jour l'avatar de l'utilisateur
       */
      async updateUserAvatar(userId, avatarUrl) {
        try {
          logger8.info("Updating user avatar", { userId });
          const user = await userModel_default.findByIdAndUpdate(
            userId,
            { $set: { avatarUrl } },
            { new: true }
          );
          return user;
        } catch (error2) {
          logger8.error("Error updating user avatar", { error: error2, userId });
          throw error2;
        }
      }
      /**
       * Ajoute une notification à l'utilisateur
       */
      async addUserNotification(userId, notification) {
        try {
          logger8.info("Adding user notification", { userId });
          const user = await userModel_default.findById(userId);
          if (!user) {
            return false;
          }
          if (!user.notifications) {
            user.notifications = [];
          }
          user.notifications.push({
            ...notification,
            id: crypto2.randomBytes(8).toString("hex"),
            createdAt: /* @__PURE__ */ new Date(),
            read: false
          });
          if (user.notifications.length > 100) {
            user.notifications = user.notifications.slice(-100);
          }
          await user.save();
          return true;
        } catch (error2) {
          logger8.error("Error adding user notification", { error: error2, userId });
          return false;
        }
      }
      /**
       * Marque une notification comme lue
       */
      async markNotificationAsRead(userId, notificationId) {
        try {
          logger8.info("Marking notification as read", { userId, notificationId });
          const user = await userModel_default.findById(userId);
          if (!user || !user.notifications) {
            return false;
          }
          const notification = user.notifications.find((n) => n.id === notificationId);
          if (!notification) {
            return false;
          }
          notification.read = true;
          notification.readAt = /* @__PURE__ */ new Date();
          await user.save();
          return true;
        } catch (error2) {
          logger8.error("Error marking notification as read", { error: error2, userId, notificationId });
          return false;
        }
      }
      /**
       * Obtient toutes les notifications de l'utilisateur
       */
      async getUserNotifications(userId, includeRead = false) {
        try {
          const user = await userModel_default.findById(userId);
          if (!user || !user.notifications) {
            return [];
          }
          return user.notifications.filter((n) => includeRead || !n.read).sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
        } catch (error2) {
          logger8.error("Error getting user notifications", { error: error2, userId });
          return [];
        }
      }
      /**
       * Supprime un utilisateur (soft delete par défaut)
       */
      async deleteUser(userId, options = {}) {
        try {
          if (!userId) {
            throw new Error("User ID is required");
          }
          logger8.info("Initiating user deletion", { userId, options });
          const user = await this.getUserById(userId);
          if (!user) {
            throw new Error("User not found");
          }
          const { softDelete = true, reason, deletedBy, preserveData = false } = options;
          if (softDelete) {
            return await this.softDeleteUser(userId, reason, deletedBy);
          } else {
            return await this.hardDeleteUser(userId, preserveData);
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error deleting user", { error: errorMessage, userId });
          throw new Error(`User deletion failed: ${errorMessage}`);
        }
      }
      /**
       * Suppression logique (soft delete) - marque l'utilisateur comme supprimé
       */
      async softDeleteUser(userId, reason, deletedBy) {
        try {
          const deletedAt = /* @__PURE__ */ new Date();
          const updateData = {
            isActive: false,
            isDeleted: true,
            deletedAt,
            deletionReason: reason,
            deletedBy,
            // Optionally anonymize email to prevent conflicts
            email: `deleted_${userId}_${Date.now()}@deleted.local`
          };
          await this.updateUser(userId, updateData);
          try {
            await this.revokeSession(userId);
          } catch (error2) {
            logger8.warn("Could not revoke all sessions during soft delete", { userId });
          }
          await this.logUserAction(userId, "USER_SOFT_DELETED", {
            reason,
            deletedBy,
            deletedAt
          });
          logger8.info("User soft deleted successfully", { userId, deletedBy, reason });
          return {
            success: true,
            userId,
            deletionType: "soft",
            deletedAt,
            message: "User soft deleted successfully"
          };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error in soft delete", { error: errorMessage, userId });
          throw error2;
        }
      }
      /**
       * Suppression physique (hard delete) - supprime définitivement l'utilisateur
       */
      async hardDeleteUser(userId, preserveData = false) {
        try {
          const deletedAt = /* @__PURE__ */ new Date();
          if (preserveData) {
            await this.archiveUserData(userId);
          }
          const deleteResult = await this.removeUserFromDatabase(userId);
          if (!deleteResult) {
            throw new Error("Failed to delete user from database");
          }
          await this.cleanupUserRelatedData(userId);
          await this.logUserAction(userId, "USER_HARD_DELETED", {
            preserveData,
            deletedAt
          });
          logger8.info("User hard deleted successfully", { userId, preserveData });
          return {
            success: true,
            userId,
            deletionType: "hard",
            deletedAt,
            message: "User permanently deleted"
          };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error in hard delete", { error: errorMessage, userId });
          throw error2;
        }
      }
      /**
       * Restaure un utilisateur supprimé logiquement
       */
      async restoreUser(userId, restoredBy) {
        try {
          const user = await this.getUserById(userId);
          if (!user) {
            throw new Error("User not found");
          }
          if (!user.isDeleted) {
            throw new Error("User is not deleted");
          }
          const updateData = {
            isActive: true,
            isDeleted: false,
            deletedAt: null,
            deletionReason: null,
            deletedBy: null,
            restoredAt: /* @__PURE__ */ new Date(),
            restoredBy
          };
          if (user.email && user.email.startsWith("deleted_")) {
            logger8.warn("Email restoration needed for user", { userId });
          }
          await this.updateUser(userId, updateData);
          await this.logUserAction(userId, "USER_RESTORED", {
            restoredBy,
            restoredAt: updateData.restoredAt
          });
          logger8.info("User restored successfully", { userId, restoredBy });
          return true;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error restoring user", { error: errorMessage, userId });
          throw new Error(`User restoration failed: ${errorMessage}`);
        }
      }
      /**
       * Archive user data before hard deletion
       */
      async archiveUserData(userId) {
        try {
          const user = await this.getUserById(userId);
          if (!user) {
            return;
          }
          const archiveData = {
            originalUserId: userId,
            userData: user,
            archivedAt: /* @__PURE__ */ new Date(),
            archiveReason: "USER_DELETION"
          };
          await this.createArchiveRecord(archiveData);
          logger8.info("User data archived successfully", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error archiving user data", { error: errorMessage, userId });
          throw error2;
        }
      }
      /**
       * Clean up user-related data after hard deletion
       */
      async cleanupUserRelatedData(userId) {
        try {
          await this.revokeSession(userId).catch(
            (err) => logger8.warn("Error cleaning up sessions", { userId, error: err.message })
          );
          await this.deleteUserPreferences(userId).catch(
            (err) => logger8.warn("Error cleaning up preferences", { userId, error: err.message })
          );
          await this.deleteUserFiles(userId).catch(
            (err) => logger8.warn("Error cleaning up files", { userId, error: err.message })
          );
          logger8.info("User related data cleaned up", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error cleaning up user data", { error: errorMessage, userId });
        }
      }
      /**
       * Remove user from database (implement based on your database)
       */
      async removeUserFromDatabase(userId) {
        try {
          logger8.info("Removing user from database", { userId });
          return true;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error removing user from database", { error: errorMessage, userId });
          return false;
        }
      }
      /**
       * Create archive record (implement based on your needs)
       */
      async createArchiveRecord(archiveData) {
        try {
          logger8.info("Creating archive record", { userId: archiveData.originalUserId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error creating archive record", { error: errorMessage });
          throw error2;
        }
      }
      /**
       * Delete user preferences
       */
      async deleteUserPreferences(userId) {
        try {
          logger8.info("Deleting user preferences", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error deleting user preferences", { error: errorMessage, userId });
          throw error2;
        }
      }
      /**
       * Delete user files
       */
      async deleteUserFiles(userId) {
        try {
          logger8.info("Deleting user files", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error deleting user files", { error: errorMessage, userId });
          throw error2;
        }
      }
      /**
       * Log user actions for audit trail
       */
      async logUserAction(userId, action, details) {
        try {
          const logEntry = {
            userId,
            action,
            details,
            timestamp: /* @__PURE__ */ new Date(),
            ip: null,
            // You might want to pass this from the request
            userAgent: null
            // You might want to pass this from the request
          };
          logger8.info("User action logged", { userId, action, details });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error logging user action", { error: errorMessage, userId, action });
        }
      }
      /**
       * Get deleted users (for admin purposes)
       */
      async getDeletedUsers(page = 1, limit = 10) {
        try {
          logger8.info("Getting deleted users", { page, limit });
          return [];
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error getting deleted users", { error: errorMessage });
          throw new Error(`Failed to get deleted users: ${errorMessage}`);
        }
      }
      /**
       * Bulk delete users
       */
      async bulkDeleteUsers(userIds, options = {}) {
        try {
          if (!userIds || userIds.length === 0) {
            throw new Error("User IDs array is required");
          }
          logger8.info("Starting bulk user deletion", { count: userIds.length, options });
          const results = [];
          for (const userId of userIds) {
            try {
              const result = await this.deleteUser(userId, options);
              results.push(result);
            } catch (error2) {
              const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
              results.push({
                success: false,
                userId,
                deletionType: options.softDelete ? "soft" : "hard",
                deletedAt: /* @__PURE__ */ new Date(),
                message: `Failed: ${errorMessage}`
              });
            }
          }
          const successCount = results.filter((r) => r.success).length;
          logger8.info("Bulk deletion completed", {
            total: userIds.length,
            successful: successCount,
            failed: userIds.length - successCount
          });
          return results;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger8.error("Error in bulk delete", { error: errorMessage });
          throw new Error(`Bulk deletion failed: ${errorMessage}`);
        }
      }
    };
  }
});

// src/users/services/authService.ts
import * as jwt2 from "jsonwebtoken";
import * as crypto3 from "crypto";
import * as speakeasy from "speakeasy";
var logger9, AuthService;
var init_authService = __esm({
  "src/users/services/authService.ts"() {
    init_config();
    init_userService();
    init_logger();
    init_userModel();
    init_redisInstance();
    logger9 = createLogger2("AuthService");
    AuthService = class {
      // private presenceService: UserPresenceService;
      constructor(userService2) {
        __publicField(this, "userService");
        this.userService = userService2 || new UserService();
      }
      /**
       * Authentifie un utilisateur avec des options supplémentaires
       */
      async authenticate(email, password, req, options) {
        const startTime = Date.now();
        try {
          if (!email || !password) {
            logger9.warn("Tentative d'authentification avec des identifiants manquants", {
              hasEmail: !!email,
              hasPassword: !!password,
              ip: req.ip
            });
            return null;
          }
          console.log(password);
          const user = await this.userService.getUserByEmailWithPassword(email);
          if (!user) {
            logger9.warn("\xC9chec d'authentification - utilisateur non trouv\xE9", {
              email: email.substring(0, 5) + "***",
              ip: req.ip
            });
            return null;
          }
          if (!user.isActive) {
            logger9.warn("\xC9chec d'authentification - compte inactif", {
              userId: user._id?.toString(),
              email: email.substring(0, 5) + "***"
            });
            return null;
          }
          if (!user.isEmailVerified) {
            logger9.warn("\xC9chec d'authentification - email non v\xE9rifi\xE9", {
              userId: user._id?.toString(),
              email: email.substring(0, 5) + "***"
            });
            return null;
          }
          logger9.info("Tentative de v\xE9rification du mot de passe", {
            userId: user._id?.toString(),
            email: email.substring(0, 5) + "***"
          });
          const isPasswordValid = await user.comparePassword(password);
          if (!isPasswordValid) {
            logger9.warn("\xC9chec d'authentification - mot de passe invalide", {
              userId: user._id?.toString(),
              email: email.substring(0, 5) + "***"
            });
            user.recordLoginAttempt({
              ipAddress: req.ip || "unknown",
              userAgent: req.headers["user-agent"],
              successful: false
            });
            await user.save();
            return null;
          }
          logger9.info("Authentification r\xE9ussie", {
            userId: user._id?.toString(),
            email: email.substring(0, 5) + "***",
            executionTime: `${Date.now() - startTime}ms`
          });
          user.updateLastLogin(req.ip || "unknown", req.headers["user-agent"]);
          user.recordLoginAttempt({
            ipAddress: req.ip || "unknown",
            userAgent: req.headers["user-agent"],
            successful: true
          });
          await user.save();
          const tokens = await this.generateAuthTokens(user, {
            rememberMe: options?.rememberMe,
            deviceInfo: {
              deviceId: options?.deviceInfo?.deviceId || "",
              deviceName: options?.deviceInfo?.deviceName || "",
              platform: options?.deviceInfo?.platform || "",
              version: options?.deviceInfo?.version || "",
              userAgent: req.headers["user-agent"],
              ip: req.ip
            }
          });
          const userAfterTokens = await this.userService.getUserByEmailWithPassword(email);
          logger9.info("V\xE9rification apr\xE8s g\xE9n\xE9ration des tokens", {
            userId: user._id?.toString(),
            refreshTokensCountBefore: user.refreshTokens?.length || 0,
            refreshTokensCountAfter: userAfterTokens?.refreshTokens?.length || 0,
            tokenGenerated: !!tokens?.refreshToken
          });
          if (!userAfterTokens?.refreshTokens || userAfterTokens.refreshTokens.length === 0) {
            logger9.error("\u274C PROBL\xC8ME : Aucun refresh token sauvegard\xE9 en base !", {
              userId: user._id?.toString()
            });
          } else {
            logger9.info("\u2705 Refresh tokens correctement sauvegard\xE9s", {
              userId: user._id?.toString(),
              count: userAfterTokens.refreshTokens.length
            });
          }
          return tokens;
        } catch (error2) {
          logger9.error("Erreur lors de l'authentification", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            email: email.substring(0, 5) + "***",
            executionTime: `${Date.now() - startTime}ms`
          });
          throw new Error("Erreur lors de l'authentification");
        }
      }
      async refreshAccessToken(refreshToken) {
        try {
          const jwtRefreshSecret = config_default.auth?.jwtRefreshSecret;
          const jwtSecret = config_default.auth?.jwtSecret;
          if (!jwtRefreshSecret || typeof jwtRefreshSecret !== "string") {
            logger9.error("JWT refresh secret not configured or invalid");
            return null;
          }
          if (!jwtSecret || typeof jwtSecret !== "string") {
            logger9.error("JWT secret not configured or invalid");
            return null;
          }
          const decoded = jwt2.verify(refreshToken, jwtRefreshSecret);
          const user = await this.userService.getUserById(decoded.userId);
          if (!user || !user.isActive) {
            logger9.warn("Token refresh failed: user not found or inactive", { userId: decoded.userId });
            return null;
          }
          const payload = {
            userId: this.getUserId(user),
            email: user.email,
            role: user.role,
            sessionId: decoded.sessionId,
            deviceId: decoded.deviceId
          };
          const expiresIn = typeof config_default.auth?.jwtExpiresIn === "string" ? config_default.auth.jwtExpiresIn : "15m";
          const accessToken = jwt2.sign(
            payload,
            jwtSecret,
            { expiresIn }
          );
          const userId = this.getUserId(user);
          logger9.info("Access token refreshed successfully", { userId });
          return accessToken;
        } catch (error2) {
          if (error2 instanceof jwt2.JsonWebTokenError) {
            logger9.warn("Invalid refresh token", { error: error2.message });
            return null;
          }
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error during token refresh", { error: errorMessage });
          throw new Error(`Token refresh failed: ${errorMessage}`);
        }
      }
      async getUserById(id) {
        return this.userService.getUserById(id);
      }
      /**
       * Déconnecte un utilisateur et met à jour sa présence
       */
      async logout(userId, sessionId) {
        try {
          if (sessionId) {
            try {
              const success = await this.userService.revokeSession?.(userId, sessionId);
              if (!success) {
                logger9.warn("Session not found or already revoked", { userId, sessionId });
              }
            } catch (error2) {
              logger9.warn("Session revocation failed", { userId, sessionId, error: error2 });
            }
          }
          await redisInstance_default.setUserOffline(userId);
          logger9.info("User logged out", { userId, sessionId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error during logout", { error: errorMessage, userId });
          throw new Error(`Logout failed: ${errorMessage}`);
        }
      }
      /**
       * Déconnecte l'utilisateur de tous les appareils
       */
      async logoutAllDevices(userId, sessionId) {
        try {
          await this.invalidateAllUserTokens(userId, sessionId);
          await redisInstance_default.setUserOffline(userId);
          logger9.info("User logged out from all devices", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error during logout all devices", { error: errorMessage, userId });
          throw new Error(`Logout all devices failed: ${errorMessage}`);
        }
      }
      /**
       * Valide un token JWT
       */
      validateToken(token) {
        try {
          if (!config_default.auth?.jwtSecret) {
            logger9.error("JWT secret not configured");
            return null;
          }
          const decoded = jwt2.verify(token, config_default.auth.jwtSecret);
          return decoded;
        } catch (error2) {
          if (error2 instanceof jwt2.TokenExpiredError) {
            logger9.warn("Token expired", { error: error2.message });
          } else if (error2 instanceof jwt2.JsonWebTokenError) {
            logger9.warn("Invalid token", { error: error2.message });
          } else {
            logger9.error("Token validation error", { error: error2 instanceof Error ? error2.message : "Unknown error" });
          }
          return null;
        }
      }
      /**
       * Valide un token temporaire (pour 2FA)
       */
      async validateTemporaryToken(token) {
        try {
          if (!config_default.auth?.jwtSecret) {
            logger9.error("JWT secret not configured");
            return null;
          }
          const decoded = jwt2.verify(token, config_default.auth.jwtSecret);
          if (!decoded.temp) {
            logger9.warn("Not a temporary token");
            return null;
          }
          const user = await this.userService.getUserById(decoded.userId);
          if (!user || !user.isActive) {
            return null;
          }
          return {
            userId: decoded.userId,
            deviceId: decoded.deviceId
          };
        } catch (error2) {
          logger9.warn("Invalid temporary token", { error: error2 instanceof Error ? error2.message : "Unknown error" });
          return null;
        }
      }
      async generateTwoFactorSecret(userId) {
        try {
          logger9.info("[2FA] Step 1 - Getting user", { userId });
          const user = await this.userService.getUserById(userId);
          if (!user) {
            logger9.warn("[2FA] User not found", { userId });
            return null;
          }
          if (!user.email) {
            logger9.error("[2FA] User is missing email", { userId });
            throw new Error("User is missing email");
          }
          logger9.info("[2FA] Step 2 - Generating secret");
          const secret = speakeasy.generateSecret({
            name: user.email,
            issuer: config_default?.app?.name || "MyApp",
            length: 32
          });
          if (!secret.otpauth_url) {
            logger9.error("[2FA] Missing OTP Auth URL", { userId });
            throw new Error("OTP Auth URL could not be generated");
          }
          logger9.debug("[2FA] OTP Auth URL generated successfully", { userId });
          logger9.info("[2FA] Step 3 - Skipping QR code generation");
          logger9.info("[2FA] Step 4 - Generating backup codes");
          const backupCodes = this.generateBackupCodes();
          logger9.info("[2FA] Step 5 - Updating user with temporary secret");
          try {
            await this.userService.updateUser(userId, {
              secret: secret.base32,
              "security.tempTwoFactorSecret": secret.base32,
              "security.tempTwoFactorSecretExpires": new Date(Date.now() + 10 * 60 * 1e3),
              // 10 minutes
              "security.backupCodes": backupCodes.map((code) => ({
                code,
                used: false,
                createdAt: /* @__PURE__ */ new Date()
              }))
            });
            logger9.info("[2FA] Temporary secret stored successfully", { userId });
          } catch (error2) {
            logger9.error("[2FA] Failed to store temporary 2FA secret in DB", {
              userId,
              error: error2.message
            });
            throw new Error("Failed to store 2FA secret");
          }
          logger9.info("[2FA] Step 6 - 2FA setup completed successfully", { userId });
          return {
            tempTwoFactorSecret: secret.base32,
            otpauthUrl: secret.otpauth_url,
            // qrCodeUrl removed - users can scan the otpauth URL or enter secret manually
            backupCodes
          };
        } catch (error2) {
          logger9.error("[2FA] Error generating 2FA secret", {
            error: error2.message,
            stack: error2.stack,
            userId
          });
          throw new Error(`2FA setup failed: ${error2.message}`);
        }
      }
      async confirmTwoFactorSetup(userId, token) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user || !user.security?.tempTwoFactorSecret) {
            logger9.warn("[2FA] No temporary secret found for user", { userId });
            return false;
          }
          if (user.security.tempTwoFactorSecretExpires && /* @__PURE__ */ new Date() > user.security.tempTwoFactorSecretExpires) {
            logger9.warn("[2FA] Temporary secret expired", { userId });
            return false;
          }
          const verified = speakeasy.totp.verify({
            secret: user.security.tempTwoFactorSecret,
            encoding: "base32",
            token,
            window: 1
          });
          if (!verified) {
            logger9.warn("[2FA] Invalid token provided", { userId });
            return false;
          }
          await this.userService.updateUser(userId, {
            "security.twoFactorSecret": user.security.tempTwoFactorSecret,
            "security.tempTwoFactorSecret": null,
            // FIXED: Added null value
            "security.tempTwoFactorSecretExpires": null
            // FIXED: Added null value and semicolon
          });
          logger9.info("[2FA] Two-factor authentication enabled successfully", { userId });
          return true;
        } catch (error2) {
          logger9.error("[2FA] Error confirming 2FA setup", {
            error: error2.message,
            userId
          });
          return false;
        }
      }
      async validateBackupCode(userId, code) {
        try {
          const secret = speakeasy.generateSecret({ name: "MyApp (test@example.com)" });
          logger9.debug("Secret base32 pour  verification:", secret.base32);
          logger9.debug("OTPAuth URL:", secret.otpauth_url);
          const user = await this.userService.getUserById(userId);
          if (!user || !user.security?.backupCodes) {
            return false;
          }
          const backupCode = user.security.backupCodes.find(
            (bc) => bc.code === code && !bc.used
          );
          if (!backupCode) {
            logger9.warn("[2FA] Invalid or already used backup code", { userId });
            return false;
          }
          backupCode.used = true;
          backupCode.usedAt = /* @__PURE__ */ new Date();
          await this.userService.updateUser(userId, {
            "security.backupCodes": user.security.backupCodes
          });
          logger9.info("[2FA] Backup code used successfully", {
            userId,
            remainingCodes: user.security.backupCodes.filter((bc) => !bc.used).length
          });
          return true;
        } catch (error2) {
          logger9.error("[2FA] Error validating backup code", {
            error: error2.message,
            userId
          });
          return false;
        }
      }
      // Méthode pour générer de nouveaux codes de sauvegarde
      async regenerateBackupCodes(userId) {
        try {
          const newCodes = this.generateBackupCodes();
          const updateData = {
            "security.backupCodes": newCodes.map((code) => ({
              code,
              used: false,
              createdAt: /* @__PURE__ */ new Date()
            }))
          };
          await this.userService.updateUser(userId, updateData);
          logger9.info("[2FA] Backup codes regenerated successfully", {
            userId,
            newCodesCount: newCodes.length
          });
          return newCodes;
        } catch (error2) {
          logger9.error("[2FA] Error regenerating backup codes", {
            error: error2.message,
            userId
          });
          return null;
        }
      }
      /**
      * Vérifie un token de vérification de compte et active le compte
      */
      async verifyAccountToken(token) {
        try {
          const tokenData = await this.validateVerificationToken(token);
          if (!tokenData) {
            logger9.warn("Invalid account verification token", { token: token.substring(0, 8) + "..." });
            return {
              success: false,
              message: "Token de v\xE9rification invalide ou expir\xE9"
            };
          }
          const { userId, email } = tokenData;
          const user = await this.userService.getUserById(userId);
          if (!user) {
            logger9.warn("User not found for account verification", { userId });
            return {
              success: false,
              message: "Utilisateur introuvable"
            };
          }
          if (user.isEmailVerified) {
            logger9.info("Account already verified", { userId, email });
            return {
              success: true,
              message: "Compte d\xE9j\xE0 v\xE9rifi\xE9",
              userId
            };
          }
          try {
            await this.userService.updateUser(userId, {
              isEmailVerified: true,
              emailVerificationToken: null,
              emailVerificationTokenExpires: null
            });
            logger9.info("Account verified successfully", { userId, email });
            return {
              success: true,
              message: "Compte v\xE9rifi\xE9 avec succ\xE8s",
              userId
            };
          } catch (updateError) {
            const errorMessage = updateError instanceof Error ? updateError.message : "Unknown error";
            logger9.error("Error updating user verification status", { error: errorMessage, userId });
            return {
              success: false,
              message: "Erreur lors de la mise \xE0 jour du statut de v\xE9rification"
            };
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error during account verification", { error: errorMessage });
          return {
            success: false,
            message: `Erreur lors de la v\xE9rification du compte: ${errorMessage}`
          };
        }
      }
      /**
       * Vérifie un code 2FA
      //  */
      // async verifyTwoFactorCode(userId: string, code: string): Promise<boolean> {
      //   try {
      //     const user = await this.userService.getUserById(userId) as UserInfo | null;
      //     if (!user || !user.twoFactorSecret) {
      //       return false;
      //     }
      //     const isValid = speakeasy.totp.verify({
      //       secret: user.twoFactorSecret,
      //       encoding: 'base32',
      //       token: code,
      //       window: 2
      //     });
      //     if (isValid) {
      //       logger.info('2FA code verified successfully', { userId });
      //     } else {
      //       logger.warn('Invalid 2FA code', { userId });
      //     }
      //     return isValid;
      //   } catch (error) {
      //     const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      //     logger.error('Error verifying 2FA code', { error: errorMessage, userId });
      //     return false;
      //   }
      // }
      async verifyTwoFactorCode(userId, code) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user || !user.security?.tempTwoFactorSecret) {
            logger9.debug("user  is  not  define");
            return false;
          }
          logger9.info("the  code  is  :", { code });
          const isValid = speakeasy.totp.verify({
            secret: user.security.tempTwoFactorSecret,
            encoding: "base32",
            token: code,
            window: 2
          });
          const generatedToken = speakeasy.totp({
            secret: user.security.tempTwoFactorSecret,
            encoding: "base32"
          });
          logger9.debug("expected token (TOTP) would be:", { generatedToken });
          if (isValid) {
            await this.userService.updateUser(userId, {
              "security.twoFactorSecret": user.security.tempTwoFactorSecret,
              "security.tempTwoFactorSecret": null,
              "security.tempTwoFactorSecretExpires": null
            });
            logger9.info("2FA setup confirmed and saved permanently", { userId });
          } else {
            logger9.warn("Invalid 2FA code during setup", { userId });
          }
          return isValid;
        } catch (error2) {
          logger9.error("Error during 2FA setup confirmation", {
            error: error2 instanceof Error ? error2.message : "Unknown error",
            userId
          });
          return false;
        }
      }
      /**
       * Génère des tokens après une 2FA réussie
       */
      async generateTokensAfter2FA(userId, deviceId) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user) {
            throw new Error("User not found");
          }
          const options = deviceId ? {
            deviceInfo: {
              deviceId,
              deviceName: "",
              platform: "",
              version: ""
            }
          } : void 0;
          const tokens = this.generateAuthTokens(user, options);
          logger9.info("Tokens generated after successful 2FA", { userId });
          return tokens;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error generating tokens after 2FA", { error: errorMessage, userId });
          throw new Error(`Token generation failed: ${errorMessage}`);
        }
      }
      /**
       * Vérifie et active définitivement la 2FA
       */
      async verifyAndEnableTwoFactor(userId, code) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user || !user.security?.tempTwoFactorSecret) {
            return false;
          }
          const isValid = speakeasy.totp.verify({
            secret: user.security.tempTwoFactorSecret,
            encoding: "base32",
            token: code,
            window: 2
          });
          if (isValid) {
            await this.userService.enableTwoFactorAuth(userId);
            logger9.info("2FA enabled successfully", { userId });
            return true;
          }
          return false;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error enabling 2FA", { error: errorMessage, userId });
          return false;
        }
      }
      /**
       * Désactive l'authentification à deux facteurs
       */
      async disableTwoFactor(userId, password) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user) {
            logger9.warn("User not found for 2FA disable", { userId });
            return false;
          }
          const isPasswordValid = await user.comparePassword(password);
          if (!isPasswordValid) {
            logger9.warn("Invalid password for 2FA disable", { userId });
            return false;
          }
          try {
            await this.userService.disableTwoFactor(userId);
            logger9.info("2FA disabled successfully", { userId });
            return true;
          } catch (error2) {
            logger9.warn("disableTwoFactor method not available", { userId });
            return false;
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error disabling 2FA", { error: errorMessage, userId });
          return false;
        }
      }
      /**
       * Génère de nouveaux codes de secours
       */
      async generateNewBackupCodes(userId) {
        try {
          const backupCodes = this.generateBackupCodes();
          try {
            await this.userService.updateBackupCodes(userId, backupCodes);
          } catch (error2) {
            logger9.warn("updateBackupCodes method not available", { userId });
            throw new Error("Backup codes update method not implemented");
          }
          logger9.info("New backup codes generated", { userId });
          return backupCodes;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error generating backup codes", { error: errorMessage, userId });
          throw new Error(`Backup codes generation failed: ${errorMessage}`);
        }
      }
      /**
       * Vérifie un code de secours
       */
      async verifyBackupCode(userId, backupCode) {
        try {
          try {
            const isValid = await this.userService.verifyAndConsumeBackupCode(userId, backupCode);
            if (isValid) {
              logger9.info("Backup code verified successfully", { userId });
            } else {
              logger9.warn("Invalid or used backup code", { userId });
            }
            return isValid;
          } catch (error2) {
            logger9.warn("verifyAndConsumeBackupCode method not available", { userId });
            return false;
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error verifying backup code", { error: errorMessage, userId });
          return false;
        }
      }
      /**
       * Récupère les sessions actives d'un utilisateur
       */
      async getActiveSessions(userId, includeExpired = false) {
        try {
          try {
            const sessions = await this.userService.getActiveSessions(userId);
            logger9.info("Active sessions retrieved", { userId, count: sessions.length });
            return sessions;
          } catch (error2) {
            logger9.warn("getActiveSessions method not available", { userId });
            return [];
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error retrieving active sessions", { error: errorMessage, userId });
          throw new Error(`Active sessions retrieval failed: ${errorMessage}`);
        }
      }
      /**
       * Révoque une session spécifique
       */
      async revokeSession(userId, sessionId) {
        try {
          try {
            const success = await this.userService.revokeSession(userId, sessionId);
            if (success) {
              logger9.info("Session revoked successfully", { userId, sessionId });
            } else {
              logger9.warn("Session not found or already revoked", { userId, sessionId });
            }
            return success;
          } catch (error2) {
            logger9.warn("revokeUserSession method not available", { userId, sessionId });
            return false;
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error revoking session", { error: errorMessage, userId, sessionId });
          throw new Error(`Session revocation failed: ${errorMessage}`);
        }
      }
      /**
       * Révoque toutes les sessions sauf la courante
       */
      async revokeAllSessionsExceptCurrent(userId, currentSessionId) {
        try {
          try {
            const revokedCount = await this.userService.revokeAllSessionsExceptCurrent(userId, currentSessionId);
            logger9.info("All sessions except current revoked", { userId, revokedCount });
            return revokedCount;
          } catch (error2) {
            logger9.warn("revokeAllSessionsExceptCurrent method not available", { userId });
            return 0;
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error revoking all sessions", { error: errorMessage, userId });
          throw new Error(`Mass session revocation failed: ${errorMessage}`);
        }
      }
      /**
       * Génère un code de vérification d'email à 6 chiffres
      */
      async generateVerificationToken(userId) {
        try {
          const code = Math.floor(1e5 + Math.random() * 9e5).toString();
          logger9.info("\u{1F50D} DEBUG - Generated verification code:", {
            userId,
            code: code.substring(0, 3) + "***",
            codeLength: code.length
          });
          const tokenExpiration = new Date(Date.now() + 15 * 60 * 1e3);
          await this.userService.updateUser(userId, {
            emailVerificationToken: code,
            emailVerificationTokenExpires: tokenExpiration
          });
          logger9.info("Verification code generated and saved", { userId });
          return code;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error generating verification code", { error: errorMessage, userId });
          throw new Error(`Verification code generation failed: ${errorMessage}`);
        }
      }
      /**
       * Valide un token de vérification d'email
       */
      async validateVerificationToken(token) {
        try {
          const user = await this.userService.getUserByVerificationToken(token);
          if (!user) {
            logger9.warn("Invalid verification token", { token: token.substring(0, 8) + "..." });
            return null;
          }
          const userId = this.getUserId(user);
          logger9.info("Verification token validated", { userId });
          return {
            userId,
            email: user.email
          };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error validating verification token", { error: errorMessage });
          return null;
        }
      }
      /**
       * Invalide toutes les autres sessions sauf la courante
       * (Alias pour revokeAllSessionsExceptCurrent)
       */
      async invalidateOtherSessions(userId, currentSessionId) {
        try {
          const revokedCount = await this.revokeAllSessionsExceptCurrent(userId, currentSessionId);
          logger9.info("Other sessions invalidated", { userId, revokedCount });
          return revokedCount;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error invalidating other sessions", { error: errorMessage, userId });
          throw new Error(`Other sessions invalidation failed: ${errorMessage}`);
        }
      }
      /**
       * Invalide toutes les sessions d'un utilisateur
       * (Alias pour logoutAllDevices)
       */
      async invalidateAllSessions(userId, sessionId) {
        try {
          await this.logoutAllDevices(userId, sessionId);
          logger9.info("All sessions invalidated", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error invalidating all sessions", { error: errorMessage, userId });
          throw new Error(`All sessions invalidation failed: ${errorMessage}`);
        }
      }
      /**
       * Invalide tous les tokens d'un utilisateur
       */
      async invalidateAllUserTokens(userId, sessionId) {
        try {
          try {
            await this.userService.revokeSession(userId, sessionId);
          } catch (error2) {
            logger9.warn("revokeAllSessions method not available", { userId });
          }
          logger9.info("All user tokens invalidated", { userId });
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error invalidating all user tokens", { error: errorMessage, userId });
          throw new Error(`Token invalidation failed: ${errorMessage}`);
        }
      }
      /**
      * Complète l'authentification 2FA après vérification du code
      */
      async validateTwoFactorLogin(tempToken, code, options) {
        try {
          const tempTokenData = await this.validateTemporaryToken(tempToken);
          if (!tempTokenData) {
            logger9.warn("Invalid temporary token for 2FA validation");
            return {
              success: false,
              message: "Token temporaire invalide ou expir\xE9"
            };
          }
          const user = await this.userService.getUserById(tempTokenData.userId);
          if (!user || !user.isActive) {
            logger9.warn("User not found or inactive for 2FA validation", { userId: tempTokenData.userId });
            return {
              success: false,
              message: "Utilisateur introuvable ou inactif"
            };
          }
          const isCodeValid = await this.verifyTwoFactorCode(tempTokenData.userId, code);
          if (!isCodeValid) {
            logger9.warn("Invalid 2FA code during login", { userId: tempTokenData.userId });
            return {
              success: false,
              message: "Code 2FA invalide"
            };
          }
          const tokens = await this.generateAuthTokens(user, options);
          const userId = this.getUserId(user);
          logger9.info("2FA authentication completed successfully", { userId });
          return {
            success: true,
            userId,
            tokens,
            message: "Authentification 2FA r\xE9ussie"
          };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error during 2FA validation", { error: errorMessage });
          return {
            success: false,
            message: `Erreur lors de la validation 2FA: ${errorMessage}`
          };
        }
      }
      /**
       * Vérifie et active la 2FA avec un token temporaire
       */
      async verifyTwoFactorToken(userId, code) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user) {
            logger9.warn("User not found for 2FA token verification", { userId });
            return false;
          }
          const tempSecret = user.security?.tempTwoFactorSecret;
          if (!tempSecret) {
            logger9.warn("No temporary 2FA secret found", { userId });
            return false;
          }
          const isValid = speakeasy.totp.verify({
            secret: tempSecret,
            encoding: "base32",
            token: code,
            window: 2
          });
          if (isValid) {
            try {
              await this.userService.enableTwoFactor(userId);
              logger9.info("2FA enabled successfully", { userId });
            } catch (error2) {
              logger9.warn("enableTwoFactor method not available, handling manually", { userId });
            }
            return true;
          } else {
            logger9.warn("Invalid 2FA token during setup", { userId });
            return false;
          }
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error verifying 2FA token", { error: errorMessage, userId });
          return false;
        }
      }
      /**
       * Récupère les informations de sécurité d'un utilisateur
       */
      async getSecurityInfo(userId) {
        try {
          const user = await this.userService.getUserById(userId);
          if (!user) {
            throw new Error("User not found");
          }
          let activeSessions = 0;
          try {
            activeSessions = await this.userService.getActiveSessionsCount(userId);
          } catch (error2) {
            logger9.warn("getActiveSessionsCount method not available", { userId });
          }
          let recentLoginAttempts = 0;
          try {
            recentLoginAttempts = await this.userService.getRecentLoginAttemptsCount(userId);
          } catch (error2) {
            logger9.warn("getRecentLoginAttemptsCount method not available", { userId });
          }
          const lastPasswordChange = user.passwordChangedAt || user.createdAt;
          const accountLockout = this.getAccountLockoutInfo(user);
          const securityInfo = {
            twoFactorEnabled: user.preferences?.twoFactorEnabled || false,
            lastPasswordChange,
            activeSessions,
            recentLoginAttempts,
            accountLockout
          };
          logger9.info("Security info retrieved", { userId });
          return securityInfo;
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          logger9.error("Error retrieving security info", { error: errorMessage, userId });
          throw new Error(`Security info retrieval failed: ${errorMessage}`);
        }
      }
      // Méthodes utilitaires privées
      /**
       * Extrait l'ID utilisateur en gérant les différents formats
       */
      getUserId(user) {
        if (typeof user._id === "string") {
          return user._id;
        } else if (user._id && typeof user._id.toString === "function") {
          return user._id.toString();
        }
        return user.id;
      }
      /**
       * Vérifie si le compte utilisateur est verrouillé
       */
      isUserAccountLocked(user) {
        if (user.security?.accountLocked && user.security.lockExpiresAt && user.security.lockExpiresAt > /* @__PURE__ */ new Date()) {
          return true;
        }
        return false;
      }
      /**
       * Récupère les informations de verrouillage du compte
       */
      getAccountLockoutInfo(user) {
        if (user.security) {
          return {
            isLocked: user.security.accountLocked || false,
            lockUntil: user.security.lockExpiresAt
          };
        }
        return {
          isLocked: false,
          lockUntil: void 0
        };
      }
      /**
       * Extrait les détails de connexion à partir de la requête
       */
      extractLoginDetails(req) {
        return {
          ipAddress: req.ip || req.socket.remoteAddress || "unknown",
          userAgent: req.headers["user-agent"] || "unknown",
          successful: false,
          timestamp: /* @__PURE__ */ new Date()
        };
      }
      /**
       * Génère un token temporaire pour la 2FA
       */
      temporary2FAToken(user, deviceId) {
        if (!config_default.auth?.jwtSecret) {
          throw new Error("JWT secret not configured");
        }
        const payload = {
          userId: this.getUserId(user),
          email: user.email,
          role: user.role,
          deviceId,
          temp: true
          // Maintenant typé correctement
        };
        return jwt2.sign(
          payload,
          config_default.auth.jwtSecret,
          { expiresIn: "10m" }
        );
      }
      /**
       * Génère les tokens d'authentification pour un utilisateur
       */
      async generateAuthTokens(user, options) {
        try {
          const payload = {
            userId: user._id?.toString(),
            email: user.email,
            role: user.role
            // sessionId: sessionId 
          };
          const accessToken = jwt2.sign(
            payload,
            config_default.auth.jwtSecret,
            { expiresIn: "30m" }
          );
          const refreshToken = jwt2.sign(
            payload,
            config_default.auth.jwtRefreshSecret,
            {
              expiresIn: options?.rememberMe ? "30d" : "7d"
            }
          );
          if (!refreshToken) {
            throw new Error("Impossible de g\xE9n\xE9rer le refresh token");
          }
          const sessionId = crypto3.randomUUID();
          const refreshTokenDoc = {
            tokenId: crypto3.randomUUID(),
            token: refreshToken,
            hashedToken: crypto3.createHash("sha256").update(refreshToken).digest("hex"),
            user: user._id,
            device: options?.deviceInfo?.deviceName || options?.deviceInfo?.deviceId || "Unknown",
            userAgent: options?.deviceInfo?.userAgent || "Unknown",
            ip: options?.deviceInfo?.ip || "Unknown",
            ipAddress: options?.deviceInfo?.ip || "Unknown",
            sessionId,
            expiresAt: new Date(Date.now() + (options?.rememberMe ? 30 : 7) * 24 * 60 * 60 * 1e3),
            isActive: true,
            lastUsedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date()
          };
          logger9.info("Tentative d'ajout du refresh token", {
            userId: user._id?.toString(),
            refreshTokensCountBefore: user.refreshTokens?.length || 0,
            hasRefreshToken: !!refreshToken,
            refreshTokenLength: refreshToken?.length || 0
          });
          if (!user.refreshTokens) {
            user.refreshTokens = [];
          }
          user.refreshTokens.push(refreshTokenDoc);
          logger9.info("Refresh token ajout\xE9 au tableau utilisateur", {
            userId: user._id?.toString(),
            refreshTokensCountAfter: user.refreshTokens.length,
            lastTokenDevice: refreshTokenDoc.device
          });
          const savedUser = await user.save();
          logger9.info("Utilisateur sauvegard\xE9 avec tokens", {
            userId: user._id?.toString(),
            refreshTokensInSavedUser: savedUser.refreshTokens?.length || 0,
            saveSuccessful: !!savedUser._id
          });
          const verificationUser = await userModel_default.findById(user._id).select("+refreshTokens");
          logger9.info("V\xE9rification finale en base de donn\xE9es", {
            userId: user._id?.toString(),
            refreshTokensInDB: verificationUser?.refreshTokens?.length || 0,
            verificationSuccessful: (verificationUser?.refreshTokens?.length || 0) > 0
          });
          if (!verificationUser?.refreshTokens || verificationUser.refreshTokens.length === 0) {
            logger9.error("\u274C \xC9CHEC CRITIQUE : Le refresh token n'a pas \xE9t\xE9 sauvegard\xE9 !");
            throw new Error("\xC9chec de sauvegarde du refresh token");
          }
          logger9.info("\u2705 Tokens g\xE9n\xE9r\xE9s et sauvegard\xE9s avec succ\xE8s", {
            userId: user._id?.toString(),
            hasRefreshTokens: verificationUser.refreshTokens.length,
            accessTokenLength: accessToken.length,
            refreshTokenLength: refreshToken.length
          });
          return {
            accessToken,
            refreshToken,
            sessionId
          };
        } catch (error2) {
          logger9.error("Erreur lors de la g\xE9n\xE9ration des tokens", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            userId: user._id?.toString(),
            stack: error2 instanceof Error ? error2.stack : void 0
          });
          throw new Error(`Erreur lors de la g\xE9n\xE9ration des tokens: ${error2 instanceof Error ? error2.message : "Erreur inconnue"}`);
        }
      }
      /**
       * Génère des codes de secours pour la 2FA
       */
      // private generateBackupCodes(): string[] {
      //   const codes: string[] = [];
      //   for (let i = 0; i < 10; i++) {
      //     // Génère des codes de 8 caractères alphanumériques
      //     const code = crypto.randomBytes(4).toString('hex').toUpperCase();
      //     codes.push(code);
      //   }
      //   return codes;
      // } 
      generateBackupCodes(count = 10) {
        const codes = [];
        for (let i = 0; i < count; i++) {
          const code = Math.random().toString(36).substring(2, 10).toUpperCase();
          codes.push(code);
        }
        return codes;
      }
    };
  }
});

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS({
  "node_modules/bson/lib/bson.cjs"(exports) {
    "use strict";
    var TypedArrayPrototypeGetSymbolToStringTag = (() => {
      const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
      return (value) => g.call(value);
    })();
    function isUint8Array(value) {
      return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
    }
    function isAnyArrayBuffer(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
    }
    function isRegExp2(regexp2) {
      return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
    }
    function isMap(value) {
      return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
    }
    function isDate2(date) {
      return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
    }
    function defaultInspect(x, _options) {
      return JSON.stringify(x, (k, v) => {
        if (typeof v === "bigint") {
          return { $numberLong: `${v}` };
        } else if (isMap(v)) {
          return Object.fromEntries(v);
        }
        return v;
      });
    }
    function getStylizeFunction(options) {
      const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
      if (stylizeExists) {
        return options.stylize;
      }
    }
    var BSON_MAJOR_VERSION = 6;
    var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
    var BSON_INT32_MAX = 2147483647;
    var BSON_INT32_MIN = -2147483648;
    var BSON_INT64_MAX = Math.pow(2, 63) - 1;
    var BSON_INT64_MIN = -Math.pow(2, 63);
    var JS_INT_MAX = Math.pow(2, 53);
    var JS_INT_MIN = -Math.pow(2, 53);
    var BSON_DATA_NUMBER = 1;
    var BSON_DATA_STRING = 2;
    var BSON_DATA_OBJECT = 3;
    var BSON_DATA_ARRAY = 4;
    var BSON_DATA_BINARY = 5;
    var BSON_DATA_UNDEFINED = 6;
    var BSON_DATA_OID = 7;
    var BSON_DATA_BOOLEAN = 8;
    var BSON_DATA_DATE = 9;
    var BSON_DATA_NULL = 10;
    var BSON_DATA_REGEXP = 11;
    var BSON_DATA_DBPOINTER = 12;
    var BSON_DATA_CODE = 13;
    var BSON_DATA_SYMBOL = 14;
    var BSON_DATA_CODE_W_SCOPE = 15;
    var BSON_DATA_INT = 16;
    var BSON_DATA_TIMESTAMP = 17;
    var BSON_DATA_LONG = 18;
    var BSON_DATA_DECIMAL128 = 19;
    var BSON_DATA_MIN_KEY = 255;
    var BSON_DATA_MAX_KEY = 127;
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
    var BSONType = Object.freeze({
      double: 1,
      string: 2,
      object: 3,
      array: 4,
      binData: 5,
      undefined: 6,
      objectId: 7,
      bool: 8,
      date: 9,
      null: 10,
      regex: 11,
      dbPointer: 12,
      javascript: 13,
      symbol: 14,
      javascriptWithScope: 15,
      int: 16,
      timestamp: 17,
      long: 18,
      decimal: 19,
      minKey: -1,
      maxKey: 127
    });
    var BSONError = class extends Error {
      get bsonError() {
        return true;
      }
      get name() {
        return "BSONError";
      }
      constructor(message, options) {
        super(message, options);
      }
      static isBSONError(value) {
        return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
      }
    };
    var BSONVersionError = class extends BSONError {
      get name() {
        return "BSONVersionError";
      }
      constructor() {
        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
      }
    };
    var BSONRuntimeError = class extends BSONError {
      get name() {
        return "BSONRuntimeError";
      }
      constructor(message) {
        super(message);
      }
    };
    var BSONOffsetError = class extends BSONError {
      get name() {
        return "BSONOffsetError";
      }
      constructor(message, offset, options) {
        super(`${message}. offset: ${offset}`, options);
        this.offset = offset;
      }
    };
    var TextDecoderFatal;
    var TextDecoderNonFatal;
    function parseUtf8(buffer2, start, end, fatal) {
      if (fatal) {
        TextDecoderFatal ?? (TextDecoderFatal = new TextDecoder("utf8", { fatal: true }));
        try {
          return TextDecoderFatal.decode(buffer2.subarray(start, end));
        } catch (cause) {
          throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
        }
      }
      TextDecoderNonFatal ?? (TextDecoderNonFatal = new TextDecoder("utf8", { fatal: false }));
      return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
    }
    function tryReadBasicLatin(uint8array, start, end) {
      if (uint8array.length === 0) {
        return "";
      }
      const stringByteLength = end - start;
      if (stringByteLength === 0) {
        return "";
      }
      if (stringByteLength > 20) {
        return null;
      }
      if (stringByteLength === 1 && uint8array[start] < 128) {
        return String.fromCharCode(uint8array[start]);
      }
      if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
      }
      if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
      }
      const latinBytes = [];
      for (let i = start; i < end; i++) {
        const byte = uint8array[i];
        if (byte > 127) {
          return null;
        }
        latinBytes.push(byte);
      }
      return String.fromCharCode(...latinBytes);
    }
    function tryWriteBasicLatin(destination, source, offset) {
      if (source.length === 0)
        return 0;
      if (source.length > 25)
        return null;
      if (destination.length - offset < source.length)
        return null;
      for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {
        const char = source.charCodeAt(charOffset);
        if (char > 127)
          return null;
        destination[destinationOffset] = char;
      }
      return source.length;
    }
    function nodejsMathRandomBytes(byteLength) {
      return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var nodejsRandomBytes = (() => {
      try {
        return __require("crypto").randomBytes;
      } catch {
        return nodejsMathRandomBytes;
      }
    })();
    var nodeJsByteUtils = {
      toLocalBufferType(potentialBuffer) {
        if (Buffer.isBuffer(potentialBuffer)) {
          return potentialBuffer;
        }
        if (ArrayBuffer.isView(potentialBuffer)) {
          return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
        }
        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return Buffer.from(potentialBuffer);
        }
        throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
      },
      allocate(size) {
        return Buffer.alloc(size);
      },
      allocateUnsafe(size) {
        return Buffer.allocUnsafe(size);
      },
      equals(a, b) {
        return nodeJsByteUtils.toLocalBufferType(a).equals(b);
      },
      fromNumberArray(array) {
        return Buffer.from(array);
      },
      fromBase64(base64) {
        return Buffer.from(base64, "base64");
      },
      toBase64(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
      },
      fromISO88591(codePoints) {
        return Buffer.from(codePoints, "binary");
      },
      toISO88591(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
      },
      fromHex(hex) {
        return Buffer.from(hex, "hex");
      },
      toHex(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
      },
      toUTF8(buffer2, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
        if (fatal) {
          for (let i = 0; i < string.length; i++) {
            if (string.charCodeAt(i) === 65533) {
              parseUtf8(buffer2, start, end, true);
              break;
            }
          }
        }
        return string;
      },
      utf8ByteLength(input) {
        return Buffer.byteLength(input, "utf8");
      },
      encodeUTF8Into(buffer2, source, byteOffset) {
        const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
        if (latinBytesWritten != null) {
          return latinBytesWritten;
        }
        return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, void 0, "utf8");
      },
      randomBytes: nodejsRandomBytes,
      swap32(buffer2) {
        return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
      }
    };
    function isReactNative() {
      const { navigator: navigator2 } = globalThis;
      return typeof navigator2 === "object" && navigator2.product === "ReactNative";
    }
    function webMathRandomBytes(byteLength) {
      if (byteLength < 0) {
        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
      }
      return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
    }
    var webRandomBytes = (() => {
      const { crypto: crypto7 } = globalThis;
      if (crypto7 != null && typeof crypto7.getRandomValues === "function") {
        return (byteLength) => {
          return crypto7.getRandomValues(webByteUtils.allocate(byteLength));
        };
      } else {
        if (isReactNative()) {
          const { console: console2 } = globalThis;
          console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
        }
        return webMathRandomBytes;
      }
    })();
    var HEX_DIGIT = /(\d|[a-f])/i;
    var webByteUtils = {
      toLocalBufferType(potentialUint8array) {
        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
        if (stringTag === "Uint8Array") {
          return potentialUint8array;
        }
        if (ArrayBuffer.isView(potentialUint8array)) {
          return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
        }
        if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
          return new Uint8Array(potentialUint8array);
        }
        throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
      },
      allocate(size) {
        if (typeof size !== "number") {
          throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
        }
        return new Uint8Array(size);
      },
      allocateUnsafe(size) {
        return webByteUtils.allocate(size);
      },
      equals(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a.byteLength; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      },
      fromNumberArray(array) {
        return Uint8Array.from(array);
      },
      fromBase64(base64) {
        return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
      },
      toBase64(uint8array) {
        return btoa(webByteUtils.toISO88591(uint8array));
      },
      fromISO88591(codePoints) {
        return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
      },
      toISO88591(uint8array) {
        return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
      },
      fromHex(hex) {
        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
        const buffer2 = [];
        for (let i = 0; i < evenLengthHex.length; i += 2) {
          const firstDigit = evenLengthHex[i];
          const secondDigit = evenLengthHex[i + 1];
          if (!HEX_DIGIT.test(firstDigit)) {
            break;
          }
          if (!HEX_DIGIT.test(secondDigit)) {
            break;
          }
          const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
          buffer2.push(hexDigit);
        }
        return Uint8Array.from(buffer2);
      },
      toHex(uint8array) {
        return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
      },
      toUTF8(uint8array, start, end, fatal) {
        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
        if (basicLatin != null) {
          return basicLatin;
        }
        return parseUtf8(uint8array, start, end, fatal);
      },
      utf8ByteLength(input) {
        return new TextEncoder().encode(input).byteLength;
      },
      encodeUTF8Into(uint8array, source, byteOffset) {
        const bytes = new TextEncoder().encode(source);
        uint8array.set(bytes, byteOffset);
        return bytes.byteLength;
      },
      randomBytes: webRandomBytes,
      swap32(buffer2) {
        if (buffer2.length % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < buffer2.length; i += 4) {
          const byte0 = buffer2[i];
          const byte1 = buffer2[i + 1];
          const byte2 = buffer2[i + 2];
          const byte3 = buffer2[i + 3];
          buffer2[i] = byte3;
          buffer2[i + 1] = byte2;
          buffer2[i + 2] = byte1;
          buffer2[i + 3] = byte0;
        }
        return buffer2;
      }
    };
    var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
    var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;
    var BSONValue = class {
      get [BSON_VERSION_SYMBOL]() {
        return BSON_MAJOR_VERSION;
      }
      [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect2) {
        return this.inspect(depth, options, inspect2);
      }
    };
    var FLOAT = new Float64Array(1);
    var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
    FLOAT[0] = -1;
    var isBigEndian = FLOAT_BYTES[7] === 0;
    var NumberUtils = {
      isBigEndian,
      getNonnegativeInt32LE(source, offset) {
        if (source[offset + 3] > 127) {
          throw new RangeError(`Size cannot be negative at offset: ${offset}`);
        }
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getInt32LE(source, offset) {
        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
      },
      getUint32LE(source, offset) {
        return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
      },
      getUint32BE(source, offset) {
        return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
      },
      getBigInt64LE(source, offset) {
        const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
        const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
        return (hi << BigInt(32)) + lo;
      },
      getFloat64LE: isBigEndian ? (source, offset) => {
        FLOAT_BYTES[7] = source[offset];
        FLOAT_BYTES[6] = source[offset + 1];
        FLOAT_BYTES[5] = source[offset + 2];
        FLOAT_BYTES[4] = source[offset + 3];
        FLOAT_BYTES[3] = source[offset + 4];
        FLOAT_BYTES[2] = source[offset + 5];
        FLOAT_BYTES[1] = source[offset + 6];
        FLOAT_BYTES[0] = source[offset + 7];
        return FLOAT[0];
      } : (source, offset) => {
        FLOAT_BYTES[0] = source[offset];
        FLOAT_BYTES[1] = source[offset + 1];
        FLOAT_BYTES[2] = source[offset + 2];
        FLOAT_BYTES[3] = source[offset + 3];
        FLOAT_BYTES[4] = source[offset + 4];
        FLOAT_BYTES[5] = source[offset + 5];
        FLOAT_BYTES[6] = source[offset + 6];
        FLOAT_BYTES[7] = source[offset + 7];
        return FLOAT[0];
      },
      setInt32BE(destination, offset, value) {
        destination[offset + 3] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset] = value;
        return 4;
      },
      setInt32LE(destination, offset, value) {
        destination[offset] = value;
        value >>>= 8;
        destination[offset + 1] = value;
        value >>>= 8;
        destination[offset + 2] = value;
        value >>>= 8;
        destination[offset + 3] = value;
        return 4;
      },
      setBigInt64LE(destination, offset, value) {
        const mask32bits = BigInt(4294967295);
        let lo = Number(value & mask32bits);
        destination[offset] = lo;
        lo >>= 8;
        destination[offset + 1] = lo;
        lo >>= 8;
        destination[offset + 2] = lo;
        lo >>= 8;
        destination[offset + 3] = lo;
        let hi = Number(value >> BigInt(32) & mask32bits);
        destination[offset + 4] = hi;
        hi >>= 8;
        destination[offset + 5] = hi;
        hi >>= 8;
        destination[offset + 6] = hi;
        hi >>= 8;
        destination[offset + 7] = hi;
        return 8;
      },
      setFloat64LE: isBigEndian ? (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[7];
        destination[offset + 1] = FLOAT_BYTES[6];
        destination[offset + 2] = FLOAT_BYTES[5];
        destination[offset + 3] = FLOAT_BYTES[4];
        destination[offset + 4] = FLOAT_BYTES[3];
        destination[offset + 5] = FLOAT_BYTES[2];
        destination[offset + 6] = FLOAT_BYTES[1];
        destination[offset + 7] = FLOAT_BYTES[0];
        return 8;
      } : (destination, offset, value) => {
        FLOAT[0] = value;
        destination[offset] = FLOAT_BYTES[0];
        destination[offset + 1] = FLOAT_BYTES[1];
        destination[offset + 2] = FLOAT_BYTES[2];
        destination[offset + 3] = FLOAT_BYTES[3];
        destination[offset + 4] = FLOAT_BYTES[4];
        destination[offset + 5] = FLOAT_BYTES[5];
        destination[offset + 6] = FLOAT_BYTES[6];
        destination[offset + 7] = FLOAT_BYTES[7];
        return 8;
      }
    };
    var Binary = class _Binary extends BSONValue {
      get _bsontype() {
        return "Binary";
      }
      constructor(buffer2, subType) {
        super();
        if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
          throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
        }
        this.sub_type = subType ?? _Binary.BSON_BINARY_SUBTYPE_DEFAULT;
        if (buffer2 == null) {
          this.buffer = ByteUtils.allocate(_Binary.BUFFER_SIZE);
          this.position = 0;
        } else {
          this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
          this.position = this.buffer.byteLength;
        }
      }
      put(byteValue) {
        if (typeof byteValue === "string" && byteValue.length !== 1) {
          throw new BSONError("only accepts single character String");
        } else if (typeof byteValue !== "number" && byteValue.length !== 1)
          throw new BSONError("only accepts single character Uint8Array or Array");
        let decodedByte;
        if (typeof byteValue === "string") {
          decodedByte = byteValue.charCodeAt(0);
        } else if (typeof byteValue === "number") {
          decodedByte = byteValue;
        } else {
          decodedByte = byteValue[0];
        }
        if (decodedByte < 0 || decodedByte > 255) {
          throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
        }
        if (this.buffer.byteLength > this.position) {
          this.buffer[this.position++] = decodedByte;
        } else {
          const newSpace = ByteUtils.allocate(_Binary.BUFFER_SIZE + this.buffer.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
          this.buffer[this.position++] = decodedByte;
        }
      }
      write(sequence, offset) {
        offset = typeof offset === "number" ? offset : this.position;
        if (this.buffer.byteLength < offset + sequence.length) {
          const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
          newSpace.set(this.buffer, 0);
          this.buffer = newSpace;
        }
        if (ArrayBuffer.isView(sequence)) {
          this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
          this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
        } else if (typeof sequence === "string") {
          throw new BSONError("input cannot be string");
        }
      }
      read(position, length) {
        length = length && length > 0 ? length : this.position;
        const end = position + length;
        return this.buffer.subarray(position, end > this.position ? this.position : end);
      }
      value() {
        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
      }
      length() {
        return this.position;
      }
      toJSON() {
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.buffer.subarray(0, this.position));
        if (encoding === "base64")
          return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        if (encoding === "utf8" || encoding === "utf-8")
          return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      }
      toExtendedJSON(options) {
        options = options || {};
        if (this.sub_type === _Binary.SUBTYPE_VECTOR) {
          validateBinaryVector(this);
        }
        const base64String = ByteUtils.toBase64(this.buffer);
        const subType = Number(this.sub_type).toString(16);
        if (options.legacy) {
          return {
            $binary: base64String,
            $type: subType.length === 1 ? "0" + subType : subType
          };
        }
        return {
          $binary: {
            base64: base64String,
            subType: subType.length === 1 ? "0" + subType : subType
          }
        };
      }
      toUUID() {
        if (this.sub_type === _Binary.SUBTYPE_UUID) {
          return new UUID(this.buffer.subarray(0, this.position));
        }
        throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`);
      }
      static createFromHexString(hex, subType) {
        return new _Binary(ByteUtils.fromHex(hex), subType);
      }
      static createFromBase64(base64, subType) {
        return new _Binary(ByteUtils.fromBase64(base64), subType);
      }
      static fromExtendedJSON(doc, options) {
        options = options || {};
        let data;
        let type;
        if ("$binary" in doc) {
          if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
            type = doc.$type ? parseInt(doc.$type, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary);
          } else {
            if (typeof doc.$binary !== "string") {
              type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
              data = ByteUtils.fromBase64(doc.$binary.base64);
            }
          }
        } else if ("$uuid" in doc) {
          type = 4;
          data = UUID.bytesFromString(doc.$uuid);
        }
        if (!data) {
          throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
        }
        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new _Binary(data, type);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
        const base64Arg = inspect2(base64, options);
        const subTypeArg = inspect2(this.sub_type, options);
        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
      }
      toInt8Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Int8) {
          throw new BSONError("Binary datatype field is not Int8");
        }
        return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toFloat32Array() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.Float32) {
          throw new BSONError("Binary datatype field is not Float32");
        }
        const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(floatBytes);
        return new Float32Array(floatBytes.buffer);
      }
      toPackedBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      }
      toBits() {
        if (this.sub_type !== _Binary.SUBTYPE_VECTOR) {
          throw new BSONError("Binary sub_type is not Vector");
        }
        if (this.buffer[0] !== _Binary.VECTOR_TYPE.PackedBit) {
          throw new BSONError("Binary datatype field is not packed bit");
        }
        const byteCount = this.length() - 2;
        const bitCount = byteCount * 8 - this.buffer[1];
        const bits = new Int8Array(bitCount);
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset / 8 | 0;
          const byte = this.buffer[byteOffset + 2];
          const shift = 7 - bitOffset % 8;
          const bit = byte >> shift & 1;
          bits[bitOffset] = bit;
        }
        return bits;
      }
      static fromInt8Array(array) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.Int8;
        buffer2[1] = 0;
        const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        buffer2.set(intBytes, 2);
        return new this(buffer2, this.SUBTYPE_VECTOR);
      }
      static fromFloat32Array(array) {
        const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
        binaryBytes[0] = _Binary.VECTOR_TYPE.Float32;
        binaryBytes[1] = 0;
        const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        binaryBytes.set(floatBytes, 2);
        if (NumberUtils.isBigEndian)
          ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
        return new this(binaryBytes, this.SUBTYPE_VECTOR);
      }
      static fromPackedBits(array, padding = 0) {
        const buffer2 = ByteUtils.allocate(array.byteLength + 2);
        buffer2[0] = _Binary.VECTOR_TYPE.PackedBit;
        buffer2[1] = padding;
        buffer2.set(array, 2);
        return new this(buffer2, this.SUBTYPE_VECTOR);
      }
      static fromBits(bits) {
        const byteLength = bits.length + 7 >>> 3;
        const bytes = new Uint8Array(byteLength + 2);
        bytes[0] = _Binary.VECTOR_TYPE.PackedBit;
        const remainder = bits.length % 8;
        bytes[1] = remainder === 0 ? 0 : 8 - remainder;
        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {
          const byteOffset = bitOffset >>> 3;
          const bit = bits[bitOffset];
          if (bit !== 0 && bit !== 1) {
            throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
          }
          if (bit === 0)
            continue;
          const shift = 7 - bitOffset % 8;
          bytes[byteOffset + 2] |= bit << shift;
        }
        return new this(bytes, _Binary.SUBTYPE_VECTOR);
      }
    };
    Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    Binary.BUFFER_SIZE = 256;
    Binary.SUBTYPE_DEFAULT = 0;
    Binary.SUBTYPE_FUNCTION = 1;
    Binary.SUBTYPE_BYTE_ARRAY = 2;
    Binary.SUBTYPE_UUID_OLD = 3;
    Binary.SUBTYPE_UUID = 4;
    Binary.SUBTYPE_MD5 = 5;
    Binary.SUBTYPE_ENCRYPTED = 6;
    Binary.SUBTYPE_COLUMN = 7;
    Binary.SUBTYPE_SENSITIVE = 8;
    Binary.SUBTYPE_VECTOR = 9;
    Binary.SUBTYPE_USER_DEFINED = 128;
    Binary.VECTOR_TYPE = Object.freeze({
      Int8: 3,
      Float32: 39,
      PackedBit: 16
    });
    function validateBinaryVector(vector) {
      if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
        return;
      const size = vector.position;
      const datatype = vector.buffer[0];
      const padding = vector.buffer[1];
      if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
        throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
        throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
      }
      if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
        throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
      }
    }
    var UUID_BYTE_LENGTH = 16;
    var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
    var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;
    var UUID = class _UUID extends Binary {
      constructor(input) {
        let bytes;
        if (input == null) {
          bytes = _UUID.generate();
        } else if (input instanceof _UUID) {
          bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
          bytes = ByteUtils.toLocalBufferType(input);
        } else if (typeof input === "string") {
          bytes = _UUID.bytesFromString(input);
        } else {
          throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
        }
        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
      }
      toHexString(includeDashes = true) {
        if (includeDashes) {
          return [
            ByteUtils.toHex(this.buffer.subarray(0, 4)),
            ByteUtils.toHex(this.buffer.subarray(4, 6)),
            ByteUtils.toHex(this.buffer.subarray(6, 8)),
            ByteUtils.toHex(this.buffer.subarray(8, 10)),
            ByteUtils.toHex(this.buffer.subarray(10, 16))
          ].join("-");
        }
        return ByteUtils.toHex(this.buffer);
      }
      toString(encoding) {
        if (encoding === "hex")
          return ByteUtils.toHex(this.id);
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      equals(otherId) {
        if (!otherId) {
          return false;
        }
        if (otherId instanceof _UUID) {
          return ByteUtils.equals(otherId.id, this.id);
        }
        try {
          return ByteUtils.equals(new _UUID(otherId).id, this.id);
        } catch {
          return false;
        }
      }
      toBinary() {
        return new Binary(this.id, Binary.SUBTYPE_UUID);
      }
      static generate() {
        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
        bytes[6] = bytes[6] & 15 | 64;
        bytes[8] = bytes[8] & 63 | 128;
        return bytes;
      }
      static isValid(input) {
        if (!input) {
          return false;
        }
        if (typeof input === "string") {
          return _UUID.isValidUUIDString(input);
        }
        if (isUint8Array(input)) {
          return input.byteLength === UUID_BYTE_LENGTH;
        }
        return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
      }
      static createFromHexString(hexString) {
        const buffer2 = _UUID.bytesFromString(hexString);
        return new _UUID(buffer2);
      }
      static createFromBase64(base64) {
        return new _UUID(ByteUtils.fromBase64(base64));
      }
      static bytesFromString(representation) {
        if (!_UUID.isValidUUIDString(representation)) {
          throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
        }
        return ByteUtils.fromHex(representation.replace(/-/g, ""));
      }
      static isValidUUIDString(representation) {
        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        return `new UUID(${inspect2(this.toHexString(), options)})`;
      }
    };
    var Code = class _Code extends BSONValue {
      get _bsontype() {
        return "Code";
      }
      constructor(code, scope) {
        super();
        this.code = code.toString();
        this.scope = scope ?? null;
      }
      toJSON() {
        if (this.scope != null) {
          return { code: this.code, scope: this.scope };
        }
        return { code: this.code };
      }
      toExtendedJSON() {
        if (this.scope) {
          return { $code: this.code, $scope: this.scope };
        }
        return { $code: this.code };
      }
      static fromExtendedJSON(doc) {
        return new _Code(doc.$code, doc.$scope);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        let parametersString = inspect2(this.code, options);
        const multiLineFn = parametersString.includes("\n");
        if (this.scope != null) {
          parametersString += `,${multiLineFn ? "\n" : " "}${inspect2(this.scope, options)}`;
        }
        const endingNewline = multiLineFn && this.scope === null;
        return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
      }
    };
    function isDBRefLike(value) {
      return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || "$db" in value && typeof value.$db === "string");
    }
    var DBRef = class _DBRef extends BSONValue {
      get _bsontype() {
        return "DBRef";
      }
      constructor(collection, oid, db, fields) {
        super();
        const parts = collection.split(".");
        if (parts.length === 2) {
          db = parts.shift();
          collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
      }
      get namespace() {
        return this.collection;
      }
      set namespace(value) {
        this.collection = value;
      }
      toJSON() {
        const o = Object.assign({
          $ref: this.collection,
          $id: this.oid
        }, this.fields);
        if (this.db != null)
          o.$db = this.db;
        return o;
      }
      toExtendedJSON(options) {
        options = options || {};
        let o = {
          $ref: this.collection,
          $id: this.oid
        };
        if (options.legacy) {
          return o;
        }
        if (this.db)
          o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
      }
      static fromExtendedJSON(doc) {
        const copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new _DBRef(doc.$ref, doc.$id, doc.$db, copy);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        const args = [
          inspect2(this.namespace, options),
          inspect2(this.oid, options),
          ...this.db ? [inspect2(this.db, options)] : [],
          ...Object.keys(this.fields).length > 0 ? [inspect2(this.fields, options)] : []
        ];
        args[1] = inspect2 === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
        return `new DBRef(${args.join(", ")})`;
      }
    };
    function removeLeadingZerosAndExplicitPlus(str) {
      if (str === "") {
        return str;
      }
      let startIndex = 0;
      const isNegative = str[startIndex] === "-";
      const isExplicitlyPositive = str[startIndex] === "+";
      if (isExplicitlyPositive || isNegative) {
        startIndex += 1;
      }
      let foundInsignificantZero = false;
      for (; startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
        foundInsignificantZero = true;
      }
      if (!foundInsignificantZero) {
        return isExplicitlyPositive ? str.slice(1) : str;
      }
      return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
    }
    function validateStringCharacters(str, radix) {
      radix = radix ?? 10;
      const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
      const regex = new RegExp(`[^-+${validCharacters}]`, "i");
      return regex.test(str) ? false : str;
    }
    var wasm = void 0;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    var MAX_INT64_STRING_LENGTH = 20;
    var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;
    var Long = class _Long extends BSONValue {
      get _bsontype() {
        return "Long";
      }
      get __isLong__() {
        return true;
      }
      constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
        super();
        const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
        const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
        const res = typeof lowOrValue === "string" ? _Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? _Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
        this.low = res.low;
        this.high = res.high;
        this.unsigned = res.unsigned;
      }
      static fromBits(lowBits, highBits, unsigned) {
        return new _Long(lowBits, highBits, unsigned);
      }
      static fromInt(value, unsigned) {
        let obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = _Long.fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      static fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? _Long.UZERO : _Long.ZERO;
        if (unsigned) {
          if (value < 0)
            return _Long.UZERO;
          if (value >= TWO_PWR_64_DBL)
            return _Long.MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -9223372036854776e3)
            return _Long.MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return _Long.MAX_VALUE;
        }
        if (value < 0)
          return _Long.fromNumber(-value, unsigned).neg();
        return _Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      static fromBigInt(value, unsigned) {
        const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
        const FROM_BIGINT_BIT_SHIFT = BigInt(32);
        return new _Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
      }
      static _fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw new BSONError("empty string");
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        let p;
        if ((p = str.indexOf("-")) > 0)
          throw new BSONError("interior hyphen");
        else if (p === 0) {
          return _Long._fromString(str.substring(1), unsigned, radix).neg();
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 8));
        let result = _Long.ZERO;
        for (let i = 0; i < str.length; i += 8) {
          const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            const power = _Long.fromNumber(Math.pow(radix, size));
            result = result.mul(power).add(_Long.fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(_Long.fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      static fromStringStrict(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ?? (radix = 10);
        if (str.trim() !== str) {
          throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
        }
        if (!validateStringCharacters(str, radix)) {
          throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
        }
        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
        const result = _Long._fromString(cleanedStr, unsigned, radix);
        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
          throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
        }
        return result;
      }
      static fromString(str, unsignedOrRadix, radix) {
        let unsigned = false;
        if (typeof unsignedOrRadix === "number") {
          radix = unsignedOrRadix, unsignedOrRadix = false;
        } else {
          unsigned = !!unsignedOrRadix;
        }
        radix ?? (radix = 10);
        if (str === "NaN" && radix < 24) {
          return _Long.ZERO;
        } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
          return _Long.ZERO;
        }
        return _Long._fromString(str, unsigned, radix);
      }
      static fromBytes(bytes, unsigned, le) {
        return le ? _Long.fromBytesLE(bytes, unsigned) : _Long.fromBytesBE(bytes, unsigned);
      }
      static fromBytesLE(bytes, unsigned) {
        return new _Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      }
      static fromBytesBE(bytes, unsigned) {
        return new _Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      }
      static isLong(value) {
        return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
      }
      static fromValue(val, unsigned) {
        if (typeof val === "number")
          return _Long.fromNumber(val, unsigned);
        if (typeof val === "string")
          return _Long.fromString(val, unsigned);
        return _Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      add(addend) {
        if (!_Long.isLong(addend))
          addend = _Long.fromValue(addend);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = addend.high >>> 16;
        const b32 = addend.high & 65535;
        const b16 = addend.low >>> 16;
        const b00 = addend.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      and(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      }
      compare(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.eq(other))
          return 0;
        const thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      }
      comp(other) {
        return this.compare(other);
      }
      divide(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (divisor.isZero())
          throw new BSONError("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? _Long.UZERO : _Long.ZERO;
        let approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(_Long.MIN_VALUE)) {
            if (divisor.eq(_Long.ONE) || divisor.eq(_Long.NEG_ONE))
              return _Long.MIN_VALUE;
            else if (divisor.eq(_Long.MIN_VALUE))
              return _Long.ONE;
            else {
              const halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(_Long.ZERO)) {
                return divisor.isNegative() ? _Long.ONE : _Long.NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(_Long.MIN_VALUE))
            return this.unsigned ? _Long.UZERO : _Long.ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = _Long.ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return _Long.UZERO;
          if (divisor.gt(this.shru(1)))
            return _Long.UONE;
          res = _Long.UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          const log2 = Math.ceil(Math.log(approx) / Math.LN2);
          const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
          let approxRes = _Long.fromNumber(approx);
          let approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = _Long.fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = _Long.ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      }
      div(divisor) {
        return this.divide(divisor);
      }
      equals(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      }
      eq(other) {
        return this.equals(other);
      }
      getHighBits() {
        return this.high;
      }
      getHighBitsUnsigned() {
        return this.high >>> 0;
      }
      getLowBits() {
        return this.low;
      }
      getLowBitsUnsigned() {
        return this.low >>> 0;
      }
      getNumBitsAbs() {
        if (this.isNegative()) {
          return this.eq(_Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        }
        const val = this.high !== 0 ? this.high : this.low;
        let bit;
        for (bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) !== 0)
            break;
        return this.high !== 0 ? bit + 33 : bit + 1;
      }
      greaterThan(other) {
        return this.comp(other) > 0;
      }
      gt(other) {
        return this.greaterThan(other);
      }
      greaterThanOrEqual(other) {
        return this.comp(other) >= 0;
      }
      gte(other) {
        return this.greaterThanOrEqual(other);
      }
      ge(other) {
        return this.greaterThanOrEqual(other);
      }
      isEven() {
        return (this.low & 1) === 0;
      }
      isNegative() {
        return !this.unsigned && this.high < 0;
      }
      isOdd() {
        return (this.low & 1) === 1;
      }
      isPositive() {
        return this.unsigned || this.high >= 0;
      }
      isZero() {
        return this.high === 0 && this.low === 0;
      }
      lessThan(other) {
        return this.comp(other) < 0;
      }
      lt(other) {
        return this.lessThan(other);
      }
      lessThanOrEqual(other) {
        return this.comp(other) <= 0;
      }
      lte(other) {
        return this.lessThanOrEqual(other);
      }
      modulo(divisor) {
        if (!_Long.isLong(divisor))
          divisor = _Long.fromValue(divisor);
        if (wasm) {
          const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      }
      mod(divisor) {
        return this.modulo(divisor);
      }
      rem(divisor) {
        return this.modulo(divisor);
      }
      multiply(multiplier) {
        if (this.isZero())
          return _Long.ZERO;
        if (!_Long.isLong(multiplier))
          multiplier = _Long.fromValue(multiplier);
        if (wasm) {
          const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return _Long.fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return _Long.ZERO;
        if (this.eq(_Long.MIN_VALUE))
          return multiplier.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (multiplier.eq(_Long.MIN_VALUE))
          return this.isOdd() ? _Long.MIN_VALUE : _Long.ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(_Long.TWO_PWR_24) && multiplier.lt(_Long.TWO_PWR_24))
          return _Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        const a48 = this.high >>> 16;
        const a32 = this.high & 65535;
        const a16 = this.low >>> 16;
        const a00 = this.low & 65535;
        const b48 = multiplier.high >>> 16;
        const b32 = multiplier.high & 65535;
        const b16 = multiplier.low >>> 16;
        const b00 = multiplier.low & 65535;
        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return _Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }
      mul(multiplier) {
        return this.multiply(multiplier);
      }
      negate() {
        if (!this.unsigned && this.eq(_Long.MIN_VALUE))
          return _Long.MIN_VALUE;
        return this.not().add(_Long.ONE);
      }
      neg() {
        return this.negate();
      }
      not() {
        return _Long.fromBits(~this.low, ~this.high, this.unsigned);
      }
      notEquals(other) {
        return !this.equals(other);
      }
      neq(other) {
        return this.notEquals(other);
      }
      ne(other) {
        return this.notEquals(other);
      }
      or(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      }
      shiftLeft(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return _Long.fromBits(0, this.low << numBits - 32, this.unsigned);
      }
      shl(numBits) {
        return this.shiftLeft(numBits);
      }
      shiftRight(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return _Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return _Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }
      shr(numBits) {
        return this.shiftRight(numBits);
      }
      shiftRightUnsigned(numBits) {
        if (_Long.isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          const high = this.high;
          if (numBits < 32) {
            const low = this.low;
            return _Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return _Long.fromBits(high, 0, this.unsigned);
          else
            return _Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      }
      shr_u(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      shru(numBits) {
        return this.shiftRightUnsigned(numBits);
      }
      subtract(subtrahend) {
        if (!_Long.isLong(subtrahend))
          subtrahend = _Long.fromValue(subtrahend);
        return this.add(subtrahend.neg());
      }
      sub(subtrahend) {
        return this.subtract(subtrahend);
      }
      toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }
      toNumber() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      }
      toBigInt() {
        return BigInt(this.toString());
      }
      toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      }
      toBytesLE() {
        const hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      }
      toBytesBE() {
        const hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      }
      toSigned() {
        if (!this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, false);
      }
      toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw new BSONError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(_Long.MIN_VALUE)) {
            const radixLong = _Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        const radixToPower = _Long.fromNumber(Math.pow(radix, 6), this.unsigned);
        let rem = this;
        let result = "";
        while (true) {
          const remDiv = rem.div(radixToPower);
          const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
          let digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) {
            return digits + result;
          } else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      }
      toUnsigned() {
        if (this.unsigned)
          return this;
        return _Long.fromBits(this.low, this.high, true);
      }
      xor(other) {
        if (!_Long.isLong(other))
          other = _Long.fromValue(other);
        return _Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      }
      eqz() {
        return this.isZero();
      }
      le(other) {
        return this.lessThanOrEqual(other);
      }
      toExtendedJSON(options) {
        if (options && options.relaxed)
          return this.toNumber();
        return { $numberLong: this.toString() };
      }
      static fromExtendedJSON(doc, options) {
        const { useBigInt64 = false, relaxed = true } = { ...options };
        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
          throw new BSONError("$numberLong string is too long");
        }
        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
          throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
        }
        if (useBigInt64) {
          const bigIntResult = BigInt(doc.$numberLong);
          return BigInt.asIntN(64, bigIntResult);
        }
        const longResult = _Long.fromString(doc.$numberLong);
        if (relaxed) {
          return longResult.toNumber();
        }
        return longResult;
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        const longVal = inspect2(this.toString(), options);
        const unsignedVal = this.unsigned ? `, ${inspect2(this.unsigned, options)}` : "";
        return `new Long(${longVal}${unsignedVal})`;
      }
    };
    Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
    Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.ZERO = Long.fromInt(0);
    Long.UZERO = Long.fromInt(0, true);
    Long.ONE = Long.fromInt(1);
    Long.UONE = Long.fromInt(1, true);
    Long.NEG_ONE = Long.fromInt(-1);
    Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = ByteUtils.fromNumberArray([
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse());
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    function isDigit(value) {
      return !isNaN(parseInt(value, 10));
    }
    function divideu128(value) {
      const DIVISOR = Long.fromNumber(1e3 * 1e3 * 1e3);
      let _rem = Long.fromNumber(0);
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (let i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    }
    function multiply64x2(left, right) {
      if (!left && !right) {
        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
      }
      const leftHigh = left.shiftRightUnsigned(32);
      const leftLow = new Long(left.getLowBits(), 0);
      const rightHigh = right.shiftRightUnsigned(32);
      const rightLow = new Long(right.getLowBits(), 0);
      let productHigh = leftHigh.multiply(rightHigh);
      let productMid = leftHigh.multiply(rightLow);
      const productMid2 = leftLow.multiply(rightHigh);
      let productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    }
    function lessThan(left, right) {
      const uhleft = left.high >>> 0;
      const uhright = right.high >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        const ulleft = left.low >>> 0;
        const ulright = right.low >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    }
    function invalidErr(string, message) {
      throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
    }
    var Decimal128 = class _Decimal128 extends BSONValue {
      get _bsontype() {
        return "Decimal128";
      }
      constructor(bytes) {
        super();
        if (typeof bytes === "string") {
          this.bytes = _Decimal128.fromString(bytes).bytes;
        } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
          if (bytes.byteLength !== 16) {
            throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
          }
          this.bytes = bytes;
        } else {
          throw new BSONError("Decimal128 must take a Buffer or string");
        }
      }
      static fromString(representation) {
        return _Decimal128._fromString(representation, { allowRounding: false });
      }
      static fromStringWithRounding(representation) {
        return _Decimal128._fromString(representation, { allowRounding: true });
      }
      static _fromString(representation, options) {
        let isNegative = false;
        let sawSign = false;
        let sawRadix = false;
        let foundNonZero = false;
        let significantDigits = 0;
        let nDigitsRead = 0;
        let nDigits = 0;
        let radixPosition = 0;
        let firstNonZero = 0;
        const digits = [0];
        let nDigitsStored = 0;
        let digitsInsert = 0;
        let lastDigit = 0;
        let exponent = 0;
        let significandHigh = new Long(0, 0);
        let significandLow = new Long(0, 0);
        let biasedExponent = 0;
        let index = 0;
        if (representation.length >= 7e3) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        const stringMatch = representation.match(PARSE_STRING_REGEXP);
        const infMatch = representation.match(PARSE_INF_REGEXP);
        const nanMatch = representation.match(PARSE_NAN_REGEXP);
        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        }
        if (stringMatch) {
          const unsignedNumber = stringMatch[2];
          const e = stringMatch[4];
          const expSign = stringMatch[5];
          const expNumber = stringMatch[6];
          if (e && expNumber === void 0)
            invalidErr(representation, "missing exponent power");
          if (e && unsignedNumber === void 0)
            invalidErr(representation, "missing exponent base");
          if (e === void 0 && (expSign || expNumber)) {
            invalidErr(representation, "missing e before exponent");
          }
        }
        if (representation[index] === "+" || representation[index] === "-") {
          sawSign = true;
          isNegative = representation[index++] === "-";
        }
        if (!isDigit(representation[index]) && representation[index] !== ".") {
          if (representation[index] === "i" || representation[index] === "I") {
            return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
          } else if (representation[index] === "N") {
            return new _Decimal128(NAN_BUFFER);
          }
        }
        while (isDigit(representation[index]) || representation[index] === ".") {
          if (representation[index] === ".") {
            if (sawRadix)
              invalidErr(representation, "contains multiple periods");
            sawRadix = true;
            index = index + 1;
            continue;
          }
          if (nDigitsStored < MAX_DIGITS) {
            if (representation[index] !== "0" || foundNonZero) {
              if (!foundNonZero) {
                firstNonZero = nDigitsRead;
              }
              foundNonZero = true;
              digits[digitsInsert++] = parseInt(representation[index], 10);
              nDigitsStored = nDigitsStored + 1;
            }
          }
          if (foundNonZero)
            nDigits = nDigits + 1;
          if (sawRadix)
            radixPosition = radixPosition + 1;
          nDigitsRead = nDigitsRead + 1;
          index = index + 1;
        }
        if (sawRadix && !nDigitsRead)
          throw new BSONError("" + representation + " not a valid Decimal128 string");
        if (representation[index] === "e" || representation[index] === "E") {
          const match = representation.substr(++index).match(EXPONENT_REGEX);
          if (!match || !match[2])
            return new _Decimal128(NAN_BUFFER);
          exponent = parseInt(match[0], 10);
          index = index + match[0].length;
        }
        if (representation[index])
          return new _Decimal128(NAN_BUFFER);
        if (!nDigitsStored) {
          digits[0] = 0;
          nDigits = 1;
          nDigitsStored = 1;
          significantDigits = 0;
        } else {
          lastDigit = nDigitsStored - 1;
          significantDigits = nDigits;
          if (significantDigits !== 1) {
            while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
              significantDigits = significantDigits - 1;
            }
          }
        }
        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
          exponent = EXPONENT_MIN;
        } else {
          exponent = exponent - radixPosition;
        }
        while (exponent > EXPONENT_MAX) {
          lastDigit = lastDigit + 1;
          if (lastDigit >= MAX_DIGITS) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
          exponent = exponent - 1;
        }
        if (options.allowRounding) {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0 && significantDigits < nDigitsStored) {
              exponent = EXPONENT_MIN;
              significantDigits = 0;
              break;
            }
            if (nDigitsStored < nDigits) {
              nDigits = nDigits - 1;
            } else {
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              const digitsString = digits.join("");
              if (digitsString.match(/^0+$/)) {
                exponent = EXPONENT_MAX;
                break;
              }
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            let endOfString = nDigitsRead;
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
              endOfString = endOfString + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            let roundBit = 0;
            if (roundDigit >= 5) {
              roundBit = 1;
              if (roundDigit === 5) {
                roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
                for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                  if (parseInt(representation[i], 10)) {
                    roundBit = 1;
                    break;
                  }
                }
              }
            }
            if (roundBit) {
              let dIdx = lastDigit;
              for (; dIdx >= 0; dIdx--) {
                if (++digits[dIdx] > 9) {
                  digits[dIdx] = 0;
                  if (dIdx === 0) {
                    if (exponent < EXPONENT_MAX) {
                      exponent = exponent + 1;
                      digits[dIdx] = 1;
                    } else {
                      return new _Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                    }
                  }
                } else {
                  break;
                }
              }
            }
          }
        } else {
          while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
            if (lastDigit === 0) {
              if (significantDigits === 0) {
                exponent = EXPONENT_MIN;
                break;
              }
              invalidErr(representation, "exponent underflow");
            }
            if (nDigitsStored < nDigits) {
              if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              nDigits = nDigits - 1;
            } else {
              if (digits[lastDigit] !== 0) {
                invalidErr(representation, "inexact rounding");
              }
              lastDigit = lastDigit - 1;
            }
            if (exponent < EXPONENT_MAX) {
              exponent = exponent + 1;
            } else {
              invalidErr(representation, "overflow");
            }
          }
          if (lastDigit + 1 < significantDigits) {
            if (sawRadix) {
              firstNonZero = firstNonZero + 1;
            }
            if (sawSign) {
              firstNonZero = firstNonZero + 1;
            }
            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
            if (roundDigit !== 0) {
              invalidErr(representation, "inexact rounding");
            }
          }
        }
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
        if (significantDigits === 0) {
          significandHigh = Long.fromNumber(0);
          significandLow = Long.fromNumber(0);
        } else if (lastDigit < 17) {
          let dIdx = 0;
          significandLow = Long.fromNumber(digits[dIdx++]);
          significandHigh = new Long(0, 0);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        } else {
          let dIdx = 0;
          significandHigh = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit - 17; dIdx++) {
            significandHigh = significandHigh.multiply(Long.fromNumber(10));
            significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
          }
          significandLow = Long.fromNumber(digits[dIdx++]);
          for (; dIdx <= lastDigit; dIdx++) {
            significandLow = significandLow.multiply(Long.fromNumber(10));
            significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
          }
        }
        const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
        significand.low = significand.low.add(significandLow);
        if (lessThan(significand.low, significandLow)) {
          significand.high = significand.high.add(Long.fromNumber(1));
        }
        biasedExponent = exponent + EXPONENT_BIAS;
        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
          dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
          dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
        } else {
          dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
          dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
        }
        dec.low = significand.low;
        if (isNegative) {
          dec.high = dec.high.or(Long.fromString("9223372036854775808"));
        }
        const buffer2 = ByteUtils.allocateUnsafe(16);
        index = 0;
        buffer2[index++] = dec.low.low & 255;
        buffer2[index++] = dec.low.low >> 8 & 255;
        buffer2[index++] = dec.low.low >> 16 & 255;
        buffer2[index++] = dec.low.low >> 24 & 255;
        buffer2[index++] = dec.low.high & 255;
        buffer2[index++] = dec.low.high >> 8 & 255;
        buffer2[index++] = dec.low.high >> 16 & 255;
        buffer2[index++] = dec.low.high >> 24 & 255;
        buffer2[index++] = dec.high.low & 255;
        buffer2[index++] = dec.high.low >> 8 & 255;
        buffer2[index++] = dec.high.low >> 16 & 255;
        buffer2[index++] = dec.high.low >> 24 & 255;
        buffer2[index++] = dec.high.high & 255;
        buffer2[index++] = dec.high.high >> 8 & 255;
        buffer2[index++] = dec.high.high >> 16 & 255;
        buffer2[index++] = dec.high.high >> 24 & 255;
        return new _Decimal128(buffer2);
      }
      toString() {
        let biased_exponent;
        let significand_digits = 0;
        const significand = new Array(36);
        for (let i = 0; i < significand.length; i++)
          significand[i] = 0;
        let index = 0;
        let is_zero = false;
        let significand_msb;
        let significand128 = { parts: [0, 0, 0, 0] };
        let j, k;
        const string = [];
        index = 0;
        const buffer2 = this.bytes;
        const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        index = 0;
        const dec = {
          low: new Long(low, midl),
          high: new Long(midh, high)
        };
        if (dec.high.lessThan(Long.ZERO)) {
          string.push("-");
        }
        const combination = high >> 26 & COMBINATION_MASK;
        if (combination >> 3 === 3) {
          if (combination === COMBINATION_INFINITY) {
            return string.join("") + "Infinity";
          } else if (combination === COMBINATION_NAN) {
            return "NaN";
          } else {
            biased_exponent = high >> 15 & EXPONENT_MASK;
            significand_msb = 8 + (high >> 14 & 1);
          }
        } else {
          significand_msb = high >> 14 & 7;
          biased_exponent = high >> 17 & EXPONENT_MASK;
        }
        const exponent = biased_exponent - EXPONENT_BIAS;
        significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
        significand128.parts[1] = midh;
        significand128.parts[2] = midl;
        significand128.parts[3] = low;
        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
          is_zero = true;
        } else {
          for (k = 3; k >= 0; k--) {
            let least_digits = 0;
            const result = divideu128(significand128);
            significand128 = result.quotient;
            least_digits = result.rem.low;
            if (!least_digits)
              continue;
            for (j = 8; j >= 0; j--) {
              significand[k * 9 + j] = least_digits % 10;
              least_digits = Math.floor(least_digits / 10);
            }
          }
        }
        if (is_zero) {
          significand_digits = 1;
          significand[index] = 0;
        } else {
          significand_digits = 36;
          while (!significand[index]) {
            significand_digits = significand_digits - 1;
            index = index + 1;
          }
        }
        const scientific_exponent = significand_digits - 1 + exponent;
        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
          if (significand_digits > 34) {
            string.push(`${0}`);
            if (exponent > 0)
              string.push(`E+${exponent}`);
            else if (exponent < 0)
              string.push(`E${exponent}`);
            return string.join("");
          }
          string.push(`${significand[index++]}`);
          significand_digits = significand_digits - 1;
          if (significand_digits) {
            string.push(".");
          }
          for (let i = 0; i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
          string.push("E");
          if (scientific_exponent > 0) {
            string.push(`+${scientific_exponent}`);
          } else {
            string.push(`${scientific_exponent}`);
          }
        } else {
          if (exponent >= 0) {
            for (let i = 0; i < significand_digits; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            let radix_position = significand_digits + exponent;
            if (radix_position > 0) {
              for (let i = 0; i < radix_position; i++) {
                string.push(`${significand[index++]}`);
              }
            } else {
              string.push("0");
            }
            string.push(".");
            while (radix_position++ < 0) {
              string.push("0");
            }
            for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
              string.push(`${significand[index++]}`);
            }
          }
        }
        return string.join("");
      }
      toJSON() {
        return { $numberDecimal: this.toString() };
      }
      toExtendedJSON() {
        return { $numberDecimal: this.toString() };
      }
      static fromExtendedJSON(doc) {
        return _Decimal128.fromString(doc.$numberDecimal);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        const d128string = inspect2(this.toString(), options);
        return `new Decimal128(${d128string})`;
      }
    };
    var Double = class _Double extends BSONValue {
      get _bsontype() {
        return "Double";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value;
      }
      static fromString(value) {
        const coercedValue = Number(value);
        if (value === "NaN")
          return new _Double(NaN);
        if (value === "Infinity")
          return new _Double(Infinity);
        if (value === "-Infinity")
          return new _Double(-Infinity);
        if (!Number.isFinite(coercedValue)) {
          throw new BSONError(`Input: ${value} is not representable as a Double`);
        }
        if (value.trim() !== value) {
          throw new BSONError(`Input: '${value}' contains whitespace`);
        }
        if (value === "") {
          throw new BSONError(`Input is an empty string`);
        }
        if (/[^-0-9.+eE]/.test(value)) {
          throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
        }
        return new _Double(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toExtendedJSON(options) {
        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
          return this.value;
        }
        if (Object.is(Math.sign(this.value), -0)) {
          return { $numberDouble: "-0.0" };
        }
        return {
          $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
        };
      }
      static fromExtendedJSON(doc, options) {
        const doubleValue = parseFloat(doc.$numberDouble);
        return options && options.relaxed ? doubleValue : new _Double(doubleValue);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        return `new Double(${inspect2(this.value, options)})`;
      }
    };
    var Int32 = class _Int32 extends BSONValue {
      get _bsontype() {
        return "Int32";
      }
      constructor(value) {
        super();
        if (value instanceof Number) {
          value = value.valueOf();
        }
        this.value = +value | 0;
      }
      static fromString(value) {
        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
        const coercedValue = Number(value);
        if (BSON_INT32_MAX < coercedValue) {
          throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
        } else if (BSON_INT32_MIN > coercedValue) {
          throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
        } else if (!Number.isSafeInteger(coercedValue)) {
          throw new BSONError(`Input: '${value}' is not a safe integer`);
        } else if (coercedValue.toString() !== cleanedValue) {
          throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
        }
        return new _Int32(coercedValue);
      }
      valueOf() {
        return this.value;
      }
      toString(radix) {
        return this.value.toString(radix);
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON(options) {
        if (options && (options.relaxed || options.legacy))
          return this.value;
        return { $numberInt: this.value.toString() };
      }
      static fromExtendedJSON(doc, options) {
        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new _Int32(doc.$numberInt);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        return `new Int32(${inspect2(this.value, options)})`;
      }
    };
    var MaxKey = class _MaxKey extends BSONValue {
      get _bsontype() {
        return "MaxKey";
      }
      toExtendedJSON() {
        return { $maxKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MaxKey();
      }
      inspect() {
        return "new MaxKey()";
      }
    };
    var MinKey = class _MinKey extends BSONValue {
      get _bsontype() {
        return "MinKey";
      }
      toExtendedJSON() {
        return { $minKey: 1 };
      }
      static fromExtendedJSON() {
        return new _MinKey();
      }
      inspect() {
        return "new MinKey()";
      }
    };
    var PROCESS_UNIQUE = null;
    var __idCache = /* @__PURE__ */ new WeakMap();
    var ObjectId3 = class _ObjectId extends BSONValue {
      get _bsontype() {
        return "ObjectId";
      }
      constructor(inputId) {
        super();
        let workingId;
        if (typeof inputId === "object" && inputId && "id" in inputId) {
          if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
            throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
          }
          if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
            workingId = ByteUtils.fromHex(inputId.toHexString());
          } else {
            workingId = inputId.id;
          }
        } else {
          workingId = inputId;
        }
        if (workingId == null || typeof workingId === "number") {
          this.buffer = _ObjectId.generate(typeof workingId === "number" ? workingId : void 0);
        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
          this.buffer = ByteUtils.toLocalBufferType(workingId);
        } else if (typeof workingId === "string") {
          if (_ObjectId.validateHexString(workingId)) {
            this.buffer = ByteUtils.fromHex(workingId);
            if (_ObjectId.cacheHexString) {
              __idCache.set(this, workingId);
            }
          } else {
            throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
          }
        } else {
          throw new BSONError("Argument passed in does not match the accepted types");
        }
      }
      get id() {
        return this.buffer;
      }
      set id(value) {
        this.buffer = value;
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, ByteUtils.toHex(value));
        }
      }
      static validateHexString(string) {
        if (string?.length !== 24)
          return false;
        for (let i = 0; i < 24; i++) {
          const char = string.charCodeAt(i);
          if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
            continue;
          }
          return false;
        }
        return true;
      }
      toHexString() {
        if (_ObjectId.cacheHexString) {
          const __id = __idCache.get(this);
          if (__id)
            return __id;
        }
        const hexString = ByteUtils.toHex(this.id);
        if (_ObjectId.cacheHexString) {
          __idCache.set(this, hexString);
        }
        return hexString;
      }
      static getInc() {
        return _ObjectId.index = (_ObjectId.index + 1) % 16777215;
      }
      static generate(time) {
        if ("number" !== typeof time) {
          time = Math.floor(Date.now() / 1e3);
        }
        const inc = _ObjectId.getInc();
        const buffer2 = ByteUtils.allocateUnsafe(12);
        NumberUtils.setInt32BE(buffer2, 0, time);
        if (PROCESS_UNIQUE === null) {
          PROCESS_UNIQUE = ByteUtils.randomBytes(5);
        }
        buffer2[4] = PROCESS_UNIQUE[0];
        buffer2[5] = PROCESS_UNIQUE[1];
        buffer2[6] = PROCESS_UNIQUE[2];
        buffer2[7] = PROCESS_UNIQUE[3];
        buffer2[8] = PROCESS_UNIQUE[4];
        buffer2[11] = inc & 255;
        buffer2[10] = inc >> 8 & 255;
        buffer2[9] = inc >> 16 & 255;
        return buffer2;
      }
      toString(encoding) {
        if (encoding === "base64")
          return ByteUtils.toBase64(this.id);
        if (encoding === "hex")
          return this.toHexString();
        return this.toHexString();
      }
      toJSON() {
        return this.toHexString();
      }
      static is(variable) {
        return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
      }
      equals(otherId) {
        if (otherId === void 0 || otherId === null) {
          return false;
        }
        if (_ObjectId.is(otherId)) {
          return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
        }
        if (typeof otherId === "string") {
          return otherId.toLowerCase() === this.toHexString();
        }
        if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
          const otherIdString = otherId.toHexString();
          const thisIdString = this.toHexString();
          return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
        }
        return false;
      }
      getTimestamp() {
        const timestamp = /* @__PURE__ */ new Date();
        const time = NumberUtils.getUint32BE(this.buffer, 0);
        timestamp.setTime(Math.floor(time) * 1e3);
        return timestamp;
      }
      static createPk() {
        return new _ObjectId();
      }
      serializeInto(uint8array, index) {
        uint8array[index] = this.buffer[0];
        uint8array[index + 1] = this.buffer[1];
        uint8array[index + 2] = this.buffer[2];
        uint8array[index + 3] = this.buffer[3];
        uint8array[index + 4] = this.buffer[4];
        uint8array[index + 5] = this.buffer[5];
        uint8array[index + 6] = this.buffer[6];
        uint8array[index + 7] = this.buffer[7];
        uint8array[index + 8] = this.buffer[8];
        uint8array[index + 9] = this.buffer[9];
        uint8array[index + 10] = this.buffer[10];
        uint8array[index + 11] = this.buffer[11];
        return 12;
      }
      static createFromTime(time) {
        const buffer2 = ByteUtils.allocate(12);
        for (let i = 11; i >= 4; i--)
          buffer2[i] = 0;
        NumberUtils.setInt32BE(buffer2, 0, time);
        return new _ObjectId(buffer2);
      }
      static createFromHexString(hexString) {
        if (hexString?.length !== 24) {
          throw new BSONError("hex string must be 24 characters");
        }
        return new _ObjectId(ByteUtils.fromHex(hexString));
      }
      static createFromBase64(base64) {
        if (base64?.length !== 16) {
          throw new BSONError("base64 string must be 16 characters");
        }
        return new _ObjectId(ByteUtils.fromBase64(base64));
      }
      static isValid(id) {
        if (id == null)
          return false;
        if (typeof id === "string")
          return _ObjectId.validateHexString(id);
        try {
          new _ObjectId(id);
          return true;
        } catch {
          return false;
        }
      }
      toExtendedJSON() {
        if (this.toHexString)
          return { $oid: this.toHexString() };
        return { $oid: this.toString("hex") };
      }
      static fromExtendedJSON(doc) {
        return new _ObjectId(doc.$oid);
      }
      isCached() {
        return _ObjectId.cacheHexString && __idCache.has(this);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        return `new ObjectId(${inspect2(this.toHexString(), options)})`;
      }
    };
    ObjectId3.index = Math.floor(Math.random() * 16777215);
    function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
      let totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
        }
        for (const key of Object.keys(object)) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    }
    function calculateElement(name, value, serializeFunctions = false, isArray2 = false, ignoreUndefined = false) {
      if (typeof value?.toBSON === "function") {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
        case "number":
          if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
            }
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray2 || !ignoreUndefined)
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
        case "object":
          if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError();
          } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
          } else if (value._bsontype === "ObjectId") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate2(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
          } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          } else if (value._bsontype === "Decimal128") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
          } else if (value._bsontype === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
            }
          } else if (value._bsontype === "Binary") {
            const binary = value;
            if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
            } else {
              return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
            }
          } else if (value._bsontype === "Symbol") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
          } else if (value._bsontype === "DBRef") {
            const ordered_values = Object.assign({
              $ref: value.collection,
              $id: value.oid
            }, value.fields);
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || isRegExp2(value)) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value._bsontype === "BSONRegExp") {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (serializeFunctions) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
          }
          return 0;
        case "bigint":
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        case "symbol":
          return 0;
        default:
          throw new BSONError(`Unrecognized JS type: ${typeof value}`);
      }
    }
    function alphabetize(str) {
      return str.split("").sort().join("");
    }
    var BSONRegExp = class _BSONRegExp extends BSONValue {
      get _bsontype() {
        return "BSONRegExp";
      }
      constructor(pattern, options) {
        super();
        this.pattern = pattern;
        this.options = alphabetize(options ?? "");
        if (this.pattern.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
        }
        if (this.options.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
        }
        for (let i = 0; i < this.options.length; i++) {
          if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
            throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
          }
        }
      }
      static parseOptions(options) {
        return options ? options.split("").sort().join("") : "";
      }
      toExtendedJSON(options) {
        options = options || {};
        if (options.legacy) {
          return { $regex: this.pattern, $options: this.options };
        }
        return { $regularExpression: { pattern: this.pattern, options: this.options } };
      }
      static fromExtendedJSON(doc) {
        if ("$regex" in doc) {
          if (typeof doc.$regex !== "string") {
            if (doc.$regex._bsontype === "BSONRegExp") {
              return doc;
            }
          } else {
            return new _BSONRegExp(doc.$regex, _BSONRegExp.parseOptions(doc.$options));
          }
        }
        if ("$regularExpression" in doc) {
          return new _BSONRegExp(doc.$regularExpression.pattern, _BSONRegExp.parseOptions(doc.$regularExpression.options));
        }
        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
      }
      inspect(depth, options, inspect2) {
        const stylize = getStylizeFunction(options) ?? ((v) => v);
        inspect2 ?? (inspect2 = defaultInspect);
        const pattern = stylize(inspect2(this.pattern), "regexp");
        const flags = stylize(inspect2(this.options), "regexp");
        return `new BSONRegExp(${pattern}, ${flags})`;
      }
    };
    var BSONSymbol = class _BSONSymbol extends BSONValue {
      get _bsontype() {
        return "BSONSymbol";
      }
      constructor(value) {
        super();
        this.value = value;
      }
      valueOf() {
        return this.value;
      }
      toString() {
        return this.value;
      }
      toJSON() {
        return this.value;
      }
      toExtendedJSON() {
        return { $symbol: this.value };
      }
      static fromExtendedJSON(doc) {
        return new _BSONSymbol(doc.$symbol);
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        return `new BSONSymbol(${inspect2(this.value, options)})`;
      }
    };
    var LongWithoutOverridesClass = Long;
    var Timestamp = class _Timestamp extends LongWithoutOverridesClass {
      get _bsontype() {
        return "Timestamp";
      }
      get i() {
        return this.low >>> 0;
      }
      get t() {
        return this.high >>> 0;
      }
      constructor(low) {
        if (low == null) {
          super(0, 0, true);
        } else if (typeof low === "bigint") {
          super(low, true);
        } else if (Long.isLong(low)) {
          super(low.low, low.high, true);
        } else if (typeof low === "object" && "t" in low && "i" in low) {
          if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
          }
          if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
          }
          const t = Number(low.t);
          const i = Number(low.i);
          if (t < 0 || Number.isNaN(t)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
          }
          if (i < 0 || Number.isNaN(i)) {
            throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
          }
          if (t > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
          }
          if (i > 4294967295) {
            throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
          }
          super(i, t, true);
        } else {
          throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
        }
      }
      toJSON() {
        return {
          $timestamp: this.toString()
        };
      }
      static fromInt(value) {
        return new _Timestamp(Long.fromInt(value, true));
      }
      static fromNumber(value) {
        return new _Timestamp(Long.fromNumber(value, true));
      }
      static fromBits(lowBits, highBits) {
        return new _Timestamp({ i: lowBits, t: highBits });
      }
      static fromString(str, optRadix) {
        return new _Timestamp(Long.fromString(str, true, optRadix));
      }
      toExtendedJSON() {
        return { $timestamp: { t: this.t, i: this.i } };
      }
      static fromExtendedJSON(doc) {
        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
        return new _Timestamp({ t, i });
      }
      inspect(depth, options, inspect2) {
        inspect2 ?? (inspect2 = defaultInspect);
        const t = inspect2(this.t, options);
        const i = inspect2(this.i, options);
        return `new Timestamp({ t: ${t}, i: ${i} })`;
      }
    };
    Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
    var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
    var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
    function internalDeserialize(buffer2, options, isArray2) {
      options = options == null ? {} : options;
      const index = options && options.index ? options.index : 0;
      const size = NumberUtils.getInt32LE(buffer2, index);
      if (size < 5) {
        throw new BSONError(`bson size must be >= 5, is ${size}`);
      }
      if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
        throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
      }
      if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
        throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
      }
      if (size + index > buffer2.byteLength) {
        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
      }
      if (buffer2[index + size - 1] !== 0) {
        throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer2, index, options, isArray2);
    }
    var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
    function deserializeObject(buffer2, index, options, isArray2 = false) {
      const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
      const raw = options["raw"] == null ? false : options["raw"];
      const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
      const promoteBuffers = options.promoteBuffers ?? false;
      const promoteLongs = options.promoteLongs ?? true;
      const promoteValues = options.promoteValues ?? true;
      const useBigInt64 = options.useBigInt64 ?? false;
      if (useBigInt64 && !promoteValues) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      if (useBigInt64 && !promoteLongs) {
        throw new BSONError("Must either request bigint or Long for int64 deserialization");
      }
      const validation = options.validation == null ? { utf8: true } : options.validation;
      let globalUTFValidation = true;
      let validationSetting;
      let utf8KeysSet;
      const utf8ValidatedKeys = validation.utf8;
      if (typeof utf8ValidatedKeys === "boolean") {
        validationSetting = utf8ValidatedKeys;
      } else {
        globalUTFValidation = false;
        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
          return utf8ValidatedKeys[key];
        });
        if (utf8ValidationValues.length === 0) {
          throw new BSONError("UTF-8 validation setting cannot be empty");
        }
        if (typeof utf8ValidationValues[0] !== "boolean") {
          throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
        }
        validationSetting = utf8ValidationValues[0];
        if (!utf8ValidationValues.every((item) => item === validationSetting)) {
          throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
        }
      }
      if (!globalUTFValidation) {
        utf8KeysSet = /* @__PURE__ */ new Set();
        for (const key of Object.keys(utf8ValidatedKeys)) {
          utf8KeysSet.add(key);
        }
      }
      const startIndex = index;
      if (buffer2.length < 5)
        throw new BSONError("corrupt bson message < 5 bytes long");
      const size = NumberUtils.getInt32LE(buffer2, index);
      index += 4;
      if (size < 5 || size > buffer2.length)
        throw new BSONError("corrupt bson message");
      const object = isArray2 ? [] : {};
      let arrayIndex = 0;
      let isPossibleDBRef = isArray2 ? false : null;
      while (true) {
        const elementType = buffer2[index++];
        if (elementType === 0)
          break;
        let i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.byteLength)
          throw new BSONError("Bad BSON Document: illegal CString");
        const name = isArray2 ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
        let shouldValidateKey = true;
        if (globalUTFValidation || utf8KeysSet?.has(name)) {
          shouldValidateKey = validationSetting;
        } else {
          shouldValidateKey = !validationSetting;
        }
        if (isPossibleDBRef !== false && name[0] === "$") {
          isPossibleDBRef = allowedDBRefKeys.test(name);
        }
        let value;
        index = i + 1;
        if (elementType === BSON_DATA_STRING) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_OID) {
          const oid = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oid[i2] = buffer2[index + i2];
          value = new ObjectId3(oid);
          index = index + 12;
        } else if (elementType === BSON_DATA_INT && promoteValues === false) {
          value = new Int32(NumberUtils.getInt32LE(buffer2, index));
          index += 4;
        } else if (elementType === BSON_DATA_INT) {
          value = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
        } else if (elementType === BSON_DATA_NUMBER) {
          value = NumberUtils.getFloat64LE(buffer2, index);
          index += 8;
          if (promoteValues === false)
            value = new Double(value);
        } else if (elementType === BSON_DATA_DATE) {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          value = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON_DATA_BOOLEAN) {
          if (buffer2[index] !== 0 && buffer2[index] !== 1)
            throw new BSONError("illegal boolean type value");
          value = buffer2[index++] === 1;
        } else if (elementType === BSON_DATA_OBJECT) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          if (objectSize <= 0 || objectSize > buffer2.length - index)
            throw new BSONError("bad embedded document length in bson");
          if (raw) {
            value = buffer2.subarray(index, index + objectSize);
          } else {
            let objectOptions = options;
            if (!globalUTFValidation) {
              objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
            }
            value = deserializeObject(buffer2, _index, objectOptions, false);
          }
          index = index + objectSize;
        } else if (elementType === BSON_DATA_ARRAY) {
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          let arrayOptions = options;
          const stopIndex = index + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name]) {
            arrayOptions = { ...options, raw: true };
          }
          if (!globalUTFValidation) {
            arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, arrayOptions, true);
          index = index + objectSize;
          if (buffer2[index - 1] !== 0)
            throw new BSONError("invalid array terminator byte");
          if (index !== stopIndex)
            throw new BSONError("corrupted array bson");
        } else if (elementType === BSON_DATA_UNDEFINED) {
          value = void 0;
        } else if (elementType === BSON_DATA_NULL) {
          value = null;
        } else if (elementType === BSON_DATA_LONG) {
          if (useBigInt64) {
            value = NumberUtils.getBigInt64LE(buffer2, index);
            index += 8;
          } else {
            const lowBits = NumberUtils.getInt32LE(buffer2, index);
            const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
            index += 8;
            const long = new Long(lowBits, highBits);
            if (promoteLongs && promoteValues === true) {
              value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
            } else {
              value = long;
            }
          }
        } else if (elementType === BSON_DATA_DECIMAL128) {
          const bytes = ByteUtils.allocateUnsafe(16);
          for (let i2 = 0; i2 < 16; i2++)
            bytes[i2] = buffer2[index + i2];
          index = index + 16;
          value = new Decimal128(bytes);
        } else if (elementType === BSON_DATA_BINARY) {
          let binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          const totalBinarySize = binarySize;
          const subType = buffer2[index++];
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found");
          if (binarySize > buffer2.byteLength)
            throw new BSONError("Binary type size larger than document size");
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = NumberUtils.getInt32LE(buffer2, index);
            index += 4;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          if (promoteBuffers && promoteValues) {
            value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
          } else {
            value = new Binary(buffer2.subarray(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
              value = value.toUUID();
            }
          }
          index = index + binarySize;
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          const optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          value = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const source = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          i = index;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new BSONError("Bad BSON Document: illegal CString");
          const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
          index = i + 1;
          value = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON_DATA_SYMBOL) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = promoteValues ? symbol : new BSONSymbol(symbol);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_TIMESTAMP) {
          value = new Timestamp({
            i: NumberUtils.getUint32LE(buffer2, index),
            t: NumberUtils.getUint32LE(buffer2, index + 4)
          });
          index += 8;
        } else if (elementType === BSON_DATA_MIN_KEY) {
          value = new MinKey();
        } else if (elementType === BSON_DATA_MAX_KEY) {
          value = new MaxKey();
        } else if (elementType === BSON_DATA_CODE) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          value = new Code(functionString);
          index = index + stringSize;
        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
          const totalSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new BSONError("code_w_scope total size shorter minimum expected length");
          }
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
            throw new BSONError("bad string length in bson");
          }
          const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const _index = index;
          const objectSize = NumberUtils.getInt32LE(buffer2, index);
          const scopeObject = deserializeObject(buffer2, _index, options, false);
          index = index + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new BSONError("code_w_scope total size is too long, clips outer document");
          }
          value = new Code(functionString, scopeObject);
        } else if (elementType === BSON_DATA_DBPOINTER) {
          const stringSize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
            throw new BSONError("bad string length in bson");
          const namespace2 = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
          index = index + stringSize;
          const oidBuffer = ByteUtils.allocateUnsafe(12);
          for (let i2 = 0; i2 < 12; i2++)
            oidBuffer[i2] = buffer2[index + i2];
          const oid = new ObjectId3(oidBuffer);
          index = index + 12;
          value = new DBRef(namespace2, oid);
        } else {
          throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
        }
        if (name === "__proto__") {
          Object.defineProperty(object, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          object[name] = value;
        }
      }
      if (size !== index - startIndex) {
        if (isArray2)
          throw new BSONError("corrupt array bson");
        throw new BSONError("corrupt object bson");
      }
      if (!isPossibleDBRef)
        return object;
      if (isDBRefLike(object)) {
        const copy = Object.assign({}, object);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(object.$ref, object.$id, object.$db, copy);
      }
      return object;
    }
    var regexp = /\x00/;
    var ignoreKeys = /* @__PURE__ */ new Set(["$db", "$ref", "$id", "$clusterTime"]);
    function serializeString(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_STRING;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes + 1;
      buffer2[index - 1] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
      NumberUtils.setInt32LE(buffer2, index, size + 1);
      index = index + 4 + size;
      buffer2[index++] = 0;
      return index;
    }
    function serializeNumber(buffer2, key, value, index) {
      const isNegativeZero = Object.is(value, -0);
      const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
      buffer2[index++] = type;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (type === BSON_DATA_INT) {
        index += NumberUtils.setInt32LE(buffer2, index, value);
      } else {
        index += NumberUtils.setFloat64LE(buffer2, index, value);
      }
      return index;
    }
    function serializeBigInt(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_LONG;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index += numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setBigInt64LE(buffer2, index, value);
      return index;
    }
    function serializeNull(buffer2, key, _, index) {
      buffer2[index++] = BSON_DATA_NULL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBoolean(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BOOLEAN;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      buffer2[index++] = value ? 1 : 0;
      return index;
    }
    function serializeDate(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DATE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const dateInMilis = Long.fromNumber(value.getTime());
      const lowBits = dateInMilis.getLowBits();
      const highBits = dateInMilis.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw new BSONError("value " + value.source + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
      buffer2[index++] = 0;
      if (value.ignoreCase)
        buffer2[index++] = 105;
      if (value.global)
        buffer2[index++] = 115;
      if (value.multiline)
        buffer2[index++] = 109;
      buffer2[index++] = 0;
      return index;
    }
    function serializeBSONRegExp(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_REGEXP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
      }
      index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
      buffer2[index++] = 0;
      const sortedOptions = value.options.split("").sort().join("");
      index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
      buffer2[index++] = 0;
      return index;
    }
    function serializeMinMax(buffer2, key, value, index) {
      if (value === null) {
        buffer2[index++] = BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer2[index++] = BSON_DATA_MIN_KEY;
      } else {
        buffer2[index++] = BSON_DATA_MAX_KEY;
      }
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      return index;
    }
    function serializeObjectId(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_OID;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += value.serializeInto(buffer2, index);
      return index;
    }
    function serializeBuffer(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = value.length;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = value[i];
      } else {
        buffer2.set(value, index);
      }
      index = index + size;
      return index;
    }
    function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4) {
      if (path4.has(value)) {
        throw new BSONError("Cannot convert circular structure to BSON");
      }
      path4.add(value);
      buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path4);
      path4.delete(value);
      return endIndex;
    }
    function serializeDecimal128(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_DECIMAL128;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      for (let i = 0; i < 16; i++)
        buffer2[index + i] = value.bytes[i];
      return index + 16;
    }
    function serializeLong(buffer2, key, value, index) {
      buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const lowBits = value.getLowBits();
      const highBits = value.getHighBits();
      index += NumberUtils.setInt32LE(buffer2, index, lowBits);
      index += NumberUtils.setInt32LE(buffer2, index, highBits);
      return index;
    }
    function serializeInt32(buffer2, key, value, index) {
      value = value.valueOf();
      buffer2[index++] = BSON_DATA_INT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setInt32LE(buffer2, index, value);
      return index;
    }
    function serializeDouble(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_NUMBER;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      index += NumberUtils.setFloat64LE(buffer2, index, value.value);
      return index;
    }
    function serializeFunction(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path4) {
      if (value.scope && typeof value.scope === "object") {
        buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        let startIndex = index;
        const functionString = value.code;
        index = index + 4;
        const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, codeSize);
        buffer2[index + 4 + codeSize - 1] = 0;
        index = index + codeSize + 4;
        const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path4);
        index = endIndex - 1;
        const totalSize = endIndex - startIndex;
        startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
        buffer2[index++] = 0;
      } else {
        buffer2[index++] = BSON_DATA_CODE;
        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
        index = index + numberOfWrittenBytes;
        buffer2[index++] = 0;
        const functionString = value.code.toString();
        const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
        NumberUtils.setInt32LE(buffer2, index, size);
        index = index + 4 + size - 1;
        buffer2[index++] = 0;
      }
      return index;
    }
    function serializeBinary(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_BINARY;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const data = value.buffer;
      let size = value.position;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
      buffer2[index++] = value.sub_type;
      if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        index += NumberUtils.setInt32LE(buffer2, index, size);
      }
      if (value.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(value);
      }
      if (size <= 16) {
        for (let i = 0; i < size; i++)
          buffer2[index + i] = data[i];
      } else {
        buffer2.set(data, index);
      }
      index = index + value.position;
      return index;
    }
    function serializeSymbol(buffer2, key, value, index) {
      buffer2[index++] = BSON_DATA_SYMBOL;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
      return index;
    }
    function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path4) {
      buffer2[index++] = BSON_DATA_OBJECT;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      let output = {
        $ref: value.collection || value.namespace,
        $id: value.oid
      };
      if (value.db != null) {
        output.$db = value.db;
      }
      output = Object.assign(output, value.fields);
      const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path4);
      const size = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, index, size);
      return endIndex;
    }
    function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path4) {
      if (path4 == null) {
        if (object == null) {
          buffer2[0] = 5;
          buffer2[1] = 0;
          buffer2[2] = 0;
          buffer2[3] = 0;
          buffer2[4] = 0;
          return 5;
        }
        if (Array.isArray(object)) {
          throw new BSONError("serialize does not support an array as the root input");
        }
        if (typeof object !== "object") {
          throw new BSONError("serialize does not support non-object as the root input");
        } else if ("_bsontype" in object && typeof object._bsontype === "string") {
          throw new BSONError(`BSON types cannot be serialized as a document`);
        } else if (isDate2(object) || isRegExp2(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
          throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
        }
        path4 = /* @__PURE__ */ new Set();
      }
      path4.add(object);
      let index = startingIndex + 4;
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; i++) {
          const key = `${i}`;
          let value = object[i];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (value === void 0) {
            index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate2(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp2(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path4);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else if (object instanceof Map || isMap(object)) {
        const iterator2 = object.entries();
        let done = false;
        while (!done) {
          const entry = iterator2.next();
          done = !!entry.done;
          if (done)
            continue;
          const key = entry.value ? entry.value[0] : void 0;
          let value = entry.value ? entry.value[1] : void 0;
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate2(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp2(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path4);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      } else {
        if (typeof object?.toBSON === "function") {
          object = object.toBSON();
          if (object != null && typeof object !== "object") {
            throw new BSONError("toBSON function did not return an object");
          }
        }
        for (const key of Object.keys(object)) {
          let value = object[key];
          if (typeof value?.toBSON === "function") {
            value = value.toBSON();
          }
          const type = typeof value;
          if (typeof key === "string" && !ignoreKeys.has(key)) {
            if (key.match(regexp) != null) {
              throw new BSONError("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if ("$" === key[0]) {
                throw new BSONError("key " + key + " must not start with '$'");
              } else if (key.includes(".")) {
                throw new BSONError("key " + key + " must not contain '.'");
              }
            }
          }
          if (value === void 0) {
            if (ignoreUndefined === false)
              index = serializeNull(buffer2, key, value, index);
          } else if (value === null) {
            index = serializeNull(buffer2, key, value, index);
          } else if (type === "string") {
            index = serializeString(buffer2, key, value, index);
          } else if (type === "number") {
            index = serializeNumber(buffer2, key, value, index);
          } else if (type === "bigint") {
            index = serializeBigInt(buffer2, key, value, index);
          } else if (type === "boolean") {
            index = serializeBoolean(buffer2, key, value, index);
          } else if (type === "object" && value._bsontype == null) {
            if (value instanceof Date || isDate2(value)) {
              index = serializeDate(buffer2, key, value, index);
            } else if (value instanceof Uint8Array || isUint8Array(value)) {
              index = serializeBuffer(buffer2, key, value, index);
            } else if (value instanceof RegExp || isRegExp2(value)) {
              index = serializeRegExp(buffer2, key, value, index);
            } else {
              index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            }
          } else if (type === "object") {
            if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
              throw new BSONVersionError();
            } else if (value._bsontype === "ObjectId") {
              index = serializeObjectId(buffer2, key, value, index);
            } else if (value._bsontype === "Decimal128") {
              index = serializeDecimal128(buffer2, key, value, index);
            } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
              index = serializeLong(buffer2, key, value, index);
            } else if (value._bsontype === "Double") {
              index = serializeDouble(buffer2, key, value, index);
            } else if (value._bsontype === "Code") {
              index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path4);
            } else if (value._bsontype === "Binary") {
              index = serializeBinary(buffer2, key, value, index);
            } else if (value._bsontype === "BSONSymbol") {
              index = serializeSymbol(buffer2, key, value, index);
            } else if (value._bsontype === "DBRef") {
              index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path4);
            } else if (value._bsontype === "BSONRegExp") {
              index = serializeBSONRegExp(buffer2, key, value, index);
            } else if (value._bsontype === "Int32") {
              index = serializeInt32(buffer2, key, value, index);
            } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
              index = serializeMinMax(buffer2, key, value, index);
            } else if (typeof value._bsontype !== "undefined") {
              throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
            }
          } else if (type === "function" && serializeFunctions) {
            index = serializeFunction(buffer2, key, value, index);
          }
        }
      }
      path4.delete(object);
      buffer2[index++] = 0;
      const size = index - startingIndex;
      startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
      return index;
    }
    function isBSONType(value) {
      return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
    }
    var keysToCodecs = {
      $oid: ObjectId3,
      $binary: Binary,
      $uuid: Binary,
      $symbol: BSONSymbol,
      $numberInt: Int32,
      $numberDecimal: Decimal128,
      $numberDouble: Double,
      $numberLong: Long,
      $minKey: MinKey,
      $maxKey: MaxKey,
      $regex: BSONRegExp,
      $regularExpression: BSONRegExp,
      $timestamp: Timestamp
    };
    function deserializeValue(value, options = {}) {
      if (typeof value === "number") {
        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
        if (options.relaxed || options.legacy) {
          return value;
        }
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (in32BitRange) {
            return new Int32(value);
          }
          if (in64BitRange) {
            if (options.useBigInt64) {
              return BigInt(value);
            }
            return Long.fromNumber(value);
          }
        }
        return new Double(value);
      }
      if (value == null || typeof value !== "object")
        return value;
      if (value.$undefined)
        return null;
      const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
      for (let i = 0; i < keys.length; i++) {
        const c = keysToCodecs[keys[i]];
        if (c)
          return c.fromExtendedJSON(value, options);
      }
      if (value.$date != null) {
        const d = value.$date;
        const date = /* @__PURE__ */ new Date();
        if (options.legacy) {
          if (typeof d === "number")
            date.setTime(d);
          else if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        } else {
          if (typeof d === "string")
            date.setTime(Date.parse(d));
          else if (Long.isLong(d))
            date.setTime(d.toNumber());
          else if (typeof d === "number" && options.relaxed)
            date.setTime(d);
          else if (typeof d === "bigint")
            date.setTime(Number(d));
          else
            throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
        }
        return date;
      }
      if (value.$code != null) {
        const copy = Object.assign({}, value);
        if (value.$scope) {
          copy.$scope = deserializeValue(value.$scope);
        }
        return Code.fromExtendedJSON(value);
      }
      if (isDBRefLike(value) || value.$dbPointer) {
        const v = value.$ref ? value : value.$dbPointer;
        if (v instanceof DBRef)
          return v;
        const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
        let valid = true;
        dollarKeys.forEach((k) => {
          if (["$ref", "$id", "$db"].indexOf(k) === -1)
            valid = false;
        });
        if (valid)
          return DBRef.fromExtendedJSON(v);
      }
      return value;
    }
    function serializeArray(array, options) {
      return array.map((v, index) => {
        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
        try {
          return serializeValue(v, options);
        } finally {
          options.seenObjects.pop();
        }
      });
    }
    function getISOString(date) {
      const isoStr = date.toISOString();
      return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
    }
    function serializeValue(value, options) {
      if (value instanceof Map || isMap(value)) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (const [k, v] of value) {
          if (typeof k !== "string") {
            throw new BSONError("Can only serialize maps with string keys");
          }
          obj[k] = v;
        }
        return serializeValue(obj, options);
      }
      if ((typeof value === "object" || typeof value === "function") && value !== null) {
        const index = options.seenObjects.findIndex((entry) => entry.obj === value);
        if (index !== -1) {
          const props = options.seenObjects.map((entry) => entry.propertyName);
          const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
          const alreadySeen = props[index];
          const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
          const current = props[props.length - 1];
          const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
          const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
          throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`);
        }
        options.seenObjects[options.seenObjects.length - 1].obj = value;
      }
      if (Array.isArray(value))
        return serializeArray(value, options);
      if (value === void 0)
        return null;
      if (value instanceof Date || isDate2(value)) {
        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 2534023188e5;
        if (options.legacy) {
          return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
        }
        return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
      }
      if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
        if (Number.isInteger(value) && !Object.is(value, -0)) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return { $numberInt: value.toString() };
          }
          if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
            return { $numberLong: value.toString() };
          }
        }
        return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
      }
      if (typeof value === "bigint") {
        if (!options.relaxed) {
          return { $numberLong: BigInt.asIntN(64, value).toString() };
        }
        return Number(BigInt.asIntN(64, value));
      }
      if (value instanceof RegExp || isRegExp2(value)) {
        let flags = value.flags;
        if (flags === void 0) {
          const match = value.toString().match(/[gimuy]*$/);
          if (match) {
            flags = match[0];
          }
        }
        const rx = new BSONRegExp(value.source, flags);
        return rx.toExtendedJSON(options);
      }
      if (value != null && typeof value === "object")
        return serializeDocument(value, options);
      return value;
    }
    var BSON_TYPE_MAPPINGS = {
      Binary: (o) => new Binary(o.value(), o.sub_type),
      Code: (o) => new Code(o.code, o.scope),
      DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
      Decimal128: (o) => new Decimal128(o.bytes),
      Double: (o) => new Double(o.value),
      Int32: (o) => new Int32(o.value),
      Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
      MaxKey: () => new MaxKey(),
      MinKey: () => new MinKey(),
      ObjectId: (o) => new ObjectId3(o),
      BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
      BSONSymbol: (o) => new BSONSymbol(o.value),
      Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
    };
    function serializeDocument(doc, options) {
      if (doc == null || typeof doc !== "object")
        throw new BSONError("not an object instance");
      const bsontype = doc._bsontype;
      if (typeof bsontype === "undefined") {
        const _doc = {};
        for (const name of Object.keys(doc)) {
          options.seenObjects.push({ propertyName: name, obj: null });
          try {
            const value = serializeValue(doc[name], options);
            if (name === "__proto__") {
              Object.defineProperty(_doc, name, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            } else {
              _doc[name] = value;
            }
          } finally {
            options.seenObjects.pop();
          }
        }
        return _doc;
      } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
        throw new BSONVersionError();
      } else if (isBSONType(doc)) {
        let outDoc = doc;
        if (typeof outDoc.toExtendedJSON !== "function") {
          const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
          if (!mapper) {
            throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
          }
          outDoc = mapper(outDoc);
        }
        if (bsontype === "Code" && outDoc.scope) {
          outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
        } else if (bsontype === "DBRef" && outDoc.oid) {
          outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
        }
        return outDoc.toExtendedJSON(options);
      } else {
        throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
      }
    }
    function parse5(text, options) {
      const ejsonOptions = {
        useBigInt64: options?.useBigInt64 ?? false,
        relaxed: options?.relaxed ?? true,
        legacy: options?.legacy ?? false
      };
      return JSON.parse(text, (key, value) => {
        if (key.indexOf("\0") !== -1) {
          throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
        }
        return deserializeValue(value, ejsonOptions);
      });
    }
    function stringify(value, replacer, space, options) {
      if (space != null && typeof space === "object") {
        options = space;
        space = 0;
      }
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        options = replacer;
        replacer = void 0;
        space = 0;
      }
      const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
        seenObjects: [{ propertyName: "(root)", obj: null }]
      });
      const doc = serializeValue(value, serializeOptions);
      return JSON.stringify(doc, replacer, space);
    }
    function EJSONserialize(value, options) {
      options = options || {};
      return JSON.parse(stringify(value, options));
    }
    function EJSONdeserialize(ejson, options) {
      options = options || {};
      return parse5(JSON.stringify(ejson), options);
    }
    var EJSON = /* @__PURE__ */ Object.create(null);
    EJSON.parse = parse5;
    EJSON.stringify = stringify;
    EJSON.serialize = EJSONserialize;
    EJSON.deserialize = EJSONdeserialize;
    Object.freeze(EJSON);
    function getSize(source, offset) {
      try {
        return NumberUtils.getNonnegativeInt32LE(source, offset);
      } catch (cause) {
        throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
      }
    }
    function findNull(bytes, offset) {
      let nullTerminatorOffset = offset;
      for (; bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
        ;
      if (nullTerminatorOffset === bytes.length - 1) {
        throw new BSONOffsetError("Null terminator not found", offset);
      }
      return nullTerminatorOffset;
    }
    function parseToElements(bytes, startOffset = 0) {
      startOffset ?? (startOffset = 0);
      if (bytes.length < 5) {
        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
      }
      const documentSize = getSize(bytes, startOffset);
      if (documentSize > bytes.length - startOffset) {
        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
      }
      if (bytes[startOffset + documentSize - 1] !== 0) {
        throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
      }
      const elements = [];
      let offset = startOffset + 4;
      while (offset <= documentSize + startOffset) {
        const type = bytes[offset];
        offset += 1;
        if (type === 0) {
          if (offset - startOffset !== documentSize) {
            throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
          }
          break;
        }
        const nameOffset = offset;
        const nameLength = findNull(bytes, offset) - nameOffset;
        offset += nameLength + 1;
        let length;
        if (type === 1 || type === 18 || type === 9 || type === 17) {
          length = 8;
        } else if (type === 16) {
          length = 4;
        } else if (type === 7) {
          length = 12;
        } else if (type === 19) {
          length = 16;
        } else if (type === 8) {
          length = 1;
        } else if (type === 10 || type === 6 || type === 127 || type === 255) {
          length = 0;
        } else if (type === 11) {
          length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
        } else if (type === 3 || type === 4 || type === 15) {
          length = getSize(bytes, offset);
        } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {
          length = getSize(bytes, offset) + 4;
          if (type === 5) {
            length += 1;
          }
          if (type === 12) {
            length += 12;
          }
        } else {
          throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
        }
        if (length > documentSize) {
          throw new BSONOffsetError("value reports length larger than document", offset);
        }
        elements.push([type, nameOffset, nameLength, offset, length]);
        offset += length;
      }
      return elements;
    }
    var onDemand = /* @__PURE__ */ Object.create(null);
    onDemand.parseToElements = parseToElements;
    onDemand.ByteUtils = ByteUtils;
    onDemand.NumberUtils = NumberUtils;
    Object.freeze(onDemand);
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer = ByteUtils.allocate(MAXSIZE);
    function setInternalBufferSize(size) {
      if (buffer.length < size) {
        buffer = ByteUtils.allocate(size);
      }
    }
    function serialize(object, options = {}) {
      const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
      if (buffer.length < minInternalBufferSize) {
        buffer = ByteUtils.allocate(minInternalBufferSize);
      }
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
      finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
      return finishedBuffer;
    }
    function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
      const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      const startIndex = typeof options.index === "number" ? options.index : 0;
      const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
      finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
      return startIndex + serializationIndex - 1;
    }
    function deserialize(buffer2, options = {}) {
      return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
    }
    function calculateObjectSize(object, options = {}) {
      options = options || {};
      const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
      return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
    }
    function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
      const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
      const bufferData = ByteUtils.toLocalBufferType(data);
      let index = startIndex;
      for (let i = 0; i < numberOfDocuments; i++) {
        const size = NumberUtils.getInt32LE(bufferData, index);
        internalOptions.index = index;
        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
        index = index + size;
      }
      return index;
    }
    var bson = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BSONError,
      BSONOffsetError,
      BSONRegExp,
      BSONRuntimeError,
      BSONSymbol,
      BSONType,
      BSONValue,
      BSONVersionError,
      Binary,
      Code,
      DBRef,
      Decimal128,
      Double,
      EJSON,
      Int32,
      Long,
      MaxKey,
      MinKey,
      ObjectId: ObjectId3,
      Timestamp,
      UUID,
      calculateObjectSize,
      deserialize,
      deserializeStream,
      onDemand,
      serialize,
      serializeWithBufferAndIndex,
      setInternalBufferSize
    });
    exports.BSON = bson;
    exports.BSONError = BSONError;
    exports.BSONOffsetError = BSONOffsetError;
    exports.BSONRegExp = BSONRegExp;
    exports.BSONRuntimeError = BSONRuntimeError;
    exports.BSONSymbol = BSONSymbol;
    exports.BSONType = BSONType;
    exports.BSONValue = BSONValue;
    exports.BSONVersionError = BSONVersionError;
    exports.Binary = Binary;
    exports.Code = Code;
    exports.DBRef = DBRef;
    exports.Decimal128 = Decimal128;
    exports.Double = Double;
    exports.EJSON = EJSON;
    exports.Int32 = Int32;
    exports.Long = Long;
    exports.MaxKey = MaxKey;
    exports.MinKey = MinKey;
    exports.ObjectId = ObjectId3;
    exports.Timestamp = Timestamp;
    exports.UUID = UUID;
    exports.calculateObjectSize = calculateObjectSize;
    exports.deserialize = deserialize;
    exports.deserializeStream = deserializeStream;
    exports.onDemand = onDemand;
    exports.serialize = serialize;
    exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
    exports.setInternalBufferSize = setInternalBufferSize;
  }
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS({
  "node_modules/mongodb/lib/bson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUTF8 = exports.getBigInt64LE = exports.getFloat64LE = exports.getInt32LE = exports.UUID = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSONError = exports.BSON = exports.Binary = void 0;
    exports.parseToElementsToArray = parseToElementsToArray;
    exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
    exports.resolveBSONOptions = resolveBSONOptions;
    exports.parseUtf8ValidationOption = parseUtf8ValidationOption;
    var bson_1 = require_bson();
    var bson_2 = require_bson();
    Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
      return bson_2.Binary;
    } });
    Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
      return bson_2.BSON;
    } });
    Object.defineProperty(exports, "BSONError", { enumerable: true, get: function() {
      return bson_2.BSONError;
    } });
    Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
      return bson_2.BSONRegExp;
    } });
    Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
      return bson_2.BSONSymbol;
    } });
    Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
      return bson_2.BSONType;
    } });
    Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function() {
      return bson_2.calculateObjectSize;
    } });
    Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
      return bson_2.Code;
    } });
    Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
      return bson_2.DBRef;
    } });
    Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
      return bson_2.Decimal128;
    } });
    Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
      return bson_2.deserialize;
    } });
    Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
      return bson_2.Double;
    } });
    Object.defineProperty(exports, "EJSON", { enumerable: true, get: function() {
      return bson_2.EJSON;
    } });
    Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
      return bson_2.Int32;
    } });
    Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
      return bson_2.Long;
    } });
    Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
      return bson_2.MaxKey;
    } });
    Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
      return bson_2.MinKey;
    } });
    Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
      return bson_2.ObjectId;
    } });
    Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
      return bson_2.serialize;
    } });
    Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
      return bson_2.Timestamp;
    } });
    Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
      return bson_2.UUID;
    } });
    function parseToElementsToArray(bytes, offset) {
      const res = bson_1.BSON.onDemand.parseToElements(bytes, offset);
      return Array.isArray(res) ? res : [...res];
    }
    exports.getInt32LE = bson_1.BSON.onDemand.NumberUtils.getInt32LE;
    exports.getFloat64LE = bson_1.BSON.onDemand.NumberUtils.getFloat64LE;
    exports.getBigInt64LE = bson_1.BSON.onDemand.NumberUtils.getBigInt64LE;
    exports.toUTF8 = bson_1.BSON.onDemand.ByteUtils.toUTF8;
    function pluckBSONSerializeOptions(options) {
      const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
      return {
        fieldsAsRaw,
        useBigInt64,
        promoteValues,
        promoteBuffers,
        promoteLongs,
        serializeFunctions,
        ignoreUndefined,
        bsonRegExp,
        raw,
        enableUtf8Validation
      };
    }
    function resolveBSONOptions(options, parent) {
      const parentOptions = parent?.bsonOptions;
      return {
        raw: options?.raw ?? parentOptions?.raw ?? false,
        useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
        promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
        promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
        promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
        ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
        bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
        serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
        fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
        enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
      };
    }
    function parseUtf8ValidationOption(options) {
      const enableUtf8Validation = options?.enableUtf8Validation;
      if (enableUtf8Validation === false) {
        return { utf8: false };
      }
      return { utf8: { writeErrors: false } };
    }
  }
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoOperationTimeoutError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteCursorError = exports.MongoClientBulkWriteError = exports.MongoGCPError = exports.MongoAzureError = exports.MongoOIDCError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoStalePrimaryError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = void 0;
    exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
    exports.isRetryableWriteError = isRetryableWriteError;
    exports.isRetryableReadError = isRetryableReadError;
    exports.isNodeShuttingDownError = isNodeShuttingDownError;
    exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
    exports.isNetworkTimeoutError = isNetworkTimeoutError;
    exports.isResumableError = isResumableError;
    exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
    exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
    exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
    exports.MONGODB_ERROR_CODES = Object.freeze({
      HostUnreachable: 6,
      HostNotFound: 7,
      AuthenticationFailed: 18,
      NetworkTimeout: 89,
      ShutdownInProgress: 91,
      PrimarySteppedDown: 189,
      ExceededTimeLimit: 262,
      SocketException: 9001,
      NotWritablePrimary: 10107,
      InterruptedAtShutdown: 11600,
      InterruptedDueToReplStateChange: 11602,
      NotPrimaryNoSecondaryOk: 13435,
      NotPrimaryOrSecondary: 13436,
      StaleShardVersion: 63,
      StaleEpoch: 150,
      StaleConfig: 13388,
      RetryChangeStream: 234,
      FailedToSatisfyReadPreference: 133,
      CursorNotFound: 43,
      LegacyNotPrimary: 10058,
      // WriteConcernTimeout is WriteConcernFailed on pre-8.1 servers
      WriteConcernTimeout: 64,
      NamespaceNotFound: 26,
      IllegalOperation: 20,
      MaxTimeMSExpired: 50,
      UnknownReplWriteConcern: 79,
      UnsatisfiableWriteConcern: 100,
      Reauthenticate: 391,
      ReadConcernMajorityNotAvailableYet: 134
    });
    exports.GET_MORE_RESUMABLE_CODES = /* @__PURE__ */ new Set([
      exports.MONGODB_ERROR_CODES.HostUnreachable,
      exports.MONGODB_ERROR_CODES.HostNotFound,
      exports.MONGODB_ERROR_CODES.NetworkTimeout,
      exports.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
      exports.MONGODB_ERROR_CODES.SocketException,
      exports.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
      exports.MONGODB_ERROR_CODES.StaleShardVersion,
      exports.MONGODB_ERROR_CODES.StaleEpoch,
      exports.MONGODB_ERROR_CODES.StaleConfig,
      exports.MONGODB_ERROR_CODES.RetryChangeStream,
      exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
      exports.MONGODB_ERROR_CODES.CursorNotFound
    ]);
    exports.MongoErrorLabel = Object.freeze({
      RetryableWriteError: "RetryableWriteError",
      TransientTransactionError: "TransientTransactionError",
      UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
      ResumableChangeStreamError: "ResumableChangeStreamError",
      HandshakeError: "HandshakeError",
      ResetPool: "ResetPool",
      PoolRequstedRetry: "PoolRequstedRetry",
      InterruptInUseConnections: "InterruptInUseConnections",
      NoWritesPerformed: "NoWritesPerformed"
    });
    function isAggregateError(e) {
      return e != null && typeof e === "object" && "errors" in e && Array.isArray(e.errors);
    }
    var MongoError = class extends Error {
      get errorLabels() {
        return Array.from(this.errorLabelSet);
      }
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
        this.errorLabelSet = /* @__PURE__ */ new Set();
      }
      /** @internal */
      static buildErrorMessage(e) {
        if (typeof e === "string") {
          return e;
        }
        if (isAggregateError(e) && e.message.length === 0) {
          return e.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e.errors.map(({ message }) => message).join(", ");
        }
        return e != null && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : "empty error message";
      }
      get name() {
        return "MongoError";
      }
      /** Legacy name for server error responses */
      get errmsg() {
        return this.message;
      }
      /**
       * Checks the error to see if it has an error label
       *
       * @param label - The error label to check for
       * @returns returns true if the error has the provided error label
       */
      hasErrorLabel(label) {
        return this.errorLabelSet.has(label);
      }
      addErrorLabel(label) {
        this.errorLabelSet.add(label);
      }
    };
    exports.MongoError = MongoError;
    var MongoServerError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message.message || message.errmsg || message.$err || "n/a");
        if (message.errorLabels) {
          for (const label of message.errorLabels)
            this.addErrorLabel(label);
        }
        this.errorResponse = message;
        for (const name in message) {
          if (name !== "errorLabels" && name !== "errmsg" && name !== "message" && name !== "errorResponse") {
            this[name] = message[name];
          }
        }
      }
      get name() {
        return "MongoServerError";
      }
    };
    exports.MongoServerError = MongoServerError;
    var MongoDriverError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoDriverError";
      }
    };
    exports.MongoDriverError = MongoDriverError;
    var MongoAPIError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoAPIError";
      }
    };
    exports.MongoAPIError = MongoAPIError;
    var MongoRuntimeError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoRuntimeError";
      }
    };
    exports.MongoRuntimeError = MongoRuntimeError;
    var MongoStalePrimaryError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoStalePrimaryError";
      }
    };
    exports.MongoStalePrimaryError = MongoStalePrimaryError;
    var MongoBatchReExecutionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "This batch has already been executed, create new batch to execute") {
        super(message);
      }
      get name() {
        return "MongoBatchReExecutionError";
      }
    };
    exports.MongoBatchReExecutionError = MongoBatchReExecutionError;
    var MongoDecompressionError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoDecompressionError";
      }
    };
    exports.MongoDecompressionError = MongoDecompressionError;
    var MongoNotConnectedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoNotConnectedError";
      }
    };
    exports.MongoNotConnectedError = MongoNotConnectedError;
    var MongoTransactionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoTransactionError";
      }
    };
    exports.MongoTransactionError = MongoTransactionError;
    var MongoExpiredSessionError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Cannot use a session that has ended") {
        super(message);
      }
      get name() {
        return "MongoExpiredSessionError";
      }
    };
    exports.MongoExpiredSessionError = MongoExpiredSessionError;
    var MongoKerberosError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoKerberosError";
      }
    };
    exports.MongoKerberosError = MongoKerberosError;
    var MongoAWSError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoAWSError";
      }
    };
    exports.MongoAWSError = MongoAWSError;
    var MongoOIDCError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoOIDCError";
      }
    };
    exports.MongoOIDCError = MongoOIDCError;
    var MongoAzureError = class extends MongoOIDCError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoAzureError";
      }
    };
    exports.MongoAzureError = MongoAzureError;
    var MongoGCPError = class extends MongoOIDCError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGCPError";
      }
    };
    exports.MongoGCPError = MongoGCPError;
    var MongoClientBulkWriteError = class extends MongoServerError {
      /**
       * Initialize the client bulk write error.
       * @param message - The error message.
       */
      constructor(message) {
        super(message);
        this.writeConcernErrors = [];
        this.writeErrors = /* @__PURE__ */ new Map();
      }
      get name() {
        return "MongoClientBulkWriteError";
      }
    };
    exports.MongoClientBulkWriteError = MongoClientBulkWriteError;
    var MongoClientBulkWriteCursorError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoClientBulkWriteCursorError";
      }
    };
    exports.MongoClientBulkWriteCursorError = MongoClientBulkWriteCursorError;
    var MongoClientBulkWriteExecutionError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoClientBulkWriteExecutionError";
      }
    };
    exports.MongoClientBulkWriteExecutionError = MongoClientBulkWriteExecutionError;
    var MongoChangeStreamError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoChangeStreamError";
      }
    };
    exports.MongoChangeStreamError = MongoChangeStreamError;
    var MongoTailableCursorError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Tailable cursor does not support this operation") {
        super(message);
      }
      get name() {
        return "MongoTailableCursorError";
      }
    };
    exports.MongoTailableCursorError = MongoTailableCursorError;
    var MongoGridFSStreamError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSStreamError";
      }
    };
    exports.MongoGridFSStreamError = MongoGridFSStreamError;
    var MongoGridFSChunkError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoGridFSChunkError";
      }
    };
    exports.MongoGridFSChunkError = MongoGridFSChunkError;
    var MongoUnexpectedServerResponseError = class extends MongoRuntimeError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoUnexpectedServerResponseError";
      }
    };
    exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;
    var MongoOperationTimeoutError = class extends MongoDriverError {
      get name() {
        return "MongoOperationTimeoutError";
      }
    };
    exports.MongoOperationTimeoutError = MongoOperationTimeoutError;
    var MongoCursorInUseError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Cursor is already initialized") {
        super(message);
      }
      get name() {
        return "MongoCursorInUseError";
      }
    };
    exports.MongoCursorInUseError = MongoCursorInUseError;
    var MongoServerClosedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Server is closed") {
        super(message);
      }
      get name() {
        return "MongoServerClosedError";
      }
    };
    exports.MongoServerClosedError = MongoServerClosedError;
    var MongoCursorExhaustedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message || "Cursor is exhausted");
      }
      get name() {
        return "MongoCursorExhaustedError";
      }
    };
    exports.MongoCursorExhaustedError = MongoCursorExhaustedError;
    var MongoTopologyClosedError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message = "Topology is closed") {
        super(message);
      }
      get name() {
        return "MongoTopologyClosedError";
      }
    };
    exports.MongoTopologyClosedError = MongoTopologyClosedError;
    var MongoNetworkError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, { cause: options?.cause });
        this.beforeHandshake = !!options?.beforeHandshake;
      }
      get name() {
        return "MongoNetworkError";
      }
    };
    exports.MongoNetworkError = MongoNetworkError;
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoNetworkTimeoutError";
      }
    };
    exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
    var MongoParseError = class extends MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoParseError";
      }
    };
    exports.MongoParseError = MongoParseError;
    var MongoInvalidArgumentError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
      }
      get name() {
        return "MongoInvalidArgumentError";
      }
    };
    exports.MongoInvalidArgumentError = MongoInvalidArgumentError;
    var MongoCompatibilityError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoCompatibilityError";
      }
    };
    exports.MongoCompatibilityError = MongoCompatibilityError;
    var MongoMissingCredentialsError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoMissingCredentialsError";
      }
    };
    exports.MongoMissingCredentialsError = MongoMissingCredentialsError;
    var MongoMissingDependencyError = class extends MongoAPIError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options) {
        super(message, options);
        this.dependencyName = options.dependencyName;
      }
      get name() {
        return "MongoMissingDependencyError";
      }
    };
    exports.MongoMissingDependencyError = MongoMissingDependencyError;
    var MongoSystemError = class extends MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, reason) {
        if (reason && reason.error) {
          super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
            cause: reason.error
          });
        } else {
          super(message);
        }
        if (reason) {
          this.reason = reason;
        }
        this.code = reason.error?.code;
      }
      get name() {
        return "MongoSystemError";
      }
    };
    exports.MongoSystemError = MongoSystemError;
    var MongoServerSelectionError = class extends MongoSystemError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, reason) {
        super(message, reason);
      }
      get name() {
        return "MongoServerSelectionError";
      }
    };
    exports.MongoServerSelectionError = MongoServerSelectionError;
    var MongoWriteConcernError = class extends MongoServerError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(result) {
        super({ ...result.writeConcernError, ...result });
        this.errInfo = result.writeConcernError.errInfo;
        this.result = result;
      }
      get name() {
        return "MongoWriteConcernError";
      }
    };
    exports.MongoWriteConcernError = MongoWriteConcernError;
    var RETRYABLE_READ_ERROR_CODES = /* @__PURE__ */ new Set([
      exports.MONGODB_ERROR_CODES.HostUnreachable,
      exports.MONGODB_ERROR_CODES.HostNotFound,
      exports.MONGODB_ERROR_CODES.NetworkTimeout,
      exports.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports.MONGODB_ERROR_CODES.SocketException,
      exports.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
      exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
      exports.MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;
    function needsRetryableWriteLabel(error2, maxWireVersion, serverType) {
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      if (error2 instanceof MongoError) {
        if ((maxWireVersion >= 9 || isRetryableWriteError(error2)) && !error2.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
          return false;
        }
      }
      if (error2 instanceof MongoWriteConcernError) {
        if (serverType === "Mongos" && maxWireVersion < 9) {
          return RETRYABLE_WRITE_ERROR_CODES.has(error2.result.code ?? 0);
        }
        const code = error2.result.writeConcernError.code ?? Number(error2.code);
        return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
      }
      if (error2 instanceof MongoError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(Number(error2.code));
      }
      const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error2.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error2.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    function isRetryableWriteError(error2) {
      return error2.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError) || error2.hasErrorLabel(exports.MongoErrorLabel.PoolRequstedRetry);
    }
    function isRetryableReadError(error2) {
      const hasRetryableErrorCode = typeof error2.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error2.code) : false;
      if (hasRetryableErrorCode) {
        return true;
      }
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error2.message);
      if (isNotWritablePrimaryError2) {
        return true;
      }
      const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error2.message);
      if (isNodeIsRecoveringError) {
        return true;
      }
      return false;
    }
    var SDAM_RECOVERING_CODES = /* @__PURE__ */ new Set([
      exports.MONGODB_ERROR_CODES.ShutdownInProgress,
      exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
      exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
      exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
    ]);
    var SDAM_NOT_PRIMARY_CODES = /* @__PURE__ */ new Set([
      exports.MONGODB_ERROR_CODES.NotWritablePrimary,
      exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
      exports.MONGODB_ERROR_CODES.LegacyNotPrimary
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = /* @__PURE__ */ new Set([
      exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
      exports.MONGODB_ERROR_CODES.ShutdownInProgress
    ]);
    function isRecoveringError(err) {
      if (typeof err.code === "number") {
        return SDAM_RECOVERING_CODES.has(err.code);
      }
      return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
    }
    function isNotWritablePrimaryError(err) {
      if (typeof err.code === "number") {
        return SDAM_NOT_PRIMARY_CODES.has(err.code);
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
    }
    function isNodeShuttingDownError(err) {
      return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
    }
    function isSDAMUnrecoverableError(error2) {
      if (error2 instanceof MongoParseError || error2 == null) {
        return true;
      }
      return isRecoveringError(error2) || isNotWritablePrimaryError(error2);
    }
    function isNetworkTimeoutError(err) {
      return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
    }
    function isResumableError(error2, wireVersion) {
      if (error2 == null || !(error2 instanceof MongoError)) {
        return false;
      }
      if (error2 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion != null && wireVersion >= 9) {
        if (error2.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
          return true;
        }
        return error2.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
      }
      if (typeof error2.code === "number") {
        return exports.GET_MORE_RESUMABLE_CODES.has(error2.code);
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/read_preference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadPreference = exports.ReadPreferenceMode = void 0;
    var error_1 = require_error();
    exports.ReadPreferenceMode = Object.freeze({
      primary: "primary",
      primaryPreferred: "primaryPreferred",
      secondary: "secondary",
      secondaryPreferred: "secondaryPreferred",
      nearest: "nearest"
    });
    var ReadPreference = class _ReadPreference {
      /**
       * @param mode - A string describing the read preference mode (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
       * @param tags - A tag set used to target reads to members with the specified tag(s). tagSet is not available if using read preference mode primary.
       * @param options - Additional read preference options
       */
      constructor(mode, tags, options) {
        if (!_ReadPreference.isValid(mode)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
        }
        if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
          options = tags;
          tags = void 0;
        } else if (tags && !Array.isArray(tags)) {
          throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
        }
        this.mode = mode;
        this.tags = tags;
        this.hedge = options?.hedge;
        this.maxStalenessSeconds = void 0;
        this.minWireVersion = void 0;
        options = options ?? {};
        if (options.maxStalenessSeconds != null) {
          if (options.maxStalenessSeconds <= 0) {
            throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
          }
          this.maxStalenessSeconds = options.maxStalenessSeconds;
          this.minWireVersion = 5;
        }
        if (this.mode === _ReadPreference.PRIMARY) {
          if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
          }
          if (this.maxStalenessSeconds) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
          }
          if (this.hedge) {
            throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
          }
        }
      }
      // Support the deprecated `preference` property introduced in the porcelain layer
      get preference() {
        return this.mode;
      }
      static fromString(mode) {
        return new _ReadPreference(mode);
      }
      /**
       * Construct a ReadPreference given an options object.
       *
       * @param options - The options object from which to extract the read preference.
       */
      static fromOptions(options) {
        if (!options)
          return;
        const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
        const readPreferenceTags = options.readPreferenceTags;
        if (readPreference == null) {
          return;
        }
        if (typeof readPreference === "string") {
          return new _ReadPreference(readPreference, readPreferenceTags, {
            maxStalenessSeconds: options.maxStalenessSeconds,
            hedge: options.hedge
          });
        } else if (!(readPreference instanceof _ReadPreference) && typeof readPreference === "object") {
          const mode = readPreference.mode || readPreference.preference;
          if (mode && typeof mode === "string") {
            return new _ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
              maxStalenessSeconds: readPreference.maxStalenessSeconds,
              hedge: options.hedge
            });
          }
        }
        if (readPreferenceTags) {
          readPreference.tags = readPreferenceTags;
        }
        return readPreference;
      }
      /**
       * Replaces options.readPreference with a ReadPreference instance
       */
      static translate(options) {
        if (options.readPreference == null)
          return options;
        const r = options.readPreference;
        if (typeof r === "string") {
          options.readPreference = new _ReadPreference(r);
        } else if (r && !(r instanceof _ReadPreference) && typeof r === "object") {
          const mode = r.mode || r.preference;
          if (mode && typeof mode === "string") {
            options.readPreference = new _ReadPreference(mode, r.tags, {
              maxStalenessSeconds: r.maxStalenessSeconds
            });
          }
        } else if (!(r instanceof _ReadPreference)) {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
        }
        return options;
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      static isValid(mode) {
        const VALID_MODES = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY,
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST,
          null
        ]);
        return VALID_MODES.has(mode);
      }
      /**
       * Validate if a mode is legal
       *
       * @param mode - The string representing the read preference mode.
       */
      isValid(mode) {
        return _ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
      }
      /**
       * Indicates that this readPreference needs the "SecondaryOk" bit when sent over the wire
       * @see https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#op-query
       */
      secondaryOk() {
        const NEEDS_SECONDARYOK = /* @__PURE__ */ new Set([
          _ReadPreference.PRIMARY_PREFERRED,
          _ReadPreference.SECONDARY,
          _ReadPreference.SECONDARY_PREFERRED,
          _ReadPreference.NEAREST
        ]);
        return NEEDS_SECONDARYOK.has(this.mode);
      }
      /**
       * Check if the two ReadPreferences are equivalent
       *
       * @param readPreference - The read preference with which to check equality
       */
      equals(readPreference) {
        return readPreference.mode === this.mode;
      }
      /** Return JSON representation */
      toJSON() {
        const readPreference = { mode: this.mode };
        if (Array.isArray(this.tags))
          readPreference.tags = this.tags;
        if (this.maxStalenessSeconds)
          readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
        if (this.hedge)
          readPreference.hedge = this.hedge;
        return readPreference;
      }
    };
    exports.ReadPreference = ReadPreference;
    ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
    ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
    ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
    ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
    ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
    ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
    ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
    ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
    ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
    ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
  }
});

// node_modules/mongodb/lib/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/sdam/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = void 0;
    exports._advanceClusterTime = _advanceClusterTime;
    exports.STATE_CLOSING = "closing";
    exports.STATE_CLOSED = "closed";
    exports.STATE_CONNECTING = "connecting";
    exports.STATE_CONNECTED = "connected";
    exports.TopologyType = Object.freeze({
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown",
      LoadBalanced: "LoadBalanced"
    });
    exports.ServerType = Object.freeze({
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown",
      LoadBalancer: "LoadBalancer"
    });
    function _advanceClusterTime(entity, $clusterTime) {
      if (entity.clusterTime == null) {
        entity.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
          entity.clusterTime = $clusterTime;
        }
      }
    }
  }
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/sdam/server_selection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;
    exports.writableServerSelector = writableServerSelector;
    exports.sameServerSelector = sameServerSelector;
    exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
    exports.readPreferenceServerSelector = readPreferenceServerSelector;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
    function writableServerSelector() {
      return function writableServer(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
      };
    }
    function sameServerSelector(description) {
      return function sameServerSelector2(topologyDescription, servers) {
        if (!description)
          return [];
        return servers.filter((sd) => {
          return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
        });
      };
    }
    function secondaryWritableServerSelector(wireVersion, readPreference) {
      if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
      }
      return readPreferenceServerSelector(readPreference);
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server2) => {
          const stalenessMS = server2.lastUpdateTime - server2.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server2);
          }
          return result;
        }, []);
      }
      if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
        return servers.reduce((result, server2) => {
          const stalenessMS = sMax.lastWriteDate - server2.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
          if (staleness <= maxStalenessSeconds) {
            result.push(server2);
          }
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server2) => {
          if (tagSetMatch(tagSet, server2.tags))
            matched.push(server2);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server2) => Math.min(server2.roundTripTime, min), Infinity);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server2) => {
        if (server2.roundTripTime <= high && server2.roundTripTime >= low)
          result.push(server2);
        return result;
      }, []);
    }
    function primaryFilter(server2) {
      return server2.type === common_1.ServerType.RSPrimary;
    }
    function secondaryFilter(server2) {
      return server2.type === common_1.ServerType.RSSecondary;
    }
    function nearestFilter(server2) {
      return server2.type === common_1.ServerType.RSSecondary || server2.type === common_1.ServerType.RSPrimary;
    }
    function knownFilter(server2) {
      return server2.type !== common_1.ServerType.Unknown;
    }
    function loadBalancerFilter(server2) {
      return server2.type === common_1.ServerType.LoadBalancer;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
      }
      return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
          return servers.filter(loadBalancerFilter);
        }
        if (topologyDescription.type === common_1.TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === common_1.TopologyType.Single) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        if (topologyDescription.type === common_1.TopologyType.Sharded) {
          const filtered = servers.filter((server2) => {
            return !deprioritized.includes(server2);
          });
          const selectable = filtered.length > 0 ? filtered : deprioritized;
          return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === read_preference_1.ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter2 = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter2))));
        if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = void 0;
    exports.MIN_SUPPORTED_SERVER_VERSION = "4.0";
    exports.MAX_SUPPORTED_SERVER_VERSION = "8.0";
    exports.MIN_SUPPORTED_WIRE_VERSION = 7;
    exports.MAX_SUPPORTED_WIRE_VERSION = 25;
    exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
    exports.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
    exports.OP_REPLY = 1;
    exports.OP_UPDATE = 2001;
    exports.OP_INSERT = 2002;
    exports.OP_QUERY = 2004;
    exports.OP_DELETE = 2006;
    exports.OP_COMPRESSED = 2012;
    exports.OP_MSG = 2013;
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.WAITING_FOR_SUITABLE_SERVER = exports.SERVER_SELECTION_SUCCEEDED = exports.SERVER_SELECTION_FAILED = exports.SERVER_SELECTION_STARTED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = void 0;
    exports.kDecoratedKeys = exports.kDecorateResult = exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = void 0;
    exports.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
    exports.SYSTEM_INDEX_COLLECTION = "system.indexes";
    exports.SYSTEM_PROFILE_COLLECTION = "system.profile";
    exports.SYSTEM_USER_COLLECTION = "system.users";
    exports.SYSTEM_COMMAND_COLLECTION = "$cmd";
    exports.SYSTEM_JS_COLLECTION = "system.js";
    exports.ERROR = "error";
    exports.TIMEOUT = "timeout";
    exports.CLOSE = "close";
    exports.OPEN = "open";
    exports.CONNECT = "connect";
    exports.CLOSED = "closed";
    exports.ENDED = "ended";
    exports.MESSAGE = "message";
    exports.PINNED = "pinned";
    exports.UNPINNED = "unpinned";
    exports.DESCRIPTION_RECEIVED = "descriptionReceived";
    exports.SERVER_OPENING = "serverOpening";
    exports.SERVER_CLOSED = "serverClosed";
    exports.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
    exports.TOPOLOGY_OPENING = "topologyOpening";
    exports.TOPOLOGY_CLOSED = "topologyClosed";
    exports.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
    exports.SERVER_SELECTION_STARTED = "serverSelectionStarted";
    exports.SERVER_SELECTION_FAILED = "serverSelectionFailed";
    exports.SERVER_SELECTION_SUCCEEDED = "serverSelectionSucceeded";
    exports.WAITING_FOR_SUITABLE_SERVER = "waitingForSuitableServer";
    exports.CONNECTION_POOL_CREATED = "connectionPoolCreated";
    exports.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
    exports.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
    exports.CONNECTION_POOL_READY = "connectionPoolReady";
    exports.CONNECTION_CREATED = "connectionCreated";
    exports.CONNECTION_READY = "connectionReady";
    exports.CONNECTION_CLOSED = "connectionClosed";
    exports.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
    exports.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
    exports.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
    exports.CONNECTION_CHECKED_IN = "connectionCheckedIn";
    exports.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
    exports.COMMAND_STARTED = "commandStarted";
    exports.COMMAND_SUCCEEDED = "commandSucceeded";
    exports.COMMAND_FAILED = "commandFailed";
    exports.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
    exports.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
    exports.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
    exports.RESPONSE = "response";
    exports.MORE = "more";
    exports.INIT = "init";
    exports.CHANGE = "change";
    exports.END = "end";
    exports.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
    exports.HEARTBEAT_EVENTS = Object.freeze([
      exports.SERVER_HEARTBEAT_STARTED,
      exports.SERVER_HEARTBEAT_SUCCEEDED,
      exports.SERVER_HEARTBEAT_FAILED
    ]);
    exports.CMAP_EVENTS = Object.freeze([
      exports.CONNECTION_POOL_CREATED,
      exports.CONNECTION_POOL_READY,
      exports.CONNECTION_POOL_CLEARED,
      exports.CONNECTION_POOL_CLOSED,
      exports.CONNECTION_CREATED,
      exports.CONNECTION_READY,
      exports.CONNECTION_CLOSED,
      exports.CONNECTION_CHECK_OUT_STARTED,
      exports.CONNECTION_CHECK_OUT_FAILED,
      exports.CONNECTION_CHECKED_OUT,
      exports.CONNECTION_CHECKED_IN
    ]);
    exports.TOPOLOGY_EVENTS = Object.freeze([
      exports.SERVER_OPENING,
      exports.SERVER_CLOSED,
      exports.SERVER_DESCRIPTION_CHANGED,
      exports.TOPOLOGY_OPENING,
      exports.TOPOLOGY_CLOSED,
      exports.TOPOLOGY_DESCRIPTION_CHANGED,
      exports.ERROR,
      exports.TIMEOUT,
      exports.CLOSE
    ]);
    exports.APM_EVENTS = Object.freeze([
      exports.COMMAND_STARTED,
      exports.COMMAND_SUCCEEDED,
      exports.COMMAND_FAILED
    ]);
    exports.SERVER_RELAY_EVENTS = Object.freeze([
      exports.SERVER_HEARTBEAT_STARTED,
      exports.SERVER_HEARTBEAT_SUCCEEDED,
      exports.SERVER_HEARTBEAT_FAILED,
      exports.COMMAND_STARTED,
      exports.COMMAND_SUCCEEDED,
      exports.COMMAND_FAILED,
      ...exports.CMAP_EVENTS
    ]);
    exports.LOCAL_SERVER_EVENTS = Object.freeze([
      exports.CONNECT,
      exports.DESCRIPTION_RECEIVED,
      exports.CLOSED,
      exports.ENDED
    ]);
    exports.MONGO_CLIENT_EVENTS = Object.freeze([
      ...exports.CMAP_EVENTS,
      ...exports.APM_EVENTS,
      ...exports.TOPOLOGY_EVENTS,
      ...exports.HEARTBEAT_EVENTS
    ]);
    exports.LEGACY_HELLO_COMMAND = "ismaster";
    exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
    exports.kDecorateResult = Symbol.for("@@mdb.decorateDecryptionResult");
    exports.kDecoratedKeys = Symbol.for("@@mdb.decryptedKeys");
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadConcern = exports.ReadConcernLevel = void 0;
    exports.ReadConcernLevel = Object.freeze({
      local: "local",
      majority: "majority",
      linearizable: "linearizable",
      available: "available",
      snapshot: "snapshot"
    });
    var ReadConcern = class _ReadConcern {
      /** Constructs a ReadConcern from the read concern level.*/
      constructor(level2) {
        this.level = exports.ReadConcernLevel[level2] ?? level2;
      }
      /**
       * Construct a ReadConcern given an options object.
       *
       * @param options - The options object from which to extract the write concern.
       */
      static fromOptions(options) {
        if (options == null) {
          return;
        }
        if (options.readConcern) {
          const { readConcern } = options;
          if (readConcern instanceof _ReadConcern) {
            return readConcern;
          } else if (typeof readConcern === "string") {
            return new _ReadConcern(readConcern);
          } else if ("level" in readConcern && readConcern.level) {
            return new _ReadConcern(readConcern.level);
          }
        }
        if (options.level) {
          return new _ReadConcern(options.level);
        }
        return;
      }
      static get MAJORITY() {
        return exports.ReadConcernLevel.majority;
      }
      static get AVAILABLE() {
        return exports.ReadConcernLevel.available;
      }
      static get LINEARIZABLE() {
        return exports.ReadConcernLevel.linearizable;
      }
      static get SNAPSHOT() {
        return exports.ReadConcernLevel.snapshot;
      }
      toJSON() {
        return { level: this.level };
      }
    };
    exports.ReadConcern = ReadConcern;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js
var require_document = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OnDemandDocument = void 0;
    var bson_1 = require_bson2();
    var OnDemandDocument = class _OnDemandDocument {
      constructor(bson, offset = 0, isArray2 = false, elements) {
        this.bson = bson;
        this.offset = offset;
        this.isArray = isArray2;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.indexFound = /* @__PURE__ */ Object.create(null);
        this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);
      }
      /** Only supports basic latin strings */
      isElementName(name, element) {
        const nameLength = element[
          2
          /* BSONElementOffset.nameLength */
        ];
        const nameOffset = element[
          1
          /* BSONElementOffset.nameOffset */
        ];
        if (name.length !== nameLength)
          return false;
        const nameEnd = nameOffset + nameLength;
        for (let byteIndex = nameOffset, charIndex = 0; charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
          if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
            return false;
        }
        return true;
      }
      /**
       * Seeks into the elements array for an element matching the given name.
       *
       * @remarks
       * Caching:
       * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately
       * - Caches names mapped to elements to avoid reiterating the array and comparing the name again
       * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name
       *
       * @param name - a basic latin string name of a BSON element
       * @returns
       */
      getElement(name) {
        const cachedElement = this.cache[name];
        if (cachedElement === false)
          return null;
        if (cachedElement != null) {
          return cachedElement;
        }
        if (typeof name === "number") {
          if (this.isArray) {
            if (name < this.elements.length) {
              const element = this.elements[name];
              const cachedElement2 = { element, value: void 0 };
              this.cache[name] = cachedElement2;
              this.indexFound[name] = true;
              return cachedElement2;
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (!(index in this.indexFound) && this.isElementName(name, element)) {
            const cachedElement2 = { element, value: void 0 };
            this.cache[name] = cachedElement2;
            this.indexFound[index] = true;
            return cachedElement2;
          }
        }
        this.cache[name] = false;
        return null;
      }
      toJSValue(element, as) {
        const type = element[
          0
          /* BSONElementOffset.type */
        ];
        const offset = element[
          3
          /* BSONElementOffset.offset */
        ];
        const length = element[
          4
          /* BSONElementOffset.length */
        ];
        if (as !== type) {
          return null;
        }
        switch (as) {
          case bson_1.BSONType.null:
          case bson_1.BSONType.undefined:
            return null;
          case bson_1.BSONType.double:
            return (0, bson_1.getFloat64LE)(this.bson, offset);
          case bson_1.BSONType.int:
            return (0, bson_1.getInt32LE)(this.bson, offset);
          case bson_1.BSONType.long:
            return (0, bson_1.getBigInt64LE)(this.bson, offset);
          case bson_1.BSONType.bool:
            return Boolean(this.bson[offset]);
          case bson_1.BSONType.objectId:
            return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
          case bson_1.BSONType.timestamp:
            return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));
          case bson_1.BSONType.string:
            return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);
          case bson_1.BSONType.binData: {
            const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);
            const subType = this.bson[offset + 4];
            if (subType === 2) {
              const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);
              if (subType2BinarySize < 0)
                throw new bson_1.BSONError("Negative binary type element size found for subtype 0x02");
              if (subType2BinarySize > totalBinarySize - 4)
                throw new bson_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
              if (subType2BinarySize < totalBinarySize - 4)
                throw new bson_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
              return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
            }
            return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
          }
          case bson_1.BSONType.date:
            return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));
          case bson_1.BSONType.object:
            return new _OnDemandDocument(this.bson, offset);
          case bson_1.BSONType.array:
            return new _OnDemandDocument(this.bson, offset, true);
          default:
            throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);
        }
      }
      /**
       * Returns the number of elements in this BSON document
       */
      size() {
        return this.elements.length;
      }
      /**
       * Checks for the existence of an element by name.
       *
       * @remarks
       * Uses `getElement` with the expectation that will populate caches such that a `has` call
       * followed by a `getElement` call will not repeat the cost paid by the first look up.
       *
       * @param name - element name
       */
      has(name) {
        const cachedElement = this.cache[name];
        if (cachedElement === false)
          return false;
        if (cachedElement != null)
          return true;
        return this.getElement(name) != null;
      }
      get(name, as, required) {
        const element = this.getElement(name);
        if (element == null) {
          if (required === true) {
            throw new bson_1.BSONError(`BSON element "${name}" is missing`);
          } else {
            return null;
          }
        }
        if (element.value == null) {
          const value = this.toJSValue(element.element, as);
          if (value == null) {
            if (required === true) {
              throw new bson_1.BSONError(`BSON element "${name}" is missing`);
            } else {
              return null;
            }
          }
          element.value = value;
        }
        return element.value;
      }
      getNumber(name, required) {
        const maybeBool = this.get(name, bson_1.BSONType.bool);
        const bool = maybeBool == null ? null : maybeBool ? 1 : 0;
        const maybeLong = this.get(name, bson_1.BSONType.long);
        const long = maybeLong == null ? null : Number(maybeLong);
        const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);
        if (required === true && result == null) {
          throw new bson_1.BSONError(`BSON element "${name}" is missing`);
        }
        return result;
      }
      /**
       * Deserialize this object, DOES NOT cache result so avoid multiple invocations
       * @param options - BSON deserialization options
       */
      toObject(options) {
        return (0, bson_1.deserialize)(this.bson, {
          ...options,
          index: this.offset,
          allowObjectSmallerThanBufferSize: true
        });
      }
      /** Returns this document's bytes only */
      toBytes() {
        const size = (0, bson_1.getInt32LE)(this.bson, this.offset);
        return this.bson.subarray(this.offset, this.offset + size);
      }
    };
    exports.OnDemandDocument = OnDemandDocument;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/responses.js
var require_responses = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientBulkWriteCursorResponse = exports.ExplainedCursorResponse = exports.CursorResponse = exports.MongoDBResponse = void 0;
    exports.isErrorResponse = isErrorResponse;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var document_1 = require_document();
    function isErrorResponse(bson, elements) {
      for (let eIdx = 0; eIdx < elements.length; eIdx++) {
        const element = elements[eIdx];
        if (element[
          2
          /* BSONElementOffset.nameLength */
        ] === 2) {
          const nameOffset = element[
            1
            /* BSONElementOffset.nameOffset */
          ];
          if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {
            const valueOffset = element[
              3
              /* BSONElementOffset.offset */
            ];
            const valueLength = element[
              4
              /* BSONElementOffset.length */
            ];
            for (let i = valueOffset; i < valueOffset + valueLength; i++) {
              if (bson[i] !== 0)
                return false;
            }
            return true;
          }
        }
      }
      return true;
    }
    var MongoDBResponse = class _MongoDBResponse extends document_1.OnDemandDocument {
      get(name, as, required) {
        try {
          return super.get(name, as, required);
        } catch (cause) {
          throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
        }
      }
      static is(value) {
        return value instanceof _MongoDBResponse;
      }
      static make(bson) {
        const elements = (0, bson_1.parseToElementsToArray)(bson, 0);
        const isError = isErrorResponse(bson, elements);
        return isError ? new _MongoDBResponse(bson, 0, false, elements) : new this(bson, 0, false, elements);
      }
      /**
       * Returns true iff:
       * - ok is 0 and the top-level code === 50
       * - ok is 1 and the writeErrors array contains a code === 50
       * - ok is 1 and the writeConcern object contains a code === 50
       */
      get isMaxTimeExpiredError() {
        const isTopLevel = this.ok === 0 && this.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
        if (isTopLevel)
          return true;
        if (this.ok === 0)
          return false;
        const isWriteConcern = this.get("writeConcernError", bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
        if (isWriteConcern)
          return true;
        const writeErrors = this.get("writeErrors", bson_1.BSONType.array);
        if (writeErrors?.size()) {
          for (let i = 0; i < writeErrors.size(); i++) {
            const isWriteError = writeErrors.get(i, bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
            if (isWriteError)
              return true;
          }
        }
        return false;
      }
      /**
       * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the
       * contents of the document.
       */
      get recoveryToken() {
        return this.get("recoveryToken", bson_1.BSONType.object)?.toObject({
          promoteValues: false,
          promoteLongs: false,
          promoteBuffers: false,
          validation: { utf8: true }
        }) ?? null;
      }
      /**
       * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.
       * For the distinct command the server adds a top-level atClusterTime field to the response.
       * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.
       */
      get atClusterTime() {
        return this.get("cursor", bson_1.BSONType.object)?.get("atClusterTime", bson_1.BSONType.timestamp) ?? this.get("atClusterTime", bson_1.BSONType.timestamp);
      }
      get operationTime() {
        return this.get("operationTime", bson_1.BSONType.timestamp);
      }
      /** Normalizes whatever BSON value is "ok" to a JS number 1 or 0. */
      get ok() {
        return this.getNumber("ok") ? 1 : 0;
      }
      get $err() {
        return this.get("$err", bson_1.BSONType.string);
      }
      get errmsg() {
        return this.get("errmsg", bson_1.BSONType.string);
      }
      get code() {
        return this.getNumber("code");
      }
      get $clusterTime() {
        if (!("clusterTime" in this)) {
          const clusterTimeDoc = this.get("$clusterTime", bson_1.BSONType.object);
          if (clusterTimeDoc == null) {
            this.clusterTime = null;
            return null;
          }
          const clusterTime = clusterTimeDoc.get("clusterTime", bson_1.BSONType.timestamp, true);
          const signature = clusterTimeDoc.get("signature", bson_1.BSONType.object)?.toObject();
          this.clusterTime = { clusterTime, signature };
        }
        return this.clusterTime ?? null;
      }
      toObject(options) {
        const exactBSONOptions = {
          ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),
          validation: (0, bson_1.parseUtf8ValidationOption)(options)
        };
        return super.toObject(exactBSONOptions);
      }
    };
    exports.MongoDBResponse = MongoDBResponse;
    MongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));
    var CursorResponse = class _CursorResponse extends MongoDBResponse {
      constructor() {
        super(...arguments);
        this._batch = null;
        this.iterated = 0;
        this._encryptedBatch = null;
      }
      /**
       * This supports a feature of the FindCursor.
       * It is an optimization to avoid an extra getMore when the limit has been reached
       */
      static get emptyGetMore() {
        return new _CursorResponse((0, bson_1.serialize)({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));
      }
      static is(value) {
        return value instanceof _CursorResponse || value === _CursorResponse.emptyGetMore;
      }
      get cursor() {
        return this.get("cursor", bson_1.BSONType.object, true);
      }
      get id() {
        try {
          return bson_1.Long.fromBigInt(this.cursor.get("id", bson_1.BSONType.long, true));
        } catch (cause) {
          throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
        }
      }
      get ns() {
        const namespace2 = this.cursor.get("ns", bson_1.BSONType.string);
        if (namespace2 != null)
          return (0, utils_1.ns)(namespace2);
        return null;
      }
      get length() {
        return Math.max(this.batchSize - this.iterated, 0);
      }
      get encryptedBatch() {
        if (this.encryptedResponse == null)
          return null;
        if (this._encryptedBatch != null)
          return this._encryptedBatch;
        const cursor = this.encryptedResponse?.get("cursor", bson_1.BSONType.object);
        if (cursor?.has("firstBatch"))
          this._encryptedBatch = cursor.get("firstBatch", bson_1.BSONType.array, true);
        else if (cursor?.has("nextBatch"))
          this._encryptedBatch = cursor.get("nextBatch", bson_1.BSONType.array, true);
        else
          throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
        return this._encryptedBatch;
      }
      get batch() {
        if (this._batch != null)
          return this._batch;
        const cursor = this.cursor;
        if (cursor.has("firstBatch"))
          this._batch = cursor.get("firstBatch", bson_1.BSONType.array, true);
        else if (cursor.has("nextBatch"))
          this._batch = cursor.get("nextBatch", bson_1.BSONType.array, true);
        else
          throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
        return this._batch;
      }
      get batchSize() {
        return this.batch?.size();
      }
      get postBatchResumeToken() {
        return this.cursor.get("postBatchResumeToken", bson_1.BSONType.object)?.toObject({
          promoteValues: false,
          promoteLongs: false,
          promoteBuffers: false,
          validation: { utf8: true }
        }) ?? null;
      }
      shift(options) {
        if (this.iterated >= this.batchSize) {
          return null;
        }
        const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;
        const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;
        this.iterated += 1;
        if (options?.raw) {
          return result.toBytes();
        } else {
          const object = result.toObject(options);
          if (encryptedResult) {
            (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);
          }
          return object;
        }
      }
      clear() {
        this.iterated = this.batchSize;
      }
    };
    exports.CursorResponse = CursorResponse;
    var ExplainedCursorResponse = class extends CursorResponse {
      constructor() {
        super(...arguments);
        this.isExplain = true;
        this._length = 1;
      }
      get id() {
        return bson_1.Long.fromBigInt(0n);
      }
      get batchSize() {
        return 0;
      }
      get ns() {
        return null;
      }
      get length() {
        return this._length;
      }
      shift(options) {
        if (this._length === 0)
          return null;
        this._length -= 1;
        return this.toObject(options);
      }
    };
    exports.ExplainedCursorResponse = ExplainedCursorResponse;
    var ClientBulkWriteCursorResponse = class extends CursorResponse {
      get insertedCount() {
        return this.get("nInserted", bson_1.BSONType.int, true);
      }
      get upsertedCount() {
        return this.get("nUpserted", bson_1.BSONType.int, true);
      }
      get matchedCount() {
        return this.get("nMatched", bson_1.BSONType.int, true);
      }
      get modifiedCount() {
        return this.get("nModified", bson_1.BSONType.int, true);
      }
      get deletedCount() {
        return this.get("nDeleted", bson_1.BSONType.int, true);
      }
      get writeConcernError() {
        return this.get("writeConcernError", bson_1.BSONType.object, false);
      }
    };
    exports.ClientBulkWriteCursorResponse = ClientBulkWriteCursorResponse;
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteConcern = exports.WRITE_CONCERN_KEYS = void 0;
    exports.throwIfWriteConcernError = throwIfWriteConcernError;
    var responses_1 = require_responses();
    var error_1 = require_error();
    exports.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];
    var WriteConcern = class _WriteConcern {
      /**
       * Constructs a WriteConcern from the write concern properties.
       * @param w - request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags.
       * @param wtimeoutMS - specify a time limit to prevent write operations from blocking indefinitely
       * @param journal - request acknowledgment that the write operation has been written to the on-disk journal
       * @param fsync - equivalent to the j option. Is deprecated and will be removed in the next major version.
       */
      constructor(w, wtimeoutMS, journal, fsync) {
        if (w != null) {
          if (!Number.isNaN(Number(w))) {
            this.w = Number(w);
          } else {
            this.w = w;
          }
        }
        if (wtimeoutMS != null) {
          this.wtimeoutMS = this.wtimeout = wtimeoutMS;
        }
        if (journal != null) {
          this.journal = this.j = journal;
        }
        if (fsync != null) {
          this.journal = this.j = fsync ? true : false;
        }
      }
      /**
       * Apply a write concern to a command document. Will modify and return the command.
       */
      static apply(command, writeConcern) {
        const wc = {};
        if (writeConcern.w != null)
          wc.w = writeConcern.w;
        if (writeConcern.wtimeoutMS != null)
          wc.wtimeout = writeConcern.wtimeoutMS;
        if (writeConcern.journal != null)
          wc.j = writeConcern.j;
        command.writeConcern = wc;
        return command;
      }
      /** Construct a WriteConcern given an options object. */
      static fromOptions(options, inherit) {
        if (options == null)
          return void 0;
        inherit = inherit ?? {};
        let opts;
        if (typeof options === "string" || typeof options === "number") {
          opts = { w: options };
        } else if (options instanceof _WriteConcern) {
          opts = options;
        } else {
          opts = options.writeConcern;
        }
        const parentOpts = inherit instanceof _WriteConcern ? inherit : inherit.writeConcern;
        const { w = void 0, wtimeout = void 0, j = void 0, fsync = void 0, journal = void 0, wtimeoutMS = void 0 } = {
          ...parentOpts,
          ...opts
        };
        if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
          return new _WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
        }
        return void 0;
      }
    };
    exports.WriteConcern = WriteConcern;
    function throwIfWriteConcernError(response) {
      if (typeof response === "object" && response != null) {
        const writeConcernError = responses_1.MongoDBResponse.is(response) && response.has("writeConcernError") ? response.toObject() : !responses_1.MongoDBResponse.is(response) && "writeConcernError" in response ? response : null;
        if (writeConcernError != null) {
          throw new error_1.MongoWriteConcernError(writeConcernError);
        }
      }
    }
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kDispose = exports.randomBytes = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = exports.DOCUMENT_DB_CHECK = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ByteUtils = void 0;
    exports.isUint8Array = isUint8Array;
    exports.hostMatchesWildcards = hostMatchesWildcards;
    exports.normalizeHintField = normalizeHintField;
    exports.isObject = isObject3;
    exports.mergeOptions = mergeOptions;
    exports.filterOptions = filterOptions;
    exports.applyRetryableWrites = applyRetryableWrites;
    exports.isPromiseLike = isPromiseLike;
    exports.decorateWithCollation = decorateWithCollation;
    exports.decorateWithReadConcern = decorateWithReadConcern;
    exports.getTopology = getTopology;
    exports.ns = ns;
    exports.makeCounter = makeCounter;
    exports.uuidV4 = uuidV4;
    exports.maxWireVersion = maxWireVersion;
    exports.arrayStrictEqual = arrayStrictEqual;
    exports.errorStrictEqual = errorStrictEqual;
    exports.makeStateMachine = makeStateMachine;
    exports.now = now;
    exports.calculateDurationInMs = calculateDurationInMs;
    exports.hasAtomicOperators = hasAtomicOperators;
    exports.resolveTimeoutOptions = resolveTimeoutOptions;
    exports.resolveOptions = resolveOptions;
    exports.isSuperset = isSuperset;
    exports.isHello = isHello;
    exports.setDifference = setDifference;
    exports.isRecord = isRecord;
    exports.emitWarning = emitWarning;
    exports.emitWarningOnce = emitWarningOnce;
    exports.enumToString = enumToString;
    exports.supportsRetryableWrites = supportsRetryableWrites;
    exports.shuffle = shuffle;
    exports.commandSupportsReadConcern = commandSupportsReadConcern;
    exports.compareObjectId = compareObjectId;
    exports.parseInteger = parseInteger;
    exports.parseUnsignedInteger = parseUnsignedInteger;
    exports.checkParentDomainMatch = checkParentDomainMatch;
    exports.get = get;
    exports.request = request;
    exports.isHostMatch = isHostMatch;
    exports.promiseWithResolvers = promiseWithResolvers;
    exports.squashError = squashError;
    exports.once = once;
    exports.maybeAddIdToDocuments = maybeAddIdToDocuments;
    exports.fileIsAccessible = fileIsAccessible;
    exports.csotMin = csotMin;
    exports.noop = noop2;
    exports.decorateDecryptionResult = decorateDecryptionResult;
    exports.addAbortListener = addAbortListener;
    exports.abortable = abortable;
    var crypto7 = __require("crypto");
    var fs_1 = __require("fs");
    var http4 = __require("http");
    var timers_1 = __require("timers");
    var url2 = __require("url");
    var url_1 = __require("url");
    var util_1 = __require("util");
    var bson_1 = require_bson2();
    var constants_1 = require_constants();
    var constants_2 = require_constants2();
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var write_concern_1 = require_write_concern();
    exports.ByteUtils = {
      toLocalBufferType(buffer) {
        return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      },
      equals(seqA, seqB) {
        return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
      },
      compare(seqA, seqB) {
        return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
      },
      toBase64(uint8array) {
        return exports.ByteUtils.toLocalBufferType(uint8array).toString("base64");
      }
    };
    function isUint8Array(value) {
      return value != null && typeof value === "object" && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Uint8Array";
    }
    function hostMatchesWildcards(host, wildcards) {
      for (const wildcard of wildcards) {
        if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
          return true;
        }
      }
      return false;
    }
    function normalizeHintField(hint) {
      let finalHint = void 0;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach((param3) => {
          finalHint[param3] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (const name in hint) {
          finalHint[name] = hint[name];
        }
      }
      return finalHint;
    }
    var TO_STRING = (object) => Object.prototype.toString.call(object);
    function isObject3(arg) {
      return "[object Object]" === TO_STRING(arg);
    }
    function mergeOptions(target, source) {
      return { ...target, ...source };
    }
    function filterOptions(options, names) {
      const filterOptions2 = {};
      for (const name in options) {
        if (names.includes(name)) {
          filterOptions2[name] = options[name];
        }
      }
      return filterOptions2;
    }
    function applyRetryableWrites(target, db) {
      if (db && db.s.options?.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function isPromiseLike(value) {
      return value != null && typeof value === "object" && "then" in value && typeof value.then === "function";
    }
    function decorateWithCollation(command, target, options) {
      const capabilities = getTopology(target).capabilities;
      if (options.collation && typeof options.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options.collation;
        } else {
          throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options) {
      if (options && options.session && options.session.inTransaction()) {
        return;
      }
      const readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function getTopology(provider) {
      if ("topology" in provider && provider.topology) {
        return provider.topology;
      } else if ("client" in provider && provider.client.topology) {
        return provider.client.topology;
      }
      throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
    }
    function ns(ns2) {
      return MongoDBNamespace.fromString(ns2);
    }
    var MongoDBNamespace = class _MongoDBNamespace {
      /**
       * Create a namespace object
       *
       * @param db - database name
       * @param collection - collection name
       */
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
        this.collection = collection === "" ? void 0 : collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBCollectionNamespace(this.db, collection);
      }
      static fromString(namespace2) {
        if (typeof namespace2 !== "string" || namespace2 === "") {
          throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace2}"`);
        }
        const [db, ...collectionParts] = namespace2.split(".");
        const collection = collectionParts.join(".");
        return new _MongoDBNamespace(db, collection === "" ? void 0 : collection);
      }
    };
    exports.MongoDBNamespace = MongoDBNamespace;
    var MongoDBCollectionNamespace = class extends MongoDBNamespace {
      constructor(db, collection) {
        super(db, collection);
        this.collection = collection;
      }
      static fromString(namespace2) {
        return super.fromString(namespace2);
      }
    };
    exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
    function* makeCounter(seed = 0) {
      let count = seed;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function uuidV4() {
      const result = crypto7.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {
          return constants_1.MAX_SUPPORTED_WIRE_VERSION;
        }
        if (topologyOrServer.hello) {
          return topologyOrServer.hello.maxWireVersion;
        }
        if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
          const lastHello = topologyOrServer.lastHello();
          if (lastHello) {
            return lastHello.maxWireVersion;
          }
        }
        if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (!lhs || !rhs) {
        return lhs === rhs;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        return -1;
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        for (const document2 of doc) {
          if (hasAtomicOperators(document2)) {
            return true;
          }
        }
        return false;
      }
      const keys = Object.keys(doc);
      return keys.length > 0 && keys[0][0] === "$";
    }
    function resolveTimeoutOptions(client, options) {
      const { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS } = client.s.options;
      return { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS, ...options };
    }
    function resolveOptions(parent, options) {
      const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
      const timeoutMS = options?.timeoutMS ?? parent?.timeoutMS;
      const session = options?.session;
      if (!session?.inTransaction()) {
        const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
        if (readConcern) {
          result.readConcern = readConcern;
        }
        let writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
        if (writeConcern) {
          if (timeoutMS != null) {
            writeConcern = write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...writeConcern,
                wtimeout: void 0,
                wtimeoutMS: void 0
              }
            });
          }
          result.writeConcern = writeConcern;
        }
      }
      result.timeoutMS = timeoutMS;
      const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
      if (readPreference) {
        result.readPreference = readPreference;
      }
      const isConvenientTransaction = session?.explicit && session?.timeoutContext != null;
      if (isConvenientTransaction && options?.timeoutMS != null) {
        throw new error_1.MongoInvalidArgumentError("An operation cannot be given a timeoutMS setting when inside a withTransaction call that has a timeoutMS setting");
      }
      return result;
    }
    function isSuperset(set, subset) {
      set = Array.isArray(set) ? new Set(set) : set;
      subset = Array.isArray(subset) ? new Set(subset) : subset;
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }
    function isHello(doc) {
      return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
    }
    function setDifference(setA, setB) {
      const difference = new Set(setA);
      for (const elem of setB) {
        difference.delete(elem);
      }
      return difference;
    }
    var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    function isRecord(value, requiredKeys = void 0) {
      if (!isObject3(value)) {
        return false;
      }
      const ctor = value.constructor;
      if (ctor && ctor.prototype) {
        if (!isObject3(ctor.prototype)) {
          return false;
        }
        if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
          return false;
        }
      }
      if (requiredKeys) {
        const keys = Object.keys(value);
        return isSuperset(keys, requiredKeys);
      }
      return true;
    }
    var List = class {
      get length() {
        return this.count;
      }
      get [Symbol.toStringTag]() {
        return "List";
      }
      constructor() {
        this.count = 0;
        this.head = {
          next: null,
          prev: null,
          value: null
        };
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      toArray() {
        return Array.from(this);
      }
      toString() {
        return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
      }
      *[Symbol.iterator]() {
        for (const node of this.nodes()) {
          yield node.value;
        }
      }
      *nodes() {
        let ptr = this.head.next;
        while (ptr !== this.head) {
          const { next } = ptr;
          yield ptr;
          ptr = next;
        }
      }
      /** Insert at end of list */
      push(value) {
        this.count += 1;
        const newNode = {
          next: this.head,
          prev: this.head.prev,
          value
        };
        this.head.prev.next = newNode;
        this.head.prev = newNode;
      }
      /** Inserts every item inside an iterable instead of the iterable itself */
      pushMany(iterable) {
        for (const value of iterable) {
          this.push(value);
        }
      }
      /** Insert at front of list */
      unshift(value) {
        this.count += 1;
        const newNode = {
          next: this.head.next,
          prev: this.head,
          value
        };
        this.head.next.prev = newNode;
        this.head.next = newNode;
      }
      remove(node) {
        if (node === this.head || this.length === 0) {
          return null;
        }
        this.count -= 1;
        const prevNode = node.prev;
        const nextNode = node.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        return node.value;
      }
      /** Removes the first node at the front of the list */
      shift() {
        return this.remove(this.head.next);
      }
      /** Removes the last node at the end of the list */
      pop() {
        return this.remove(this.head.prev);
      }
      /** Iterates through the list and removes nodes where filter returns true */
      prune(filter2) {
        for (const node of this.nodes()) {
          if (filter2(node.value)) {
            this.remove(node);
          }
        }
      }
      clear() {
        this.count = 0;
        this.head.next = this.head;
        this.head.prev = this.head;
      }
      /** Returns the first item in the list, does not remove */
      first() {
        return this.head.next.value;
      }
      /** Returns the last item in the list, does not remove */
      last() {
        return this.head.prev.value;
      }
    };
    exports.List = List;
    var BufferPool = class {
      constructor() {
        this.buffers = new List();
        this.totalByteLength = 0;
      }
      get length() {
        return this.totalByteLength;
      }
      /** Adds a buffer to the internal buffer pool list */
      append(buffer) {
        this.buffers.push(buffer);
        this.totalByteLength += buffer.length;
      }
      /**
       * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,
       * otherwise return null. Size can be negative, caller should error check.
       */
      getInt32() {
        if (this.totalByteLength < 4) {
          return null;
        }
        const firstBuffer = this.buffers.first();
        if (firstBuffer != null && firstBuffer.byteLength >= 4) {
          return firstBuffer.readInt32LE(0);
        }
        const top4Bytes = this.read(4);
        const value = top4Bytes.readInt32LE(0);
        this.totalByteLength += 4;
        this.buffers.unshift(top4Bytes);
        return value;
      }
      /** Reads the requested number of bytes, optionally consuming them */
      read(size) {
        if (typeof size !== "number" || size < 0) {
          throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
        }
        if (size > this.totalByteLength) {
          return Buffer.alloc(0);
        }
        const result = Buffer.allocUnsafe(size);
        for (let bytesRead = 0; bytesRead < size; ) {
          const buffer = this.buffers.shift();
          if (buffer == null) {
            break;
          }
          const bytesRemaining = size - bytesRead;
          const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
          const bytes = buffer.subarray(0, bytesReadable);
          result.set(bytes, bytesRead);
          bytesRead += bytesReadable;
          this.totalByteLength -= bytesReadable;
          if (bytesReadable < buffer.byteLength) {
            this.buffers.unshift(buffer.subarray(bytesReadable));
          }
        }
        return result;
      }
    };
    exports.BufferPool = BufferPool;
    var HostAddress = class _HostAddress {
      constructor(hostString) {
        this.host = void 0;
        this.port = void 0;
        this.socketPath = void 0;
        this.isIPv6 = false;
        const escapedHost = hostString.split(" ").join("%20");
        if (escapedHost.endsWith(".sock")) {
          this.socketPath = decodeURIComponent(escapedHost);
          return;
        }
        const urlString = `iLoveJS://${escapedHost}`;
        let url3;
        try {
          url3 = new url_1.URL(urlString);
        } catch (urlError) {
          const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
          runtimeError.cause = urlError;
          throw runtimeError;
        }
        const hostname = url3.hostname;
        const port = url3.port;
        let normalized = decodeURIComponent(hostname).toLowerCase();
        if (normalized.startsWith("[") && normalized.endsWith("]")) {
          this.isIPv6 = true;
          normalized = normalized.substring(1, hostname.length - 1);
        }
        this.host = normalized.toLowerCase();
        if (typeof port === "number") {
          this.port = port;
        } else if (typeof port === "string" && port !== "") {
          this.port = Number.parseInt(port, 10);
        } else {
          this.port = 27017;
        }
        if (this.port === 0) {
          throw new error_1.MongoParseError("Invalid port (zero) with hostname");
        }
        Object.freeze(this);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.inspect();
      }
      inspect() {
        return `new HostAddress('${this.toString()}')`;
      }
      toString() {
        if (typeof this.host === "string") {
          if (this.isIPv6) {
            return `[${this.host}]:${this.port}`;
          }
          return `${this.host}:${this.port}`;
        }
        return `${this.socketPath}`;
      }
      static fromString(s) {
        return new _HostAddress(s);
      }
      static fromHostPort(host, port) {
        if (host.includes(":")) {
          host = `[${host}]`;
        }
        return _HostAddress.fromString(`${host}:${port}`);
      }
      static fromSrvRecord({ name, port }) {
        return _HostAddress.fromHostPort(name, port);
      }
      toHostPort() {
        if (this.socketPath) {
          return { host: this.socketPath, port: 0 };
        }
        const host = this.host ?? "";
        const port = this.port ?? 0;
        return { host, port };
      }
    };
    exports.HostAddress = HostAddress;
    exports.DEFAULT_PK_FACTORY = {
      // We prefer not to rely on ObjectId having a createPk method
      createPk() {
        return new bson_1.ObjectId();
      }
    };
    exports.MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
    }
    var emittedWarnings = /* @__PURE__ */ new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    function enumToString(en) {
      return Object.values(en).join(", ");
    }
    function supportsRetryableWrites(server2) {
      if (!server2) {
        return false;
      }
      if (server2.loadBalanced) {
        return true;
      }
      if (server2.description.logicalSessionTimeoutMinutes != null) {
        if (server2.description.type !== common_1.ServerType.Standalone) {
          return true;
        }
      }
      return false;
    }
    function shuffle(sequence, limit = 0) {
      const items = Array.from(sequence);
      if (limit > items.length) {
        throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
      }
      let remainingItemsToShuffle = items.length;
      const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
      while (remainingItemsToShuffle > lowerBound) {
        const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
        remainingItemsToShuffle -= 1;
        const swapHold = items[remainingItemsToShuffle];
        items[remainingItemsToShuffle] = items[randomIndex];
        items[randomIndex] = swapHold;
      }
      return limit % items.length === 0 ? items : items.slice(lowerBound);
    }
    function commandSupportsReadConcern(command) {
      if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
        return true;
      }
      return false;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null && oid2 == null) {
        return 0;
      }
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      return exports.ByteUtils.compare(oid1.id, oid2.id);
    }
    function parseInteger(value) {
      if (typeof value === "number")
        return Math.trunc(value);
      const parsedValue = Number.parseInt(String(value), 10);
      return Number.isNaN(parsedValue) ? null : parsedValue;
    }
    function parseUnsignedInteger(value) {
      const parsedInt = parseInteger(value);
      return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
    }
    function checkParentDomainMatch(address, srvHost) {
      const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
      const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
      const allCharacterBeforeFirstDot = /^.*?\./;
      const srvIsLessThanThreeParts = normalizedSrvHost.split(".").length < 3;
      const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
      let srvHostDomain = srvIsLessThanThreeParts ? normalizedSrvHost : `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
      if (!srvHostDomain.startsWith(".")) {
        srvHostDomain = "." + srvHostDomain;
      }
      if (srvIsLessThanThreeParts && normalizedAddress.split(".").length <= normalizedSrvHost.split(".").length) {
        throw new error_1.MongoAPIError("Server record does not have at least one more domain level than parent URI");
      }
      if (!addressDomain.endsWith(srvHostDomain)) {
        throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
      }
    }
    function get(url3, options = {}) {
      return new Promise((resolve, reject) => {
        let timeoutId;
        const request2 = http4.get(url3, options, (response) => {
          response.setEncoding("utf8");
          let body3 = "";
          response.on("data", (chunk) => body3 += chunk);
          response.on("end", () => {
            (0, timers_1.clearTimeout)(timeoutId);
            resolve({ status: response.statusCode, body: body3 });
          });
        }).on("error", (error2) => {
          (0, timers_1.clearTimeout)(timeoutId);
          reject(error2);
        }).end();
        timeoutId = (0, timers_1.setTimeout)(() => {
          request2.destroy(new error_1.MongoNetworkTimeoutError(`request timed out after 10 seconds`));
        }, 1e4);
      });
    }
    async function request(uri, options = {}) {
      return await new Promise((resolve, reject) => {
        const requestOptions = {
          method: "GET",
          timeout: 1e4,
          json: true,
          ...url2.parse(uri),
          ...options
        };
        const req = http4.request(requestOptions, (res) => {
          res.setEncoding("utf8");
          let data = "";
          res.on("data", (d) => {
            data += d;
          });
          res.once("end", () => {
            if (options.json === false) {
              resolve(data);
              return;
            }
            try {
              const parsed = JSON.parse(data);
              resolve(parsed);
            } catch {
              reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
            }
          });
        });
        req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options.timeout} ms`)));
        req.once("error", (error2) => reject(error2));
        req.end();
      });
    }
    exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
    exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
    exports.DOCUMENT_DB_MSG = "You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb";
    exports.COSMOS_DB_MSG = "You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb";
    function isHostMatch(match, host) {
      return host && match.test(host.toLowerCase()) ? true : false;
    }
    function promiseWithResolvers() {
      let resolve;
      let reject;
      const promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
        resolve = promiseResolve;
        reject = promiseReject;
      });
      return { promise, resolve, reject };
    }
    function squashError(_error) {
      return;
    }
    exports.randomBytes = (0, util_1.promisify)(crypto7.randomBytes);
    async function once(ee, name, options) {
      options?.signal?.throwIfAborted();
      const { promise, resolve, reject } = promiseWithResolvers();
      const onEvent = (data) => resolve(data);
      const onError2 = (error2) => reject(error2);
      const abortListener = addAbortListener(options?.signal, function() {
        reject(this.reason);
      });
      ee.once(name, onEvent).once("error", onError2);
      try {
        return await promise;
      } finally {
        ee.off(name, onEvent);
        ee.off("error", onError2);
        abortListener?.[exports.kDispose]();
      }
    }
    function maybeAddIdToDocuments(coll, docOrDocs, options) {
      const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docOrDocs;
      }
      const transform = (doc) => {
        if (doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      };
      return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
    }
    async function fileIsAccessible(fileName, mode) {
      try {
        await fs_1.promises.access(fileName, mode);
        return true;
      } catch {
        return false;
      }
    }
    function csotMin(duration1, duration2) {
      if (duration1 === 0)
        return duration2;
      if (duration2 === 0)
        return duration1;
      return Math.min(duration1, duration2);
    }
    function noop2() {
      return;
    }
    function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {
      if (isTopLevelDecorateCall) {
        if (Buffer.isBuffer(original)) {
          original = (0, bson_1.deserialize)(original);
        }
        if (Buffer.isBuffer(decrypted)) {
          throw new error_1.MongoRuntimeError("Expected result of decryption to be deserialized BSON object");
        }
      }
      if (!decrypted || typeof decrypted !== "object")
        return;
      for (const k of Object.keys(decrypted)) {
        const originalValue = original[k];
        if (originalValue && originalValue._bsontype === "Binary" && originalValue.sub_type === 6) {
          if (!decrypted[constants_2.kDecoratedKeys]) {
            Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
              value: [],
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          decrypted[constants_2.kDecoratedKeys].push(k);
          continue;
        }
        decorateDecryptionResult(decrypted[k], originalValue, false);
      }
    }
    exports.kDispose = Symbol.dispose ?? Symbol("dispose");
    function addAbortListener(signal, listener) {
      if (signal == null)
        return;
      signal.addEventListener("abort", listener, { once: true });
      return { [exports.kDispose]: () => signal.removeEventListener("abort", listener) };
    }
    async function abortable(promise, { signal }) {
      if (signal == null) {
        return await promise;
      }
      const { promise: aborted, reject } = promiseWithResolvers();
      const abortListener = signal.aborted ? reject(signal.reason) : addAbortListener(signal, function() {
        reject(this.reason);
      });
      try {
        return await Promise.race([promise, aborted]);
      } finally {
        abortListener?.[exports.kDispose]();
      }
    }
  }
});

// node_modules/mongodb/lib/timeout.js
var require_timeout = __commonJS({
  "node_modules/mongodb/lib/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = void 0;
    var timers_1 = __require("timers");
    var error_1 = require_error();
    var utils_1 = require_utils();
    var TimeoutError = class extends Error {
      get name() {
        return "TimeoutError";
      }
      constructor(message, options) {
        super(message, options);
        this.duration = options.duration;
      }
      static is(error2) {
        return error2 != null && typeof error2 === "object" && "name" in error2 && error2.name === "TimeoutError";
      }
    };
    exports.TimeoutError = TimeoutError;
    var Timeout = class _Timeout extends Promise {
      get remainingTime() {
        if (this.timedOut)
          return 0;
        if (this.duration === 0)
          return Infinity;
        return this.start + this.duration - Math.trunc(performance.now());
      }
      get timeElapsed() {
        return Math.trunc(performance.now()) - this.start;
      }
      /** Create a new timeout that expires in `duration` ms */
      constructor(executor = () => null, options) {
        const duration = options?.duration ?? 0;
        const unref = !!options?.unref;
        const rejection = options?.rejection;
        if (duration < 0) {
          throw new error_1.MongoInvalidArgumentError("Cannot create a Timeout with a negative duration");
        }
        let reject;
        super((_, promiseReject) => {
          reject = promiseReject;
          executor(utils_1.noop, promiseReject);
        });
        this.ended = null;
        this.timedOut = false;
        this.cleared = false;
        this.duration = duration;
        this.start = Math.trunc(performance.now());
        if (rejection == null && this.duration > 0) {
          this.id = (0, timers_1.setTimeout)(() => {
            this.ended = Math.trunc(performance.now());
            this.timedOut = true;
            reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));
          }, this.duration);
          if (typeof this.id.unref === "function" && unref) {
            this.id.unref();
          }
        } else if (rejection != null) {
          this.ended = Math.trunc(performance.now());
          this.timedOut = true;
          reject(rejection);
        }
      }
      /**
       * Clears the underlying timeout. This method is idempotent
       */
      clear() {
        (0, timers_1.clearTimeout)(this.id);
        this.id = void 0;
        this.timedOut = false;
        this.cleared = true;
      }
      throwIfExpired() {
        if (this.timedOut) {
          this.then(void 0, utils_1.squashError);
          throw new TimeoutError("Timed out", { duration: this.duration });
        }
      }
      static expires(duration, unref) {
        return new _Timeout(void 0, { duration, unref });
      }
      static reject(rejection) {
        return new _Timeout(void 0, { duration: 0, unref: true, rejection });
      }
    };
    exports.Timeout = Timeout;
    function isLegacyTimeoutContextOptions(v) {
      return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "waitQueueTimeoutMS" in v && typeof v.waitQueueTimeoutMS === "number";
    }
    function isCSOTTimeoutContextOptions(v) {
      return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "timeoutMS" in v && typeof v.timeoutMS === "number";
    }
    var TimeoutContext = class {
      static create(options) {
        if (options.session?.timeoutContext != null)
          return options.session?.timeoutContext;
        if (isCSOTTimeoutContextOptions(options))
          return new CSOTTimeoutContext(options);
        else if (isLegacyTimeoutContextOptions(options))
          return new LegacyTimeoutContext(options);
        else
          throw new error_1.MongoRuntimeError("Unrecognized options");
      }
    };
    exports.TimeoutContext = TimeoutContext;
    var CSOTTimeoutContext = class _CSOTTimeoutContext extends TimeoutContext {
      constructor(options) {
        super();
        this.minRoundTripTime = 0;
        this.start = Math.trunc(performance.now());
        this.timeoutMS = options.timeoutMS;
        this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
        this.socketTimeoutMS = options.socketTimeoutMS;
        this.clearServerSelectionTimeout = false;
      }
      get maxTimeMS() {
        return this.remainingTimeMS - this.minRoundTripTime;
      }
      get remainingTimeMS() {
        const timePassed = Math.trunc(performance.now()) - this.start;
        return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;
      }
      csotEnabled() {
        return true;
      }
      get serverSelectionTimeout() {
        if (typeof this._serverSelectionTimeout !== "object" || this._serverSelectionTimeout?.cleared) {
          const { remainingTimeMS, serverSelectionTimeoutMS } = this;
          if (remainingTimeMS <= 0)
            return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));
          const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 && (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;
          if (usingServerSelectionTimeoutMS) {
            this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);
          } else {
            if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {
              this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);
            } else {
              this._serverSelectionTimeout = null;
            }
          }
        }
        return this._serverSelectionTimeout;
      }
      get connectionCheckoutTimeout() {
        if (typeof this._connectionCheckoutTimeout !== "object" || this._connectionCheckoutTimeout?.cleared) {
          if (typeof this._serverSelectionTimeout === "object") {
            this._connectionCheckoutTimeout = this._serverSelectionTimeout;
          } else {
            throw new error_1.MongoRuntimeError("Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira");
          }
        }
        return this._connectionCheckoutTimeout;
      }
      get timeoutForSocketWrite() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
          return null;
        if (remainingTimeMS > 0)
          return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket write"));
      }
      get timeoutForSocketRead() {
        const { remainingTimeMS } = this;
        if (!Number.isFinite(remainingTimeMS))
          return null;
        if (remainingTimeMS > 0)
          return Timeout.expires(remainingTimeMS);
        return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket read"));
      }
      refresh() {
        this.start = Math.trunc(performance.now());
        this.minRoundTripTime = 0;
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
      }
      clear() {
        this._serverSelectionTimeout?.clear();
        this._connectionCheckoutTimeout?.clear();
      }
      /**
       * @internal
       * Throws a MongoOperationTimeoutError if the context has expired.
       * If the context has not expired, returns the `remainingTimeMS`
       **/
      getRemainingTimeMSOrThrow(message) {
        const { remainingTimeMS } = this;
        if (remainingTimeMS <= 0)
          throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);
        return remainingTimeMS;
      }
      /**
       * @internal
       * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.
       * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.
       */
      clone() {
        const timeoutContext = new _CSOTTimeoutContext({
          timeoutMS: this.timeoutMS,
          serverSelectionTimeoutMS: this.serverSelectionTimeoutMS
        });
        timeoutContext.start = this.start;
        return timeoutContext;
      }
      refreshed() {
        return new _CSOTTimeoutContext(this);
      }
      addMaxTimeMSToCommand(command, options) {
        if (options.omitMaxTimeMS)
          return;
        const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;
        if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))
          command.maxTimeMS = maxTimeMS;
      }
      getSocketTimeoutMS() {
        return 0;
      }
    };
    exports.CSOTTimeoutContext = CSOTTimeoutContext;
    var LegacyTimeoutContext = class _LegacyTimeoutContext extends TimeoutContext {
      constructor(options) {
        super();
        this.options = options;
        this.clearServerSelectionTimeout = true;
      }
      csotEnabled() {
        return false;
      }
      get serverSelectionTimeout() {
        if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)
          return Timeout.expires(this.options.serverSelectionTimeoutMS);
        return null;
      }
      get connectionCheckoutTimeout() {
        if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)
          return Timeout.expires(this.options.waitQueueTimeoutMS);
        return null;
      }
      get timeoutForSocketWrite() {
        return null;
      }
      get timeoutForSocketRead() {
        return null;
      }
      refresh() {
        return;
      }
      clear() {
        return;
      }
      get maxTimeMS() {
        return null;
      }
      refreshed() {
        return new _LegacyTimeoutContext(this.options);
      }
      addMaxTimeMSToCommand(_command, _options) {
      }
      getSocketTimeoutMS() {
        return this.options.socketTimeoutMS;
      }
    };
    exports.LegacyTimeoutContext = LegacyTimeoutContext;
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractOperation = exports.Aspect = void 0;
    exports.defineAspects = defineAspects;
    var bson_1 = require_bson2();
    var read_preference_1 = require_read_preference();
    exports.Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXPLAINABLE: Symbol("EXPLAINABLE"),
      SKIP_COLLATION: Symbol("SKIP_COLLATION"),
      CURSOR_CREATING: Symbol("CURSOR_CREATING"),
      MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER"),
      COMMAND_BATCHING: Symbol("COMMAND_BATCHING")
    };
    var AbstractOperation = class {
      constructor(options = {}) {
        this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary;
        this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
        this._session = options.session != null ? options.session : void 0;
        this.options = options;
        this.bypassPinningCheck = !!options.bypassPinningCheck;
        this.trySecondaryWrite = false;
      }
      hasAspect(aspect) {
        const ctor = this.constructor;
        if (ctor.aspects == null) {
          return false;
        }
        return ctor.aspects.has(aspect);
      }
      // Make sure the session is not writable from outside this class.
      get session() {
        return this._session;
      }
      clearSession() {
        this._session = void 0;
      }
      resetBatch() {
        return true;
      }
      get canRetryRead() {
        return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.READ_OPERATION);
      }
      get canRetryWrite() {
        return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.WRITE_OPERATION);
      }
    };
    exports.AbstractOperation = AbstractOperation;
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeOperation = executeOperation;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var server_selection_1 = require_server_selection();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var operation_1 = require_operation();
    var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    async function executeOperation(client, operation, timeoutContext) {
      if (!(operation instanceof operation_1.AbstractOperation)) {
        throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
      }
      const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;
      let session = operation.session;
      let owner;
      if (session == null) {
        owner = Symbol();
        session = client.startSession({ owner, explicit: false });
      } else if (session.hasEnded) {
        throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
        throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
      } else if (session.client !== client) {
        throw new error_1.MongoInvalidArgumentError("ClientSession must be from the same MongoClient");
      }
      const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
      const inTransaction = !!session?.inTransaction();
      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === "runCommand")) {
        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
      }
      if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
        session.unpin();
      }
      timeoutContext ?? (timeoutContext = timeout_1.TimeoutContext.create({
        session,
        serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,
        waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,
        timeoutMS: operation.options.timeoutMS
      }));
      try {
        return await tryOperation(operation, {
          topology,
          timeoutContext,
          session,
          readPreference
        });
      } finally {
        if (session?.owner != null && session.owner === owner) {
          await session.endSession();
        }
      }
    }
    async function autoConnect(client) {
      if (client.topology == null) {
        if (client.s.hasBeenClosed) {
          throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
        }
        client.s.options.__skipPingOnConnect = true;
        try {
          await client.connect();
          if (client.topology == null) {
            throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
          }
          return client.topology;
        } finally {
          delete client.s.options.__skipPingOnConnect;
        }
      }
      return client.topology;
    }
    async function tryOperation(operation, { topology, timeoutContext, session, readPreference }) {
      let selector;
      if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
        selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
      } else if (operation.trySecondaryWrite) {
        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
      } else {
        selector = readPreference;
      }
      let server2 = await topology.selectServer(selector, {
        session,
        operationName: operation.commandName,
        timeoutContext,
        signal: operation.options.signal
      });
      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
      const inTransaction = session?.inTransaction() ?? false;
      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server2) && operation.canRetryWrite;
      const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);
      if (hasWriteAspect && willRetryWrite && session != null) {
        operation.options.willRetryWrite = true;
        session.incrementTransactionNumber();
      }
      const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;
      let previousOperationError;
      let previousServer;
      for (let tries = 0; tries < maxTries; tries++) {
        if (previousOperationError) {
          if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
            throw new error_1.MongoServerError({
              message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
              errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
              originalError: previousOperationError
            });
          }
          if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {
            throw previousOperationError;
          }
          if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))
            throw previousOperationError;
          if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))
            throw previousOperationError;
          if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {
            session.unpin({ force: true, forceClear: true });
          }
          server2 = await topology.selectServer(selector, {
            session,
            operationName: operation.commandName,
            previousServer,
            signal: operation.options.signal
          });
          if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server2)) {
            throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
          }
        }
        try {
          if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {
            operation.resetBatch();
          }
          return await operation.execute(server2, session, timeoutContext);
        } catch (operationError) {
          if (!(operationError instanceof error_1.MongoError))
            throw operationError;
          if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
            throw previousOperationError;
          }
          previousServer = server2.description;
          previousOperationError = operationError;
          timeoutContext.clear();
        }
      }
      throw previousOperationError ?? new error_1.MongoRuntimeError("Tried to propagate retryability error, but no error was found.");
    }
  }
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS({
  "node_modules/mongodb/lib/mongo_logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = void 0;
    exports.parseSeverityFromString = parseSeverityFromString;
    exports.createStdioLogger = createStdioLogger;
    exports.stringifyWithMaxLen = stringifyWithMaxLen;
    exports.defaultLogTransform = defaultLogTransform;
    var util_1 = __require("util");
    var bson_1 = require_bson2();
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    exports.SeverityLevel = Object.freeze({
      EMERGENCY: "emergency",
      ALERT: "alert",
      CRITICAL: "critical",
      ERROR: "error",
      WARNING: "warn",
      NOTICE: "notice",
      INFORMATIONAL: "info",
      DEBUG: "debug",
      TRACE: "trace",
      OFF: "off"
    });
    exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1e3;
    var SeverityLevelMap = class extends Map {
      constructor(entries) {
        const newEntries = [];
        for (const [level2, value] of entries) {
          newEntries.push([value, level2]);
        }
        newEntries.push(...entries);
        super(newEntries);
      }
      getNumericSeverityLevel(severity) {
        return this.get(severity);
      }
      getSeverityLevelName(level2) {
        return this.get(level2);
      }
    };
    exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
      [exports.SeverityLevel.OFF, -Infinity],
      [exports.SeverityLevel.EMERGENCY, 0],
      [exports.SeverityLevel.ALERT, 1],
      [exports.SeverityLevel.CRITICAL, 2],
      [exports.SeverityLevel.ERROR, 3],
      [exports.SeverityLevel.WARNING, 4],
      [exports.SeverityLevel.NOTICE, 5],
      [exports.SeverityLevel.INFORMATIONAL, 6],
      [exports.SeverityLevel.DEBUG, 7],
      [exports.SeverityLevel.TRACE, 8]
    ]);
    exports.MongoLoggableComponent = Object.freeze({
      COMMAND: "command",
      TOPOLOGY: "topology",
      SERVER_SELECTION: "serverSelection",
      CONNECTION: "connection",
      CLIENT: "client"
    });
    function parseSeverityFromString(s) {
      const validSeverities = Object.values(exports.SeverityLevel);
      const lowerSeverity = s?.toLowerCase();
      if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
        return lowerSeverity;
      }
      return null;
    }
    function createStdioLogger(stream4) {
      return {
        write: (0, util_1.promisify)((log, cb) => {
          const logLine = (0, util_1.inspect)(log, { compact: true, breakLength: Infinity });
          stream4.write(`${logLine}
`, "utf-8", cb);
          return;
        })
      };
    }
    function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
      if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
      }
      if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
      }
      if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
        return { mongodbLogPath, mongodbLogPathIsStdErr: false };
      }
      if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
        return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
      }
      if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
        return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
      }
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    function resolveSeverityConfiguration(clientOption, environmentOption, defaultSeverity) {
      return parseSeverityFromString(clientOption) ?? parseSeverityFromString(environmentOption) ?? defaultSeverity;
    }
    function compareSeverity(s0, s1) {
      const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
      const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
      return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
    }
    function stringifyWithMaxLen(value, maxDocumentLength, options = {}) {
      let strToTruncate = "";
      let currentLength = 0;
      const maxDocumentLengthEnsurer = function maxDocumentLengthEnsurer2(key, value2) {
        if (currentLength >= maxDocumentLength) {
          return void 0;
        }
        if (key === "") {
          currentLength += 1;
          return value2;
        }
        currentLength += key.length + 4;
        if (value2 == null)
          return value2;
        switch (typeof value2) {
          case "string":
            currentLength += value2.length + 2;
            break;
          case "number":
          case "bigint":
            currentLength += String(value2).length;
            break;
          case "boolean":
            currentLength += value2 ? 4 : 5;
            break;
          case "object":
            if ((0, utils_1.isUint8Array)(value2)) {
              currentLength += 22 + value2.byteLength + value2.byteLength * 0.33 + 18 | 0;
            } else if ("_bsontype" in value2) {
              const v = value2;
              switch (v._bsontype) {
                case "Int32":
                  currentLength += String(v.value).length;
                  break;
                case "Double":
                  currentLength += (v.value | 0) === v.value ? String(v.value).length + 2 : String(v.value).length;
                  break;
                case "Long":
                  currentLength += v.toString().length;
                  break;
                case "ObjectId":
                  currentLength += 35;
                  break;
                case "MaxKey":
                case "MinKey":
                  currentLength += 13;
                  break;
                case "Binary":
                  currentLength += 22 + value2.position + value2.position * 0.33 + 18 | 0;
                  break;
                case "Timestamp":
                  currentLength += 19 + String(v.t).length + 5 + String(v.i).length + 2;
                  break;
                case "Code":
                  if (v.scope == null) {
                    currentLength += v.code.length + 10 + 2;
                  } else {
                    currentLength += v.code.length + 10 + 11;
                  }
                  break;
                case "BSONRegExp":
                  currentLength += 34 + v.pattern.length + 13 + v.options.length + 3;
                  break;
              }
            }
        }
        return value2;
      };
      if (typeof value === "string") {
        strToTruncate = value;
      } else if (typeof value === "function") {
        strToTruncate = value.name;
      } else {
        try {
          if (maxDocumentLength !== 0) {
            strToTruncate = bson_1.EJSON.stringify(value, maxDocumentLengthEnsurer, 0, options);
          } else {
            strToTruncate = bson_1.EJSON.stringify(value, options);
          }
        } catch (e) {
          strToTruncate = `Extended JSON serialization failed with: ${e.message}`;
        }
      }
      if (maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength && strToTruncate.charCodeAt(maxDocumentLength - 1) !== strToTruncate.codePointAt(maxDocumentLength - 1)) {
        maxDocumentLength--;
        if (maxDocumentLength === 0) {
          return "";
        }
      }
      return maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength ? `${strToTruncate.slice(0, maxDocumentLength)}...` : strToTruncate;
    }
    function isLogConvertible(obj) {
      const objAsLogConvertible = obj;
      return objAsLogConvertible.toLog !== void 0 && typeof objAsLogConvertible.toLog === "function";
    }
    function attachServerSelectionFields(log, serverSelectionEvent, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
      const { selector, operation, topologyDescription, message } = serverSelectionEvent;
      log.selector = stringifyWithMaxLen(selector, maxDocumentLength);
      log.operation = operation;
      log.topologyDescription = stringifyWithMaxLen(topologyDescription, maxDocumentLength);
      log.message = message;
      return log;
    }
    function attachCommandFields(log, commandEvent) {
      log.commandName = commandEvent.commandName;
      log.requestId = commandEvent.requestId;
      log.driverConnectionId = commandEvent.connectionId;
      const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      if (commandEvent?.serviceId) {
        log.serviceId = commandEvent.serviceId.toHexString();
      }
      log.databaseName = commandEvent.databaseName;
      log.serverConnectionId = commandEvent.serverConnectionId;
      return log;
    }
    function attachConnectionFields(log, event) {
      const { host, port } = utils_1.HostAddress.fromString(event.address).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      return log;
    }
    function attachSDAMFields(log, sdamEvent) {
      log.topologyId = sdamEvent.topologyId;
      return log;
    }
    function attachServerHeartbeatFields(log, serverHeartbeatEvent) {
      const { awaited, connectionId } = serverHeartbeatEvent;
      log.awaited = awaited;
      log.driverConnectionId = serverHeartbeatEvent.connectionId;
      const { host, port } = utils_1.HostAddress.fromString(connectionId).toHostPort();
      log.serverHost = host;
      log.serverPort = port;
      return log;
    }
    function defaultLogTransform(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
      let log = /* @__PURE__ */ Object.create(null);
      switch (logObject.name) {
        case constants_1.SERVER_SELECTION_STARTED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          return log;
        case constants_1.SERVER_SELECTION_FAILED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.failure = logObject.failure?.message;
          return log;
        case constants_1.SERVER_SELECTION_SUCCEEDED:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.serverHost = logObject.serverHost;
          log.serverPort = logObject.serverPort;
          return log;
        case constants_1.WAITING_FOR_SUITABLE_SERVER:
          log = attachServerSelectionFields(log, logObject, maxDocumentLength);
          log.remainingTimeMS = logObject.remainingTimeMS;
          return log;
        case constants_1.COMMAND_STARTED:
          log = attachCommandFields(log, logObject);
          log.message = "Command started";
          log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength, { relaxed: true });
          log.databaseName = logObject.databaseName;
          return log;
        case constants_1.COMMAND_SUCCEEDED:
          log = attachCommandFields(log, logObject);
          log.message = "Command succeeded";
          log.durationMS = logObject.duration;
          log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
          return log;
        case constants_1.COMMAND_FAILED:
          log = attachCommandFields(log, logObject);
          log.message = "Command failed";
          log.durationMS = logObject.duration;
          log.failure = logObject.failure?.message ?? "(redacted)";
          return log;
        case constants_1.CONNECTION_POOL_CREATED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool created";
          if (logObject.options) {
            const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
            log = {
              ...log,
              maxIdleTimeMS,
              minPoolSize,
              maxPoolSize,
              maxConnecting,
              waitQueueTimeoutMS
            };
          }
          return log;
        case constants_1.CONNECTION_POOL_READY:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool ready";
          return log;
        case constants_1.CONNECTION_POOL_CLEARED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool cleared";
          if (logObject.serviceId?._bsontype === "ObjectId") {
            log.serviceId = logObject.serviceId?.toHexString();
          }
          return log;
        case constants_1.CONNECTION_POOL_CLOSED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection pool closed";
          return log;
        case constants_1.CONNECTION_CREATED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection created";
          log.driverConnectionId = logObject.connectionId;
          return log;
        case constants_1.CONNECTION_READY:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection ready";
          log.driverConnectionId = logObject.connectionId;
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CLOSED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection closed";
          log.driverConnectionId = logObject.connectionId;
          switch (logObject.reason) {
            case "stale":
              log.reason = "Connection became stale because the pool was cleared";
              break;
            case "idle":
              log.reason = "Connection has been available but unused for longer than the configured max idle time";
              break;
            case "error":
              log.reason = "An error occurred while using the connection";
              if (logObject.error) {
                log.error = logObject.error;
              }
              break;
            case "poolClosed":
              log.reason = "Connection pool was closed";
              break;
            default:
              log.reason = `Unknown close reason: ${logObject.reason}`;
          }
          return log;
        case constants_1.CONNECTION_CHECK_OUT_STARTED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checkout started";
          return log;
        case constants_1.CONNECTION_CHECK_OUT_FAILED:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checkout failed";
          switch (logObject.reason) {
            case "poolClosed":
              log.reason = "Connection pool was closed";
              break;
            case "timeout":
              log.reason = "Wait queue timeout elapsed without a connection becoming available";
              break;
            case "connectionError":
              log.reason = "An error occurred while trying to establish a new connection";
              if (logObject.error) {
                log.error = logObject.error;
              }
              break;
            default:
              log.reason = `Unknown close reason: ${logObject.reason}`;
          }
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CHECKED_OUT:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checked out";
          log.driverConnectionId = logObject.connectionId;
          log.durationMS = logObject.durationMS;
          return log;
        case constants_1.CONNECTION_CHECKED_IN:
          log = attachConnectionFields(log, logObject);
          log.message = "Connection checked in";
          log.driverConnectionId = logObject.connectionId;
          return log;
        case constants_1.SERVER_OPENING:
          log = attachSDAMFields(log, logObject);
          log = attachConnectionFields(log, logObject);
          log.message = "Starting server monitoring";
          return log;
        case constants_1.SERVER_CLOSED:
          log = attachSDAMFields(log, logObject);
          log = attachConnectionFields(log, logObject);
          log.message = "Stopped server monitoring";
          return log;
        case constants_1.SERVER_HEARTBEAT_STARTED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat started";
          return log;
        case constants_1.SERVER_HEARTBEAT_SUCCEEDED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat succeeded";
          log.durationMS = logObject.duration;
          log.serverConnectionId = logObject.serverConnectionId;
          log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
          return log;
        case constants_1.SERVER_HEARTBEAT_FAILED:
          log = attachSDAMFields(log, logObject);
          log = attachServerHeartbeatFields(log, logObject);
          log.message = "Server heartbeat failed";
          log.durationMS = logObject.duration;
          log.failure = logObject.failure?.message;
          return log;
        case constants_1.TOPOLOGY_OPENING:
          log = attachSDAMFields(log, logObject);
          log.message = "Starting topology monitoring";
          return log;
        case constants_1.TOPOLOGY_CLOSED:
          log = attachSDAMFields(log, logObject);
          log.message = "Stopped topology monitoring";
          return log;
        case constants_1.TOPOLOGY_DESCRIPTION_CHANGED:
          log = attachSDAMFields(log, logObject);
          log.message = "Topology description changed";
          log.previousDescription = log.reply = stringifyWithMaxLen(logObject.previousDescription, maxDocumentLength);
          log.newDescription = log.reply = stringifyWithMaxLen(logObject.newDescription, maxDocumentLength);
          return log;
        default:
          for (const [key, value] of Object.entries(logObject)) {
            if (value != null)
              log[key] = value;
          }
      }
      return log;
    }
    var MongoLogger = class {
      constructor(options) {
        this.pendingLog = null;
        this.error = this.log.bind(this, "error");
        this.warn = this.log.bind(this, "warn");
        this.info = this.log.bind(this, "info");
        this.debug = this.log.bind(this, "debug");
        this.trace = this.log.bind(this, "trace");
        this.componentSeverities = options.componentSeverities;
        this.maxDocumentLength = options.maxDocumentLength;
        this.logDestination = options.logDestination;
        this.logDestinationIsStdErr = options.logDestinationIsStdErr;
        this.severities = this.createLoggingSeverities();
      }
      createLoggingSeverities() {
        const severities = Object();
        for (const component of Object.values(exports.MongoLoggableComponent)) {
          severities[component] = {};
          for (const severityLevel of Object.values(exports.SeverityLevel)) {
            severities[component][severityLevel] = compareSeverity(severityLevel, this.componentSeverities[component]) <= 0;
          }
        }
        return severities;
      }
      turnOffSeverities() {
        for (const component of Object.values(exports.MongoLoggableComponent)) {
          this.componentSeverities[component] = exports.SeverityLevel.OFF;
          for (const severityLevel of Object.values(exports.SeverityLevel)) {
            this.severities[component][severityLevel] = false;
          }
        }
      }
      logWriteFailureHandler(error2) {
        if (this.logDestinationIsStdErr) {
          this.turnOffSeverities();
          this.clearPendingLog();
          return;
        }
        this.logDestination = createStdioLogger(process.stderr);
        this.logDestinationIsStdErr = true;
        this.clearPendingLog();
        this.error(exports.MongoLoggableComponent.CLIENT, {
          toLog: function() {
            return {
              message: "User input for mongodbLogPath is now invalid. Logging is halted.",
              error: error2.message
            };
          }
        });
        this.turnOffSeverities();
        this.clearPendingLog();
      }
      clearPendingLog() {
        this.pendingLog = null;
      }
      willLog(component, severity) {
        if (severity === exports.SeverityLevel.OFF)
          return false;
        return this.severities[component][severity];
      }
      log(severity, component, message) {
        if (!this.willLog(component, severity))
          return;
        let logMessage = { t: /* @__PURE__ */ new Date(), c: component, s: severity };
        if (typeof message === "string") {
          logMessage.message = message;
        } else if (typeof message === "object") {
          if (isLogConvertible(message)) {
            logMessage = { ...logMessage, ...message.toLog() };
          } else {
            logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
          }
        }
        if ((0, utils_1.isPromiseLike)(this.pendingLog)) {
          this.pendingLog = this.pendingLog.then(() => this.logDestination.write(logMessage)).then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
          return;
        }
        try {
          const logResult = this.logDestination.write(logMessage);
          if ((0, utils_1.isPromiseLike)(logResult)) {
            this.pendingLog = logResult.then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
          }
        } catch (error2) {
          this.logWriteFailureHandler(error2);
        }
      }
      /**
       * Merges options set through environment variables and the MongoClient, preferring environment
       * variables when both are set, and substituting defaults for values not set. Options set in
       * constructor take precedence over both environment variables and MongoClient options.
       *
       * @remarks
       * When parsing component severity levels, invalid values are treated as unset and replaced with
       * the default severity.
       *
       * @param envOptions - options set for the logger from the environment
       * @param clientOptions - options set for the logger in the MongoClient options
       * @returns a MongoLoggerOptions object to be used when instantiating a new MongoLogger
       */
      static resolveOptions(envOptions, clientOptions) {
        const resolvedLogPath = resolveLogPath(envOptions, clientOptions);
        const combinedOptions = {
          ...envOptions,
          ...clientOptions,
          mongodbLogPath: resolvedLogPath.mongodbLogPath,
          mongodbLogPathIsStdErr: resolvedLogPath.mongodbLogPathIsStdErr
        };
        const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports.SeverityLevel.OFF);
        return {
          componentSeverities: {
            command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
            topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
            serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
            connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
            client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
            default: defaultSeverity
          },
          maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ?? (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1e3,
          logDestination: combinedOptions.mongodbLogPath,
          logDestinationIsStdErr: combinedOptions.mongodbLogPathIsStdErr
        };
      }
    };
    exports.MongoLogger = MongoLogger;
  }
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS({
  "node_modules/mongodb/lib/mongo_types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationToken = exports.TypedEventEmitter = void 0;
    var events_1 = __require("events");
    var mongo_logger_1 = require_mongo_logger();
    var utils_1 = require_utils();
    var TypedEventEmitter = class extends events_1.EventEmitter {
      /** @internal */
      emitAndLog(event, ...args) {
        this.emit(event, ...args);
        if (this.component)
          this.mongoLogger?.debug(this.component, args[0]);
      }
      /** @internal */
      emitAndLogHeartbeat(event, topologyId, serverConnectionId, ...args) {
        this.emit(event, ...args);
        if (this.component) {
          const loggableHeartbeatEvent = {
            topologyId,
            serverConnectionId: serverConnectionId ?? null,
            ...args[0]
          };
          this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
        }
      }
      /** @internal */
      emitAndLogCommand(monitorCommands, event, databaseName, connectionEstablished, ...args) {
        if (monitorCommands) {
          this.emit(event, ...args);
        }
        if (connectionEstablished) {
          const loggableCommandEvent = {
            databaseName,
            ...args[0]
          };
          this.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
        }
      }
    };
    exports.TypedEventEmitter = TypedEventEmitter;
    var CancellationToken = class extends TypedEventEmitter {
      constructor(...args) {
        super(...args);
        this.on("error", utils_1.noop);
      }
    };
    exports.CancellationToken = CancellationToken;
  }
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/operations/get_more.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GetMoreOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var operation_1 = require_operation();
    var GetMoreOperation = class extends operation_1.AbstractOperation {
      constructor(ns, cursorId, server2, options) {
        super(options);
        this.options = options;
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server2;
      }
      get commandName() {
        return "getMore";
      }
      /**
       * Although there is a server already associated with the get more operation, the signature
       * for execute passes a server so we will just use that one.
       */
      async execute(server2, _session, timeoutContext) {
        if (server2 !== this.server) {
          throw new error_1.MongoRuntimeError("Getmore must run on the same server operation began on");
        }
        if (this.cursorId == null || this.cursorId.isZero()) {
          throw new error_1.MongoRuntimeError("Unable to iterate cursor with no id");
        }
        const collection = this.ns.collection;
        if (collection == null) {
          throw new error_1.MongoRuntimeError("A collection name must be determined before getMore");
        }
        const getMoreCmd = {
          getMore: this.cursorId,
          collection
        };
        if (typeof this.options.batchSize === "number") {
          getMoreCmd.batchSize = Math.abs(this.options.batchSize);
        }
        if (typeof this.options.maxAwaitTimeMS === "number") {
          getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
        }
        if (this.options.comment !== void 0 && (0, utils_1.maxWireVersion)(server2) >= 9) {
          getMoreCmd.comment = this.options.comment;
        }
        const commandOptions = {
          returnFieldSelector: null,
          documentsReturnedIn: "nextBatch",
          timeoutContext,
          ...this.options
        };
        return await server2.command(this.ns, getMoreCmd, commandOptions, responses_1.CursorResponse);
      }
    };
    exports.GetMoreOperation = GetMoreOperation;
    (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/operations/kill_cursors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KillCursorsOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var operation_1 = require_operation();
    var KillCursorsOperation = class extends operation_1.AbstractOperation {
      constructor(cursorId, ns, server2, options) {
        super(options);
        this.ns = ns;
        this.cursorId = cursorId;
        this.server = server2;
      }
      get commandName() {
        return "killCursors";
      }
      async execute(server2, session, timeoutContext) {
        if (server2 !== this.server) {
          throw new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on");
        }
        const killCursors = this.ns.collection;
        if (killCursors == null) {
          throw new error_1.MongoRuntimeError("A collection name must be determined before killCursors");
        }
        const killCursorsCommand = {
          killCursors,
          cursors: [this.cursorId]
        };
        try {
          await server2.command(this.ns, killCursorsCommand, {
            session,
            timeoutContext
          });
        } catch (error2) {
          (0, utils_1.squashError)(error2);
        }
      }
    };
    exports.KillCursorsOperation = KillCursorsOperation;
    (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
  }
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS({
  "node_modules/mongodb/lib/operations/delete.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = void 0;
    exports.makeDeleteStatement = makeDeleteStatement;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DeleteOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options) {
        super(void 0, options);
        this.options = options;
        this.ns = ns;
        this.statements = statements;
      }
      get commandName() {
        return "delete";
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options ?? {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          delete: this.ns.collection,
          deletes: this.statements,
          ordered
        };
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
          }
        }
        const res = await super.executeCommand(server2, session, command, timeoutContext);
        return res;
      }
    };
    exports.DeleteOperation = DeleteOperation;
    var DeleteOneOperation = class extends DeleteOperation {
      constructor(collection, filter2, options) {
        super(collection.s.namespace, [makeDeleteStatement(filter2, { ...options, limit: 1 })], options);
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (this.explain)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        };
      }
    };
    exports.DeleteOneOperation = DeleteOneOperation;
    var DeleteManyOperation = class extends DeleteOperation {
      constructor(collection, filter2, options) {
        super(collection.s.namespace, [makeDeleteStatement(filter2, options)], options);
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (this.explain)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        };
      }
    };
    exports.DeleteManyOperation = DeleteManyOperation;
    function makeDeleteStatement(filter2, options) {
      const op = {
        q: filter2,
        limit: typeof options.limit === "number" ? options.limit : 0
      };
      if (options.collation) {
        op.collation = options.collation;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      return op;
    }
    (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DeleteOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(DeleteManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BulkWriteOperation = void 0;
    var operation_1 = require_operation();
    var BulkWriteOperation = class extends operation_1.AbstractOperation {
      constructor(collection, operations, options) {
        super(options);
        this.options = options;
        this.collection = collection;
        this.operations = operations;
      }
      get commandName() {
        return "bulkWrite";
      }
      async execute(server2, session, timeoutContext) {
        const coll = this.collection;
        const operations = this.operations;
        const options = {
          ...this.options,
          ...this.bsonOptions,
          readPreference: this.readPreference,
          timeoutContext
        };
        const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
        for (let i = 0; i < operations.length; i++) {
          bulk.raw(operations[i]);
        }
        return await bulk.execute({ ...options, session });
      }
    };
    exports.BulkWriteOperation = BulkWriteOperation;
    (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS({
  "node_modules/mongodb/lib/operations/insert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var bulk_write_1 = require_bulk_write();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var InsertOperation = class extends command_1.CommandOperation {
      constructor(ns, documents, options) {
        super(void 0, options);
        this.options = { ...options, checkKeys: options.checkKeys ?? false };
        this.ns = ns;
        this.documents = documents;
      }
      get commandName() {
        return "insert";
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options ?? {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          insert: this.ns.collection,
          documents: this.documents,
          ordered
        };
        if (typeof options.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        return await super.executeCommand(server2, session, command, timeoutContext);
      }
    };
    exports.InsertOperation = InsertOperation;
    var InsertOneOperation = class extends InsertOperation {
      constructor(collection, doc, options) {
        super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors) {
          throw new error_1.MongoServerError(res.writeErrors[0]);
        }
        return {
          acknowledged: this.writeConcern?.w !== 0,
          insertedId: this.documents[0]._id
        };
      }
    };
    exports.InsertOneOperation = InsertOneOperation;
    var InsertManyOperation = class extends operation_1.AbstractOperation {
      constructor(collection, docs, options) {
        super(options);
        if (!Array.isArray(docs)) {
          throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
        }
        this.options = options;
        this.collection = collection;
        this.docs = docs;
      }
      get commandName() {
        return "insert";
      }
      async execute(server2, session, timeoutContext) {
        const coll = this.collection;
        const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map((document2) => ({
          insertOne: { document: document2 }
        })), options);
        try {
          const res = await bulkWriteOperation.execute(server2, session, timeoutContext);
          return {
            acknowledged: writeConcern?.w !== 0,
            insertedCount: res.insertedCount,
            insertedIds: res.insertedIds
          };
        } catch (err) {
          if (err && err.message === "Operation must be an object with an operation key") {
            throw new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
          }
          throw err;
        }
      }
    };
    exports.InsertManyOperation = InsertManyOperation;
    (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS({
  "node_modules/mongodb/lib/operations/update.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = void 0;
    exports.makeUpdateStatement = makeUpdateStatement;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var UpdateOperation = class extends command_1.CommandOperation {
      constructor(ns, statements, options) {
        super(void 0, options);
        this.options = options;
        this.ns = ns;
        this.statements = statements;
      }
      get commandName() {
        return "update";
      }
      get canRetryWrite() {
        if (super.canRetryWrite === false) {
          return false;
        }
        return this.statements.every((op) => op.multi == null || op.multi === false);
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options ?? {};
        const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
        const command = {
          update: this.ns.collection,
          updates: this.statements,
          ordered
        };
        if (typeof options.bypassDocumentValidation === "boolean") {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
        if (unacknowledgedWrite) {
          if (this.statements.find((o) => o.hint)) {
            throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
          }
        }
        const res = await super.executeCommand(server2, session, command, timeoutContext);
        return res;
      }
    };
    exports.UpdateOperation = UpdateOperation;
    var UpdateOneOperation = class extends UpdateOperation {
      constructor(collection, filter2, update, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter2, update, { ...options, multi: false })], options);
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports.UpdateOneOperation = UpdateOneOperation;
    var UpdateManyOperation = class extends UpdateOperation {
      constructor(collection, filter2, update, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter2, update, { ...options, multi: true })], options);
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports.UpdateManyOperation = UpdateManyOperation;
    var ReplaceOneOperation = class extends UpdateOperation {
      constructor(collection, filter2, replacement, options) {
        super(collection.s.namespace, [makeUpdateStatement(filter2, replacement, { ...options, multi: false })], options);
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
      }
      async execute(server2, session, timeoutContext) {
        const res = await super.execute(server2, session, timeoutContext);
        if (this.explain != null)
          return res;
        if (res.code)
          throw new error_1.MongoServerError(res);
        if (res.writeErrors)
          throw new error_1.MongoServerError(res.writeErrors[0]);
        return {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified ?? res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        };
      }
    };
    exports.ReplaceOneOperation = ReplaceOneOperation;
    function makeUpdateStatement(filter2, update, options) {
      if (filter2 == null || typeof filter2 !== "object") {
        throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
      }
      const op = { q: filter2, u: update };
      if (typeof options.upsert === "boolean") {
        op.upsert = options.upsert;
      }
      if (options.multi) {
        op.multi = options.multi;
      }
      if (options.hint) {
        op.hint = options.hint;
      }
      if (options.arrayFilters) {
        op.arrayFilters = options.arrayFilters;
      }
      if (options.collation) {
        op.collation = options.collation;
      }
      return op;
    }
    (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
    (0, operation_1.defineAspects)(UpdateOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(UpdateManyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.SKIP_COLLATION
    ]);
    (0, operation_1.defineAspects)(ReplaceOneOperation, [
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.SKIP_COLLATION
    ]);
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BulkOperationBase = exports.BulkWriteShimOperation = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;
    exports.mergeBatchResults = mergeBatchResults;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var delete_1 = require_delete();
    var execute_operation_1 = require_execute_operation();
    var insert_1 = require_insert();
    var operation_1 = require_operation();
    var update_1 = require_update();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    exports.BatchType = Object.freeze({
      INSERT: 1,
      UPDATE: 2,
      DELETE: 3
    });
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    exports.Batch = Batch;
    var BulkWriteResult = class _BulkWriteResult {
      static generateIdMap(ids) {
        const idMap = {};
        for (const doc of ids) {
          idMap[doc.index] = doc._id;
        }
        return idMap;
      }
      /**
       * Create a new BulkWriteResult instance
       * @internal
       */
      constructor(bulkResult, isOrdered) {
        this.result = bulkResult;
        this.insertedCount = this.result.nInserted ?? 0;
        this.matchedCount = this.result.nMatched ?? 0;
        this.modifiedCount = this.result.nModified ?? 0;
        this.deletedCount = this.result.nRemoved ?? 0;
        this.upsertedCount = this.result.upserted.length ?? 0;
        this.upsertedIds = _BulkWriteResult.generateIdMap(this.result.upserted);
        this.insertedIds = _BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
        Object.defineProperty(this, "result", { value: this.result, enumerable: false });
      }
      /** Evaluates to true if the bulk operation correctly executes */
      get ok() {
        return this.result.ok;
      }
      /**
       * Returns document_ids that were actually inserted
       * @internal
       */
      getSuccessfullyInsertedIds(bulkResult, isOrdered) {
        if (bulkResult.writeErrors.length === 0)
          return bulkResult.insertedIds;
        if (isOrdered) {
          return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
        }
        return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some((writeError) => index === writeError.index));
      }
      /** Returns the upserted id at the given index */
      getUpsertedIdAt(index) {
        return this.result.upserted[index];
      }
      /** Returns raw internal result */
      getRawResponse() {
        return this.result;
      }
      /** Returns true if the bulk operation contains a write error */
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      /** Returns the number of write errors off the bulk operation */
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      /** Returns a specific write error object */
      getWriteErrorAt(index) {
        return index < this.result.writeErrors.length ? this.result.writeErrors[index] : void 0;
      }
      /** Retrieve all write errors */
      getWriteErrors() {
        return this.result.writeErrors;
      }
      /** Retrieve the write concern error if one exists */
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernTimeout });
        }
      }
      toString() {
        return `BulkWriteResult(${bson_1.EJSON.stringify(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    exports.BulkWriteResult = BulkWriteResult;
    var WriteConcernError = class {
      constructor(error2) {
        this.serverError = error2;
      }
      /** Write concern error code. */
      get code() {
        return this.serverError.code;
      }
      /** Write concern error message. */
      get errmsg() {
        return this.serverError.errmsg;
      }
      /** Write concern error info. */
      get errInfo() {
        return this.serverError.errInfo;
      }
      toJSON() {
        return this.serverError;
      }
      toString() {
        return `WriteConcernError(${this.errmsg})`;
      }
    };
    exports.WriteConcernError = WriteConcernError;
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      /** WriteError code. */
      get code() {
        return this.err.code;
      }
      /** WriteError original bulk operation index. */
      get index() {
        return this.err.index;
      }
      /** WriteError message. */
      get errmsg() {
        return this.err.errmsg;
      }
      /** WriteError details. */
      get errInfo() {
        return this.err.errInfo;
      }
      /** Returns the underlying operation that caused the error */
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    exports.WriteError = WriteError;
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      }
      if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          errInfo: result.errInfo,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (isInsertBatch(batch) && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (isDeleteBatch(batch) && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (isUpdateBatch(batch) && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = 0;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            errInfo: result.writeErrors[i].errInfo,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    async function executeCommands(bulkOperation, options) {
      if (bulkOperation.s.batches.length === 0) {
        return new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      }
      for (const batch of bulkOperation.s.batches) {
        const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
          ...options,
          ordered: bulkOperation.isOrdered
        });
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (bulkOperation.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (bulkOperation.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (isUpdateBatch(batch)) {
            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
          }
          if (isDeleteBatch(batch)) {
            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
          }
        }
        const operation = isInsertBatch(batch) ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isUpdateBatch(batch) ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isDeleteBatch(batch) ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : null;
        if (operation == null)
          throw new error_1.MongoRuntimeError(`Unknown batchType: ${batch.batchType}`);
        let thrownError = null;
        let result;
        try {
          result = await (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, operation, finalOptions.timeoutContext);
        } catch (error2) {
          thrownError = error2;
        }
        if (thrownError != null) {
          if (thrownError instanceof error_1.MongoWriteConcernError) {
            mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
            const writeResult3 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
            throw new MongoBulkWriteError({
              message: thrownError.result.writeConcernError.errmsg,
              code: thrownError.result.writeConcernError.code
            }, writeResult3);
          } else {
            throw new MongoBulkWriteError(thrownError, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
          }
        }
        mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
        const writeResult2 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
        bulkOperation.handleWriteError(writeResult2);
      }
      bulkOperation.s.batches.length = 0;
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      bulkOperation.handleWriteError(writeResult);
      return writeResult;
    }
    var MongoBulkWriteError = class extends error_1.MongoServerError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(error2, result) {
        super(error2);
        this.writeErrors = [];
        if (error2 instanceof WriteConcernError)
          this.err = error2;
        else if (!(error2 instanceof Error)) {
          this.message = error2.message;
          this.code = error2.code;
          this.writeErrors = error2.writeErrors ?? [];
        }
        this.result = result;
        Object.assign(this, error2);
      }
      get name() {
        return "MongoBulkWriteError";
      }
      /** Number of documents inserted. */
      get insertedCount() {
        return this.result.insertedCount;
      }
      /** Number of documents matched for update. */
      get matchedCount() {
        return this.result.matchedCount;
      }
      /** Number of documents modified. */
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      /** Number of documents deleted. */
      get deletedCount() {
        return this.result.deletedCount;
      }
      /** Number of documents upserted. */
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      /** Inserted document generated Id's, hash key is the index of the originating operation */
      get insertedIds() {
        return this.result.insertedIds;
      }
      /** Upserted document generated Id's, hash key is the index of the originating operation */
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    exports.MongoBulkWriteError = MongoBulkWriteError;
    var FindOperators = class {
      /**
       * Creates a new FindOperators object.
       * @internal
       */
      constructor(bulkOperation) {
        this.bulkOperation = bulkOperation;
      }
      /** Add a multiple update operation to the bulk operation */
      update(updateDocument) {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
          ...currentOp,
          multi: true
        }));
      }
      /** Add a single update operation to the bulk operation */
      updateOne(updateDocument) {
        if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
      }
      /** Add a replace one operation to the bulk operation */
      replaceOne(replacement) {
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
        }
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
      }
      /** Add a delete one operation to the bulk operation */
      deleteOne() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
      }
      /** Add a delete many operation to the bulk operation */
      delete() {
        const currentOp = buildCurrentOp(this.bulkOperation);
        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
      }
      /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */
      upsert() {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.upsert = true;
        return this;
      }
      /** Specifies the collation for the query condition. */
      collation(collation) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.collation = collation;
        return this;
      }
      /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */
      arrayFilters(arrayFilters) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
        return this;
      }
      /** Specifies hint for the bulk operation. */
      hint(hint) {
        if (!this.bulkOperation.s.currentOp) {
          this.bulkOperation.s.currentOp = {};
        }
        this.bulkOperation.s.currentOp.hint = hint;
        return this;
      }
    };
    exports.FindOperators = FindOperators;
    var BulkWriteShimOperation = class extends operation_1.AbstractOperation {
      constructor(bulkOperation, options) {
        super(options);
        this.bulkOperation = bulkOperation;
      }
      get commandName() {
        return "bulkWrite";
      }
      async execute(_server, session, timeoutContext) {
        if (this.options.session == null) {
          this.options.session = session;
        }
        return await executeCommands(this.bulkOperation, { ...this.options, timeoutContext });
      }
    };
    exports.BulkWriteShimOperation = BulkWriteShimOperation;
    var BulkOperationBase = class {
      /**
       * Create a new OrderedBulkOperation or UnorderedBulkOperation instance
       * @internal
       */
      constructor(collection, options, isOrdered) {
        this.collection = collection;
        this.isOrdered = isOrdered;
        const topology = (0, utils_1.getTopology)(collection);
        options = options == null ? {} : options;
        const namespace2 = collection.s.namespace;
        const executed = false;
        const currentOp = void 0;
        const hello = topology.lastHello();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options);
        finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          // Final result
          bulkResult,
          // Current batch state
          currentBatch: void 0,
          currentIndex: 0,
          // ordered specific
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          // unordered specific
          currentInsertBatch: void 0,
          currentUpdateBatch: void 0,
          currentRemoveBatch: void 0,
          batches: [],
          // Write concern
          writeConcern: write_concern_1.WriteConcern.fromOptions(options),
          // Max batch size options
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          // Namespace
          namespace: namespace2,
          // Topology
          topology,
          // Options
          options: finalOptions,
          // BSON options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options),
          // Current operation
          currentOp,
          // Executed
          executed,
          // Collection
          collection,
          // Fundamental error
          err: void 0,
          // check keys
          checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
        };
        if (options.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      /**
       * Add a single insert document to the bulk operation
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Adds three inserts to the bulkOp.
       * bulkOp
       *   .insert({ a: 1 })
       *   .insert({ b: 2 })
       *   .insert({ c: 3 });
       * await bulkOp.execute();
       * ```
       */
      insert(document2) {
        (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, {
          forceServerObjectId: this.shouldForceServerObjectId()
        });
        return this.addToOperationsList(exports.BatchType.INSERT, document2);
      }
      /**
       * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.
       * Returns a builder object used to complete the definition of the operation.
       *
       * @example
       * ```ts
       * const bulkOp = collection.initializeOrderedBulkOp();
       *
       * // Add an updateOne to the bulkOp
       * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });
       *
       * // Add an updateMany to the bulkOp
       * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });
       *
       * // Add an upsert
       * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });
       *
       * // Add a deletion
       * bulkOp.find({ g: 7 }).deleteOne();
       *
       * // Add a multi deletion
       * bulkOp.find({ h: 8 }).delete();
       *
       * // Add a replaceOne
       * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});
       *
       * // Update using a pipeline (requires Mongodb 4.2 or higher)
       * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([
       *   { $set: { total: { $sum: [ '$y', '$z' ] } } }
       * ]);
       *
       * // All of the ops will now be executed
       * await bulkOp.execute();
       * ```
       */
      find(selector) {
        if (!selector) {
          throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      /** Specifies a raw operation to perform in the bulk write. */
      raw(op) {
        if (op == null || typeof op !== "object") {
          throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
        }
        if ("insertOne" in op) {
          const forceServerObjectId = this.shouldForceServerObjectId();
          const document2 = op.insertOne && op.insertOne.document == null ? (
            // TODO(NODE-6003): remove support for omitting the `documents` subdocument in bulk inserts
            op.insertOne
          ) : op.insertOne.document;
          (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, { forceServerObjectId });
          return this.addToOperationsList(exports.BatchType.INSERT, document2);
        }
        if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
          if ("replaceOne" in op) {
            if ("q" in op.replaceOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
            if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
            }
            return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
          }
          if ("updateOne" in op) {
            if ("q" in op.updateOne) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
              ...op.updateOne,
              multi: false
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
          }
          if ("updateMany" in op) {
            if ("q" in op.updateMany) {
              throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
            }
            const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
              ...op.updateMany,
              multi: true
            });
            if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
              throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
            }
            return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
          }
        }
        if ("deleteOne" in op) {
          if ("q" in op.deleteOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
        }
        if ("deleteMany" in op) {
          if ("q" in op.deleteMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
        }
        throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
      }
      get length() {
        return this.s.currentIndex;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get batches() {
        const batches = [...this.s.batches];
        if (this.isOrdered) {
          if (this.s.currentBatch)
            batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            batches.push(this.s.currentRemoveBatch);
        }
        return batches;
      }
      async execute(options = {}) {
        if (this.s.executed) {
          throw new error_1.MongoBatchReExecutionError();
        }
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (writeConcern) {
          this.s.writeConcern = writeConcern;
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
        }
        this.s.executed = true;
        const finalOptions = { ...this.s.options, ...options };
        const operation = new BulkWriteShimOperation(this, finalOptions);
        return await (0, execute_operation_1.executeOperation)(this.s.collection.client, operation, finalOptions.timeoutContext);
      }
      /**
       * Handles the write error before executing commands
       * @internal
       */
      handleWriteError(writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          throw new MongoBulkWriteError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }, writeResult);
        }
        const writeConcernError = writeResult.getWriteConcernError();
        if (writeConcernError) {
          throw new MongoBulkWriteError(writeConcernError, writeResult);
        }
      }
      shouldForceServerObjectId() {
        return this.s.options.forceServerObjectId === true || this.s.collection.s.db.options?.forceServerObjectId === true;
      }
    };
    exports.BulkOperationBase = BulkOperationBase;
    function isInsertBatch(batch) {
      return batch.batchType === exports.BatchType.INSERT;
    }
    function isUpdateBatch(batch) {
      return batch.batchType === exports.BatchType.UPDATE;
    }
    function isDeleteBatch(batch) {
      return batch.batchType === exports.BatchType.DELETE;
    }
    function buildCurrentOp(bulkOp) {
      let { currentOp } = bulkOp.s;
      bulkOp.s.currentOp = void 0;
      if (!currentOp)
        currentOp = {};
      return currentOp;
    }
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OrderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common2();
    var OrderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options) {
        super(collection, options, true);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize)
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        const maxKeySize = this.s.maxKeySize;
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
          this.s.currentBatchSize = 0;
          this.s.currentBatchSizeBytes = 0;
        }
        if (batchType === common_1.BatchType.INSERT) {
          this.s.bulkResult.insertedIds.push({
            index: this.s.currentIndex,
            _id: document2._id
          });
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatchSize += 1;
        this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
        this.s.currentIndex += 1;
        return this;
      }
    };
    exports.OrderedBulkOperation = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnorderedBulkOperation = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var common_1 = require_common2();
    var UnorderedBulkOperation = class extends common_1.BulkOperationBase {
      /** @internal */
      constructor(collection, options) {
        super(collection, options, false);
      }
      handleWriteError(writeResult) {
        if (this.s.batches.length) {
          return;
        }
        return super.handleWriteError(writeResult);
      }
      addToOperationsList(batchType, document2) {
        const bsonSize = BSON.calculateObjectSize(document2, {
          checkKeys: false,
          // Since we don't know what the user selected for BSON options here,
          // err on the safe side, and check the size with ignoreUndefined: false.
          ignoreUndefined: false
        });
        if (bsonSize >= this.s.maxBsonObjectSize) {
          throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
        }
        this.s.currentBatch = void 0;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentBatch = this.s.currentInsertBatch;
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentBatch = this.s.currentUpdateBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentBatch = this.s.currentRemoveBatch;
        }
        const maxKeySize = this.s.maxKeySize;
        if (this.s.currentBatch == null) {
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (
          // New batch if we exceed the max batch op size
          this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,
          // since we can't sent an empty batch
          this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch
          this.s.currentBatch.batchType !== batchType
        ) {
          this.s.batches.push(this.s.currentBatch);
          this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        }
        if (Array.isArray(document2)) {
          throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
        }
        this.s.currentBatch.operations.push(document2);
        this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
        this.s.currentIndex = this.s.currentIndex + 1;
        if (batchType === common_1.BatchType.INSERT) {
          this.s.currentInsertBatch = this.s.currentBatch;
          this.s.bulkResult.insertedIds.push({
            index: this.s.bulkResult.insertedIds.length,
            _id: document2._id
          });
        } else if (batchType === common_1.BatchType.UPDATE) {
          this.s.currentUpdateBatch = this.s.currentBatch;
        } else if (batchType === common_1.BatchType.DELETE) {
          this.s.currentRemoveBatch = this.s.currentBatch;
        }
        this.s.currentBatch.size += 1;
        this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
        return this;
      }
    };
    exports.UnorderedBulkOperation = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports.DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends command_1.CommandOperation {
      constructor(ns, pipeline, options) {
        super(void 0, { ...options, dbName: ns.db });
        this.options = { ...options };
        this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline;
        this.hasWriteStage = false;
        if (typeof options?.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options.out });
          this.hasWriteStage = true;
        } else if (pipeline.length > 0) {
          const finalStage = pipeline[pipeline.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.trySecondaryWrite = true;
        } else {
          delete this.options.writeConcern;
        }
        if (this.explain && this.writeConcern) {
          throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options?.cursor != null && typeof options.cursor !== "object") {
          throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
        }
      }
      get commandName() {
        return "aggregate";
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server2);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = void 0;
        }
        if (this.hasWriteStage && this.writeConcern) {
          write_concern_1.WriteConcern.apply(command, this.writeConcern);
        }
        if (options.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        if (typeof options.allowDiskUse === "boolean") {
          command.allowDiskUse = options.allowDiskUse;
        }
        if (options.hint) {
          command.hint = options.hint;
        }
        if (options.let) {
          command.let = options.let;
        }
        if (options.comment !== void 0) {
          command.comment = options.comment;
        }
        command.cursor = options.cursor || {};
        if (options.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options.batchSize;
        }
        return await super.executeCommand(server2, session, command, timeoutContext, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
      }
    };
    exports.AggregateOperation = AggregateOperation;
    (0, operation_1.defineAspects)(AggregateOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/aggregation_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregationCursor = void 0;
    var error_1 = require_error();
    var explain_1 = require_explain();
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils();
    var abstract_cursor_1 = require_abstract_cursor();
    var AggregationCursor = class _AggregationCursor extends explain_1.ExplainableCursor {
      /** @internal */
      constructor(client, namespace2, pipeline = [], options = {}) {
        super(client, namespace2, options);
        this.pipeline = pipeline;
        this.aggregateOptions = options;
        const lastStage = this.pipeline[this.pipeline.length - 1];
        if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (lastStage?.$merge != null || lastStage?.$out != null))
          throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);
        delete clonedOptions.session;
        return new _AggregationCursor(this.client, this.namespace, this.pipeline, {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      async _initialize(session) {
        const options = {
          ...this.aggregateOptions,
          ...this.cursorOptions,
          session,
          signal: this.signal
        };
        if (options.explain) {
          try {
            (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
          } catch {
            throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in aggregateOptions");
          }
        }
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options);
        const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);
        return { server: aggregateOperation.server, session, response };
      }
      async explain(verbosity, options) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
        return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
          ...this.aggregateOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        }))).shift(this.deserializationOptions);
      }
      addStage(stage) {
        this.throwIfInitialized();
        if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (stage.$out != null || stage.$merge != null)) {
          throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
        }
        this.pipeline.push(stage);
        return this;
      }
      group($group) {
        return this.addStage({ $group });
      }
      /** Add a limit stage to the aggregation pipeline */
      limit($limit) {
        return this.addStage({ $limit });
      }
      /** Add a match stage to the aggregation pipeline */
      match($match) {
        return this.addStage({ $match });
      }
      /** Add an out stage to the aggregation pipeline */
      out($out) {
        return this.addStage({ $out });
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.aggregate().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project($project) {
        return this.addStage({ $project });
      }
      /** Add a lookup stage to the aggregation pipeline */
      lookup($lookup) {
        return this.addStage({ $lookup });
      }
      /** Add a redact stage to the aggregation pipeline */
      redact($redact) {
        return this.addStage({ $redact });
      }
      /** Add a skip stage to the aggregation pipeline */
      skip($skip) {
        return this.addStage({ $skip });
      }
      /** Add a sort stage to the aggregation pipeline */
      sort($sort) {
        return this.addStage({ $sort });
      }
      /** Add a unwind stage to the aggregation pipeline */
      unwind($unwind) {
        return this.addStage({ $unwind });
      }
      /** Add a geoNear stage to the aggregation pipeline */
      geoNear($geoNear) {
        return this.addStage({ $geoNear });
      }
    };
    exports.AggregationCursor = AggregationCursor;
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var CountOperation = class extends command_1.CommandOperation {
      constructor(namespace2, filter2, options) {
        super({ s: { namespace: namespace2 } }, options);
        this.options = options;
        this.collectionName = namespace2.collection;
        this.query = filter2;
      }
      get commandName() {
        return "count";
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options;
        const cmd = {
          count: this.collectionName,
          query: this.query
        };
        if (typeof options.limit === "number") {
          cmd.limit = options.limit;
        }
        if (typeof options.skip === "number") {
          cmd.skip = options.skip;
        }
        if (options.hint != null) {
          cmd.hint = options.hint;
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        const result = await super.executeCommand(server2, session, cmd, timeoutContext);
        return result ? result.n : 0;
      }
    };
    exports.CountOperation = CountOperation;
    (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// node_modules/mongodb/lib/sort.js
var require_sort = __commonJS({
  "node_modules/mongodb/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatSort = formatSort;
    var error_1 = require_error();
    function prepareDirection(direction = 1) {
      const value = `${direction}`.toLowerCase();
      if (isMeta(direction))
        return direction;
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
      }
    }
    function isMeta(t) {
      return typeof t === "object" && t != null && "$meta" in t && typeof t.$meta === "string";
    }
    function isPair(t) {
      if (Array.isArray(t) && t.length === 2) {
        try {
          prepareDirection(t[1]);
          return true;
        } catch {
          return false;
        }
      }
      return false;
    }
    function isDeep(t) {
      return Array.isArray(t) && Array.isArray(t[0]);
    }
    function isMap(t) {
      return t instanceof Map && t.size > 0;
    }
    function pairToMap(v) {
      return /* @__PURE__ */ new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
    }
    function deepToMap(t) {
      const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
      return new Map(sortEntries);
    }
    function stringsToMap(t) {
      const sortEntries = t.map((key) => [`${key}`, 1]);
      return new Map(sortEntries);
    }
    function objectToMap(t) {
      const sortEntries = Object.entries(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function mapToMap(t) {
      const sortEntries = Array.from(t).map(([k, v]) => [
        `${k}`,
        prepareDirection(v)
      ]);
      return new Map(sortEntries);
    }
    function formatSort(sort, direction) {
      if (sort == null)
        return void 0;
      if (typeof sort === "string")
        return /* @__PURE__ */ new Map([[sort, prepareDirection(direction)]]);
      if (typeof sort !== "object") {
        throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
      }
      if (!Array.isArray(sort)) {
        return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : void 0;
      }
      if (!sort.length)
        return void 0;
      if (isDeep(sort))
        return deepToMap(sort);
      if (isPair(sort))
        return pairToMap(sort);
      return stringsToMap(sort);
    }
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FindOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var explain_1 = require_explain();
    var read_concern_1 = require_read_concern();
    var sort_1 = require_sort();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var FindOperation = class extends command_1.CommandOperation {
      constructor(ns, filter2 = {}, options = {}) {
        super(void 0, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.ns = ns;
        if (typeof filter2 !== "object" || Array.isArray(filter2)) {
          throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
        }
        this.filter = filter2 != null && filter2._bsontype === "ObjectId" ? { _id: filter2 } : filter2;
      }
      get commandName() {
        return "find";
      }
      async execute(server2, session, timeoutContext) {
        this.server = server2;
        const options = this.options;
        let findCommand = makeFindCommand(this.ns, this.filter, options);
        if (this.explain) {
          (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
          findCommand = (0, explain_1.decorateWithExplain)(findCommand, this.explain);
        }
        return await server2.command(this.ns, findCommand, {
          ...this.options,
          ...this.bsonOptions,
          documentsReturnedIn: "firstBatch",
          session,
          timeoutContext
        }, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
      }
    };
    exports.FindOperation = FindOperation;
    function makeFindCommand(ns, filter2, options) {
      const findCommand = {
        find: ns.collection,
        filter: filter2
      };
      if (options.sort) {
        findCommand.sort = (0, sort_1.formatSort)(options.sort);
      }
      if (options.projection) {
        let projection = options.projection;
        if (projection && Array.isArray(projection)) {
          projection = projection.length ? projection.reduce((result, field) => {
            result[field] = 1;
            return result;
          }, {}) : { _id: 1 };
        }
        findCommand.projection = projection;
      }
      if (options.hint) {
        findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
      }
      if (typeof options.skip === "number") {
        findCommand.skip = options.skip;
      }
      if (typeof options.limit === "number") {
        if (options.limit < 0) {
          findCommand.limit = -options.limit;
          findCommand.singleBatch = true;
        } else {
          findCommand.limit = options.limit;
        }
      }
      if (typeof options.batchSize === "number") {
        if (options.batchSize < 0) {
          if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
            findCommand.limit = -options.batchSize;
          }
          findCommand.singleBatch = true;
        } else {
          findCommand.batchSize = options.batchSize;
        }
      }
      if (typeof options.singleBatch === "boolean") {
        findCommand.singleBatch = options.singleBatch;
      }
      if (options.comment !== void 0) {
        findCommand.comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        findCommand.maxTimeMS = options.maxTimeMS;
      }
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        findCommand.readConcern = readConcern.toJSON();
      }
      if (options.max) {
        findCommand.max = options.max;
      }
      if (options.min) {
        findCommand.min = options.min;
      }
      if (typeof options.returnKey === "boolean") {
        findCommand.returnKey = options.returnKey;
      }
      if (typeof options.showRecordId === "boolean") {
        findCommand.showRecordId = options.showRecordId;
      }
      if (typeof options.tailable === "boolean") {
        findCommand.tailable = options.tailable;
      }
      if (typeof options.oplogReplay === "boolean") {
        findCommand.oplogReplay = options.oplogReplay;
      }
      if (typeof options.timeout === "boolean") {
        findCommand.noCursorTimeout = !options.timeout;
      } else if (typeof options.noCursorTimeout === "boolean") {
        findCommand.noCursorTimeout = options.noCursorTimeout;
      }
      if (typeof options.awaitData === "boolean") {
        findCommand.awaitData = options.awaitData;
      }
      if (typeof options.allowPartialResults === "boolean") {
        findCommand.allowPartialResults = options.allowPartialResults;
      }
      if (options.collation) {
        findCommand.collation = options.collation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options.allowDiskUse;
      }
      if (options.let) {
        findCommand.let = options.let;
      }
      return findCommand;
    }
    (0, operation_1.defineAspects)(FindOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/find_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FindCursor = exports.FLAGS = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var explain_1 = require_explain();
    var count_1 = require_count();
    var execute_operation_1 = require_execute_operation();
    var find_1 = require_find();
    var sort_1 = require_sort();
    var utils_1 = require_utils();
    exports.FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    var FindCursor = class _FindCursor extends explain_1.ExplainableCursor {
      /** @internal */
      constructor(client, namespace2, filter2 = {}, options = {}) {
        super(client, namespace2, options);
        this.numReturned = 0;
        this.cursorFilter = filter2;
        this.findOptions = options;
        if (options.sort != null) {
          this.findOptions.sort = (0, sort_1.formatSort)(options.sort);
        }
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
        delete clonedOptions.session;
        return new _FindCursor(this.client, this.namespace, this.cursorFilter, {
          ...clonedOptions
        });
      }
      map(transform) {
        return super.map(transform);
      }
      /** @internal */
      async _initialize(session) {
        const options = {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          session,
          signal: this.signal
        };
        if (options.explain) {
          try {
            (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
          } catch {
            throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in findOptions");
          }
        }
        const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, options);
        const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation, this.timeoutContext);
        this.numReturned = response.batchSize;
        return { server: findOperation.server, session, response };
      }
      /** @internal */
      async getMore(batchSize) {
        const numReturned = this.numReturned;
        if (numReturned) {
          const limit = this.findOptions.limit;
          batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
          if (batchSize <= 0) {
            try {
              await this.close();
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
            return responses_1.CursorResponse.emptyGetMore;
          }
        }
        const response = await super.getMore(batchSize);
        this.numReturned = this.numReturned + response.batchSize;
        return response;
      }
      /**
       * Get the count of documents for this cursor
       * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead
       */
      async count(options) {
        (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
        if (typeof options === "boolean") {
          throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
        }
        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...options
        }));
      }
      async explain(verbosity, options) {
        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
        return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
          ...this.findOptions,
          // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        }))).shift(this.deserializationOptions);
      }
      /** Set the cursor query */
      filter(filter2) {
        this.throwIfInitialized();
        this.cursorFilter = filter2;
        return this;
      }
      /**
       * Set the cursor hint
       *
       * @param hint - If specified, then the query system will only consider plans using the hinted index.
       */
      hint(hint) {
        this.throwIfInitialized();
        this.findOptions.hint = hint;
        return this;
      }
      /**
       * Set the cursor min
       *
       * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
       */
      min(min) {
        this.throwIfInitialized();
        this.findOptions.min = min;
        return this;
      }
      /**
       * Set the cursor max
       *
       * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
       */
      max(max) {
        this.throwIfInitialized();
        this.findOptions.max = max;
        return this;
      }
      /**
       * Set the cursor returnKey.
       * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.
       * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.
       *
       * @param value - the returnKey value.
       */
      returnKey(value) {
        this.throwIfInitialized();
        this.findOptions.returnKey = value;
        return this;
      }
      /**
       * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.
       *
       * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
       */
      showRecordId(value) {
        this.throwIfInitialized();
        this.findOptions.showRecordId = value;
        return this;
      }
      /**
       * Add a query modifier to the cursor query
       *
       * @param name - The query modifier (must start with $, such as $orderby etc)
       * @param value - The modifier value.
       */
      addQueryModifier(name, value) {
        this.throwIfInitialized();
        if (name[0] !== "$") {
          throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
        }
        const field = name.substr(1);
        switch (field) {
          case "comment":
            this.findOptions.comment = value;
            break;
          case "explain":
            this.findOptions.explain = value;
            break;
          case "hint":
            this.findOptions.hint = value;
            break;
          case "max":
            this.findOptions.max = value;
            break;
          case "maxTimeMS":
            this.findOptions.maxTimeMS = value;
            break;
          case "min":
            this.findOptions.min = value;
            break;
          case "orderby":
            this.findOptions.sort = (0, sort_1.formatSort)(value);
            break;
          case "query":
            this.cursorFilter = value;
            break;
          case "returnKey":
            this.findOptions.returnKey = value;
            break;
          case "showDiskLoc":
            this.findOptions.showRecordId = value;
            break;
          default:
            throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
        }
        return this;
      }
      /**
       * Add a comment to the cursor query allowing for tracking the comment in the log.
       *
       * @param value - The comment attached to this query.
       */
      comment(value) {
        this.throwIfInitialized();
        this.findOptions.comment = value;
        return this;
      }
      /**
       * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
       *
       * @param value - Number of milliseconds to wait before aborting the tailed query.
       */
      maxAwaitTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
        }
        this.findOptions.maxAwaitTimeMS = value;
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this.findOptions.maxTimeMS = value;
        return this;
      }
      /**
       * Add a project stage to the aggregation pipeline
       *
       * @remarks
       * In order to strictly type this function you must provide an interface
       * that represents the effect of your projection on the result documents.
       *
       * By default chaining a projection to your cursor changes the returned type to the generic
       * {@link Document} type.
       * You should specify a parameterized type to have assertions on your final results.
       *
       * @example
       * ```typescript
       * // Best way
       * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
       * // Flexible way
       * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });
       * ```
       *
       * @remarks
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling project,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<{ a: number; b: string }> = coll.find();
       * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
       * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
       *
       * // or always use chaining and save the final cursor
       *
       * const cursor = coll.find().project<{ a: string }>({
       *   _id: 0,
       *   a: { $convert: { input: '$a', to: 'string' }
       * }});
       * ```
       */
      project(value) {
        this.throwIfInitialized();
        this.findOptions.projection = value;
        return this;
      }
      /**
       * Sets the sort order of the cursor query.
       *
       * @param sort - The key or keys set for the sort.
       * @param direction - The direction of the sorting (1 or -1).
       */
      sort(sort, direction) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
        }
        this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
        return this;
      }
      /**
       * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)
       *
       * @remarks
       * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}
       */
      allowDiskUse(allow = true) {
        this.throwIfInitialized();
        if (!this.findOptions.sort) {
          throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
        }
        if (!allow) {
          this.findOptions.allowDiskUse = false;
          return this;
        }
        this.findOptions.allowDiskUse = true;
        return this;
      }
      /**
       * Set the collation options for the cursor.
       *
       * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
       */
      collation(value) {
        this.throwIfInitialized();
        this.findOptions.collation = value;
        return this;
      }
      /**
       * Set the limit for the cursor.
       *
       * @param value - The limit for the cursor query.
       */
      limit(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
        }
        this.findOptions.limit = value;
        return this;
      }
      /**
       * Set the skip for the cursor.
       *
       * @param value - The skip for the cursor query.
       */
      skip(value) {
        this.throwIfInitialized();
        if (this.findOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
        }
        this.findOptions.skip = value;
        return this;
      }
    };
    exports.FindCursor = FindCursor;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListIndexesOperation = exports.DropIndexOperation = exports.CreateIndexesOperation = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var VALID_INDEX_OPTIONS = /* @__PURE__ */ new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "hidden",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "version",
      // text indexes
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      // 2d-sphere indexes
      "2dsphereIndexVersion",
      // 2d indexes
      "bits",
      "min",
      "max",
      // geoHaystack Indexes
      "bucketSize",
      // wildcard indexes
      "wildcardProjection"
    ]);
    function isIndexDirection(x) {
      return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
    }
    function isSingleIndexTuple(t) {
      return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
    }
    function constructIndexDescriptionMap(indexSpec) {
      const key = /* @__PURE__ */ new Map();
      const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
      for (const spec of indexSpecs) {
        if (typeof spec === "string") {
          key.set(spec, 1);
        } else if (Array.isArray(spec)) {
          key.set(spec[0], spec[1] ?? 1);
        } else if (spec instanceof Map) {
          for (const [property2, value] of spec) {
            key.set(property2, value);
          }
        } else if ((0, utils_1.isObject)(spec)) {
          for (const [property2, value] of Object.entries(spec)) {
            key.set(property2, value);
          }
        }
      }
      return key;
    }
    function resolveIndexDescription(description) {
      const validProvidedOptions = Object.entries(description).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName));
      return Object.fromEntries(
        // we support the `version` option, but the `createIndexes` command expects it to be the `v`
        validProvidedOptions.map(([name, value]) => name === "version" ? ["v", value] : [name, value])
      );
    }
    var CreateIndexesOperation = class _CreateIndexesOperation extends command_1.CommandOperation {
      constructor(parent, collectionName, indexes, options) {
        super(parent, options);
        this.options = options ?? {};
        this.collectionName = collectionName;
        this.indexes = indexes.map((userIndex) => {
          const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
          const name = userIndex.name ?? Array.from(key).flat().join("_");
          const validIndexOptions = resolveIndexDescription(userIndex);
          return {
            ...validIndexOptions,
            name,
            key
          };
        });
      }
      static fromIndexDescriptionArray(parent, collectionName, indexes, options) {
        return new _CreateIndexesOperation(parent, collectionName, indexes, options);
      }
      static fromIndexSpecification(parent, collectionName, indexSpec, options = {}) {
        const key = constructIndexDescriptionMap(indexSpec);
        const description = { ...options, key };
        return new _CreateIndexesOperation(parent, collectionName, [description], options);
      }
      get commandName() {
        return "createIndexes";
      }
      async execute(server2, session, timeoutContext) {
        const options = this.options;
        const indexes = this.indexes;
        const serverWireVersion = (0, utils_1.maxWireVersion)(server2);
        const cmd = { createIndexes: this.collectionName, indexes };
        if (options.commitQuorum != null) {
          if (serverWireVersion < 9) {
            throw new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4");
          }
          cmd.commitQuorum = options.commitQuorum;
        }
        this.options.collation = void 0;
        await super.executeCommand(server2, session, cmd, timeoutContext);
        const indexNames = indexes.map((index) => index.name || "");
        return indexNames;
      }
    };
    exports.CreateIndexesOperation = CreateIndexesOperation;
    var DropIndexOperation = class extends command_1.CommandOperation {
      constructor(collection, indexName, options) {
        super(collection, options);
        this.options = options ?? {};
        this.collection = collection;
        this.indexName = indexName;
      }
      get commandName() {
        return "dropIndexes";
      }
      async execute(server2, session, timeoutContext) {
        const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
        return await super.executeCommand(server2, session, cmd, timeoutContext);
      }
    };
    exports.DropIndexOperation = DropIndexOperation;
    var ListIndexesOperation = class extends command_1.CommandOperation {
      constructor(collection, options) {
        super(collection, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.collectionNamespace = collection.s.namespace;
      }
      get commandName() {
        return "listIndexes";
      }
      async execute(server2, session, timeoutContext) {
        const serverWireVersion = (0, utils_1.maxWireVersion)(server2);
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        const command = { listIndexes: this.collectionNamespace.collection, cursor };
        if (serverWireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return await super.executeCommand(server2, session, command, timeoutContext, responses_1.CursorResponse);
      }
    };
    exports.ListIndexesOperation = ListIndexesOperation;
    (0, operation_1.defineAspects)(ListIndexesOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
    (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_indexes_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListIndexesCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListIndexesCursor = class _ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
      constructor(collection, options) {
        super(collection.client, collection.s.namespace, options);
        this.parent = collection;
        this.options = options;
      }
      clone() {
        return new _ListIndexesCursor(this.parent, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new indexes_1.ListIndexesOperation(this.parent, {
          ...this.cursorOptions,
          ...this.options,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
        return { server: operation.server, session, response };
      }
    };
    exports.ListIndexesCursor = ListIndexesCursor;
  }
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListSearchIndexesCursor = void 0;
    var aggregation_cursor_1 = require_aggregation_cursor();
    var ListSearchIndexesCursor = class extends aggregation_cursor_1.AggregationCursor {
      /** @internal */
      constructor({ fullNamespace: ns, client }, name, options = {}) {
        const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
        super(client, ns, pipeline, options);
      }
    };
    exports.ListSearchIndexesCursor = ListSearchIndexesCursor;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DistinctOperation = void 0;
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DistinctOperation = class extends command_1.CommandOperation {
      /**
       * Construct a Distinct operation.
       *
       * @param collection - Collection instance.
       * @param key - Field of the document to find distinct values for.
       * @param query - The query for filtering the set of documents to which we apply the distinct filter.
       * @param options - Optional settings. See Collection.prototype.distinct for a list of options.
       */
      constructor(collection, key, query2, options) {
        super(collection, options);
        this.options = options ?? {};
        this.collection = collection;
        this.key = key;
        this.query = query2;
      }
      get commandName() {
        return "distinct";
      }
      async execute(server2, session, timeoutContext) {
        const coll = this.collection;
        const key = this.key;
        const query2 = this.query;
        const options = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query: query2
        };
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.comment !== "undefined") {
          cmd.comment = options.comment;
        }
        if (options.hint != null) {
          cmd.hint = options.hint;
        }
        (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
        const result = await super.executeCommand(server2, session, cmd, timeoutContext);
        return this.explain ? result : result.values;
      }
    };
    exports.DistinctOperation = DistinctOperation;
    (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DropCollectionOperation = class _DropCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options = {}) {
        super(db, options);
        this.db = db;
        this.options = options;
        this.name = name;
      }
      get commandName() {
        return "drop";
      }
      async execute(server2, session, timeoutContext) {
        const db = this.db;
        const options = this.options;
        const name = this.name;
        const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;
        let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (!encryptedFields && encryptedFieldsMap) {
          const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
          encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
        }
        if (encryptedFields) {
          const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const dropOp = new _DropCollectionOperation(db, collectionName);
            try {
              await dropOp.executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext);
            } catch (err) {
              if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
                throw err;
              }
            }
          }
        }
        return await this.executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext);
      }
      async executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext) {
        await super.executeCommand(server2, session, { drop: this.name }, timeoutContext);
        return true;
      }
    };
    exports.DropCollectionOperation = DropCollectionOperation;
    var DropDatabaseOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      get commandName() {
        return "dropDatabase";
      }
      async execute(server2, session, timeoutContext) {
        await super.executeCommand(server2, session, { dropDatabase: 1 }, timeoutContext);
        return true;
      }
    };
    exports.DropDatabaseOperation = DropDatabaseOperation;
    (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
    (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EstimatedDocumentCountOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var EstimatedDocumentCountOperation = class extends command_1.CommandOperation {
      constructor(collection, options = {}) {
        super(collection, options);
        this.options = options;
        this.collectionName = collection.collectionName;
      }
      get commandName() {
        return "count";
      }
      async execute(server2, session, timeoutContext) {
        const cmd = { count: this.collectionName };
        if (typeof this.options.maxTimeMS === "number") {
          cmd.maxTimeMS = this.options.maxTimeMS;
        }
        if (this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        const response = await super.executeCommand(server2, session, cmd, timeoutContext);
        return response?.n || 0;
      }
    };
    exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
    (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = exports.ReturnDocument = void 0;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var sort_1 = require_sort();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    exports.ReturnDocument = Object.freeze({
      BEFORE: "before",
      AFTER: "after"
    });
    function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
      cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
      cmdBase.upsert = options.upsert === true;
      if (options.bypassDocumentValidation === true) {
        cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      return cmdBase;
    }
    var FindAndModifyOperation = class extends command_1.CommandOperation {
      constructor(collection, query2, options) {
        super(collection, options);
        this.options = options ?? {};
        this.cmdBase = {
          remove: false,
          new: false,
          upsert: false
        };
        options.includeResultMetadata ?? (options.includeResultMetadata = false);
        const sort = (0, sort_1.formatSort)(options.sort);
        if (sort) {
          this.cmdBase.sort = sort;
        }
        if (options.projection) {
          this.cmdBase.fields = options.projection;
        }
        if (options.maxTimeMS) {
          this.cmdBase.maxTimeMS = options.maxTimeMS;
        }
        if (options.writeConcern) {
          this.cmdBase.writeConcern = options.writeConcern;
        }
        if (options.let) {
          this.cmdBase.let = options.let;
        }
        if (options.comment !== void 0) {
          this.cmdBase.comment = options.comment;
        }
        this.readPreference = read_preference_1.ReadPreference.primary;
        this.collection = collection;
        this.query = query2;
      }
      get commandName() {
        return "findAndModify";
      }
      async execute(server2, session, timeoutContext) {
        const coll = this.collection;
        const query2 = this.query;
        const options = { ...this.options, ...this.bsonOptions };
        const cmd = {
          findAndModify: coll.collectionName,
          query: query2,
          ...this.cmdBase
        };
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
        if (options.hint) {
          const unacknowledgedWrite = this.writeConcern?.w === 0;
          if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server2) < 8) {
            throw new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands");
          }
          cmd.hint = options.hint;
        }
        const result = await super.executeCommand(server2, session, cmd, timeoutContext);
        return options.includeResultMetadata ? result : result.value ?? null;
      }
    };
    exports.FindAndModifyOperation = FindAndModifyOperation;
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, options) {
        if (filter2 == null || typeof filter2 !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        super(collection, filter2, options);
        this.cmdBase.remove = true;
      }
    };
    exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, replacement, options) {
        if (filter2 == null || typeof filter2 !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
        }
        if ((0, utils_1.hasAtomicOperators)(replacement)) {
          throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
        }
        super(collection, filter2, options);
        this.cmdBase.update = replacement;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      }
    };
    exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, update, options) {
        if (filter2 == null || typeof filter2 !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
        }
        if (update == null || typeof update !== "object") {
          throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
        }
        if (!(0, utils_1.hasAtomicOperators)(update)) {
          throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
        }
        super(collection, filter2, options);
        this.cmdBase.update = update;
        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
        if (options.arrayFilters) {
          this.cmdBase.arrayFilters = options.arrayFilters;
        }
      }
    };
    exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
    (0, operation_1.defineAspects)(FindAndModifyOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.EXPLAINABLE
    ]);
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsCappedOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var IsCappedOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options) {
        super(options);
        this.options = options;
        this.collection = collection;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server2, session) {
        const coll = this.collection;
        const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
        if (collection == null || collection.options == null) {
          throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
        }
        return !!collection.options?.capped;
      }
    };
    exports.IsCappedOperation = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OptionsOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var OptionsOperation = class extends operation_1.AbstractOperation {
      constructor(collection, options) {
        super(options);
        this.options = options;
        this.collection = collection;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server2, session) {
        const coll = this.collection;
        const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
        if (collection == null || collection.options == null) {
          throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
        }
        return collection.options;
      }
    };
    exports.OptionsOperation = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RenameOperation = void 0;
    var collection_1 = require_collection();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var RenameOperation = class extends command_1.CommandOperation {
      constructor(collection, newName, options) {
        super(collection, options);
        this.collection = collection;
        this.newName = newName;
        this.options = options;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "renameCollection";
      }
      async execute(server2, session, timeoutContext) {
        const renameCollection = this.collection.namespace;
        const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
        const dropTarget = typeof this.options.dropTarget === "boolean" ? this.options.dropTarget : false;
        const command = {
          renameCollection,
          to: toCollection,
          dropTarget
        };
        await super.executeCommand(server2, session, command, timeoutContext);
        return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
      }
    };
    exports.RenameOperation = RenameOperation;
    (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/create.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateSearchIndexesOperation = void 0;
    var operation_1 = require_operation();
    var CreateSearchIndexesOperation = class extends operation_1.AbstractOperation {
      constructor(collection, descriptions) {
        super();
        this.collection = collection;
        this.descriptions = descriptions;
      }
      get commandName() {
        return "createSearchIndexes";
      }
      async execute(server2, session, timeoutContext) {
        const namespace2 = this.collection.fullNamespace;
        const command = {
          createSearchIndexes: namespace2.collection,
          indexes: this.descriptions
        };
        const res = await server2.command(namespace2, command, {
          session,
          timeoutContext
        });
        const indexesCreated = res?.indexesCreated ?? [];
        return indexesCreated.map(({ name }) => name);
      }
    };
    exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/drop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DropSearchIndexOperation = void 0;
    var error_1 = require_error();
    var operation_1 = require_operation();
    var DropSearchIndexOperation = class extends operation_1.AbstractOperation {
      constructor(collection, name) {
        super();
        this.collection = collection;
        this.name = name;
      }
      get commandName() {
        return "dropSearchIndex";
      }
      async execute(server2, session, timeoutContext) {
        const namespace2 = this.collection.fullNamespace;
        const command = {
          dropSearchIndex: namespace2.collection
        };
        if (typeof this.name === "string") {
          command.name = this.name;
        }
        try {
          await server2.command(namespace2, command, { session, timeoutContext });
        } catch (error2) {
          const isNamespaceNotFoundError = error2 instanceof error_1.MongoServerError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
          if (!isNamespaceNotFoundError) {
            throw error2;
          }
        }
      }
    };
    exports.DropSearchIndexOperation = DropSearchIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update2 = __commonJS({
  "node_modules/mongodb/lib/operations/search_indexes/update.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdateSearchIndexOperation = void 0;
    var operation_1 = require_operation();
    var UpdateSearchIndexOperation = class extends operation_1.AbstractOperation {
      constructor(collection, name, definition) {
        super();
        this.collection = collection;
        this.name = name;
        this.definition = definition;
      }
      get commandName() {
        return "updateSearchIndex";
      }
      async execute(server2, session, timeoutContext) {
        const namespace2 = this.collection.fullNamespace;
        const command = {
          updateSearchIndex: namespace2.collection,
          name: this.name,
          definition: this.definition
        };
        await server2.command(namespace2, command, { session, timeoutContext });
        return;
      }
    };
    exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Collection = void 0;
    var bson_1 = require_bson2();
    var ordered_1 = require_ordered();
    var unordered_1 = require_unordered();
    var change_stream_1 = require_change_stream();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var find_cursor_1 = require_find_cursor();
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
    var error_1 = require_error();
    var bulk_write_1 = require_bulk_write();
    var count_1 = require_count();
    var delete_1 = require_delete();
    var distinct_1 = require_distinct();
    var drop_1 = require_drop();
    var estimated_document_count_1 = require_estimated_document_count();
    var execute_operation_1 = require_execute_operation();
    var find_and_modify_1 = require_find_and_modify();
    var indexes_1 = require_indexes();
    var insert_1 = require_insert();
    var is_capped_1 = require_is_capped();
    var options_operation_1 = require_options_operation();
    var rename_1 = require_rename();
    var create_1 = require_create();
    var drop_2 = require_drop2();
    var update_1 = require_update2();
    var update_2 = require_update();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var Collection = class {
      /**
       * Create a new Collection instance
       * @internal
       */
      constructor(db, name, options) {
        this.s = {
          db,
          options,
          namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
          pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
          readPreference: read_preference_1.ReadPreference.fromOptions(options),
          bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
          readConcern: read_concern_1.ReadConcern.fromOptions(options),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options)
        };
        this.client = db.client;
      }
      /**
       * The name of the database this collection belongs to
       */
      get dbName() {
        return this.s.namespace.db;
      }
      /**
       * The name of this collection
       */
      get collectionName() {
        return this.s.namespace.collection;
      }
      /**
       * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`
       */
      get namespace() {
        return this.fullNamespace.toString();
      }
      /**
       *  @internal
       *
       * The `MongoDBNamespace` for the collection.
       */
      get fullNamespace() {
        return this.s.namespace;
      }
      /**
       * The current readConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readConcern() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      /**
       * The current writeConcern of the collection. If not explicitly defined for
       * this collection, will be inherited from the parent DB
       */
      get writeConcern() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
      /** The current index hint for the collection */
      get hint() {
        return this.s.collectionHint;
      }
      set hint(v) {
        this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
      }
      get timeoutMS() {
        return this.s.options.timeoutMS;
      }
      /**
       * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param doc - The document to insert
       * @param options - Optional settings for the command
       */
      async insertOne(doc, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param docs - The documents to insert
       * @param options - Optional settings for the command
       */
      async insertMany(docs, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
      }
      /**
       * Perform a bulkWrite operation without a fluent API
       *
       * Legal operation types are
       * - `insertOne`
       * - `replaceOne`
       * - `updateOne`
       * - `updateMany`
       * - `deleteOne`
       * - `deleteMany`
       *
       * If documents passed in do not contain the **_id** field,
       * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
       * can be overridden by setting the **forceServerObjectId** flag.
       *
       * @param operations - Bulk operations to perform
       * @param options - Optional settings for the command
       * @throws MongoDriverError if operations is not an array
       */
      async bulkWrite(operations, options) {
        if (!Array.isArray(operations)) {
          throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
        }
        return await (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
      }
      /**
       * Update a single document in a collection
       *
       * The value of `update` can be either:
       * - UpdateFilter<TSchema> - A document that contains update operator expressions,
       * - Document[] - an aggregation pipeline.
       *
       * @param filter - The filter used to select the document to update
       * @param update - The modifications to apply
       * @param options - Optional settings for the command
       */
      async updateOne(filter2, update, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter2, update, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Replace a document in a collection with another document
       *
       * @param filter - The filter used to select the document to replace
       * @param replacement - The Document that replaces the matching document
       * @param options - Optional settings for the command
       */
      async replaceOne(filter2, replacement, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter2, replacement, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Update multiple documents in a collection
       *
       * The value of `update` can be either:
       * - UpdateFilter<TSchema> - A document that contains update operator expressions,
       * - Document[] - an aggregation pipeline.
       *
       * @param filter - The filter used to select the document to update
       * @param update - The modifications to apply
       * @param options - Optional settings for the command
       */
      async updateMany(filter2, update, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter2, update, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Delete a document from a collection
       *
       * @param filter - The filter used to select the document to remove
       * @param options - Optional settings for the command
       */
      async deleteOne(filter2 = {}, options = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter2, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Delete multiple documents from a collection
       *
       * @param filter - The filter used to select the documents to remove
       * @param options - Optional settings for the command
       */
      async deleteMany(filter2 = {}, options = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter2, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Rename the collection.
       *
       * @remarks
       * This operation does not inherit options from the Db or MongoClient.
       *
       * @param newName - New name of of the collection.
       * @param options - Optional settings for the command
       */
      async rename(newName, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, (0, utils_1.resolveOptions)(void 0, {
          ...options,
          readPreference: read_preference_1.ReadPreference.PRIMARY
        })));
      }
      /**
       * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
       *
       * @param options - Optional settings for the command
       */
      async drop(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
      }
      async findOne(filter2 = {}, options = {}) {
        const cursor = this.find(filter2, options).limit(-1).batchSize(1);
        const res = await cursor.next();
        await cursor.close();
        return res;
      }
      find(filter2 = {}, options = {}) {
        return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter2, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Returns the options of the collection.
       *
       * @param options - Optional settings for the command
       */
      async options(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Returns if the collection is a capped collection
       *
       * @param options - Optional settings for the command
       */
      async isCapped(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Creates an index on the db and collection collection.
       *
       * @param indexSpec - The field name or index specification to create an index for
       * @param options - Optional settings for the command
       *
       * @example
       * ```ts
       * const collection = client.db('foo').collection('bar');
       *
       * await collection.createIndex({ a: 1, b: -1 });
       *
       * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes
       * await collection.createIndex([ [c, 1], [d, -1] ]);
       *
       * // Equivalent to { e: 1 }
       * await collection.createIndex('e');
       *
       * // Equivalent to { f: 1, g: 1 }
       * await collection.createIndex(['f', 'g'])
       *
       * // Equivalent to { h: 1, i: -1 }
       * await collection.createIndex([ { h: 1 }, { i: -1 } ]);
       *
       * // Equivalent to { j: 1, k: -1, l: 2d }
       * await collection.createIndex(['j', ['k', -1], { l: '2d' }])
       * ```
       */
      async createIndex(indexSpec, options) {
        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
        return indexes[0];
      }
      /**
       * Creates multiple indexes in the collection, this method is only supported for
       * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
       * error.
       *
       * **Note**: Unlike {@link Collection#createIndex| createIndex}, this function takes in raw index specifications.
       * Index specifications are defined {@link https://www.mongodb.com/docs/manual/reference/command/createIndexes/| here}.
       *
       * @param indexSpecs - An array of index specifications to be created
       * @param options - Optional settings for the command
       *
       * @example
       * ```ts
       * const collection = client.db('foo').collection('bar');
       * await collection.createIndexes([
       *   // Simple index on field fizz
       *   {
       *     key: { fizz: 1 },
       *   }
       *   // wildcard index
       *   {
       *     key: { '$**': 1 }
       *   },
       *   // named index on darmok and jalad
       *   {
       *     key: { darmok: 1, jalad: -1 }
       *     name: 'tanagra'
       *   }
       * ]);
       * ```
       */
      async createIndexes(indexSpecs, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: void 0 })));
      }
      /**
       * Drops an index from this collection.
       *
       * @param indexName - Name of the index to drop.
       * @param options - Optional settings for the command
       */
      async dropIndex(indexName, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
          ...(0, utils_1.resolveOptions)(this, options),
          readPreference: read_preference_1.ReadPreference.primary
        }));
      }
      /**
       * Drops all indexes from this collection.
       *
       * @param options - Optional settings for the command
       */
      async dropIndexes(options) {
        try {
          await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, "*", (0, utils_1.resolveOptions)(this, options)));
          return true;
        } catch (error2) {
          if (error2 instanceof error_1.MongoOperationTimeoutError)
            throw error2;
          return false;
        }
      }
      /**
       * Get the list of all indexes information for the collection.
       *
       * @param options - Optional settings for the command
       */
      listIndexes(options) {
        return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Checks if one or more indexes exist on the collection, fails on first non-existing index
       *
       * @param indexes - One or more index names to check.
       * @param options - Optional settings for the command
       */
      async indexExists(indexes, options) {
        const indexNames = Array.isArray(indexes) ? indexes : [indexes];
        const allIndexes = new Set(await this.listIndexes(options).map(({ name }) => name).toArray());
        return indexNames.every((name) => allIndexes.has(name));
      }
      async indexInformation(options) {
        return await this.indexes({
          ...options,
          full: options?.full ?? false
        });
      }
      /**
       * Gets an estimate of the count of documents in a collection using collection metadata.
       * This will always run a count command on all server versions.
       *
       * due to an oversight in versions 5.0.0-5.0.8 of MongoDB, the count command,
       * which estimatedDocumentCount uses in its implementation, was not included in v1 of
       * the Stable API, and so users of the Stable API with estimatedDocumentCount are
       * recommended to upgrade their server version to 5.0.9+ or set apiStrict: false to avoid
       * encountering errors.
       *
       * @see {@link https://www.mongodb.com/docs/manual/reference/command/count/#behavior|Count: Behavior}
       * @param options - Optional settings for the command
       */
      async estimatedDocumentCount(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Gets the number of documents matching the filter.
       * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
       *
       * Due to countDocuments using the $match aggregation pipeline stage, certain query operators cannot be used in countDocuments. This includes the $where and $near query operators, among others. Details can be found in the documentation for the $match aggregation pipeline stage.
       *
       * **Note**: When migrating from {@link Collection#count| count} to {@link Collection#countDocuments| countDocuments}
       * the following query operators must be replaced:
       *
       * | Operator | Replacement |
       * | -------- | ----------- |
       * | `$where`   | [`$expr`][1] |
       * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |
       * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |
       *
       * [1]: https://www.mongodb.com/docs/manual/reference/operator/query/expr/
       * [2]: https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
       * [3]: https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
       * [4]: https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
       *
       * @param filter - The filter for the count
       * @param options - Optional settings for the command
       *
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/expr/
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center
       * @see https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere
       */
      async countDocuments(filter2 = {}, options = {}) {
        const pipeline = [];
        pipeline.push({ $match: filter2 });
        if (typeof options.skip === "number") {
          pipeline.push({ $skip: options.skip });
        }
        if (typeof options.limit === "number") {
          pipeline.push({ $limit: options.limit });
        }
        pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
        const cursor = this.aggregate(pipeline, options);
        const doc = await cursor.next();
        await cursor.close();
        return doc?.n ?? 0;
      }
      async distinct(key, filter2 = {}, options = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter2, (0, utils_1.resolveOptions)(this, options)));
      }
      async indexes(options) {
        const indexes = await this.listIndexes(options).toArray();
        const full = options?.full ?? true;
        if (full) {
          return indexes;
        }
        const object = Object.fromEntries(indexes.map(({ name, key }) => [name, Object.entries(key)]));
        return object;
      }
      async findOneAndDelete(filter2, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter2, (0, utils_1.resolveOptions)(this, options)));
      }
      async findOneAndReplace(filter2, replacement, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter2, replacement, (0, utils_1.resolveOptions)(this, options)));
      }
      async findOneAndUpdate(filter2, update, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter2, update, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Execute an aggregation framework pipeline against the collection, needs MongoDB \>= 2.2
       *
       * @param pipeline - An array of aggregation pipelines to execute
       * @param options - Optional settings for the command
       */
      aggregate(pipeline = [], options) {
        if (!Array.isArray(pipeline)) {
          throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
        }
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to override the schema that may be defined for this specific collection
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       * @example
       * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`
       * ```ts
       * collection.watch<{ _id: number }>()
       *   .on('change', change => console.log(change._id.toFixed(4)));
       * ```
       *
       * @example
       * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.
       * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.
       * No need start from scratch on the ChangeStreamInsertDocument type!
       * By using an intersection we can save time and ensure defaults remain the same type!
       * ```ts
       * collection
       *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([
       *     { $addFields: { comment: 'big changes' } },
       *     { $match: { operationType: 'insert' } }
       *   ])
       *   .on('change', change => {
       *     change.comment.startsWith('big');
       *     change.operationType === 'insert';
       *     // No need to narrow in code because the generics did that for us!
       *     expectType<Schema>(change.fullDocument);
       *   });
       * ```
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       *
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TLocal - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
          options = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeUnorderedBulkOp(options) {
        return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.
       *
       * @throws MongoNotConnectedError
       * @remarks
       * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implementation.
       * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.
       */
      initializeOrderedBulkOp(options) {
        return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * An estimated count of matching documents in the db to a filter.
       *
       * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents
       * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments| countDocuments}.
       * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount| estimatedDocumentCount}.
       *
       * @deprecated use {@link Collection#countDocuments| countDocuments} or {@link Collection#estimatedDocumentCount| estimatedDocumentCount} instead
       *
       * @param filter - The filter for the count.
       * @param options - Optional settings for the command
       */
      async count(filter2 = {}, options = {}) {
        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter2, (0, utils_1.resolveOptions)(this, options)));
      }
      listSearchIndexes(indexNameOrOptions, options) {
        options = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options == null ? {} : options;
        const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
        return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
      }
      /**
       * Creates a single search index for the collection.
       *
       * @param description - The index description for the new search index.
       * @returns A promise that resolves to the name of the new search index.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async createSearchIndex(description) {
        const [index] = await this.createSearchIndexes([description]);
        return index;
      }
      /**
       * Creates multiple search indexes for the current collection.
       *
       * @param descriptions - An array of `SearchIndexDescription`s for the new search indexes.
       * @returns A promise that resolves to an array of the newly created search index names.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       * @returns
       */
      async createSearchIndexes(descriptions) {
        return await (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
      }
      /**
       * Deletes a search index by index name.
       *
       * @param name - The name of the search index to be deleted.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async dropSearchIndex(name) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
      }
      /**
       * Updates a search index by replacing the existing index definition with the provided definition.
       *
       * @param name - The name of the search index to update.
       * @param definition - The new search index definition.
       *
       * @remarks Only available when used against a 7.0+ Atlas cluster.
       */
      async updateSearchIndex(name, definition) {
        return await (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
      }
    };
    exports.Collection = Collection;
  }
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/change_stream_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangeStreamCursor = void 0;
    var change_stream_1 = require_change_stream();
    var constants_1 = require_constants2();
    var aggregate_1 = require_aggregate();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils();
    var abstract_cursor_1 = require_abstract_cursor();
    var ChangeStreamCursor = class _ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
      constructor(client, namespace2, pipeline = [], options = {}) {
        super(client, namespace2, { ...options, tailable: true, awaitData: true });
        this.pipeline = pipeline;
        this.changeStreamCursorOptions = options;
        this._resumeToken = null;
        this.startAtOperationTime = options.startAtOperationTime ?? null;
        if (options.startAfter) {
          this.resumeToken = options.startAfter;
        } else if (options.resumeAfter) {
          this.resumeToken = options.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const options = {
          ...this.changeStreamCursorOptions
        };
        for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
          delete options[key];
        }
        if (this.resumeToken != null) {
          if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
            options.startAfter = this.resumeToken;
          } else {
            options.resumeAfter = this.resumeToken;
          }
        } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
          options.startAtOperationTime = this.startAtOperationTime;
        }
        return options;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
          this.resumeToken = this.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(response) {
        const { postBatchResumeToken } = response;
        if (postBatchResumeToken) {
          this.postBatchResumeToken = postBatchResumeToken;
          if (response.batchSize === 0) {
            this.resumeToken = postBatchResumeToken;
          }
        }
      }
      clone() {
        return new _ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
          ...this.cursorOptions
        });
      }
      async _initialize(session) {
        const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
          ...this.cursorOptions,
          ...this.changeStreamCursorOptions,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, this.timeoutContext);
        const server2 = aggregateOperation.server;
        this.maxWireVersion = (0, utils_1.maxWireVersion)(server2);
        if (this.startAtOperationTime == null && this.changeStreamCursorOptions.resumeAfter == null && this.changeStreamCursorOptions.startAfter == null && this.maxWireVersion >= 7) {
          this.startAtOperationTime = response.operationTime;
        }
        this._processBatch(response);
        this.emit(constants_1.INIT, response);
        this.emit(constants_1.RESPONSE);
        return { server: server2, session, response };
      }
      async getMore(batchSize) {
        const response = await super.getMore(batchSize);
        this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
        this._processBatch(response);
        this.emit(change_stream_1.ChangeStream.MORE, response);
        this.emit(change_stream_1.ChangeStream.RESPONSE);
        return response;
      }
    };
    exports.ChangeStreamCursor = ChangeStreamCursor;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCollectionsOperation = void 0;
    var responses_1 = require_responses();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListCollectionsOperation = class extends command_1.CommandOperation {
      constructor(db, filter2, options) {
        super(db, options);
        this.options = { ...options };
        delete this.options.writeConcern;
        this.db = db;
        this.filter = filter2;
        this.nameOnly = !!this.options.nameOnly;
        this.authorizedCollections = !!this.options.authorizedCollections;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server2, session, timeoutContext) {
        return await super.executeCommand(server2, session, this.generateCommand((0, utils_1.maxWireVersion)(server2)), timeoutContext, responses_1.CursorResponse);
      }
      /* This is here for the purpose of unit testing the final command that gets sent. */
      generateCommand(wireVersion) {
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly,
          authorizedCollections: this.authorizedCollections
        };
        if (wireVersion >= 9 && this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return command;
      }
    };
    exports.ListCollectionsOperation = ListCollectionsOperation;
    (0, operation_1.defineAspects)(ListCollectionsOperation, [
      operation_1.Aspect.READ_OPERATION,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.CURSOR_CREATING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/list_collections_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListCollectionsCursor = void 0;
    var execute_operation_1 = require_execute_operation();
    var list_collections_1 = require_list_collections();
    var abstract_cursor_1 = require_abstract_cursor();
    var ListCollectionsCursor = class _ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
      constructor(db, filter2, options) {
        super(db.client, db.s.namespace, options);
        this.parent = db;
        this.filter = filter2;
        this.options = options;
      }
      clone() {
        return new _ListCollectionsCursor(this.parent, this.filter, {
          ...this.options,
          ...this.cursorOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
          ...this.cursorOptions,
          ...this.options,
          session,
          signal: this.signal
        });
        const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
        return { server: operation.server, session, response };
      }
    };
    exports.ListCollectionsCursor = ListCollectionsCursor;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RunAdminCommandOperation = exports.RunCommandOperation = void 0;
    var utils_1 = require_utils();
    var operation_1 = require_operation();
    var RunCommandOperation = class extends operation_1.AbstractOperation {
      constructor(parent, command, options) {
        super(options);
        this.command = command;
        this.options = options;
        this.ns = parent.s.namespace.withCollection("$cmd");
      }
      get commandName() {
        return "runCommand";
      }
      async execute(server2, session, timeoutContext) {
        this.server = server2;
        const res = await server2.command(this.ns, this.command, {
          ...this.options,
          readPreference: this.readPreference,
          session,
          timeoutContext
        }, this.options.responseType);
        return res;
      }
    };
    exports.RunCommandOperation = RunCommandOperation;
    var RunAdminCommandOperation = class extends operation_1.AbstractOperation {
      constructor(command, options) {
        super(options);
        this.command = command;
        this.options = options;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "runCommand";
      }
      async execute(server2, session, timeoutContext) {
        this.server = server2;
        const res = await server2.command(this.ns, this.command, {
          ...this.options,
          readPreference: this.readPreference,
          session,
          timeoutContext
        });
        return res;
      }
    };
    exports.RunAdminCommandOperation = RunAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/run_command_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RunCommandCursor = void 0;
    var responses_1 = require_responses();
    var error_1 = require_error();
    var execute_operation_1 = require_execute_operation();
    var get_more_1 = require_get_more();
    var run_command_1 = require_run_command();
    var utils_1 = require_utils();
    var abstract_cursor_1 = require_abstract_cursor();
    var RunCommandCursor = class extends abstract_cursor_1.AbstractCursor {
      /**
       * Controls the `getMore.comment` field
       * @param comment - any BSON value
       */
      setComment(comment) {
        this.getMoreOptions.comment = comment;
        return this;
      }
      /**
       * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await
       * @param maxTimeMS - the number of milliseconds to wait for new data
       */
      setMaxTimeMS(maxTimeMS) {
        this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
        return this;
      }
      /**
       * Controls the `getMore.batchSize` field
       * @param batchSize - the number documents to return in the `nextBatch`
       */
      setBatchSize(batchSize) {
        this.getMoreOptions.batchSize = batchSize;
        return this;
      }
      /** Unsupported for RunCommandCursor */
      clone() {
        throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
      }
      /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */
      withReadConcern(_) {
        throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
      }
      /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */
      addCursorFlag(_, __) {
        throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
      }
      /**
       * Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document
       */
      maxTimeMS(_) {
        throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
      }
      /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */
      batchSize(_) {
        throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
      }
      /** @internal */
      constructor(db, command, options = {}) {
        super(db.client, (0, utils_1.ns)(db.namespace), options);
        this.getMoreOptions = {};
        this.db = db;
        this.command = Object.freeze({ ...command });
      }
      /** @internal */
      async _initialize(session) {
        const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
          ...this.cursorOptions,
          session,
          readPreference: this.cursorOptions.readPreference,
          responseType: responses_1.CursorResponse
        });
        const response = await (0, execute_operation_1.executeOperation)(this.client, operation, this.timeoutContext);
        return {
          server: operation.server,
          session,
          response
        };
      }
      /** @internal */
      async getMore(_batchSize) {
        const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
          ...this.cursorOptions,
          session: this.session,
          ...this.getMoreOptions
        });
        return await (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, this.timeoutContext);
      }
    };
    exports.RunCommandCursor = RunCommandCursor;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionsOperation = void 0;
    var collection_1 = require_collection();
    var operation_1 = require_operation();
    var CollectionsOperation = class extends operation_1.AbstractOperation {
      constructor(db, options) {
        super(options);
        this.options = options;
        this.db = db;
      }
      get commandName() {
        return "listCollections";
      }
      async execute(server2, session) {
        const documents = await this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray();
        const collections = [];
        for (const { name } of documents) {
          if (!name.includes("$")) {
            collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
          }
        }
        return collections;
      }
    };
    exports.CollectionsOperation = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CreateCollectionOperation = void 0;
    var constants_1 = require_constants();
    var collection_1 = require_collection();
    var error_1 = require_error();
    var command_1 = require_command();
    var indexes_1 = require_indexes();
    var operation_1 = require_operation();
    var ILLEGAL_COMMAND_FIELDS = /* @__PURE__ */ new Set([
      "w",
      "wtimeout",
      "timeoutMS",
      "j",
      "fsync",
      "autoIndexId",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern",
      "raw",
      "fieldsAsRaw",
      "useBigInt64",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bsonRegExp",
      "serializeFunctions",
      "ignoreUndefined",
      "enableUtf8Validation"
    ]);
    var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";
    var CreateCollectionOperation = class _CreateCollectionOperation extends command_1.CommandOperation {
      constructor(db, name, options = {}) {
        super(db, options);
        this.options = options;
        this.db = db;
        this.name = name;
      }
      get commandName() {
        return "create";
      }
      async execute(server2, session, timeoutContext) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const encryptedFields = options.encryptedFields ?? db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (encryptedFields) {
          if (!server2.loadBalanced && server2.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
            throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
          }
          const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const createOp = new _CreateCollectionOperation(db, collectionName, {
              clusteredIndex: {
                key: { _id: 1 },
                unique: true
              }
            });
            await createOp.executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext);
          }
          if (!options.encryptedFields) {
            this.options = { ...this.options, encryptedFields };
          }
        }
        const coll = await this.executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext);
        if (encryptedFields) {
          const createIndexOp = indexes_1.CreateIndexesOperation.fromIndexSpecification(db, name, { __safeContent__: 1 }, {});
          await createIndexOp.execute(server2, session, timeoutContext);
        }
        return coll;
      }
      async executeWithoutEncryptedFieldsCheck(server2, session, timeoutContext) {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const cmd = { create: name };
        for (const n in options) {
          if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        }
        await super.executeCommand(server2, session, cmd, timeoutContext);
        return new collection_1.Collection(db, name, options);
      }
    };
    exports.CreateCollectionOperation = CreateCollectionOperation;
    (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfilingLevelOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      get commandName() {
        return "profile";
      }
      async execute(server2, session, timeoutContext) {
        const doc = await super.executeCommand(server2, session, { profile: -1 }, timeoutContext);
        if (doc.ok === 1) {
          const was = doc.was;
          if (was === 0)
            return "off";
          if (was === 1)
            return "slow_only";
          if (was === 2)
            return "all";
          throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
        } else {
          throw new error_1.MongoUnexpectedServerResponseError("Error with profile command");
        }
      }
    };
    exports.ProfilingLevelOperation = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoveUserOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var RemoveUserOperation = class extends command_1.CommandOperation {
      constructor(db, username, options) {
        super(db, options);
        this.options = options;
        this.username = username;
      }
      get commandName() {
        return "dropUser";
      }
      async execute(server2, session, timeoutContext) {
        await super.executeCommand(server2, session, { dropUser: this.username }, timeoutContext);
        return true;
      }
    };
    exports.RemoveUserOperation = RemoveUserOperation;
    (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetProfilingLevelOperation = exports.ProfilingLevel = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var levelValues = /* @__PURE__ */ new Set(["off", "slow_only", "all"]);
    exports.ProfilingLevel = Object.freeze({
      off: "off",
      slowOnly: "slow_only",
      all: "all"
    });
    var SetProfilingLevelOperation = class extends command_1.CommandOperation {
      constructor(db, level2, options) {
        super(db, options);
        this.options = options;
        switch (level2) {
          case exports.ProfilingLevel.off:
            this.profile = 0;
            break;
          case exports.ProfilingLevel.slowOnly:
            this.profile = 1;
            break;
          case exports.ProfilingLevel.all:
            this.profile = 2;
            break;
          default:
            this.profile = 0;
            break;
        }
        this.level = level2;
      }
      get commandName() {
        return "profile";
      }
      async execute(server2, session, timeoutContext) {
        const level2 = this.level;
        if (!levelValues.has(level2)) {
          throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`);
        }
        await super.executeCommand(server2, session, { profile: this.profile }, timeoutContext);
        return level2;
      }
    };
    exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DbStatsOperation = void 0;
    var command_1 = require_command();
    var operation_1 = require_operation();
    var DbStatsOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options;
      }
      get commandName() {
        return "dbStats";
      }
      async execute(server2, session, timeoutContext) {
        const command = { dbStats: true };
        if (this.options.scale != null) {
          command.scale = this.options.scale;
        }
        return await super.executeCommand(server2, session, command, timeoutContext);
      }
    };
    exports.DbStatsOperation = DbStatsOperation;
    (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Db = void 0;
    var admin_1 = require_admin();
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var collection_1 = require_collection();
    var CONSTANTS = require_constants2();
    var aggregation_cursor_1 = require_aggregation_cursor();
    var list_collections_cursor_1 = require_list_collections_cursor();
    var run_command_cursor_1 = require_run_command_cursor();
    var error_1 = require_error();
    var collections_1 = require_collections();
    var create_collection_1 = require_create_collection();
    var drop_1 = require_drop();
    var execute_operation_1 = require_execute_operation();
    var indexes_1 = require_indexes();
    var profiling_level_1 = require_profiling_level();
    var remove_user_1 = require_remove_user();
    var rename_1 = require_rename();
    var run_command_1 = require_run_command();
    var set_profiling_level_1 = require_set_profiling_level();
    var stats_1 = require_stats();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var DB_OPTIONS_ALLOW_LIST = [
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "authSource",
      "ignoreUndefined",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "useBigInt64",
      "promoteBuffers",
      "promoteLongs",
      "bsonRegExp",
      "enableUtf8Validation",
      "promoteValues",
      "compression",
      "retryWrites",
      "timeoutMS"
    ];
    var Db = class {
      /**
       * Creates a new Db instance.
       *
       * Db name cannot contain a dot, the server may apply more restrictions when an operation is run.
       *
       * @param client - The MongoClient for the database.
       * @param databaseName - The name of the database this instance represents.
       * @param options - Optional settings for Db construction.
       */
      constructor(client, databaseName, options) {
        options = options ?? {};
        options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
        if (typeof databaseName === "string" && databaseName.includes(".")) {
          throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
        }
        this.s = {
          // Options
          options,
          // Unpack read preference
          readPreference: read_preference_1.ReadPreference.fromOptions(options),
          // Merge bson options
          bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
          // Set up the primary key factory or fallback to ObjectId
          pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
          // ReadConcern
          readConcern: read_concern_1.ReadConcern.fromOptions(options),
          writeConcern: write_concern_1.WriteConcern.fromOptions(options),
          // Namespace
          namespace: new utils_1.MongoDBNamespace(databaseName)
        };
        this.client = client;
      }
      get databaseName() {
        return this.s.namespace.db;
      }
      // Options
      get options() {
        return this.s.options;
      }
      /**
       * Check if a secondary can be used (because the read preference is *not* set to primary)
       */
      get secondaryOk() {
        return this.s.readPreference?.preference !== "primary" || false;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      /**
       * The current readPreference of the Db. If not explicitly defined for
       * this Db, will be inherited from the parent MongoClient
       */
      get readPreference() {
        if (this.s.readPreference == null) {
          return this.client.readPreference;
        }
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      // get the write Concern
      get writeConcern() {
        return this.s.writeConcern;
      }
      get namespace() {
        return this.s.namespace.toString();
      }
      get timeoutMS() {
        return this.s.options?.timeoutMS;
      }
      /**
       * Create a new collection on a server with the specified options. Use this to create capped collections.
       * More information about command options available at https://www.mongodb.com/docs/manual/reference/command/create/
       *
       * Collection namespace validation is performed server-side.
       *
       * @param name - The name of the collection to create
       * @param options - Optional settings for the command
       */
      async createCollection(name, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Execute a command
       *
       * @remarks
       * This command does not inherit options from the MongoClient.
       *
       * The driver will ensure the following fields are attached to the command sent to the server:
       * - `lsid` - sourced from an implicit session or options.session
       * - `$readPreference` - defaults to primary or can be configured by options.readPreference
       * - `$db` - sourced from the name of this database
       *
       * If the client has a serverApi setting:
       * - `apiVersion`
       * - `apiStrict`
       * - `apiDeprecationErrors`
       *
       * When in a transaction:
       * - `readConcern` - sourced from readConcern set on the TransactionOptions
       * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
       *
       * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
       *
       * @param command - The command to run
       * @param options - Optional settings for the command
       */
      async command(command, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, (0, utils_1.resolveOptions)(void 0, {
          ...(0, bson_1.resolveBSONOptions)(options),
          timeoutMS: options?.timeoutMS ?? this.timeoutMS,
          session: options?.session,
          readPreference: options?.readPreference,
          signal: options?.signal
        })));
      }
      /**
       * Execute an aggregation framework pipeline against the database.
       *
       * @param pipeline - An array of aggregation stages to be executed
       * @param options - Optional settings for the command
       */
      aggregate(pipeline = [], options) {
        return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
      }
      /** Return the Admin db instance */
      admin() {
        return new admin_1.Admin(this);
      }
      /**
       * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
       *
       * Collection namespace validation is performed server-side.
       *
       * @param name - the collection name we wish to access.
       * @returns return the new Collection instance
       */
      collection(name, options = {}) {
        if (typeof options === "function") {
          throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
        }
        return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Get all the db statistics.
       *
       * @param options - Optional settings for the command
       */
      async stats(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      listCollections(filter2 = {}, options = {}) {
        return new list_collections_cursor_1.ListCollectionsCursor(this, filter2, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Rename a collection.
       *
       * @remarks
       * This operation does not inherit options from the MongoClient.
       *
       * @param fromCollection - Name of current collection to rename
       * @param toCollection - New name of of the collection
       * @param options - Optional settings for the command
       */
      async renameCollection(fromCollection, toCollection, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, (0, utils_1.resolveOptions)(void 0, {
          ...options,
          new_collection: true,
          readPreference: read_preference_1.ReadPreference.primary
        })));
      }
      /**
       * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
       *
       * @param name - Name of collection to drop
       * @param options - Optional settings for the command
       */
      async dropCollection(name, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Drop a database, removing it permanently from the server.
       *
       * @param options - Optional settings for the command
       */
      async dropDatabase(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Fetch all collections for the current db.
       *
       * @param options - Optional settings for the command
       */
      async collections(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Creates an index on the db and collection.
       *
       * @param name - Name of the collection to create the index on.
       * @param indexSpec - Specify the field to index, or an index specification
       * @param options - Optional settings for the command
       */
      async createIndex(name, indexSpec, options) {
        const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options));
        return indexes[0];
      }
      /**
       * Remove a user from a database
       *
       * @param username - The username to remove
       * @param options - Optional settings for the command
       */
      async removeUser(username, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Set the current profiling level of MongoDB
       *
       * @param level - The new profiling level (off, slow_only, all).
       * @param options - Optional settings for the command
       */
      async setProfilingLevel(level2, options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level2, (0, utils_1.resolveOptions)(this, options)));
      }
      /**
       * Retrieve the current profiling Level for MongoDB
       *
       * @param options - Optional settings for the command
       */
      async profilingLevel(options) {
        return await (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
      }
      async indexInformation(name, options) {
        return await this.collection(name).indexInformation((0, utils_1.resolveOptions)(this, options));
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this database. Will ignore all
       * changes to system collections.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the collections within this database
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
          options = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
      }
      /**
       * A low level cursor API providing basic driver functionality:
       * - ClientSession management
       * - ReadPreference for server selection
       * - Running getMores automatically when a local batch is exhausted
       *
       * @param command - The command that will start a cursor on the server.
       * @param options - Configurations for running the command, bson options will apply to getMores
       */
      runCursorCommand(command, options) {
        return new run_command_cursor_1.RunCommandCursor(this, command, options);
      }
    };
    exports.Db = Db;
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangeStream = void 0;
    var collection_1 = require_collection();
    var constants_1 = require_constants2();
    var abstract_cursor_1 = require_abstract_cursor();
    var change_stream_cursor_1 = require_change_stream_cursor();
    var db_1 = require_db();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var mongo_types_1 = require_mongo_types();
    var resource_management_1 = require_resource_management();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var CHANGE_STREAM_OPTIONS = [
      "resumeAfter",
      "startAfter",
      "startAtOperationTime",
      "fullDocument",
      "fullDocumentBeforeChange",
      "showExpandedEvents"
    ];
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
    var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
    var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";
    var ChangeStream = class _ChangeStream extends mongo_types_1.TypedEventEmitter {
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /**
       * @internal
       *
       * @param parent - The parent object that created this change stream
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
       */
      constructor(parent, pipeline = [], options = {}) {
        super();
        this.pipeline = pipeline;
        this.options = { ...options };
        let serverSelectionTimeoutMS;
        delete this.options.writeConcern;
        if (parent instanceof collection_1.Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;
        } else if (parent instanceof db_1.Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;
        } else if (parent instanceof mongo_client_1.MongoClient) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;
        } else {
          throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
        }
        this.contextOwner = Symbol();
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (!this.options.readPreference && parent.readPreference) {
          this.options.readPreference = parent.readPreference;
        }
        this.cursor = this._createChangeStreamCursor(options);
        this.isClosed = false;
        this.mode = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this._streamEvents(this.cursor);
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursorStream?.removeAllListeners("data");
          }
        });
        if (this.options.timeoutMS != null) {
          this.timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS: this.options.timeoutMS,
            serverSelectionTimeoutMS
          });
        }
      }
      /** The cached resume token that is used to resume after the most recently returned change. */
      get resumeToken() {
        return this.cursor?.resumeToken;
      }
      /** Check if there is any document still available in the Change Stream */
      async hasNext() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const hasNext = await this.cursor.hasNext();
              return hasNext;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                  throw error3;
                }
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      /** Get the next available document from the Change Stream. */
      async next() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const change = await this.cursor.next();
              const processedChange = this._processChange(change ?? null);
              return processedChange;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                  throw error3;
                }
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      /**
       * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned
       */
      async tryNext() {
        this._setIsIterator();
        this.timeoutContext?.refresh();
        try {
          while (true) {
            try {
              const change = await this.cursor.tryNext();
              return change ?? null;
            } catch (error2) {
              try {
                await this._processErrorIteratorMode(error2, this.cursor.id != null);
              } catch (error3) {
                if (error3 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null)
                  throw error3;
                try {
                  await this.close();
                } catch (error4) {
                  (0, utils_1.squashError)(error4);
                }
                throw error3;
              }
            }
          }
        } finally {
          this.timeoutContext?.clear();
        }
      }
      async *[Symbol.asyncIterator]() {
        if (this.closed) {
          return;
        }
        try {
          while (true) {
            yield await this.next();
          }
        } finally {
          try {
            await this.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
      }
      /** Is the cursor closed */
      get closed() {
        return this.isClosed || this.cursor.closed;
      }
      /**
       * Frees the internal resources used by the change stream.
       */
      async close() {
        this.timeoutContext?.clear();
        this.timeoutContext = void 0;
        this.isClosed = true;
        const cursor = this.cursor;
        try {
          await cursor.close();
        } finally {
          this._endStream();
        }
      }
      /**
       * Return a modified Readable stream including a possible transform method.
       *
       * NOTE: When using a Stream to process change stream events, the stream will
       * NOT automatically resume in the case a resumable error is encountered.
       *
       * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed
       */
      stream(options) {
        if (this.closed) {
          throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
        }
        this.streamOptions = options;
        return this.cursor.stream(options);
      }
      /** @internal */
      _setIsEmitter() {
        if (this.mode === "iterator") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
        }
        this.mode = "emitter";
      }
      /** @internal */
      _setIsIterator() {
        if (this.mode === "emitter") {
          throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
        }
        this.mode = "iterator";
      }
      /**
       * Create a new change stream cursor based on self's configuration
       * @internal
       */
      _createChangeStreamCursor(options) {
        const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
        if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
          changeStreamStageOptions.allChangesForCluster = true;
        }
        const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
        const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
        if (client == null) {
          throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
        }
        const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, {
          ...options,
          timeoutContext: this.timeoutContext ? new abstract_cursor_1.CursorTimeoutContext(this.timeoutContext, this.contextOwner) : void 0
        });
        for (const event of CHANGE_STREAM_EVENTS) {
          changeStreamCursor.on(event, (e) => this.emit(event, e));
        }
        if (this.listenerCount(_ChangeStream.CHANGE) > 0) {
          this._streamEvents(changeStreamCursor);
        }
        return changeStreamCursor;
      }
      /** @internal */
      _closeEmitterModeWithError(error2) {
        this.emit(_ChangeStream.ERROR, error2);
        this.close().then(void 0, utils_1.squashError);
      }
      /** @internal */
      _streamEvents(cursor) {
        this._setIsEmitter();
        const stream4 = this.cursorStream ?? cursor.stream();
        this.cursorStream = stream4;
        stream4.on("data", (change) => {
          try {
            const processedChange = this._processChange(change);
            this.emit(_ChangeStream.CHANGE, processedChange);
          } catch (error2) {
            this.emit(_ChangeStream.ERROR, error2);
          }
          this.timeoutContext?.refresh();
        });
        stream4.on("error", (error2) => this._processErrorStreamMode(error2, this.cursor.id != null));
      }
      /** @internal */
      _endStream() {
        this.cursorStream?.removeAllListeners("data");
        this.cursorStream?.removeAllListeners("close");
        this.cursorStream?.removeAllListeners("end");
        this.cursorStream?.destroy();
        this.cursorStream = void 0;
      }
      /** @internal */
      _processChange(change) {
        if (this.isClosed) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change == null) {
          throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change && !change._id) {
          throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
        }
        this.cursor.cacheResumeToken(change._id);
        this.options.startAtOperationTime = void 0;
        return change;
      }
      /** @internal */
      _processErrorStreamMode(changeStreamError, cursorInitialized) {
        if (this.isClosed)
          return;
        if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
          this._endStream();
          this.cursor.close().then(() => this._resume(changeStreamError), (e) => {
            (0, utils_1.squashError)(e);
            return this._resume(changeStreamError);
          }).then(() => {
            if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
              this.emit(_ChangeStream.ERROR, changeStreamError);
          }, () => this._closeEmitterModeWithError(changeStreamError));
        } else {
          this._closeEmitterModeWithError(changeStreamError);
        }
      }
      /** @internal */
      async _processErrorIteratorMode(changeStreamError, cursorInitialized) {
        if (this.isClosed) {
          throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
          try {
            await this.cursor.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
          await this._resume(changeStreamError);
          if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
            throw changeStreamError;
        } else {
          try {
            await this.close();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
          throw changeStreamError;
        }
      }
      async _resume(changeStreamError) {
        this.timeoutContext?.refresh();
        const topology = (0, utils_1.getTopology)(this.parent);
        try {
          await topology.selectServer(this.cursor.readPreference, {
            operationName: "reconnect topology in change stream",
            timeoutContext: this.timeoutContext
          });
          this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
        } catch {
          await this.close();
          throw changeStreamError;
        }
      }
    };
    exports.ChangeStream = ChangeStream;
    ChangeStream.RESPONSE = constants_1.RESPONSE;
    ChangeStream.MORE = constants_1.MORE;
    ChangeStream.INIT = constants_1.INIT;
    ChangeStream.CLOSE = constants_1.CLOSE;
    ChangeStream.CHANGE = constants_1.CHANGE;
    ChangeStream.END = constants_1.END;
    ChangeStream.ERROR = constants_1.ERROR;
    ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
    (0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray2(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray2(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-fetch/node_modules/webidl-conversions/lib/index.js"(exports, module) {
    "use strict";
    var conversions = {};
    module.exports = conversions;
    function sign2(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts) opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign2(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound) x = lowerBound;
          if (x > upperBound) x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign2(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts) opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    module.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module.exports.wrapperSymbol = Symbol("wrapper");
    module.exports.implSymbol = Symbol("impl");
    module.exports.wrapperForImpl = function(impl) {
      return impl[module.exports.wrapperSymbol];
    };
    module.exports.implForWrapper = function(wrapper) {
      return wrapper[module.exports.implSymbol];
    };
  }
});

// node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/node-fetch/node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/node-fetch/node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode2 = __require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode2.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error2 = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error2 = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error2 = true;
          break;
        }
      }
      return {
        label,
        error: error2
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode2.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) return null;
      return labels.join(".");
    };
    module.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var punycode2 = __require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode2.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode2.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode2.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url2) {
      return url2.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url2) {
      const path4 = url2.path;
      if (path4.length === 0) {
        return;
      }
      if (url2.scheme === "file" && path4.length === 1 && isNormalizedWindowsDriveLetter(path4[0])) {
        return;
      }
      path4.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return url2.host === null || url2.host === "" || url2.cannotBeABaseURL || url2.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url2, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode2.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output = url2.scheme + ":";
      if (url2.host !== null) {
        output += "//";
        if (url2.username !== "" || url2.password !== "") {
          output += url2.username;
          if (url2.password !== "") {
            output += ":" + url2.password;
          }
          output += "@";
        }
        output += serializeHost(url2.host);
        if (url2.port !== null) {
          output += ":" + url2.port;
        }
      } else if (url2.host === null && url2.scheme === "file") {
        output += "//";
      }
      if (url2.cannotBeABaseURL) {
        output += url2.path[0];
      } else {
        for (const string of url2.path) {
          output += "/" + string;
        }
      }
      if (url2.query !== null) {
        output += "?" + url2.query;
      }
      if (!excludeFragment && url2.fragment !== null) {
        output += "#" + url2.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url2) {
      switch (url2.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url2.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url2, username) {
      url2.username = "";
      const decoded = punycode2.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url2.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url2, password) {
      url2.password = "";
      const decoded = punycode2.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url2.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url2 = constructorArgs[0];
        const base2 = constructorArgs[1];
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) {
          return "";
        }
        if (url2.port === null) {
          return usm.serializeHost(url2.host);
        }
        return usm.serializeHost(url2.host) + ":" + usm.serializeInteger(url2.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url2 = this._url;
        if (v === "") {
          url2.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url2.query = "";
        usm.basicURLParse(input, { url: url2, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/URL.js"(exports, module) {
    "use strict";
    var conversions = require_lib();
    var utils = require_utils2();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL3(url2) {
      if (!this || this[impl] || !(this instanceof URL3)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module.exports.setup(this, args);
    }
    URL3.prototype.toJSON = function toJSON2() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL3.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL3.prototype.toString = function() {
      if (!this || !module.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL3.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL3.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL3.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData) privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL3,
      expose: {
        Window: { URL: URL3 },
        Worker: { URL: URL3 }
      }
    };
  }
});

// node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/node-fetch/node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  AbortError: () => AbortError,
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response,
  default: () => lib_default2
});
import Stream from "stream";
import http from "http";
import Url from "url";
import https from "https";
import zlib from "zlib";
function FetchError(message, type, systemError) {
  Error.call(this, message);
  this.message = message;
  this.type = type;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
function Body(body3) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body3 == null) {
    body3 = null;
  } else if (isURLSearchParams(body3)) {
    body3 = Buffer.from(body3.toString());
  } else if (isBlob(body3)) ;
  else if (Buffer.isBuffer(body3)) ;
  else if (Object.prototype.toString.call(body3) === "[object ArrayBuffer]") {
    body3 = Buffer.from(body3);
  } else if (ArrayBuffer.isView(body3)) {
    body3 = Buffer.from(body3.buffer, body3.byteOffset, body3.byteLength);
  } else if (body3 instanceof Stream) ;
  else {
    body3 = Buffer.from(String(body3));
  }
  this[INTERNALS] = {
    body: body3,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body3 instanceof Stream) {
    body3.on("error", function(err) {
      const error2 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error2;
    });
  }
}
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body3 = this.body;
  if (body3 === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body3)) {
    body3 = body3.stream();
  }
  if (Buffer.isBuffer(body3)) {
    return Body.Promise.resolve(body3);
  }
  if (!(body3 instanceof Stream)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body3.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body3.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body3.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance) {
  let p1, p2;
  let body3 = instance.body;
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body3 instanceof Stream && typeof body3.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body3.pipe(p1);
    body3.pipe(p2);
    instance[INTERNALS].body = p1;
    body3 = p2;
  }
  return body3;
}
function extractContentType(body3) {
  if (body3 === null) {
    return null;
  } else if (typeof body3 === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body3)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body3)) {
    return body3.type || null;
  } else if (Buffer.isBuffer(body3)) {
    return null;
  } else if (Object.prototype.toString.call(body3) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body3)) {
    return null;
  } else if (typeof body3.getBoundary === "function") {
    return `multipart/form-data;boundary=${body3.getBoundary()}`;
  } else if (body3 instanceof Stream) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance) {
  const body3 = instance.body;
  if (body3 === null) {
    return 0;
  } else if (isBlob(body3)) {
    return body3.size;
  } else if (Buffer.isBuffer(body3)) {
    return body3.length;
  } else if (body3 && typeof body3.getLengthSync === "function") {
    if (body3._lengthRetrievers && body3._lengthRetrievers.length == 0 || // 1.x
    body3.hasKnownLength && body3.hasKnownLength()) {
      return body3.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance) {
  const body3 = instance.body;
  if (body3 === null) {
    dest.end();
  } else if (isBlob(body3)) {
    body3.stream().pipe(dest);
  } else if (Buffer.isBuffer(body3)) {
    dest.write(body3);
    dest.end();
  } else {
    body3.pipe(dest);
  }
}
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map2, name) {
  name = name.toLowerCase();
  for (const key in map2) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
function createHeadersIterator(target, kind) {
  const iterator2 = Object.create(HeadersIteratorPrototype);
  iterator2[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator2;
}
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent = request.agent;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent
  });
}
function AbortError(message) {
  Error.call(this, message);
  this.type = "aborted";
  this.message = message;
  Error.captureStackTrace(this, this.constructor);
}
function fetch2(url2, opts) {
  if (!fetch2.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch2.Promise;
  return new fetch2.Promise(function(resolve, reject) {
    const request = new Request(url2, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? https : http).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error2 = new AbortError("The user aborted a request.");
      reject(error2);
      if (request.body && request.body instanceof Stream.Readable) {
        destroyStream(request.body, error2);
      }
      if (!response || !response.body) return;
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal) signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s) {
        s.addListener("close", function(hadError) {
          const hasDataListener = s.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch2.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL$1(location, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch2(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal) signal.removeEventListener("abort", abortAndFinalize);
      });
      let body3 = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body3, response_options);
        resolve(response);
        return;
      }
      const zlibOptions2 = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body3 = body3.pipe(zlib.createGunzip(zlibOptions2));
        response = new Response(body3, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body3 = body3.pipe(zlib.createInflate());
          } else {
            body3 = body3.pipe(zlib.createInflateRaw());
          }
          response = new Response(body3, response_options);
          resolve(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response(body3, response_options);
            resolve(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
        body3 = body3.pipe(zlib.createBrotliDecompress());
        response = new Response(body3, response_options);
        resolve(response);
        return;
      }
      response = new Response(body3, response_options);
      resolve(response);
    });
    writeToStream(req, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let socket;
  request.on("socket", function(s) {
    socket = s;
  });
  request.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket && socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
function destroyStream(stream4, err) {
  if (stream4.destroy) {
    stream4.destroy(err);
  } else {
    stream4.emit("error", err);
    stream4.end();
  }
}
var import_whatwg_url, Readable, BUFFER, TYPE, Blob2, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default2;
var init_lib = __esm({
  "node_modules/node-fetch/lib/index.mjs"() {
    import_whatwg_url = __toESM(require_public_api(), 1);
    Readable = Stream.Readable;
    BUFFER = Symbol("buffer");
    TYPE = Symbol("type");
    Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    try {
      convert = __require("encoding").convert;
    } catch (e) {
    }
    INTERNALS = Symbol("Body internals");
    PassThrough = Stream.PassThrough;
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    Body.Promise = global.Promise;
    invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    MAP = Symbol("map");
    Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null) ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    INTERNAL = Symbol("internal");
    HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$1 = Symbol("Response internals");
    STATUS_CODES = http.STATUS_CODES;
    Response = class _Response {
      constructor() {
        let body3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body3, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body3 != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body3);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    INTERNALS$2 = Symbol("Request internals");
    URL2 = Url.URL || import_whatwg_url.default.URL;
    parse_url = Url.parse;
    format_url = Url.format;
    streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init) signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    URL$1 = Url.URL || import_whatwg_url.default.URL;
    PassThrough$1 = Stream.PassThrough;
    isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    lib_default2 = fetch2;
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    var isStream2 = (stream4) => stream4 !== null && typeof stream4 === "object" && typeof stream4.pipe === "function";
    isStream2.writable = (stream4) => isStream2(stream4) && stream4.writable !== false && typeof stream4._write === "function" && typeof stream4._writableState === "object";
    isStream2.readable = (stream4) => isStream2(stream4) && stream4.readable !== false && typeof stream4._read === "function" && typeof stream4._readableState === "object";
    isStream2.duplex = (stream4) => isStream2.writable(stream4) && isStream2.readable(stream4);
    isStream2.transform = (stream4) => isStream2.duplex(stream4) && typeof stream4._transform === "function";
    module.exports = isStream2;
  }
});

// node_modules/gcp-metadata/node_modules/gaxios/build/src/common.js
var require_common3 = __commonJS({
  "node_modules/gcp-metadata/node_modules/gaxios/build/src/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaxiosError = void 0;
    var GaxiosError = class extends Error {
      constructor(message, options, response) {
        super(message);
        this.response = response;
        this.config = options;
        this.response.data = translateData(options.responseType, response.data);
        this.code = response.status.toString();
      }
    };
    exports.GaxiosError = GaxiosError;
    function translateData(responseType, data) {
      switch (responseType) {
        case "stream":
          return data;
        case "json":
          return JSON.parse(JSON.stringify(data));
        case "arraybuffer":
          return JSON.parse(Buffer.from(data).toString("utf8"));
        case "blob":
          return JSON.parse(data.text());
        default:
          return data;
      }
    }
  }
});

// node_modules/gcp-metadata/node_modules/gaxios/build/src/retry.js
var require_retry = __commonJS({
  "node_modules/gcp-metadata/node_modules/gaxios/build/src/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRetryConfig = void 0;
    async function getRetryConfig(err) {
      var _a;
      let config3 = getConfig(err);
      if (!err || !err.config || !config3 && !err.config.retry) {
        return { shouldRetry: false };
      }
      config3 = config3 || {};
      config3.currentRetryAttempt = config3.currentRetryAttempt || 0;
      config3.retry = config3.retry === void 0 || config3.retry === null ? 3 : config3.retry;
      config3.httpMethodsToRetry = config3.httpMethodsToRetry || [
        "GET",
        "HEAD",
        "PUT",
        "OPTIONS",
        "DELETE"
      ];
      config3.noResponseRetries = config3.noResponseRetries === void 0 || config3.noResponseRetries === null ? 2 : config3.noResponseRetries;
      const retryRanges = [
        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
        // 1xx - Retry (Informational, request still processing)
        // 2xx - Do not retry (Success)
        // 3xx - Do not retry (Redirect)
        // 4xx - Do not retry (Client errors)
        // 429 - Retry ("Too Many Requests")
        // 5xx - Retry (Server errors)
        [100, 199],
        [429, 429],
        [500, 599]
      ];
      config3.statusCodesToRetry = config3.statusCodesToRetry || retryRanges;
      err.config.retryConfig = config3;
      const shouldRetryFn = config3.shouldRetry || shouldRetryRequest;
      if (!await shouldRetryFn(err)) {
        return { shouldRetry: false, config: err.config };
      }
      const retryDelay = config3.currentRetryAttempt ? 0 : (_a = config3.retryDelay) !== null && _a !== void 0 ? _a : 100;
      const delay = retryDelay + (Math.pow(2, config3.currentRetryAttempt) - 1) / 2 * 1e3;
      err.config.retryConfig.currentRetryAttempt += 1;
      const backoff = config3.retryBackoff ? config3.retryBackoff(err, delay) : new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
      if (config3.onRetryAttempt) {
        config3.onRetryAttempt(err);
      }
      await backoff;
      return { shouldRetry: true, config: err.config };
    }
    exports.getRetryConfig = getRetryConfig;
    function shouldRetryRequest(err) {
      const config3 = getConfig(err);
      if (err.name === "AbortError") {
        return false;
      }
      if (!config3 || config3.retry === 0) {
        return false;
      }
      if (!err.response && (config3.currentRetryAttempt || 0) >= config3.noResponseRetries) {
        return false;
      }
      if (!err.config.method || config3.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
        return false;
      }
      if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config3.statusCodesToRetry) {
          const status = err.response.status;
          if (status >= min && status <= max) {
            isInRange = true;
            break;
          }
        }
        if (!isInRange) {
          return false;
        }
      }
      config3.currentRetryAttempt = config3.currentRetryAttempt || 0;
      if (config3.currentRetryAttempt >= config3.retry) {
        return false;
      }
      return true;
    }
    function getConfig(err) {
      if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
      }
      return;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace2) {
        let hash = 0;
        for (let i = 0; i < namespace2.length; i++) {
          hash = (hash << 5) - hash + namespace2.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace2) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace2;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace2);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace2);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace2, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace2);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace2) => "-" + namespace2)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common4()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level2) {
      if (level2 === 0) {
        return false;
      }
      return {
        level: level2,
        hasBasic: true,
        has256: level2 >= 2,
        has16m: level2 >= 3
      };
    }
    function supportsColor(stream4) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream4 && !stream4.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      const level2 = supportsColor(stream4);
      return translateLevel(level2);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util3 = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common4()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/gcp-metadata/node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/gcp-metadata/node_modules/agent-base/dist/src/promisify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports.default = promisify;
  }
});

// node_modules/gcp-metadata/node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/gcp-metadata/node_modules/agent-base/dist/src/index.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = __require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module.exports = createAgent;
  }
});

// node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports.default = parseProxyResponse;
  }
});

// node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(__require("net"));
    var tls_1 = __importDefault(__require("tls"));
    var url_1 = __importDefault(__require("url"));
    var assert_1 = __importDefault(__require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/gcp-metadata/node_modules/https-proxy-agent/dist/index.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module.exports = createHttpsProxyAgent;
  }
});

// node_modules/gcp-metadata/node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS({
  "node_modules/gcp-metadata/node_modules/gaxios/build/src/gaxios.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gaxios = void 0;
    var extend_1 = __importDefault(require_extend());
    var https_1 = __require("https");
    var node_fetch_1 = __importDefault((init_lib(), __toCommonJS(lib_exports)));
    var querystring_1 = __importDefault(__require("querystring"));
    var is_stream_1 = __importDefault(require_is_stream());
    var url_1 = __require("url");
    var common_1 = require_common3();
    var retry_1 = require_retry();
    var fetch3 = hasFetch() ? window.fetch : node_fetch_1.default;
    function hasWindow() {
      return typeof window !== "undefined" && !!window;
    }
    function hasFetch() {
      return hasWindow() && !!window.fetch;
    }
    function hasBuffer() {
      return typeof Buffer !== "undefined";
    }
    function hasHeader(options, header) {
      return !!getHeader(options, header);
    }
    function getHeader(options, header) {
      header = header.toLowerCase();
      for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) {
        if (header === key.toLowerCase()) {
          return options.headers[key];
        }
      }
      return void 0;
    }
    var HttpsProxyAgent;
    function loadProxy() {
      var _a, _b, _c, _d;
      const proxy = ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.HTTPS_PROXY) || ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.https_proxy) || ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c.HTTP_PROXY) || ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.http_proxy);
      if (proxy) {
        HttpsProxyAgent = require_dist();
      }
      return proxy;
    }
    loadProxy();
    function skipProxy(url2) {
      var _a;
      const noProxyEnv = (_a = process.env.NO_PROXY) !== null && _a !== void 0 ? _a : process.env.no_proxy;
      if (!noProxyEnv) {
        return false;
      }
      const noProxyUrls = noProxyEnv.split(",");
      const parsedURL = new url_1.URL(url2);
      return !!noProxyUrls.find((url3) => {
        if (url3.startsWith("*.") || url3.startsWith(".")) {
          url3 = url3.replace(/^\*\./, ".");
          return parsedURL.hostname.endsWith(url3);
        } else {
          return url3 === parsedURL.origin || url3 === parsedURL.hostname;
        }
      });
    }
    function getProxy(url2) {
      if (skipProxy(url2)) {
        return void 0;
      } else {
        return loadProxy();
      }
    }
    var Gaxios = class {
      /**
       * The Gaxios class is responsible for making HTTP requests.
       * @param defaults The default set of options to be used for this instance.
       */
      constructor(defaults2) {
        this.agentCache = /* @__PURE__ */ new Map();
        this.defaults = defaults2 || {};
      }
      /**
       * Perform an HTTP request with the given options.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async request(opts = {}) {
        opts = this.validateOpts(opts);
        return this._request(opts);
      }
      async _defaultAdapter(opts) {
        const fetchImpl = opts.fetchImplementation || fetch3;
        const res = await fetchImpl(opts.url, opts);
        const data = await this.getResponseData(opts, res);
        return this.translateResponse(opts, res, data);
      }
      /**
       * Internal, retryable version of the `request` method.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async _request(opts = {}) {
        try {
          let translatedResponse;
          if (opts.adapter) {
            translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
          } else {
            translatedResponse = await this._defaultAdapter(opts);
          }
          if (!opts.validateStatus(translatedResponse.status)) {
            if (opts.responseType === "stream") {
              let response = "";
              await new Promise((resolve) => {
                translatedResponse.data.on("data", (chunk) => {
                  response += chunk;
                });
                translatedResponse.data.on("end", resolve);
              });
              translatedResponse.data = response;
            }
            throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
          }
          return translatedResponse;
        } catch (e) {
          const err = e;
          err.config = opts;
          const { shouldRetry, config: config3 } = await (0, retry_1.getRetryConfig)(err);
          if (shouldRetry && config3) {
            err.config.retryConfig.currentRetryAttempt = config3.retryConfig.currentRetryAttempt;
            return this._request(err.config);
          }
          throw err;
        }
      }
      async getResponseData(opts, res) {
        switch (opts.responseType) {
          case "stream":
            return res.body;
          case "json": {
            let data = await res.text();
            try {
              data = JSON.parse(data);
            } catch (_a) {
            }
            return data;
          }
          case "arraybuffer":
            return res.arrayBuffer();
          case "blob":
            return res.blob();
          default:
            return res.text();
        }
      }
      /**
       * Validates the options, and merges them with defaults.
       * @param opts The original options passed from the client.
       */
      validateOpts(options) {
        const opts = (0, extend_1.default)(true, {}, this.defaults, options);
        if (!opts.url) {
          throw new Error("URL is required.");
        }
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) {
          opts.url = baseUrl + opts.url;
        }
        opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
        if (opts.params && Object.keys(opts.params).length > 0) {
          let additionalQueryParams = opts.paramsSerializer(opts.params);
          if (additionalQueryParams.startsWith("?")) {
            additionalQueryParams = additionalQueryParams.slice(1);
          }
          const prefix = opts.url.includes("?") ? "&" : "?";
          opts.url = opts.url + prefix + additionalQueryParams;
        }
        if (typeof options.maxContentLength === "number") {
          opts.size = options.maxContentLength;
        }
        if (typeof options.maxRedirects === "number") {
          opts.follow = options.maxRedirects;
        }
        opts.headers = opts.headers || {};
        if (opts.data) {
          const isFormData2 = typeof FormData === "undefined" ? false : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;
          if (is_stream_1.default.readable(opts.data)) {
            opts.body = opts.data;
          } else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
            opts.body = opts.data;
            if (!hasHeader(opts, "Content-Type")) {
              opts.headers["Content-Type"] = "application/json";
            }
          } else if (typeof opts.data === "object") {
            if (!isFormData2) {
              if (getHeader(opts, "content-type") === "application/x-www-form-urlencoded") {
                opts.body = opts.paramsSerializer(opts.data);
              } else {
                if (!hasHeader(opts, "Content-Type")) {
                  opts.headers["Content-Type"] = "application/json";
                }
                opts.body = JSON.stringify(opts.data);
              }
            }
          } else {
            opts.body = opts.data;
          }
        }
        opts.validateStatus = opts.validateStatus || this.validateStatus;
        opts.responseType = opts.responseType || "json";
        if (!opts.headers["Accept"] && opts.responseType === "json") {
          opts.headers["Accept"] = "application/json";
        }
        opts.method = opts.method || "GET";
        const proxy = getProxy(opts.url);
        if (proxy) {
          if (this.agentCache.has(proxy)) {
            opts.agent = this.agentCache.get(proxy);
          } else {
            if (opts.cert && opts.key) {
              const parsedURL = new url_1.URL(proxy);
              opts.agent = new HttpsProxyAgent({
                port: parsedURL.port,
                host: parsedURL.host,
                protocol: parsedURL.protocol,
                cert: opts.cert,
                key: opts.key
              });
            } else {
              opts.agent = new HttpsProxyAgent(proxy);
            }
            this.agentCache.set(proxy, opts.agent);
          }
        } else if (opts.cert && opts.key) {
          if (this.agentCache.has(opts.key)) {
            opts.agent = this.agentCache.get(opts.key);
          } else {
            opts.agent = new https_1.Agent({
              cert: opts.cert,
              key: opts.key
            });
            this.agentCache.set(opts.key, opts.agent);
          }
        }
        return opts;
      }
      /**
       * By default, throw for any non-2xx status code
       * @param status status code from the HTTP response
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
      /**
       * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
       * @param params key value pars to encode
       */
      paramsSerializer(params) {
        return querystring_1.default.stringify(params);
      }
      translateResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
          headers[key] = value;
        });
        return {
          config: opts,
          data,
          headers,
          status: res.status,
          statusText: res.statusText,
          // XMLHttpRequestLike
          request: {
            responseURL: res.url
          }
        };
      }
    };
    exports.Gaxios = Gaxios;
  }
});

// node_modules/gcp-metadata/node_modules/gaxios/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/gcp-metadata/node_modules/gaxios/build/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.request = exports.instance = exports.Gaxios = exports.GaxiosError = void 0;
    var gaxios_1 = require_gaxios();
    Object.defineProperty(exports, "Gaxios", { enumerable: true, get: function() {
      return gaxios_1.Gaxios;
    } });
    var common_1 = require_common3();
    Object.defineProperty(exports, "GaxiosError", { enumerable: true, get: function() {
      return common_1.GaxiosError;
    } });
    exports.instance = new gaxios_1.Gaxios();
    async function request(opts) {
      return exports.instance.request(opts);
    }
    exports.request = request;
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET2.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET2.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET2 = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET: ALPHABET2
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base2) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base2 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base2;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base2) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base2 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base2) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base2) {
              base2 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base2 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base2);
                xc = multiply(xc, n, base2);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base2 / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base2) n = base2 - 1;
                    prod = multiply(yc, n, base2);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base2);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base2);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base2);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base2 == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base2, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base2 ? p1 : m;
                });
                if (b) {
                  base2 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base2);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base2, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base2 = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base2 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base2;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format3) {
          var str, x = this;
          if (format3 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format3 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format3 = dp;
              dp = rm = null;
            } else {
              format3 = FORMAT;
            }
          } else if (typeof format3 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format3);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format3.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format3.prefix || "") + str + (format3.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format2(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET2.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent2, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent2;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent2 = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent2 += " ";
            }
          } else if (typeof space === "string") {
            indent2 = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error2 = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error2("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error2("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error2("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error2("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error2("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error2('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error2("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error2("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error2("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error2("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS({
  "node_modules/gcp-metadata/build/src/gcp-residency.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;
    var fs_1 = __require("fs");
    var os_1 = __require("os");
    exports.GCE_LINUX_BIOS_PATHS = {
      BIOS_DATE: "/sys/class/dmi/id/bios_date",
      BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
    };
    var GCE_MAC_ADDRESS_REGEX = /^42:01/;
    function isGoogleCloudServerless() {
      const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
      return !!isGFEnvironment;
    }
    exports.isGoogleCloudServerless = isGoogleCloudServerless;
    function isGoogleComputeEngineLinux() {
      if ((0, os_1.platform)() !== "linux")
        return false;
      try {
        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
        return /Google/.test(biosVendor);
      } catch (_a) {
        return false;
      }
    }
    exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
    function isGoogleComputeEngineMACAddress() {
      const interfaces = (0, os_1.networkInterfaces)();
      for (const item of Object.values(interfaces)) {
        if (!item)
          continue;
        for (const { mac } of item) {
          if (GCE_MAC_ADDRESS_REGEX.test(mac)) {
            return true;
          }
        }
      }
      return false;
    }
    exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
    function isGoogleComputeEngine() {
      return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
    }
    exports.isGoogleComputeEngine = isGoogleComputeEngine;
    function detectGCPResidency() {
      return isGoogleCloudServerless() || isGoogleComputeEngine();
    }
    exports.detectGCPResidency = detectGCPResidency;
  }
});

// node_modules/gcp-metadata/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/gcp-metadata/build/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
    var gaxios_1 = require_src3();
    var jsonBigint = require_json_bigint();
    var gcp_residency_1 = require_gcp_residency();
    exports.BASE_PATH = "/computeMetadata/v1";
    exports.HOST_ADDRESS = "http://169.254.169.254";
    exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
    exports.HEADER_NAME = "Metadata-Flavor";
    exports.HEADER_VALUE = "Google";
    exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
    exports.METADATA_SERVER_DETECTION = Object.freeze({
      "assume-present": "don't try to ping the metadata server, but assume it's present",
      none: "don't try to ping the metadata server, but don't try to use it either",
      "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
      "ping-only": "skip the BIOS probe, and go straight to pinging"
    });
    function getBaseUrl(baseUrl) {
      if (!baseUrl) {
        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
      }
      if (!/^https?:\/\//.test(baseUrl)) {
        baseUrl = `http://${baseUrl}`;
      }
      return new URL(exports.BASE_PATH, baseUrl).href;
    }
    function validate4(options) {
      Object.keys(options).forEach((key) => {
        switch (key) {
          case "params":
          case "property":
          case "headers":
            break;
          case "qs":
            throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
          default:
            throw new Error(`'${key}' is not a valid configuration option.`);
        }
      });
    }
    async function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {
      options = options || {};
      if (typeof options === "string") {
        options = { property: options };
      }
      let property2 = "";
      if (typeof options === "object" && options.property) {
        property2 = "/" + options.property;
      }
      validate4(options);
      try {
        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
        const res = await requestMethod({
          url: `${getBaseUrl()}/${type}${property2}`,
          headers: Object.assign({}, exports.HEADERS, options.headers),
          retryConfig: { noResponseRetries },
          params: options.params,
          responseType: "text",
          timeout: requestTimeout()
        });
        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {
          throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);
        } else if (!res.data) {
          throw new Error("Invalid response from the metadata service");
        }
        if (typeof res.data === "string") {
          try {
            return jsonBigint.parse(res.data);
          } catch (_a) {
          }
        }
        return res.data;
      } catch (e) {
        const err = e;
        if (err.response && err.response.status !== 200) {
          err.message = `Unsuccessful response status code. ${err.message}`;
        }
        throw e;
      }
    }
    async function fastFailMetadataRequest(options) {
      const secondaryOptions = {
        ...options,
        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))
      };
      let responded = false;
      const r1 = (0, gaxios_1.request)(options).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r2;
        } else {
          responded = true;
          throw err;
        }
      });
      const r2 = (0, gaxios_1.request)(secondaryOptions).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r1;
        } else {
          responded = true;
          throw err;
        }
      });
      return Promise.race([r1, r2]);
    }
    function instance(options) {
      return metadataAccessor("instance", options);
    }
    exports.instance = instance;
    function project(options) {
      return metadataAccessor("project", options);
    }
    exports.project = project;
    function detectGCPAvailableRetries() {
      return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
    }
    var cachedIsAvailableResponse;
    async function isAvailable() {
      if (process.env.METADATA_SERVER_DETECTION) {
        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
        if (!(value in exports.METADATA_SERVER_DETECTION)) {
          throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
        }
        switch (value) {
          case "assume-present":
            return true;
          case "none":
            return false;
          case "bios-only":
            return getGCPResidency();
          case "ping-only":
        }
      }
      try {
        if (cachedIsAvailableResponse === void 0) {
          cachedIsAvailableResponse = metadataAccessor(
            "instance",
            void 0,
            detectGCPAvailableRetries(),
            // If the default HOST_ADDRESS has been overridden, we should not
            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
            // a non-GCP environment):
            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
          );
        }
        await cachedIsAvailableResponse;
        return true;
      } catch (e) {
        const err = e;
        if (process.env.DEBUG_AUTH) {
          console.info(err);
        }
        if (err.type === "request-timeout") {
          return false;
        }
        if (err.response && err.response.status === 404) {
          return false;
        } else {
          if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code
          // is not populated:
          (!err.code || ![
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "ENETUNREACH",
            "ENOENT",
            "ENOTFOUND",
            "ECONNREFUSED"
          ].includes(err.code))) {
            let code = "UNKNOWN";
            if (err.code)
              code = err.code;
            process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
          }
          return false;
        }
      }
    }
    exports.isAvailable = isAvailable;
    function resetIsAvailableCache() {
      cachedIsAvailableResponse = void 0;
    }
    exports.resetIsAvailableCache = resetIsAvailableCache;
    exports.gcpResidencyCache = null;
    function getGCPResidency() {
      if (exports.gcpResidencyCache === null) {
        setGCPResidency();
      }
      return exports.gcpResidencyCache;
    }
    exports.getGCPResidency = getGCPResidency;
    function setGCPResidency(value = null) {
      exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
    }
    exports.setGCPResidency = setGCPResidency;
    function requestTimeout() {
      return getGCPResidency() ? 0 : 3e3;
    }
    exports.requestTimeout = requestTimeout;
    __exportStar(require_gcp_residency(), exports);
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils3 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = __require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils3();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class _SmartBuffer {
      /**
       * Creates a new SmartBuffer instance.
       *
       * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
       */
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (_SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      /**
       * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
       *
       * @param size { Number } The size of the internal Buffer.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
       *
       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
       * @param encoding { String } The BufferEncoding to use for strings.
       *
       * @return { SmartBuffer }
       */
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      /**
       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
       *
       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
       */
      static fromOptions(options) {
        return new this(options);
      }
      /**
       * Type checking function that determines if an object is a SmartBufferOptions object.
       */
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      // Signed integers
      /**
       * Reads an Int8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      /**
       * Reads an Int16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      /**
       * Reads an Int16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      /**
       * Reads an Int32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      /**
       * Reads an Int32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      /**
       * Reads a BigInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      /**
       * Reads a BigInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      /**
       * Writes an Int8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      /**
       * Inserts an Int8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      /**
       * Writes an Int16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Inserts an Int16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      /**
       * Writes an Int16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Inserts an Int16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      /**
       * Writes an Int32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Inserts an Int32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      /**
       * Writes an Int32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Inserts an Int32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigInt64BE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigInt64BE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigInt64LE value to the current write position (or at optional offset).
       *
       * @param value { BigInt } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      /**
       * Inserts a Int64LE value at the given offset value.
       *
       * @param value { BigInt } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      // Unsigned Integers
      /**
       * Reads an UInt8 value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      /**
       * Reads an UInt16BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      /**
       * Reads an UInt16LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      /**
       * Reads an UInt32BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      /**
       * Reads an UInt32LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      /**
       * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      /**
       * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { BigInt }
       */
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      /**
       * Writes an UInt8 value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Inserts an UInt8 value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      /**
       * Writes an UInt16BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Inserts an UInt16BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      /**
       * Writes an UInt16LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Inserts an UInt16LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      /**
       * Writes an UInt32BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Inserts an UInt32BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      /**
       * Writes an UInt32LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Inserts an UInt32LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      /**
       * Writes a BigUInt64BE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64BE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      /**
       * Writes a BigUInt64LE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      /**
       * Inserts a BigUInt64LE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      // Floating Point
      /**
       * Reads an FloatBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      /**
       * Reads an FloatLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      /**
       * Writes a FloatBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Inserts a FloatBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      /**
       * Writes a FloatLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      /**
       * Inserts a FloatLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      // Double Floating Point
      /**
       * Reads an DoublEBE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      /**
       * Reads an DoubleLE value from the current read position or an optionally provided offset.
       *
       * @param offset { Number } The offset to read data from (optional)
       * @return { Number }
       */
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      /**
       * Writes a DoubleBE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Inserts a DoubleBE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      /**
       * Writes a DoubleLE value to the current write position (or at optional offset).
       *
       * @param value { Number } The value to write.
       * @param offset { Number } The offset to write the value at.
       *
       * @return this
       */
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      /**
       * Inserts a DoubleLE value at the given offset value.
       *
       * @param value { Number } The value to insert.
       * @param offset { Number } The offset to insert the value at.
       *
       * @return this
       */
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      // Strings
      /**
       * Reads a String from the current read position.
       *
       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
       *             the string (Defaults to instance level encoding).
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      /**
       * Inserts a String
       *
       * @param value { String } The String value to insert.
       * @param offset { Number } The offset to insert the string at.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      /**
       * Writes a String
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      /**
       * Reads a null-terminated String from the current read position.
       *
       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
       *
       * @return { String }
       */
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      /**
       * Inserts a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated String.
       *
       * @param value { String } The String value to write.
       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       *
       * @return this
       */
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      // Buffers
      /**
       * Reads a Buffer from the internal read position.
       *
       * @param length { Number } The length of data to read as a Buffer.
       *
       * @return { Buffer }
       */
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      /**
       * Writes a Buffer to the current write position.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      /**
       * Reads a null-terminated Buffer from the current read poisiton.
       *
       * @return { Buffer }
       */
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      /**
       * Inserts a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      /**
       * Writes a null-terminated Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       *
       * @return this
       */
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      /**
       * Clears the SmartBuffer instance to its original empty state.
       */
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      /**
       * Gets the remaining data left to be read from the SmartBuffer instance.
       *
       * @return { Number }
       */
      remaining() {
        return this.length - this._readOffset;
      }
      /**
       * Gets the current read offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get readOffset() {
        return this._readOffset;
      }
      /**
       * Sets the read offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      /**
       * Gets the current write offset value of the SmartBuffer instance.
       *
       * @return { Number }
       */
      get writeOffset() {
        return this._writeOffset;
      }
      /**
       * Sets the write offset value of the SmartBuffer instance.
       *
       * @param offset { Number } - The offset value to set.
       */
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      /**
       * Gets the currently set string encoding of the SmartBuffer instance.
       *
       * @return { BufferEncoding } The string Buffer encoding currently set.
       */
      get encoding() {
        return this._encoding;
      }
      /**
       * Sets the string encoding of the SmartBuffer instance.
       *
       * @param encoding { BufferEncoding } The string Buffer encoding to set.
       */
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      /**
       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
       *
       * @return { Buffer } The Buffer value.
       */
      get internalBuffer() {
        return this._buff;
      }
      /**
       * Gets the value of the internal managed Buffer (Includes managed data only)
       *
       * @param { Buffer }
       */
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      /**
       * Gets the String value of the internal managed Buffer
       *
       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
       */
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      /**
       * Destroys the SmartBuffer instance.
       */
      destroy() {
        this.clear();
        return this;
      }
      /**
       * Handles inserting and writing strings.
       *
       * @param value { String } The String value to insert.
       * @param isInsert { Boolean } True if inserting a string, false if writing.
       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
       */
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      /**
       * Handles writing or insert of a Buffer.
       *
       * @param value { Buffer } The Buffer to write.
       * @param offset { Number } The offset to write the Buffer to.
       */
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      /**
       * Ensures that the internal Buffer is large enough to read data.
       *
       * @param length { Number } The length of the data that needs to be read.
       * @param offset { Number } The offset of the data that needs to be read.
       */
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to insert data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written.
       */
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write data.
       *
       * @param dataLength { Number } The length of the data that needs to be written.
       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
       */
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      /**
       * Ensures that the internal Buffer is large enough to write at least the given amount of data.
       *
       * @param minLength { Number } The minimum length of the data needs to be written.
       */
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      /**
       * Reads a numeric number value using the provided function.
       *
       * @typeparam T { number | bigint } The type of the value to be read
       *
       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes read.
       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
       *
       * @returns { T } the number value
       */
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      /**
       * Inserts a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      /**
       * Writes a numeric number value based on the given offset and value.
       *
       * @typeparam T { number | bigint } The type of the value to be written
       *
       * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
       * @param byteSize { Number } The number of bytes written.
       * @param value { T } The number value to write.
       * @param offset { Number } the offset to write the number at (REQUIRED).
       *
       * @returns SmartBuffer this buffer
       */
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants3 = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      // Command response + incoming connection (bind)
      Socks5ResponseHeader: 5,
      // We need at least 5 to read the hostname length, then we wait for the address+port information.
      Socks5ResponseIPv4: 10,
      // 4 header + 4 ip + 2 port
      Socks5ResponseIPv6: 22,
      // 4 header + 16 ip + 2 port
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      // 4 header + 1 host length + host + 2 port
      // Command response + incoming connection (bind)
      Socks4Response: 8
      // 2 header + 2 port + 4 ip
    };
    exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (exports.SocksCommand = SocksCommand = {}));
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (exports.Socks4Response = Socks4Response = {}));
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (exports.Socks5Response = Socks5Response = {}));
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (exports.SocksClientState = SocksClientState = {}));
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffleArray = exports.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports.shuffleArray = shuffleArray;
  }
});

// node_modules/ip-address/dist/common.js
var require_common5 = __commonJS({
  "node_modules/ip-address/dist/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInSubnet = isInSubnet;
    exports.isCorrect = isCorrect;
    exports.numberToPaddedHex = numberToPaddedHex;
    exports.stringToPaddedHex = stringToPaddedHex;
    exports.testBit = testBit;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    function numberToPaddedHex(number) {
      return number.toString(16).padStart(2, "0");
    }
    function stringToPaddedHex(numberString) {
      return numberToPaddedHex(parseInt(numberString, 10));
    }
    function testBit(binaryValue, position) {
      const { length } = binaryValue;
      if (position > length) {
        return false;
      }
      const positionInString = length - position;
      return binaryValue.substring(positionInString, positionInString + 1) === "1";
    }
  }
});

// node_modules/ip-address/dist/v4/constants.js
var require_constants4 = __commonJS({
  "node_modules/ip-address/dist/v4/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;
    exports.BITS = 32;
    exports.GROUPS = 4;
    exports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/address-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressError = void 0;
    var AddressError = class extends Error {
      constructor(message, parseMessage) {
        super(message);
        this.name = "AddressError";
        this.parseMessage = parseMessage;
      }
    };
    exports.AddressError = AddressError;
  }
});

// node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/ipv4.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address4 = void 0;
    var common = __importStar(require_common5());
    var constants = __importStar(require_constants4());
    var address_error_1 = require_address_error();
    var Address4 = class _Address4 {
      constructor(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        const subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      static isValid(address) {
        try {
          new _Address4(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /*
       * Parses a v4 address
       */
      parse(address) {
        const groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      }
      /**
       * Returns the correct form of an address
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      correctForm() {
        return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
      }
      /**
       * Converts a hex string to an IPv4 address object
       * @memberof Address4
       * @static
       * @param {string} hex - a hex string to convert
       * @returns {Address4}
       */
      static fromHex(hex) {
        const padded = hex.replace(/:/g, "").padStart(8, "0");
        const groups = [];
        let i;
        for (i = 0; i < 8; i += 2) {
          const h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new _Address4(groups.join("."));
      }
      /**
       * Converts an integer into a IPv4 address object
       * @memberof Address4
       * @static
       * @param {integer} integer - a number to convert
       * @returns {Address4}
       */
      static fromInteger(integer) {
        return _Address4.fromHex(integer.toString(16));
      }
      /**
       * Return an address from in-addr.arpa form
       * @memberof Address4
       * @static
       * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
       * @returns {Adress4}
       * @example
       * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
       * address.correctForm(); // '192.0.2.42'
       */
      static fromArpa(arpaFormAddress) {
        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        const address = leader.split(".").reverse().join(".");
        return new _Address4(address);
      }
      /**
       * Converts an IPv4 address object to a hex string
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toHex() {
        return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(":");
      }
      /**
       * Converts an IPv4 address object to an array of bytes
       * @memberof Address4
       * @instance
       * @returns {Array}
       */
      toArray() {
        return this.parsedAddress.map((part) => parseInt(part, 10));
      }
      /**
       * Converts an IPv4 address object to an IPv6 address group
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      toGroup6() {
        const output = [];
        let i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);
        }
        return output.join(":");
      }
      /**
       * Returns the address as a `bigint`
       * @memberof Address4
       * @instance
       * @returns {bigint}
       */
      bigInt() {
        return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join("")}`);
      }
      /**
       * Helper function getting start address.
       * @memberof Address4
       * @instance
       * @returns {bigint}
       */
      _startAddress() {
        return BigInt(`0b${this.mask() + "0".repeat(constants.BITS - this.subnetMask)}`);
      }
      /**
       * The first address in the range given by this address' subnet.
       * Often referred to as the Network Address.
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddress() {
        return _Address4.fromBigInt(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      startAddressExclusive() {
        const adjust = BigInt("1");
        return _Address4.fromBigInt(this._startAddress() + adjust);
      }
      /**
       * Helper function getting end address.
       * @memberof Address4
       * @instance
       * @returns {bigint}
       */
      _endAddress() {
        return BigInt(`0b${this.mask() + "1".repeat(constants.BITS - this.subnetMask)}`);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddress() {
        return _Address4.fromBigInt(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address4
       * @instance
       * @returns {Address4}
       */
      endAddressExclusive() {
        const adjust = BigInt("1");
        return _Address4.fromBigInt(this._endAddress() - adjust);
      }
      /**
       * Converts a BigInt to a v4 address object
       * @memberof Address4
       * @static
       * @param {bigint} bigInt - a BigInt to convert
       * @returns {Address4}
       */
      static fromBigInt(bigInt) {
        return _Address4.fromHex(bigInt.toString(16));
      }
      /**
       * Returns the first n bits of the address, defaulting to the
       * subnet mask
       * @memberof Address4
       * @instance
       * @returns {String}
       */
      mask(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      }
      /**
       * Returns the bits in the given range as a base-2 string
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address4
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return `${reversed}.in-addr.arpa.`;
      }
      /**
       * Returns true if the given address is a multicast address
       * @memberof Address4
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.isInSubnet(new _Address4("224.0.0.0/4"));
      }
      /**
       * Returns a zero-padded base-2 string representation of the address
       * @memberof Address4
       * @instance
       * @returns {string}
       */
      binaryZeroPad() {
        return this.bigInt().toString(2).padStart(constants.BITS, "0");
      }
      /**
       * Groups an IPv4 address for inclusion at the end of an IPv6 address
       * @returns {String}
       */
      groupForV6() {
        const segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, `<span class="hover-group group-v4 group-6">${segments.slice(0, 2).join(".")}</span>.<span class="hover-group group-v4 group-7">${segments.slice(2, 4).join(".")}</span>`);
      }
    };
    exports.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/v6/constants.js
var require_constants5 = __commonJS({
  "node_modules/ip-address/dist/v6/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;
    exports.BITS = 128;
    exports.GROUPS = 8;
    exports.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports.RE_ZONE_STRING = /%.*$/;
    exports.RE_URL = /^\[{0,1}([0-9a-f:]+)\]{0,1}/;
    exports.RE_URL_WITH_PORT = /\[([0-9a-f:]+)\]:([0-9]{1,5})/;
  }
});

// node_modules/ip-address/dist/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/ip-address/dist/v6/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spanAllZeroes = spanAllZeroes;
    exports.spanAll = spanAll;
    exports.spanLeadingZeroes = spanLeadingZeroes;
    exports.simpleGroup = simpleGroup;
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    function spanAll(s, offset = 0) {
      const letters = s.split("");
      return letters.map((n, i) => `<span class="digit value-${n} position-${i + offset}">${spanAllZeroes(n)}</span>`).join("");
    }
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      const groups = address.split(":");
      return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
    }
    function simpleGroup(addressString, offset = 0) {
      const groups = addressString.split(":");
      return groups.map((g, i) => {
        if (/group-v4/.test(g)) {
          return g;
        }
        return `<span class="hover-group group-${i + offset}">${spanLeadingZeroesSimple(g)}</span>`;
      });
    }
  }
});

// node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/v6/regular-expressions.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADDRESS_BOUNDARY = void 0;
    exports.groupPossibilities = groupPossibilities;
    exports.padGroup = padGroup;
    exports.simpleRegularExpression = simpleRegularExpression;
    exports.possibleElisions = possibleElisions;
    var v6 = __importStar(require_constants5());
    function groupPossibilities(possibilities) {
      return `(${possibilities.join("|")})`;
    }
    function padGroup(group) {
      if (group.length < 4) {
        return `0{0,${4 - group.length}}${group}`;
      }
      return group;
    }
    exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      const zeroIndexes = [];
      groups.forEach((group, i) => {
        const groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
        if (i === zeroIndex) {
          const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":"));
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      const left = moreLeft ? "" : ":";
      const right = moreRight ? "" : ":";
      const possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push(`${left}(:0{1,4}){1,${elidedGroups - 1}}`);
      possibilities.push(`(0{1,4}:){1,${elidedGroups - 1}}${right}`);
      possibilities.push(`(0{1,4}:){${elidedGroups - 1}}0{1,4}`);
      for (let groups = 1; groups < elidedGroups - 1; groups++) {
        for (let position = 1; position < elidedGroups - groups; position++) {
          possibilities.push(`(0{1,4}:){${position}}:(0{1,4}:){${elidedGroups - position - groups - 1}}0{1,4}`);
        }
      }
      return groupPossibilities(possibilities);
    }
  }
});

// node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/ipv6.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Address6 = void 0;
    var common = __importStar(require_common5());
    var constants4 = __importStar(require_constants4());
    var constants6 = __importStar(require_constants5());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var common_1 = require_common5();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      const r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      const s1 = [];
      const s2 = [];
      let i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return parseInt(octet, 16).toString(16).padStart(4, "0");
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = class _Address6 {
      constructor(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        const subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        const zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      static isValid(address) {
        try {
          new _Address6(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      /**
       * Convert a BigInt to a v6 address object
       * @memberof Address6
       * @static
       * @param {bigint} bigInt - a BigInt to convert
       * @returns {Address6}
       * @example
       * var bigInt = BigInt('1000000000000');
       * var address = Address6.fromBigInt(bigInt);
       * address.correctForm(); // '::e8:d4a5:1000'
       */
      static fromBigInt(bigInt) {
        const hex = bigInt.toString(16).padStart(32, "0");
        const groups = [];
        let i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new _Address6(groups.join(":"));
      }
      /**
       * Convert a URL (with optional port number) to an address object
       * @memberof Address6
       * @static
       * @param {string} url - a URL with optional port number
       * @example
       * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
       * addressAndPort.address.correctForm(); // 'ffff::'
       * addressAndPort.port; // 8080
       */
      static fromURL(url2) {
        let host;
        let port = null;
        let result;
        if (url2.indexOf("[") !== -1 && url2.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url2);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url2.indexOf("/") !== -1) {
          url2 = url2.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url2);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url2;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new _Address6(host),
          port
        };
      }
      /**
       * Create an IPv6-mapped address given an IPv4 address
       * @memberof Address6
       * @static
       * @param {string} address - An IPv4 address string
       * @returns {Address6}
       * @example
       * var address = Address6.fromAddress4('192.168.0.1');
       * address.correctForm(); // '::ffff:c0a8:1'
       * address.to4in6(); // '::ffff:192.168.0.1'
       */
      static fromAddress4(address) {
        const address4 = new ipv4_1.Address4(address);
        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new _Address6(`::ffff:${address4.correctForm()}/${mask6}`);
      }
      /**
       * Return an address from ip6.arpa form
       * @memberof Address6
       * @static
       * @param {string} arpaFormAddress - an 'ip6.arpa' form address
       * @returns {Adress6}
       * @example
       * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
       * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
       */
      static fromArpa(arpaFormAddress) {
        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        const semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        const parts = address.split(".").reverse();
        for (let i = semicolonAmount; i > 0; i--) {
          const insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new _Address6(address);
      }
      /**
       * Return the Microsoft UNC transcription of the address
       * @memberof Address6
       * @instance
       * @returns {String} the Microsoft UNC transcription of the address
       */
      microsoftTranscription() {
        return `${this.correctForm().replace(/:/g, "-")}.ipv6-literal.net`;
      }
      /**
       * Return the first n bits of the address, defaulting to the subnet mask
       * @memberof Address6
       * @instance
       * @param {number} [mask=subnet] - the number of bits to mask
       * @returns {String} the first n bits of the address as a string
       */
      mask(mask = this.subnetMask) {
        return this.getBitsBase2(0, mask);
      }
      /**
       * Return the number of possible subnets of a given size in the address
       * @memberof Address6
       * @instance
       * @param {number} [subnetSize=128] - the subnet size
       * @returns {String}
       */
      // TODO: probably useful to have a numeric version of this too
      possibleSubnets(subnetSize = 128) {
        const availableBits = constants6.BITS - this.subnetMask;
        const subnetBits = Math.abs(subnetSize - constants6.BITS);
        const subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas((BigInt("2") ** BigInt(subnetPowers)).toString(10));
      }
      /**
       * Helper function getting start address.
       * @memberof Address6
       * @instance
       * @returns {bigint}
       */
      _startAddress() {
        return BigInt(`0b${this.mask() + "0".repeat(constants6.BITS - this.subnetMask)}`);
      }
      /**
       * The first address in the range given by this address' subnet
       * Often referred to as the Network Address.
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddress() {
        return _Address6.fromBigInt(this._startAddress());
      }
      /**
       * The first host address in the range given by this address's subnet ie
       * the first address after the Network Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      startAddressExclusive() {
        const adjust = BigInt("1");
        return _Address6.fromBigInt(this._startAddress() + adjust);
      }
      /**
       * Helper function getting end address.
       * @memberof Address6
       * @instance
       * @returns {bigint}
       */
      _endAddress() {
        return BigInt(`0b${this.mask() + "1".repeat(constants6.BITS - this.subnetMask)}`);
      }
      /**
       * The last address in the range given by this address' subnet
       * Often referred to as the Broadcast
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddress() {
        return _Address6.fromBigInt(this._endAddress());
      }
      /**
       * The last host address in the range given by this address's subnet ie
       * the last address prior to the Broadcast Address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      endAddressExclusive() {
        const adjust = BigInt("1");
        return _Address6.fromBigInt(this._endAddress() - adjust);
      }
      /**
       * Return the scope of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getScope() {
        let scope = constants6.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      }
      /**
       * Return the type of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getType() {
        for (const subnet of Object.keys(constants6.TYPES)) {
          if (this.isInSubnet(new _Address6(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      }
      /**
       * Return the bits in the given range as a BigInt
       * @memberof Address6
       * @instance
       * @returns {bigint}
       */
      getBits(start, end) {
        return BigInt(`0b${this.getBitsBase2(start, end)}`);
      }
      /**
       * Return the bits in the given range as a base-2 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      /**
       * Return the bits in the given range as a base-16 string
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsBase16(start, end) {
        const length = end - start;
        if (length % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length / 4, "0");
      }
      /**
       * Return the bits that are set past the subnet mask length
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      getBitsPastSubnet() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      }
      /**
       * Return the reversed ip6.arpa form of the address
       * @memberof Address6
       * @param {Object} options
       * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
       * @instance
       * @returns {String}
       */
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const characters = Math.floor(this.subnetMask / 4);
        const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return `${reversed}.ip6.arpa.`;
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      }
      /**
       * Return the correct form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      correctForm() {
        let i;
        let groups = [];
        let zeroCounter = 0;
        const zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          const value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
        if (zeroes.length > 0) {
          const index = zeroLengths.indexOf(Math.max(...zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        let correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/(^compact)|(compact$)/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      }
      /**
       * Return a zero-padded base-2 string representation of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       * @example
       * var address = new Address6('2001:4860:4001:803::1011');
       * address.binaryZeroPad();
       * // '0010000000000001010010000110000001000000000000010000100000000011
       * //  0000000000000000000000000000000000000000000000000001000000010001'
       */
      binaryZeroPad() {
        return this.bigInt().toString(2).padStart(constants6.BITS, "0");
      }
      // TODO: Improve the semantics of this helper function
      parse4in6(address) {
        const groups = address.split(":");
        const lastGroup = groups.slice(-1)[0];
        const address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (let i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      }
      // TODO: Make private?
      parse(address) {
        address = this.parse4in6(address);
        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError(`Bad character${badCharacters.length > 1 ? "s" : ""} detected in address: ${badCharacters.join("")}`, address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError(`Address failed regex: ${badAddress.join("")}`, address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        let groups = [];
        const halves = address.split("::");
        if (halves.length === 2) {
          let first = halves[0].split(":");
          let last = halves[1].split(":");
          if (first.length === 1 && first[0] === "") {
            first = [];
          }
          if (last.length === 1 && last[0] === "") {
            last = [];
          }
          const remaining = this.groups - (first.length + last.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first.length;
          this.elisionEnd = first.length + this.elidedGroups;
          groups = groups.concat(first);
          for (let i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map((group) => parseInt(group, 16).toString(16));
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      }
      /**
       * Return the canonical form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      canonicalForm() {
        return this.parsedAddress.map(paddedHex).join(":");
      }
      /**
       * Return the decimal form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      decimal() {
        return this.parsedAddress.map((n) => parseInt(n, 16).toString(10).padStart(5, "0")).join(":");
      }
      /**
       * Return the address as a BigInt
       * @memberof Address6
       * @instance
       * @returns {bigint}
       */
      bigInt() {
        return BigInt(`0x${this.parsedAddress.map(paddedHex).join("")}`);
      }
      /**
       * Return the last two groups of this address as an IPv4 address string
       * @memberof Address6
       * @instance
       * @returns {Address4}
       * @example
       * var address = new Address6('2001:4860:4001::1825:bf11');
       * address.to4().correctForm(); // '24.37.191.17'
       */
      to4() {
        const binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(BigInt(`0b${binary.slice(96, 128).join("")}`).toString(16));
      }
      /**
       * Return the v4-in-v6 form of the address
       * @memberof Address6
       * @instance
       * @returns {String}
       */
      to4in6() {
        const address4 = this.to4();
        const address6 = new _Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
        const correct = address6.correctForm();
        let infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      }
      /**
       * Return an object containing the Teredo properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspectTeredo() {
        const prefix = this.getBitsBase16(0, 32);
        const bitsForUdpPort = this.getBits(80, 96);
        const udpPort = (bitsForUdpPort ^ BigInt("0xffff")).toString();
        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        const bitsForClient4 = this.getBits(96, 128);
        const client4 = ipv4_1.Address4.fromHex((bitsForClient4 ^ BigInt("0xffffffff")).toString(16));
        const flagsBase2 = this.getBitsBase2(64, 80);
        const coneNat = (0, common_1.testBit)(flagsBase2, 15);
        const reserved = (0, common_1.testBit)(flagsBase2, 14);
        const groupIndividual = (0, common_1.testBit)(flagsBase2, 8);
        const universalLocal = (0, common_1.testBit)(flagsBase2, 9);
        const nonce = BigInt(`0b${flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16)}`).toString(10);
        return {
          prefix: `${prefix.slice(0, 4)}:${prefix.slice(4, 8)}`,
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      }
      /**
       * Return an object containing the 6to4 properties of the address
       * @memberof Address6
       * @instance
       * @returns {Object}
       */
      inspect6to4() {
        const prefix = this.getBitsBase16(0, 16);
        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: prefix.slice(0, 4),
          gateway: gateway.address
        };
      }
      /**
       * Return a v6 6to4 address from a v6 v4inv6 address
       * @memberof Address6
       * @instance
       * @returns {Address6}
       */
      to6to4() {
        if (!this.is4()) {
          return null;
        }
        const addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new _Address6(addr6to4);
      }
      /**
       * Return a byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toByteArray() {
        const valueWithoutPadding = this.bigInt().toString(16);
        const leadingPad = "0".repeat(valueWithoutPadding.length % 2);
        const value = `${leadingPad}${valueWithoutPadding}`;
        const bytes = [];
        for (let i = 0, length = value.length; i < length; i += 2) {
          bytes.push(parseInt(value.substring(i, i + 2), 16));
        }
        return bytes;
      }
      /**
       * Return an unsigned byte array
       * @memberof Address6
       * @instance
       * @returns {Array}
       */
      toUnsignedByteArray() {
        return this.toByteArray().map(unsignByte);
      }
      /**
       * Convert a byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromByteArray(bytes) {
        return this.fromUnsignedByteArray(bytes.map(unsignByte));
      }
      /**
       * Convert an unsigned byte array to an Address6 object
       * @memberof Address6
       * @static
       * @returns {Address6}
       */
      static fromUnsignedByteArray(bytes) {
        const BYTE_MAX = BigInt("256");
        let result = BigInt("0");
        let multiplier = BigInt("1");
        for (let i = bytes.length - 1; i >= 0; i--) {
          result += multiplier * BigInt(bytes[i].toString(10));
          multiplier *= BYTE_MAX;
        }
        return _Address6.fromBigInt(result);
      }
      /**
       * Returns true if the address is in the canonical form, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isCanonical() {
        return this.addressMinusSuffix === this.canonicalForm();
      }
      /**
       * Returns true if the address is a link local address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLinkLocal() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      }
      /**
       * Returns true if the address is a multicast address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isMulticast() {
        return this.getType() === "Multicast";
      }
      /**
       * Returns true if the address is a v4-in-v6 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is4() {
        return this.v4;
      }
      /**
       * Returns true if the address is a Teredo address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isTeredo() {
        return this.isInSubnet(new _Address6("2001::/32"));
      }
      /**
       * Returns true if the address is a 6to4 address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      is6to4() {
        return this.isInSubnet(new _Address6("2002::/16"));
      }
      /**
       * Returns true if the address is a loopback address, false otherwise
       * @memberof Address6
       * @instance
       * @returns {boolean}
       */
      isLoopback() {
        return this.getType() === "Loopback";
      }
      // #endregion
      // #region HTML
      /**
       * @returns {String} the address in link form with a default port of 80
       */
      href(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = `:${optionalPort}`;
        }
        return `http://[${this.correctForm()}]${optionalPort}/`;
      }
      /**
       * @returns {String} a link suitable for conveying the address via a URL hash
       */
      link(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        let formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        const form = formFunction.call(this);
        if (options.className) {
          return `<a href="${options.prefix}${form}" class="${options.className}">${form}</a>`;
        }
        return `<a href="${options.prefix}${form}">${form}</a>`;
      }
      /**
       * Groups an address
       * @returns {String}
       */
      group() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        const output = [];
        const [left, right] = this.address.split("::");
        if (left.length) {
          output.push(...helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        const classes = ["hover-group"];
        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push(`group-${i}`);
        }
        output.push(`<span class="${classes.join(" ")}"></span>`);
        if (right.length) {
          output.push(...helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      }
      // #endregion
      // #region Regular expressions
      /**
       * Generate a regular expression string that can be used to find or validate
       * all variations of this address
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {string}
       */
      regularExpressionString(substringSearch = false) {
        let output = [];
        const address6 = new _Address6(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
        } else {
          const halves = address6.address.split("::");
          if (halves[0].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = [
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])(",
            ...output,
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ];
        }
        return output.join("");
      }
      /**
       * Generate a regular expression that can be used to find or validate all
       * variations of this address.
       * @memberof Address6
       * @instance
       * @param {boolean} substringSearch
       * @returns {RegExp}
       */
      regularExpression(substringSearch = false) {
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      }
    };
    exports.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/ip-address.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers());
    exports.v6 = { helpers };
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ipToBuffer = exports.int32ToIpv4 = exports.ipv4ToInt32 = exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants3();
    var stream4 = __require("stream");
    var ip_address_1 = require_ip_address();
    var net = __require("net");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream4.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && Buffer.byteLength(remoteHost.host) < 256 && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
    function ipv4ToInt32(ip) {
      const address = new ip_address_1.Address4(ip);
      return address.toArray().reduce((acc, part) => (acc << 8) + part, 0) >>> 0;
    }
    exports.ipv4ToInt32 = ipv4ToInt32;
    function int32ToIpv4(int32) {
      const octet1 = int32 >>> 24 & 255;
      const octet2 = int32 >>> 16 & 255;
      const octet3 = int32 >>> 8 & 255;
      const octet4 = int32 & 255;
      return [octet1, octet2, octet3, octet4].join(".");
    }
    exports.int32ToIpv4 = int32ToIpv4;
    function ipToBuffer(ip) {
      if (net.isIPv4(ip)) {
        const address = new ip_address_1.Address4(ip);
        return Buffer.from(address.toArray());
      } else if (net.isIPv6(ip)) {
        const address = new ip_address_1.Address6(ip);
        return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
      } else {
        throw new Error("Invalid IP address format");
      }
    }
    exports.ipToBuffer = ipToBuffer;
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocksClientError = exports.SocksClient = void 0;
    var events_1 = __require("events");
    var net = __require("net");
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants3();
    var helpers_1 = require_helpers2();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var ip_address_1 = require_ip_address();
    var SocksClient = class _SocksClient extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      /**
       * Creates a new SOCKS connection.
       *
       * Note: Supports callbacks and promises. Only supports the connect command.
       * @param options { SocksClientOptions } Options.
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new _SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      /**
       * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
       *
       * Note: Supports callbacks and promises. Only supports the connect method.
       * Note: Implemented via createConnection() factory function.
       * @param options { SocksClientChainOptions } Options
       * @param callback { Function } An optional callback function.
       * @returns { Promise }
       */
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield _SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      /**
       * Creates a SOCKS UDP Frame.
       * @param options
       */
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      /**
       * Parses a SOCKS UDP frame.
       * @param data
       */
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      /**
       * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
       */
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      /**
       * Starts the connection establishment to the proxy and destination.
       * @param existingSocket Connected socket to use instead of creating a new one (internal use).
       */
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      /**
       * Handles internal Socks timeout callback.
       * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
       */
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      /**
       * Handles Socket connect event.
       */
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles Socket data event.
       * @param data
       */
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      /**
       * Handles processing of the data we have received.
       */
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      /**
       * Handles Socket close event.
       * @param had_error
       */
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      /**
       * Handles Socket error event.
       * @param err
       */
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      /**
       * Removes internal event listeners on the underlying Socket.
       */
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      /**
       * Closes and destroys the underlying Socket. Emits an error event.
       * @param err { String } An error string to include in error event.
       */
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      /**
       * Sends initial Socks v4 handshake request.
       */
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      /**
       * Handles Socks v4 handshake response.
       * @param data
       */
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      /**
       * Handles Socks v4 incoming connection request (BIND)
       * @param data
       */
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      /**
       * Sends initial Socks v5 handshake request.
       */
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      /**
       * Handles initial Socks v5 handshake response.
       * @param data
       */
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      /**
       * Sends Socks v5 user & password auth handshake.
       *
       * Note: No auth and user/pass are currently supported.
       */
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      /**
       * Handles Socks v5 auth handshake response.
       * @param data
       */
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      /**
       * Sends Socks v5 final handshake request.
       */
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      /**
       * Handles Socks v5 final handshake response.
       * @param data
       */
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      /**
       * Handles Socks v5 incoming connection request (BIND).
       */
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports);
  }
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS({
  "node_modules/mongodb/lib/deps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aws4 = void 0;
    exports.getKerberos = getKerberos;
    exports.getZstdLibrary = getZstdLibrary;
    exports.getAwsCredentialProvider = getAwsCredentialProvider;
    exports.getGcpMetadata = getGcpMetadata;
    exports.getSnappy = getSnappy;
    exports.getSocks = getSocks;
    exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
    var error_1 = require_error();
    function makeErrorModule(error2) {
      const props = error2 ? { kModuleError: error2 } : {};
      return new Proxy(props, {
        get: (_, key) => {
          if (key === "kModuleError") {
            return error2;
          }
          throw error2;
        },
        set: () => {
          throw error2;
        }
      });
    }
    function getKerberos() {
      let kerberos;
      try {
        kerberos = __require("kerberos");
      } catch (error2) {
        kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication", { cause: error2, dependencyName: "kerberos" }));
      }
      return kerberos;
    }
    function getZstdLibrary() {
      let ZStandard;
      try {
        ZStandard = __require("@mongodb-js/zstd");
      } catch (error2) {
        ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression", { cause: error2, dependencyName: "zstd" }));
      }
      return ZStandard;
    }
    function getAwsCredentialProvider() {
      try {
        const credentialProvider = __require("@aws-sdk/credential-providers");
        return credentialProvider;
      } catch (error2) {
        return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found. Please install it to enable getting aws credentials via the official sdk.", { cause: error2, dependencyName: "@aws-sdk/credential-providers" }));
      }
    }
    function getGcpMetadata() {
      try {
        const credentialProvider = require_src4();
        return credentialProvider;
      } catch (error2) {
        return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `gcp-metadata` not found. Please install it to enable getting gcp credentials via the official sdk.", { cause: error2, dependencyName: "gcp-metadata" }));
      }
    }
    function getSnappy() {
      try {
        const value = __require("snappy");
        return value;
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause: error2, dependencyName: "snappy" });
        return { kModuleError };
      }
    }
    function getSocks() {
      try {
        const value = require_build();
        return value;
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy", { cause: error2, dependencyName: "socks" });
        return { kModuleError };
      }
    }
    exports.aws4 = loadAws4();
    function loadAws4() {
      let aws4;
      try {
        aws4 = __require("aws4");
      } catch (error2) {
        aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication", { cause: error2, dependencyName: "aws4" }));
      }
      return aws4;
    }
    function getMongoDBClientEncryption() {
      let mongodbClientEncryption = null;
      try {
        mongodbClientEncryption = __require("mongodb-client-encryption");
      } catch (error2) {
        const kModuleError = new error_1.MongoMissingDependencyError("Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.", { cause: error2, dependencyName: "mongodb-client-encryption" });
        return { kModuleError };
      }
      return mongodbClientEncryption;
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/auth_provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthProvider = exports.AuthContext = void 0;
    var error_1 = require_error();
    var AuthContext = class {
      constructor(connection, credentials, options) {
        this.reauthenticating = false;
        this.connection = connection;
        this.credentials = credentials;
        this.options = options;
      }
    };
    exports.AuthContext = AuthContext;
    var AuthProvider = class {
      /**
       * Prepare the handshake document before the initial handshake.
       *
       * @param handshakeDoc - The document used for the initial handshake on a connection
       * @param authContext - Context for authentication flow
       */
      async prepare(handshakeDoc, _authContext) {
        return handshakeDoc;
      }
      /**
       * Reauthenticate.
       * @param context - The shared auth context.
       */
      async reauth(context) {
        if (context.reauthenticating) {
          throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
        }
        try {
          context.reauthenticating = true;
          await this.auth(context);
        } finally {
          context.reauthenticating = false;
        }
      }
    };
    exports.AuthProvider = AuthProvider;
  }
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/gssapi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;
    exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
    exports.resolveCname = resolveCname;
    var dns = __require("dns");
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    exports.GSSAPICanonicalizationValue = Object.freeze({
      on: true,
      off: false,
      none: "none",
      forward: "forward",
      forwardAndReverse: "forwardAndReverse"
    });
    async function externalCommand(connection, command) {
      const response = await connection.command((0, utils_1.ns)("$external.$cmd"), command);
      return response;
    }
    var krb;
    var GSSAPI = class extends auth_provider_1.AuthProvider {
      async auth(authContext) {
        const { connection, credentials } = authContext;
        if (credentials == null) {
          throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
        }
        const { username } = credentials;
        const client = await makeKerberosClient(authContext);
        const payload = await client.step("");
        const saslStartResponse = await externalCommand(connection, saslStart(payload));
        const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
        const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
        const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
        await externalCommand(connection, {
          saslContinue: 1,
          conversationId: saslContinueResponse.conversationId,
          payload: finalizePayload
        });
      }
    };
    exports.GSSAPI = GSSAPI;
    async function makeKerberosClient(authContext) {
      const { hostAddress } = authContext.options;
      const { credentials } = authContext;
      if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
        throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
      }
      loadKrb();
      if ("kModuleError" in krb) {
        throw krb["kModuleError"];
      }
      const { initializeClient } = krb;
      const { username, password } = credentials;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
      const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
      const initOptions = {};
      if (password != null) {
        Object.assign(initOptions, { user: username, password });
      }
      const spnHost = mechanismProperties.SERVICE_HOST ?? host;
      let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
      if ("SERVICE_REALM" in mechanismProperties) {
        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
      }
      return await initializeClient(spn, initOptions);
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    async function negotiate(client, retries, payload) {
      try {
        const response = await client.step(payload);
        return response || "";
      } catch (error2) {
        if (retries === 0) {
          throw error2;
        }
        return await negotiate(client, retries - 1, payload);
      }
    }
    async function finalize(client, user, payload) {
      const response = await client.unwrap(payload);
      return await client.wrap(response || "", { user });
    }
    async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
      const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
      if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
        return host;
      }
      if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
        const { address } = await dns.promises.lookup(host);
        try {
          const results = await dns.promises.resolvePtr(address);
          return results.length > 0 ? results[0] : host;
        } catch {
          return await resolveCname(host);
        }
      } else {
        return await resolveCname(host);
      }
    }
    async function resolveCname(host) {
      try {
        const results = await dns.promises.resolveCname(host);
        return results.length > 0 ? results[0] : host;
      } catch {
        return host;
      }
    }
    function loadKrb() {
      if (!krb) {
        krb = (0, deps_1.getKerberos)();
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/providers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = void 0;
    exports.AuthMechanism = Object.freeze({
      MONGODB_AWS: "MONGODB-AWS",
      MONGODB_CR: "MONGODB-CR",
      MONGODB_DEFAULT: "DEFAULT",
      MONGODB_GSSAPI: "GSSAPI",
      MONGODB_PLAIN: "PLAIN",
      MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
      MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
      MONGODB_X509: "MONGODB-X509",
      MONGODB_OIDC: "MONGODB-OIDC"
    });
    exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = /* @__PURE__ */ new Set([
      exports.AuthMechanism.MONGODB_GSSAPI,
      exports.AuthMechanism.MONGODB_AWS,
      exports.AuthMechanism.MONGODB_OIDC,
      exports.AuthMechanism.MONGODB_X509
    ]);
  }
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongo_credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = void 0;
    var error_1 = require_error();
    var gssapi_1 = require_gssapi();
    var providers_1 = require_providers();
    function getDefaultAuthMechanism(hello) {
      if (hello) {
        if (Array.isArray(hello.saslSupportedMechs)) {
          return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
        }
      }
      return providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    }
    var ALLOWED_ENVIRONMENT_NAMES = [
      "test",
      "azure",
      "gcp",
      "k8s"
    ];
    var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
    exports.DEFAULT_ALLOWED_HOSTS = [
      "*.mongodb.net",
      "*.mongodb-qa.net",
      "*.mongodb-dev.net",
      "*.mongodbgov.net",
      "localhost",
      "127.0.0.1",
      "::1"
    ];
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.";
    var MongoCredentials = class _MongoCredentials {
      constructor(options) {
        this.username = options.username ?? "";
        this.password = options.password;
        this.source = options.source;
        if (!this.source && options.db) {
          this.source = options.db;
        }
        this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
        this.mechanismProperties = options.mechanismProperties || {};
        if (this.mechanism.match(/MONGODB-AWS/i)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
            this.mechanismProperties = {
              ...this.mechanismProperties,
              AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
            };
          }
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
          };
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      /** Determines if two MongoCredentials objects are equivalent */
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      /**
       * If the authentication mechanism is set to "default", resolves the authMechanism
       * based on the server version and server supported sasl mechanisms.
       *
       * @param hello - A hello response from the server
       */
      resolveAuthMechanism(hello) {
        if (this.mechanism.match(/DEFAULT/i)) {
          return new _MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(hello),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
      validate() {
        if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
          throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
          if (this.username && this.mechanismProperties.ENVIRONMENT && this.mechanismProperties.ENVIRONMENT !== "azure") {
            throw new error_1.MongoInvalidArgumentError(`username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`);
          }
          if (this.username && this.password) {
            throw new error_1.MongoInvalidArgumentError(`No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`);
          }
          if ((this.mechanismProperties.ENVIRONMENT === "azure" || this.mechanismProperties.ENVIRONMENT === "gcp") && !this.mechanismProperties.TOKEN_RESOURCE) {
            throw new error_1.MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);
          }
          if (this.mechanismProperties.ENVIRONMENT && !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)) {
            throw new error_1.MongoInvalidArgumentError(`Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
          }
          if (!this.mechanismProperties.ENVIRONMENT && !this.mechanismProperties.OIDC_CALLBACK && !this.mechanismProperties.OIDC_HUMAN_CALLBACK) {
            throw new error_1.MongoInvalidArgumentError(`Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
          }
          if (this.mechanismProperties.ALLOWED_HOSTS) {
            const hosts = this.mechanismProperties.ALLOWED_HOSTS;
            if (!Array.isArray(hosts)) {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
            for (const host of hosts) {
              if (typeof host !== "string") {
                throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
              }
            }
          }
        }
        if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
          if (this.source != null && this.source !== "$external") {
            throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
          }
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
          throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
        }
        if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
          if (this.password === "") {
            Reflect.set(this, "password", void 0);
            return;
          }
          throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
        }
        const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
        if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
          throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
        }
      }
      static merge(creds, options) {
        return new _MongoCredentials({
          username: options.username ?? creds?.username ?? "",
          password: options.password ?? creds?.password ?? "",
          mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
          mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
          source: options.source ?? options.db ?? creds?.source ?? "admin"
        });
      }
    };
    exports.MongoCredentials = MongoCredentials;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports) {
    "use strict";
    function makeException(ErrorType, message, options) {
      if (options.globals) {
        ErrorType = options.globals[ErrorType.name];
      }
      return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
    }
    function toNumber(value, options) {
      if (typeof value === "bigint") {
        throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
      }
      if (!options.globals) {
        return Number(value);
      }
      return options.globals.Number(value);
    }
    function evenRound(x) {
      if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
        return censorNegativeZero(Math.floor(x));
      }
      return censorNegativeZero(Math.round(x));
    }
    function integerPart(n) {
      return censorNegativeZero(Math.trunc(n));
    }
    function sign2(x) {
      return x < 0 ? -1 : 1;
    }
    function modulo(x, y) {
      const signMightNotMatch = x % y;
      if (sign2(y) !== sign2(signMightNotMatch)) {
        return signMightNotMatch + y;
      }
      return signMightNotMatch;
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function createIntegerConversion(bitLength, { unsigned }) {
      let lowerBound, upperBound;
      if (unsigned) {
        lowerBound = 0;
        upperBound = 2 ** bitLength - 1;
      } else {
        lowerBound = -(2 ** (bitLength - 1));
        upperBound = 2 ** (bitLength - 1) - 1;
      }
      const twoToTheBitLength = 2 ** bitLength;
      const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
      return (value, options = {}) => {
        let x = toNumber(value, options);
        x = censorNegativeZero(x);
        if (options.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = integerPart(x);
        if (x >= lowerBound && x <= upperBound) {
          return x;
        }
        x = modulo(x, twoToTheBitLength);
        if (!unsigned && x >= twoToOneLessThanTheBitLength) {
          return x - twoToTheBitLength;
        }
        return x;
      };
    }
    function createLongLongConversion(bitLength, { unsigned }) {
      const upperBound = Number.MAX_SAFE_INTEGER;
      const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
      const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
      return (value, options = {}) => {
        let x = toNumber(value, options);
        x = censorNegativeZero(x);
        if (options.enforceRange) {
          if (!Number.isFinite(x)) {
            throw makeException(TypeError, "is not a finite number", options);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw makeException(
              TypeError,
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              options
            );
          }
          return x;
        }
        if (!Number.isNaN(x) && options.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        let xBigInt = BigInt(integerPart(x));
        xBigInt = asBigIntN(bitLength, xBigInt);
        return Number(xBigInt);
      };
    }
    exports.any = (value) => {
      return value;
    };
    exports.undefined = () => {
      return void 0;
    };
    exports.boolean = (value) => {
      return Boolean(value);
    };
    exports.byte = createIntegerConversion(8, { unsigned: false });
    exports.octet = createIntegerConversion(8, { unsigned: true });
    exports.short = createIntegerConversion(16, { unsigned: false });
    exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
    exports.long = createIntegerConversion(32, { unsigned: false });
    exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
    exports["long long"] = createLongLongConversion(64, { unsigned: false });
    exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
    exports.double = (value, options = {}) => {
      const x = toNumber(value, options);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      return x;
    };
    exports["unrestricted double"] = (value, options = {}) => {
      const x = toNumber(value, options);
      return x;
    };
    exports.float = (value, options = {}) => {
      const x = toNumber(value, options);
      if (!Number.isFinite(x)) {
        throw makeException(TypeError, "is not a finite floating-point value", options);
      }
      if (Object.is(x, -0)) {
        return x;
      }
      const y = Math.fround(x);
      if (!Number.isFinite(y)) {
        throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
      }
      return y;
    };
    exports["unrestricted float"] = (value, options = {}) => {
      const x = toNumber(value, options);
      if (isNaN(x)) {
        return x;
      }
      if (Object.is(x, -0)) {
        return x;
      }
      return Math.fround(x);
    };
    exports.DOMString = (value, options = {}) => {
      if (options.treatNullAsEmptyString && value === null) {
        return "";
      }
      if (typeof value === "symbol") {
        throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
      }
      const StringCtor = options.globals ? options.globals.String : String;
      return StringCtor(value);
    };
    exports.ByteString = (value, options = {}) => {
      const x = exports.DOMString(value, options);
      let c;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw makeException(TypeError, "is not a valid ByteString", options);
        }
      }
      return x;
    };
    exports.USVString = (value, options = {}) => {
      const S = exports.DOMString(value, options);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d = S.charCodeAt(i + 1);
          if (56320 <= d && d <= 57343) {
            const a = c & 1023;
            const b = d & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
      return U.join("");
    };
    exports.object = (value, options = {}) => {
      if (value === null || typeof value !== "object" && typeof value !== "function") {
        throw makeException(TypeError, "is not an object", options);
      }
      return value;
    };
    var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
    function isNonSharedArrayBuffer(value) {
      try {
        abByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isSharedArrayBuffer(value) {
      try {
        sabByteLengthGetter.call(value);
        return true;
      } catch {
        return false;
      }
    }
    function isArrayBufferDetached(value) {
      try {
        new Uint8Array(value);
        return false;
      } catch {
        return true;
      }
    }
    exports.ArrayBuffer = (value, options = {}) => {
      if (!isNonSharedArrayBuffer(value)) {
        if (options.allowShared && !isSharedArrayBuffer(value)) {
          throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
        }
        throw makeException(TypeError, "is not an ArrayBuffer", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
    exports.DataView = (value, options = {}) => {
      try {
        dvByteLengthGetter.call(value);
      } catch (e) {
        throw makeException(TypeError, "is not a DataView", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
      }
      return value;
    };
    var typedArrayNameGetter = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Uint8Array).prototype,
      Symbol.toStringTag
    ).get;
    [
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Uint8ClampedArray,
      Float32Array,
      Float64Array
    ].forEach((func) => {
      const { name } = func;
      const article = /^[AEIOU]/u.test(name) ? "an" : "a";
      exports[name] = (value, options = {}) => {
        if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
          throw makeException(TypeError, `is not ${article} ${name} object`, options);
        }
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      };
    });
    exports.ArrayBufferView = (value, options = {}) => {
      if (!ArrayBuffer.isView(value)) {
        throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
    exports.BufferSource = (value, options = {}) => {
      if (ArrayBuffer.isView(value)) {
        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
          throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
        }
        if (isArrayBufferDetached(value.buffer)) {
          throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
        }
        return value;
      }
      if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
      }
      if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
      }
      if (isArrayBufferDetached(value)) {
        throw makeException(TypeError, "is a detached ArrayBuffer", options);
      }
      return value;
    };
    exports.DOMTimeStamp = exports["unsigned long long"];
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    function isObject3(value) {
      return typeof value === "object" && value !== null || typeof value === "function";
    }
    var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
    function define2(target, source) {
      for (const key of Reflect.ownKeys(source)) {
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
          throw new TypeError(`Cannot redefine property: ${String(key)}`);
        }
      }
    }
    function newObjectInRealm(globalObject, object) {
      const ctorRegistry = initCtorRegistry(globalObject);
      return Object.defineProperties(
        Object.create(ctorRegistry["%Object.prototype%"]),
        Object.getOwnPropertyDescriptors(object)
      );
    }
    var wrapperSymbol = Symbol("wrapper");
    var implSymbol = Symbol("impl");
    var sameObjectCaches = Symbol("SameObject caches");
    var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
    var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    function initCtorRegistry(globalObject) {
      if (hasOwn(globalObject, ctorRegistrySymbol)) {
        return globalObject[ctorRegistrySymbol];
      }
      const ctorRegistry = /* @__PURE__ */ Object.create(null);
      ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
      ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(
        Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]())
      );
      try {
        ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(
          Object.getPrototypeOf(
            globalObject.eval("(async function* () {})").prototype
          )
        );
      } catch {
        ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
      }
      globalObject[ctorRegistrySymbol] = ctorRegistry;
      return ctorRegistry;
    }
    function getSameObject(wrapper, prop, creator) {
      if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
      }
      if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
      }
      wrapper[sameObjectCaches][prop] = creator();
      return wrapper[sameObjectCaches][prop];
    }
    function wrapperForImpl(impl) {
      return impl ? impl[wrapperSymbol] : null;
    }
    function implForWrapper(wrapper) {
      return wrapper ? wrapper[implSymbol] : null;
    }
    function tryWrapperForImpl(impl) {
      const wrapper = wrapperForImpl(impl);
      return wrapper ? wrapper : impl;
    }
    function tryImplForWrapper(wrapper) {
      const impl = implForWrapper(wrapper);
      return impl ? impl : wrapper;
    }
    var iterInternalSymbol = Symbol("internal");
    function isArrayIndexPropName(P) {
      if (typeof P !== "string") {
        return false;
      }
      const i = P >>> 0;
      if (i === 2 ** 32 - 1) {
        return false;
      }
      const s = `${i}`;
      if (P !== s) {
        return false;
      }
      return true;
    }
    var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
    function isArrayBuffer2(value) {
      try {
        byteLengthGetter.call(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    function iteratorResult([key, value], kind) {
      let result;
      switch (kind) {
        case "key":
          result = key;
          break;
        case "value":
          result = value;
          break;
        case "key+value":
          result = [key, value];
          break;
      }
      return { value: result, done: false };
    }
    var supportsPropertyIndex = Symbol("supports property index");
    var supportedPropertyIndices = Symbol("supported property indices");
    var supportsPropertyName = Symbol("supports property name");
    var supportedPropertyNames = Symbol("supported property names");
    var indexedGet = Symbol("indexed property get");
    var indexedSetNew = Symbol("indexed property set new");
    var indexedSetExisting = Symbol("indexed property set existing");
    var namedGet = Symbol("named property get");
    var namedSetNew = Symbol("named property set new");
    var namedSetExisting = Symbol("named property set existing");
    var namedDelete = Symbol("named property delete");
    var asyncIteratorNext = Symbol("async iterator get the next iteration result");
    var asyncIteratorReturn = Symbol("async iterator return steps");
    var asyncIteratorInit = Symbol("async iterator initialization steps");
    var asyncIteratorEOI = Symbol("async iterator end of iteration");
    module.exports = exports = {
      isObject: isObject3,
      hasOwn,
      define: define2,
      newObjectInRealm,
      wrapperSymbol,
      implSymbol,
      getSameObject,
      ctorRegistrySymbol,
      initCtorRegistry,
      wrapperForImpl,
      implForWrapper,
      tryWrapperForImpl,
      tryImplForWrapper,
      iterInternalSymbol,
      isArrayBuffer: isArrayBuffer2,
      isArrayIndexPropName,
      supportsPropertyIndex,
      supportedPropertyIndices,
      supportsPropertyName,
      supportedPropertyNames,
      indexedGet,
      indexedSetNew,
      indexedSetExisting,
      namedGet,
      namedSetNew,
      namedSetExisting,
      namedDelete,
      asyncIteratorNext,
      asyncIteratorReturn,
      asyncIteratorInit,
      asyncIteratorEOI,
      iteratorResult
    };
  }
});

// node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "node_modules/punycode/punycode.es6.js"() {
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7F]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
    basicToDigit = function(codePoint) {
      if (codePoint >= 48 && codePoint < 58) {
        return 26 + (codePoint - 48);
      }
      if (codePoint >= 65 && codePoint < 91) {
        return codePoint - 65;
      }
      if (codePoint >= 97 && codePoint < 123) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base) {
            error("invalid-input");
          }
          if (digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          const baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      const inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      const basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue === n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              const qMinusT = q - t;
              const baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      "version": "2.3.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS({
  "node_modules/tr46/lib/regexes.js"(exports, module) {
    "use strict";
    var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113B8}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
    var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{113CE}-\u{113D0}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}\u{1612F}]/u;
    var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10EC3}\u{10EC4}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10EC2}-\u{10EC4}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
    var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCEF}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
    var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0897-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2429\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E5\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D69}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10EFC}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CC00}-\u{1CCD5}\u{1CCF0}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6C1}\u{1D6DB}\u{1D6FB}\u{1D715}\u{1D735}\u{1D74F}\u{1D76F}\u{1D789}\u{1D7A9}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
    var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10D40}-\u{10D49}\u{10E60}-\u{10E7E}]/u;
    var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B4E-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2429\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E5\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6E}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D5}\u{113D7}\u{113D8}\u{113E1}\u{113E2}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F5A}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CC00}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E5D0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
    var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCF9}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    module.exports = {
      combiningMarks,
      combiningClassVirama,
      validZWNJ,
      bidiDomain,
      bidiS1LTR,
      bidiS1RTL,
      bidiS2,
      bidiS3,
      bidiS4EN,
      bidiS4AN,
      bidiS5,
      bidiS6
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable2 = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], 2], [[45, 46], 2], [47, 2], [[48, 57], 2], [[58, 64], 2], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 2], [[97, 122], 2], [[123, 127], 2], [[128, 159], 3], [160, 1, " "], [[161, 167], 2], [168, 1, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 1, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 1, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 1, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 1, " \u0306"], [729, 1, " \u0307"], [730, 1, " \u030A"], [731, 1, " \u0328"], [732, 1, " \u0303"], [733, 1, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 1, " \u03B9"], [[891, 893], 2], [894, 1, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 1, " \u0301"], [901, 1, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1e3, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 1, "\u04CF"], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2198], 3], [2199, 2], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [4256, 1, "\u2D00"], [4257, 1, "\u2D01"], [4258, 1, "\u2D02"], [4259, 1, "\u2D03"], [4260, 1, "\u2D04"], [4261, 1, "\u2D05"], [4262, 1, "\u2D06"], [4263, 1, "\u2D07"], [4264, 1, "\u2D08"], [4265, 1, "\u2D09"], [4266, 1, "\u2D0A"], [4267, 1, "\u2D0B"], [4268, 1, "\u2D0C"], [4269, 1, "\u2D0D"], [4270, 1, "\u2D0E"], [4271, 1, "\u2D0F"], [4272, 1, "\u2D10"], [4273, 1, "\u2D11"], [4274, 1, "\u2D12"], [4275, 1, "\u2D13"], [4276, 1, "\u2D14"], [4277, 1, "\u2D15"], [4278, 1, "\u2D16"], [4279, 1, "\u2D17"], [4280, 1, "\u2D18"], [4281, 1, "\u2D19"], [4282, 1, "\u2D1A"], [4283, 1, "\u2D1B"], [4284, 1, "\u2D1C"], [4285, 1, "\u2D1D"], [4286, 1, "\u2D1E"], [4287, 1, "\u2D1F"], [4288, 1, "\u2D20"], [4289, 1, "\u2D21"], [4290, 1, "\u2D22"], [4291, 1, "\u2D23"], [4292, 1, "\u2D24"], [4293, 1, "\u2D25"], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 7], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6e3], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 7], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6154], 2], [[6155, 6158], 7], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [6989, 3], [[6990, 6991], 2], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 2], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [7305, 1, "\u1C8A"], [7306, 2], [[7307, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "\xDF"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8e3, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 1, " \u0313"], [8126, 1, "\u03B9"], [8127, 1, " \u0313"], [8128, 1, " \u0342"], [8129, 1, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 1, " \u0313\u0300"], [8142, 1, " \u0313\u0301"], [8143, 1, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 1, " \u0314\u0300"], [8158, 1, " \u0314\u0301"], [8159, 1, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 1, " \u0308\u0300"], [8174, 1, " \u0308\u0301"], [8175, 1, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 1, " \u0301"], [8190, 1, " \u0314"], [8191, 3], [[8192, 8202], 1, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 1, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 1, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 1, "!!"], [8253, 2], [8254, 1, " \u0305"], [[8255, 8262], 2], [8263, 1, "??"], [8264, 1, "?!"], [8265, 1, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 1, " "], [[8288, 8291], 7], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 7], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 1, "+"], [8315, 1, "\u2212"], [8316, 1, "="], [8317, 1, "("], [8318, 1, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 1, "+"], [8331, 1, "\u2212"], [8332, 1, "="], [8333, 1, "("], [8334, 1, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 1, "a/c"], [8449, 1, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 1, "c/o"], [8454, 1, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 1, "\u214E"], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 1, "\u2184"], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9e3], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9257], 2], [[9258, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 1, "(1)"], [9333, 1, "(2)"], [9334, 1, "(3)"], [9335, 1, "(4)"], [9336, 1, "(5)"], [9337, 1, "(6)"], [9338, 1, "(7)"], [9339, 1, "(8)"], [9340, 1, "(9)"], [9341, 1, "(10)"], [9342, 1, "(11)"], [9343, 1, "(12)"], [9344, 1, "(13)"], [9345, 1, "(14)"], [9346, 1, "(15)"], [9347, 1, "(16)"], [9348, 1, "(17)"], [9349, 1, "(18)"], [9350, 1, "(19)"], [9351, 1, "(20)"], [[9352, 9371], 3], [9372, 1, "(a)"], [9373, 1, "(b)"], [9374, 1, "(c)"], [9375, 1, "(d)"], [9376, 1, "(e)"], [9377, 1, "(f)"], [9378, 1, "(g)"], [9379, 1, "(h)"], [9380, 1, "(i)"], [9381, 1, "(j)"], [9382, 1, "(k)"], [9383, 1, "(l)"], [9384, 1, "(m)"], [9385, 1, "(n)"], [9386, 1, "(o)"], [9387, 1, "(p)"], [9388, 1, "(q)"], [9389, 1, "(r)"], [9390, 1, "(s)"], [9391, 1, "(t)"], [9392, 1, "(u)"], [9393, 1, "(v)"], [9394, 1, "(w)"], [9395, 1, "(x)"], [9396, 1, "(y)"], [9397, 1, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 1, "::="], [10869, 1, "=="], [10870, 1, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 1, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 1, " \u3099"], [12444, 1, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 7], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12773], 2], [[12774, 12782], 3], [12783, 3], [[12784, 12799], 2], [12800, 1, "(\u1100)"], [12801, 1, "(\u1102)"], [12802, 1, "(\u1103)"], [12803, 1, "(\u1105)"], [12804, 1, "(\u1106)"], [12805, 1, "(\u1107)"], [12806, 1, "(\u1109)"], [12807, 1, "(\u110B)"], [12808, 1, "(\u110C)"], [12809, 1, "(\u110E)"], [12810, 1, "(\u110F)"], [12811, 1, "(\u1110)"], [12812, 1, "(\u1111)"], [12813, 1, "(\u1112)"], [12814, 1, "(\uAC00)"], [12815, 1, "(\uB098)"], [12816, 1, "(\uB2E4)"], [12817, 1, "(\uB77C)"], [12818, 1, "(\uB9C8)"], [12819, 1, "(\uBC14)"], [12820, 1, "(\uC0AC)"], [12821, 1, "(\uC544)"], [12822, 1, "(\uC790)"], [12823, 1, "(\uCC28)"], [12824, 1, "(\uCE74)"], [12825, 1, "(\uD0C0)"], [12826, 1, "(\uD30C)"], [12827, 1, "(\uD558)"], [12828, 1, "(\uC8FC)"], [12829, 1, "(\uC624\uC804)"], [12830, 1, "(\uC624\uD6C4)"], [12831, 3], [12832, 1, "(\u4E00)"], [12833, 1, "(\u4E8C)"], [12834, 1, "(\u4E09)"], [12835, 1, "(\u56DB)"], [12836, 1, "(\u4E94)"], [12837, 1, "(\u516D)"], [12838, 1, "(\u4E03)"], [12839, 1, "(\u516B)"], [12840, 1, "(\u4E5D)"], [12841, 1, "(\u5341)"], [12842, 1, "(\u6708)"], [12843, 1, "(\u706B)"], [12844, 1, "(\u6C34)"], [12845, 1, "(\u6728)"], [12846, 1, "(\u91D1)"], [12847, 1, "(\u571F)"], [12848, 1, "(\u65E5)"], [12849, 1, "(\u682A)"], [12850, 1, "(\u6709)"], [12851, 1, "(\u793E)"], [12852, 1, "(\u540D)"], [12853, 1, "(\u7279)"], [12854, 1, "(\u8CA1)"], [12855, 1, "(\u795D)"], [12856, 1, "(\u52B4)"], [12857, 1, "(\u4EE3)"], [12858, 1, "(\u547C)"], [12859, 1, "(\u5B66)"], [12860, 1, "(\u76E3)"], [12861, 1, "(\u4F01)"], [12862, 1, "(\u8CC7)"], [12863, 1, "(\u5354)"], [12864, 1, "(\u796D)"], [12865, 1, "(\u4F11)"], [12866, 1, "(\u81EA)"], [12867, 1, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13e3, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [42955, 1, "\u0264"], [42956, 1, "\uA7CD"], [42957, 2], [[42958, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [42970, 1, "\uA7DB"], [42971, 2], [42972, 1, "\u019B"], [[42973, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43e3, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64e3, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\u{242EE}"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\u{2284A}"], [64208, 1, "\u{22844}"], [64209, 1, "\u{233D5}"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\u{25249}"], [64214, 1, "\u{25CD0}"], [64215, 1, "\u{27ED3}"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 1, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 1, " \u064C\u0651"], [64607, 1, " \u064D\u0651"], [64608, 1, " \u064E\u0651"], [64609, 1, " \u064F\u0651"], [64610, 1, " \u0650\u0651"], [64611, 1, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 1, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 1, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 1, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 1, ":"], [65044, 1, ";"], [65045, 1, "!"], [65046, 1, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 1, "_"], [65077, 1, "("], [65078, 1, ")"], [65079, 1, "{"], [65080, 1, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 1, "["], [65096, 1, "]"], [[65097, 65100], 1, " \u0305"], [[65101, 65103], 1, "_"], [65104, 1, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 1, ";"], [65109, 1, ":"], [65110, 1, "?"], [65111, 1, "!"], [65112, 1, "\u2014"], [65113, 1, "("], [65114, 1, ")"], [65115, 1, "{"], [65116, 1, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 1, "#"], [65120, 1, "&"], [65121, 1, "*"], [65122, 1, "+"], [65123, 1, "-"], [65124, 1, "<"], [65125, 1, ">"], [65126, 1, "="], [65127, 3], [65128, 1, "\\"], [65129, 1, "$"], [65130, 1, "%"], [65131, 1, "@"], [[65132, 65135], 3], [65136, 1, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 1, " \u064C"], [65139, 2], [65140, 1, " \u064D"], [65141, 3], [65142, 1, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 1, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 1, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 1, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 1, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 1, "!"], [65282, 1, '"'], [65283, 1, "#"], [65284, 1, "$"], [65285, 1, "%"], [65286, 1, "&"], [65287, 1, "'"], [65288, 1, "("], [65289, 1, ")"], [65290, 1, "*"], [65291, 1, "+"], [65292, 1, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 1, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 1, ":"], [65307, 1, ";"], [65308, 1, "<"], [65309, 1, "="], [65310, 1, ">"], [65311, 1, "?"], [65312, 1, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 1, "["], [65340, 1, "\\"], [65341, 1, "]"], [65342, 1, "^"], [65343, 1, "_"], [65344, 1, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 1, "{"], [65372, 1, "|"], [65373, 1, "}"], [65374, 1, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 7], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 1, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66e3, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\u{10428}"], [66561, 1, "\u{10429}"], [66562, 1, "\u{1042A}"], [66563, 1, "\u{1042B}"], [66564, 1, "\u{1042C}"], [66565, 1, "\u{1042D}"], [66566, 1, "\u{1042E}"], [66567, 1, "\u{1042F}"], [66568, 1, "\u{10430}"], [66569, 1, "\u{10431}"], [66570, 1, "\u{10432}"], [66571, 1, "\u{10433}"], [66572, 1, "\u{10434}"], [66573, 1, "\u{10435}"], [66574, 1, "\u{10436}"], [66575, 1, "\u{10437}"], [66576, 1, "\u{10438}"], [66577, 1, "\u{10439}"], [66578, 1, "\u{1043A}"], [66579, 1, "\u{1043B}"], [66580, 1, "\u{1043C}"], [66581, 1, "\u{1043D}"], [66582, 1, "\u{1043E}"], [66583, 1, "\u{1043F}"], [66584, 1, "\u{10440}"], [66585, 1, "\u{10441}"], [66586, 1, "\u{10442}"], [66587, 1, "\u{10443}"], [66588, 1, "\u{10444}"], [66589, 1, "\u{10445}"], [66590, 1, "\u{10446}"], [66591, 1, "\u{10447}"], [66592, 1, "\u{10448}"], [66593, 1, "\u{10449}"], [66594, 1, "\u{1044A}"], [66595, 1, "\u{1044B}"], [66596, 1, "\u{1044C}"], [66597, 1, "\u{1044D}"], [66598, 1, "\u{1044E}"], [66599, 1, "\u{1044F}"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\u{104D8}"], [66737, 1, "\u{104D9}"], [66738, 1, "\u{104DA}"], [66739, 1, "\u{104DB}"], [66740, 1, "\u{104DC}"], [66741, 1, "\u{104DD}"], [66742, 1, "\u{104DE}"], [66743, 1, "\u{104DF}"], [66744, 1, "\u{104E0}"], [66745, 1, "\u{104E1}"], [66746, 1, "\u{104E2}"], [66747, 1, "\u{104E3}"], [66748, 1, "\u{104E4}"], [66749, 1, "\u{104E5}"], [66750, 1, "\u{104E6}"], [66751, 1, "\u{104E7}"], [66752, 1, "\u{104E8}"], [66753, 1, "\u{104E9}"], [66754, 1, "\u{104EA}"], [66755, 1, "\u{104EB}"], [66756, 1, "\u{104EC}"], [66757, 1, "\u{104ED}"], [66758, 1, "\u{104EE}"], [66759, 1, "\u{104EF}"], [66760, 1, "\u{104F0}"], [66761, 1, "\u{104F1}"], [66762, 1, "\u{104F2}"], [66763, 1, "\u{104F3}"], [66764, 1, "\u{104F4}"], [66765, 1, "\u{104F5}"], [66766, 1, "\u{104F6}"], [66767, 1, "\u{104F7}"], [66768, 1, "\u{104F8}"], [66769, 1, "\u{104F9}"], [66770, 1, "\u{104FA}"], [66771, 1, "\u{104FB}"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\u{10597}"], [66929, 1, "\u{10598}"], [66930, 1, "\u{10599}"], [66931, 1, "\u{1059A}"], [66932, 1, "\u{1059B}"], [66933, 1, "\u{1059C}"], [66934, 1, "\u{1059D}"], [66935, 1, "\u{1059E}"], [66936, 1, "\u{1059F}"], [66937, 1, "\u{105A0}"], [66938, 1, "\u{105A1}"], [66939, 3], [66940, 1, "\u{105A3}"], [66941, 1, "\u{105A4}"], [66942, 1, "\u{105A5}"], [66943, 1, "\u{105A6}"], [66944, 1, "\u{105A7}"], [66945, 1, "\u{105A8}"], [66946, 1, "\u{105A9}"], [66947, 1, "\u{105AA}"], [66948, 1, "\u{105AB}"], [66949, 1, "\u{105AC}"], [66950, 1, "\u{105AD}"], [66951, 1, "\u{105AE}"], [66952, 1, "\u{105AF}"], [66953, 1, "\u{105B0}"], [66954, 1, "\u{105B1}"], [66955, 3], [66956, 1, "\u{105B3}"], [66957, 1, "\u{105B4}"], [66958, 1, "\u{105B5}"], [66959, 1, "\u{105B6}"], [66960, 1, "\u{105B7}"], [66961, 1, "\u{105B8}"], [66962, 1, "\u{105B9}"], [66963, 3], [66964, 1, "\u{105BB}"], [66965, 1, "\u{105BC}"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67007], 3], [[67008, 67059], 2], [[67060, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\u{1DF04}"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\u{1DF05}"], [67488, 1, "\u028E"], [67489, 1, "\u{1DF06}"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\u{1DF08}"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\u{1DF0A}"], [67514, 1, "\u{1DF1E}"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\u{10CC0}"], [68737, 1, "\u{10CC1}"], [68738, 1, "\u{10CC2}"], [68739, 1, "\u{10CC3}"], [68740, 1, "\u{10CC4}"], [68741, 1, "\u{10CC5}"], [68742, 1, "\u{10CC6}"], [68743, 1, "\u{10CC7}"], [68744, 1, "\u{10CC8}"], [68745, 1, "\u{10CC9}"], [68746, 1, "\u{10CCA}"], [68747, 1, "\u{10CCB}"], [68748, 1, "\u{10CCC}"], [68749, 1, "\u{10CCD}"], [68750, 1, "\u{10CCE}"], [68751, 1, "\u{10CCF}"], [68752, 1, "\u{10CD0}"], [68753, 1, "\u{10CD1}"], [68754, 1, "\u{10CD2}"], [68755, 1, "\u{10CD3}"], [68756, 1, "\u{10CD4}"], [68757, 1, "\u{10CD5}"], [68758, 1, "\u{10CD6}"], [68759, 1, "\u{10CD7}"], [68760, 1, "\u{10CD8}"], [68761, 1, "\u{10CD9}"], [68762, 1, "\u{10CDA}"], [68763, 1, "\u{10CDB}"], [68764, 1, "\u{10CDC}"], [68765, 1, "\u{10CDD}"], [68766, 1, "\u{10CDE}"], [68767, 1, "\u{10CDF}"], [68768, 1, "\u{10CE0}"], [68769, 1, "\u{10CE1}"], [68770, 1, "\u{10CE2}"], [68771, 1, "\u{10CE3}"], [68772, 1, "\u{10CE4}"], [68773, 1, "\u{10CE5}"], [68774, 1, "\u{10CE6}"], [68775, 1, "\u{10CE7}"], [68776, 1, "\u{10CE8}"], [68777, 1, "\u{10CE9}"], [68778, 1, "\u{10CEA}"], [68779, 1, "\u{10CEB}"], [68780, 1, "\u{10CEC}"], [68781, 1, "\u{10CED}"], [68782, 1, "\u{10CEE}"], [68783, 1, "\u{10CEF}"], [68784, 1, "\u{10CF0}"], [68785, 1, "\u{10CF1}"], [68786, 1, "\u{10CF2}"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 68927], 3], [[68928, 68943], 2], [68944, 1, "\u{10D70}"], [68945, 1, "\u{10D71}"], [68946, 1, "\u{10D72}"], [68947, 1, "\u{10D73}"], [68948, 1, "\u{10D74}"], [68949, 1, "\u{10D75}"], [68950, 1, "\u{10D76}"], [68951, 1, "\u{10D77}"], [68952, 1, "\u{10D78}"], [68953, 1, "\u{10D79}"], [68954, 1, "\u{10D7A}"], [68955, 1, "\u{10D7B}"], [68956, 1, "\u{10D7C}"], [68957, 1, "\u{10D7D}"], [68958, 1, "\u{10D7E}"], [68959, 1, "\u{10D7F}"], [68960, 1, "\u{10D80}"], [68961, 1, "\u{10D81}"], [68962, 1, "\u{10D82}"], [68963, 1, "\u{10D83}"], [68964, 1, "\u{10D84}"], [68965, 1, "\u{10D85}"], [[68966, 68968], 3], [[68969, 68973], 2], [68974, 2], [[68975, 68997], 2], [[68998, 69005], 3], [[69006, 69007], 2], [[69008, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69313], 3], [[69314, 69316], 2], [[69317, 69371], 3], [69372, 2], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70527], 3], [[70528, 70537], 2], [70538, 3], [70539, 2], [[70540, 70541], 3], [70542, 2], [70543, 3], [[70544, 70581], 2], [70582, 3], [[70583, 70592], 2], [70593, 3], [70594, 2], [[70595, 70596], 3], [70597, 2], [70598, 3], [[70599, 70602], 2], [70603, 3], [[70604, 70611], 2], [[70612, 70613], 2], [70614, 3], [[70615, 70616], 2], [[70617, 70624], 3], [[70625, 70626], 2], [[70627, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71375], 3], [[71376, 71395], 2], [[71396, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\u{118C0}"], [71841, 1, "\u{118C1}"], [71842, 1, "\u{118C2}"], [71843, 1, "\u{118C3}"], [71844, 1, "\u{118C4}"], [71845, 1, "\u{118C5}"], [71846, 1, "\u{118C6}"], [71847, 1, "\u{118C7}"], [71848, 1, "\u{118C8}"], [71849, 1, "\u{118C9}"], [71850, 1, "\u{118CA}"], [71851, 1, "\u{118CB}"], [71852, 1, "\u{118CC}"], [71853, 1, "\u{118CD}"], [71854, 1, "\u{118CE}"], [71855, 1, "\u{118CF}"], [71856, 1, "\u{118D0}"], [71857, 1, "\u{118D1}"], [71858, 1, "\u{118D2}"], [71859, 1, "\u{118D3}"], [71860, 1, "\u{118D4}"], [71861, 1, "\u{118D5}"], [71862, 1, "\u{118D6}"], [71863, 1, "\u{118D7}"], [71864, 1, "\u{118D8}"], [71865, 1, "\u{118D9}"], [71866, 1, "\u{118DA}"], [71867, 1, "\u{118DB}"], [71868, 1, "\u{118DC}"], [71869, 1, "\u{118DD}"], [71870, 1, "\u{118DE}"], [71871, 1, "\u{118DF}"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72639], 3], [[72640, 72672], 2], [72673, 2], [[72674, 72687], 3], [[72688, 72697], 2], [[72698, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [73562, 2], [[73563, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 78943], 3], [[78944, 82938], 2], [[82939, 82943], 3], [[82944, 83526], 2], [[83527, 90367], 3], [[90368, 90425], 2], [[90426, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93503], 3], [[93504, 93548], 2], [[93549, 93551], 2], [[93552, 93561], 2], [[93562, 93759], 3], [93760, 1, "\u{16E60}"], [93761, 1, "\u{16E61}"], [93762, 1, "\u{16E62}"], [93763, 1, "\u{16E63}"], [93764, 1, "\u{16E64}"], [93765, 1, "\u{16E65}"], [93766, 1, "\u{16E66}"], [93767, 1, "\u{16E67}"], [93768, 1, "\u{16E68}"], [93769, 1, "\u{16E69}"], [93770, 1, "\u{16E6A}"], [93771, 1, "\u{16E6B}"], [93772, 1, "\u{16E6C}"], [93773, 1, "\u{16E6D}"], [93774, 1, "\u{16E6E}"], [93775, 1, "\u{16E6F}"], [93776, 1, "\u{16E70}"], [93777, 1, "\u{16E71}"], [93778, 1, "\u{16E72}"], [93779, 1, "\u{16E73}"], [93780, 1, "\u{16E74}"], [93781, 1, "\u{16E75}"], [93782, 1, "\u{16E76}"], [93783, 1, "\u{16E77}"], [93784, 1, "\u{16E78}"], [93785, 1, "\u{16E79}"], [93786, 1, "\u{16E7A}"], [93787, 1, "\u{16E7B}"], [93788, 1, "\u{16E7C}"], [93789, 1, "\u{16E7D}"], [93790, 1, "\u{16E7E}"], [93791, 1, "\u{16E7F}"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101630], 3], [101631, 2], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 117759], 3], [[117760, 117973], 2], [117974, 1, "a"], [117975, 1, "b"], [117976, 1, "c"], [117977, 1, "d"], [117978, 1, "e"], [117979, 1, "f"], [117980, 1, "g"], [117981, 1, "h"], [117982, 1, "i"], [117983, 1, "j"], [117984, 1, "k"], [117985, 1, "l"], [117986, 1, "m"], [117987, 1, "n"], [117988, 1, "o"], [117989, 1, "p"], [117990, 1, "q"], [117991, 1, "r"], [117992, 1, "s"], [117993, 1, "t"], [117994, 1, "u"], [117995, 1, "v"], [117996, 1, "w"], [117997, 1, "x"], [117998, 1, "y"], [117999, 1, "z"], [118e3, 1, "0"], [118001, 1, "1"], [118002, 1, "2"], [118003, 1, "3"], [118004, 1, "4"], [118005, 1, "5"], [118006, 1, "6"], [118007, 1, "7"], [118008, 1, "8"], [118009, 1, "9"], [[118010, 118015], 3], [[118016, 118451], 2], [[118452, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\u{1D157}\u{1D165}"], [119135, 1, "\u{1D158}\u{1D165}"], [119136, 1, "\u{1D158}\u{1D165}\u{1D16E}"], [119137, 1, "\u{1D158}\u{1D165}\u{1D16F}"], [119138, 1, "\u{1D158}\u{1D165}\u{1D170}"], [119139, 1, "\u{1D158}\u{1D165}\u{1D171}"], [119140, 1, "\u{1D158}\u{1D165}\u{1D172}"], [[119141, 119154], 2], [[119155, 119162], 7], [[119163, 119226], 2], [119227, 1, "\u{1D1B9}\u{1D165}"], [119228, 1, "\u{1D1BA}\u{1D165}"], [119229, 1, "\u{1D1B9}\u{1D165}\u{1D16E}"], [119230, 1, "\u{1D1BA}\u{1D165}\u{1D16E}"], [119231, 1, "\u{1D1B9}\u{1D165}\u{1D16F}"], [119232, 1, "\u{1D1BA}\u{1D165}\u{1D16F}"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [12e4, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, "\u0430"], [122929, 1, "\u0431"], [122930, 1, "\u0432"], [122931, 1, "\u0433"], [122932, 1, "\u0434"], [122933, 1, "\u0435"], [122934, 1, "\u0436"], [122935, 1, "\u0437"], [122936, 1, "\u0438"], [122937, 1, "\u043A"], [122938, 1, "\u043B"], [122939, 1, "\u043C"], [122940, 1, "\u043E"], [122941, 1, "\u043F"], [122942, 1, "\u0440"], [122943, 1, "\u0441"], [122944, 1, "\u0442"], [122945, 1, "\u0443"], [122946, 1, "\u0444"], [122947, 1, "\u0445"], [122948, 1, "\u0446"], [122949, 1, "\u0447"], [122950, 1, "\u0448"], [122951, 1, "\u044B"], [122952, 1, "\u044D"], [122953, 1, "\u044E"], [122954, 1, "\uA689"], [122955, 1, "\u04D9"], [122956, 1, "\u0456"], [122957, 1, "\u0458"], [122958, 1, "\u04E9"], [122959, 1, "\u04AF"], [122960, 1, "\u04CF"], [122961, 1, "\u0430"], [122962, 1, "\u0431"], [122963, 1, "\u0432"], [122964, 1, "\u0433"], [122965, 1, "\u0434"], [122966, 1, "\u0435"], [122967, 1, "\u0436"], [122968, 1, "\u0437"], [122969, 1, "\u0438"], [122970, 1, "\u043A"], [122971, 1, "\u043B"], [122972, 1, "\u043E"], [122973, 1, "\u043F"], [122974, 1, "\u0441"], [122975, 1, "\u0443"], [122976, 1, "\u0444"], [122977, 1, "\u0445"], [122978, 1, "\u0446"], [122979, 1, "\u0447"], [122980, 1, "\u0448"], [122981, 1, "\u044A"], [122982, 1, "\u044B"], [122983, 1, "\u0491"], [122984, 1, "\u0456"], [122985, 1, "\u0455"], [122986, 1, "\u045F"], [122987, 1, "\u04AB"], [122988, 1, "\uA651"], [122989, 1, "\u04B1"], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124367], 3], [[124368, 124410], 2], [[124411, 124414], 3], [124415, 2], [[124416, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\u{1E922}"], [125185, 1, "\u{1E923}"], [125186, 1, "\u{1E924}"], [125187, 1, "\u{1E925}"], [125188, 1, "\u{1E926}"], [125189, 1, "\u{1E927}"], [125190, 1, "\u{1E928}"], [125191, 1, "\u{1E929}"], [125192, 1, "\u{1E92A}"], [125193, 1, "\u{1E92B}"], [125194, 1, "\u{1E92C}"], [125195, 1, "\u{1E92D}"], [125196, 1, "\u{1E92E}"], [125197, 1, "\u{1E92F}"], [125198, 1, "\u{1E930}"], [125199, 1, "\u{1E931}"], [125200, 1, "\u{1E932}"], [125201, 1, "\u{1E933}"], [125202, 1, "\u{1E934}"], [125203, 1, "\u{1E935}"], [125204, 1, "\u{1E936}"], [125205, 1, "\u{1E937}"], [125206, 1, "\u{1E938}"], [125207, 1, "\u{1E939}"], [125208, 1, "\u{1E93A}"], [125209, 1, "\u{1E93B}"], [125210, 1, "\u{1E93C}"], [125211, 1, "\u{1E93D}"], [125212, 1, "\u{1E93E}"], [125213, 1, "\u{1E93F}"], [125214, 1, "\u{1E940}"], [125215, 1, "\u{1E941}"], [125216, 1, "\u{1E942}"], [125217, 1, "\u{1E943}"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 1, "0,"], [127234, 1, "1,"], [127235, 1, "2,"], [127236, 1, "3,"], [127237, 1, "4,"], [127238, 1, "5,"], [127239, 1, "6,"], [127240, 1, "7,"], [127241, 1, "8,"], [127242, 1, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 1, "(a)"], [127249, 1, "(b)"], [127250, 1, "(c)"], [127251, 1, "(d)"], [127252, 1, "(e)"], [127253, 1, "(f)"], [127254, 1, "(g)"], [127255, 1, "(h)"], [127256, 1, "(i)"], [127257, 1, "(j)"], [127258, 1, "(k)"], [127259, 1, "(l)"], [127260, 1, "(m)"], [127261, 1, "(n)"], [127262, 1, "(o)"], [127263, 1, "(p)"], [127264, 1, "(q)"], [127265, 1, "(r)"], [127266, 1, "(s)"], [127267, 1, "(t)"], [127268, 1, "(u)"], [127269, 1, "(v)"], [127270, 1, "(w)"], [127271, 1, "(x)"], [127272, 1, "(y)"], [127273, 1, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128e3, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129211], 2], [[129212, 129215], 3], [[129216, 129217], 2], [[129218, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [129673, 2], [[129674, 129678], 3], [129679, 2], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 2], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [129734, 2], [[129735, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [129756, 2], [[129757, 129758], 3], [129759, 2], [[129760, 129767], 2], [129768, 2], [129769, 2], [[129770, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 2], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 191471], 3], [[191472, 192093], 2], [[192094, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\u{20122}"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\u{2063A}"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\u{2051C}"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\u{2054B}"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\u{291DF}"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\u{20A2C}"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\u{20B63}"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\u{214E4}"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\u{216A8}"], [194657, 1, "\u{216EA}"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 1, "\u36FC"], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\u{219C8}"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\u{21B18}"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 1, "\u5F53"], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\u{21DE4}"], [194684, 1, "\u5D43"], [194685, 1, "\u{21DE6}"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\u{22183}"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\u{2A392}"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\u{22331}"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\u{232B8}"], [194712, 1, "\u{261DA}"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\u{226D4}"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\u{22B0C}"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\u{22BF1}"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\u{2300A}"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\u{233C3}"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\u{2346D}"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\u{236A3}"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\u{238A7}"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\u{23A8D}"], [194808, 1, "\u{21D0B}"], [194809, 1, "\u{23AFA}"], [194810, 1, "\u6C4E"], [194811, 1, "\u{23CBC}"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\u{23D1E}"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\u{23ED1}"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\u{23F5E}"], [194833, 1, "\u{23F8E}"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\u{20525}"], [194844, 1, "\u7145"], [194845, 1, "\u{24263}"], [194846, 1, "\u719C"], [194847, 1, "\u{243AB}"], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\u{24608}"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\u{24735}"], [194855, 1, "\u{24814}"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\u{24C36}"], [194870, 1, "\u753E"], [194871, 1, "\u{24C92}"], [194872, 1, "\u7570"], [194873, 1, "\u{2219F}"], [194874, 1, "\u7610"], [194875, 1, "\u{24FA1}"], [194876, 1, "\u{24FB8}"], [194877, 1, "\u{25044}"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\u{250F3}"], [194882, 1, "\u{250F2}"], [194883, 1, "\u{25119}"], [194884, 1, "\u{25133}"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\u{2541D}"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\u{25626}"], [194899, 1, "\u7956"], [194900, 1, "\u{2569A}"], [194901, 1, "\u{256C5}"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\u{2597C}"], [[194909, 194910], 1, "\u{25AA7}"], [194911, 1, "\u7AEE"], [194912, 1, "\u4202"], [194913, 1, "\u{25BAB}"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\u{25C80}"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\u{25F86}"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\u{26228}"], [194931, 1, "\u{26247}"], [194932, 1, "\u4359"], [194933, 1, "\u{262D9}"], [194934, 1, "\u7F7A"], [194935, 1, "\u{2633E}"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\u{264DA}"], [194940, 1, "\u{26523}"], [194941, 1, "\u8060"], [194942, 1, "\u{265A8}"], [194943, 1, "\u8070"], [194944, 1, "\u{2335F}"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\u{267A7}"], [194952, 1, "\u{267B5}"], [194953, 1, "\u{23393}"], [194954, 1, "\u{2339C}"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\u{26B3C}"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\u{26C36}"], [194981, 1, "\u{26D6B}"], [194982, 1, "\u{26CD5}"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\u{273CA}"], [194988, 1, "\u8564"], [194989, 1, "\u{26F2C}"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\u{26FB1}"], [194993, 1, "\u{270D2}"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195e3, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 1, "\u45D7"], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\u{27667}"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\u{278AE}"], [195020, 1, "\u{27966}"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\u{27CA8}"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\u{27F2F}"], [195033, 1, "\u{20804}"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\u{208DE}"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\u{285D2}"], [195041, 1, "\u{285ED}"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\u{2872E}"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\u{28BFA}"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\u{28D77}"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\u{29145}"], [195063, 1, "\u{2921A}"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\u{2940A}"], [195068, 1, "\u4AB2"], [195069, 1, "\u{29496}"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\u{295B6}"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\u{29B30}"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\u{2A0CE}"], [195089, 1, "\u4CF8"], [195090, 1, "\u{2A105}"], [195091, 1, "\u{2A20E}"], [195092, 1, "\u{2A291}"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\u{2A600}"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918e3, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
  }
});

// node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS({
  "node_modules/tr46/lib/statusMapping.js"(exports, module) {
    "use strict";
    module.exports.STATUS_MAPPING = {
      mapped: 1,
      valid: 2,
      disallowed: 3,
      deviation: 6,
      ignored: 7
    };
  }
});

// node_modules/tr46/index.js
var require_tr462 = __commonJS({
  "node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode2 = (init_punycode_es6(), __toCommonJS(punycode_es6_exports));
    var regexes = require_regexes();
    var mappingTable = require_mappingTable2();
    var { STATUS_MAPPING } = require_statusMapping();
    function containsNonASCII(str) {
      return /[^\x00-\x7F]/u.test(str);
    }
    function findStatus(val) {
      let start = 0;
      let end = mappingTable.length - 1;
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const target = mappingTable[mid];
        const min = Array.isArray(target[0]) ? target[0][0] : target[0];
        const max = Array.isArray(target[0]) ? target[0][1] : target[0];
        if (min <= val && max >= val) {
          return target.slice(1);
        } else if (min > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    function mapChars(domainName, { transitionalProcessing }) {
      let processed = "";
      for (const ch of domainName) {
        const [status, mapping] = findStatus(ch.codePointAt(0));
        switch (status) {
          case STATUS_MAPPING.disallowed:
            processed += ch;
            break;
          case STATUS_MAPPING.ignored:
            break;
          case STATUS_MAPPING.mapped:
            if (transitionalProcessing && ch === "\u1E9E") {
              processed += "ss";
            } else {
              processed += mapping;
            }
            break;
          case STATUS_MAPPING.deviation:
            if (transitionalProcessing) {
              processed += mapping;
            } else {
              processed += ch;
            }
            break;
          case STATUS_MAPPING.valid:
            processed += ch;
            break;
        }
      }
      return processed;
    }
    function validateLabel(label, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      transitionalProcessing,
      useSTD3ASCIIRules,
      isBidi
    }) {
      if (label.length === 0) {
        return true;
      }
      if (label.normalize("NFC") !== label) {
        return false;
      }
      const codePoints = Array.from(label);
      if (checkHyphens) {
        if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
          return false;
        }
      }
      if (!checkHyphens) {
        if (label.startsWith("xn--")) {
          return false;
        }
      }
      if (label.includes(".")) {
        return false;
      }
      if (regexes.combiningMarks.test(codePoints[0])) {
        return false;
      }
      for (const ch of codePoints) {
        const codePoint = ch.codePointAt(0);
        const [status] = findStatus(codePoint);
        if (transitionalProcessing) {
          if (status !== STATUS_MAPPING.valid) {
            return false;
          }
        } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
          return false;
        }
        if (useSTD3ASCIIRules && codePoint <= 127) {
          if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {
            return false;
          }
        }
      }
      if (checkJoiners) {
        let last = 0;
        for (const [i, ch] of codePoints.entries()) {
          if (ch === "\u200C" || ch === "\u200D") {
            if (i > 0) {
              if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
                continue;
              }
              if (ch === "\u200C") {
                const next = codePoints.indexOf("\u200C", i + 1);
                const test2 = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
                if (regexes.validZWNJ.test(test2.join(""))) {
                  last = i + 1;
                  continue;
                }
              }
            }
            return false;
          }
        }
      }
      if (checkBidi && isBidi) {
        let rtl;
        if (regexes.bidiS1LTR.test(codePoints[0])) {
          rtl = false;
        } else if (regexes.bidiS1RTL.test(codePoints[0])) {
          rtl = true;
        } else {
          return false;
        }
        if (rtl) {
          if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
            return false;
          }
        } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
          return false;
        }
      }
      return true;
    }
    function isBidiDomain(labels) {
      const domain = labels.map((label) => {
        if (label.startsWith("xn--")) {
          try {
            return punycode2.decode(label.substring(4));
          } catch {
            return "";
          }
        }
        return label;
      }).join(".");
      return regexes.bidiDomain.test(domain);
    }
    function processing(domainName, options) {
      let string = mapChars(domainName, options);
      string = string.normalize("NFC");
      const labels = string.split(".");
      const isBidi = isBidiDomain(labels);
      let error2 = false;
      for (const [i, origLabel] of labels.entries()) {
        let label = origLabel;
        let transitionalProcessingForThisLabel = options.transitionalProcessing;
        if (label.startsWith("xn--")) {
          if (containsNonASCII(label)) {
            error2 = true;
            continue;
          }
          try {
            label = punycode2.decode(label.substring(4));
          } catch {
            if (!options.ignoreInvalidPunycode) {
              error2 = true;
              continue;
            }
          }
          labels[i] = label;
          if (label === "" || !containsNonASCII(label)) {
            error2 = true;
          }
          transitionalProcessingForThisLabel = false;
        }
        if (error2) {
          continue;
        }
        const validation = validateLabel(label, {
          ...options,
          transitionalProcessing: transitionalProcessingForThisLabel,
          isBidi
        });
        if (!validation) {
          error2 = true;
        }
      }
      return {
        string: labels.join("."),
        error: error2
      };
    }
    function toASCII2(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      verifyDNSLength = false,
      transitionalProcessing = false,
      ignoreInvalidPunycode = false
    } = {}) {
      const result = processing(domainName, {
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules,
        transitionalProcessing,
        ignoreInvalidPunycode
      });
      let labels = result.string.split(".");
      labels = labels.map((l) => {
        if (containsNonASCII(l)) {
          try {
            return `xn--${punycode2.encode(l)}`;
          } catch {
            result.error = true;
          }
        }
        return l;
      });
      if (verifyDNSLength) {
        const total = labels.join(".").length;
        if (total > 253 || total === 0) {
          result.error = true;
        }
        for (let i = 0; i < labels.length; ++i) {
          if (labels[i].length > 63 || labels[i].length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) {
        return null;
      }
      return labels.join(".");
    }
    function toUnicode2(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      transitionalProcessing = false,
      ignoreInvalidPunycode = false
    } = {}) {
      const result = processing(domainName, {
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules,
        transitionalProcessing,
        ignoreInvalidPunycode
      });
      return {
        domain: result.string,
        error: result.error
      };
    }
    module.exports = {
      toASCII: toASCII2,
      toUnicode: toUnicode2
    };
  }
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS({
  "node_modules/whatwg-url/lib/infra.js"(exports, module) {
    "use strict";
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    module.exports = {
      isASCIIDigit,
      isASCIIAlpha,
      isASCIIAlphanumeric,
      isASCIIHex
    };
  }
});

// node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS({
  "node_modules/whatwg-url/lib/encoding.js"(exports, module) {
    "use strict";
    var utf8Encoder = new TextEncoder();
    var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
    function utf8Encode(string) {
      return utf8Encoder.encode(string);
    }
    function utf8DecodeWithoutBOM(bytes) {
      return utf8Decoder.decode(bytes);
    }
    module.exports = {
      utf8Encode,
      utf8DecodeWithoutBOM
    };
  }
});

// node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS({
  "node_modules/whatwg-url/lib/percent-encoding.js"(exports, module) {
    "use strict";
    var { isASCIIHex } = require_infra();
    var { utf8Encode } = require_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = `0${hex}`;
      }
      return `%${hex}`;
    }
    function percentDecodeBytes(input) {
      const output = new Uint8Array(input.byteLength);
      let outputIndex = 0;
      for (let i = 0; i < input.byteLength; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[outputIndex++] = byte;
        } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
          output[outputIndex++] = byte;
        } else {
          const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
          output[outputIndex++] = bytePoint;
          i += 2;
        }
      }
      return output.slice(0, outputIndex);
    }
    function percentDecodeString(input) {
      const bytes = utf8Encode(input);
      return percentDecodeBytes(bytes);
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
    function isFragmentPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
    }
    var extraQueryPercentEncodeSet = /* @__PURE__ */ new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
    function isQueryPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
    }
    function isSpecialQueryPercentEncode(c) {
      return isQueryPercentEncode(c) || c === p("'");
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([p("?"), p("`"), p("{"), p("}"), p("^")]);
    function isPathPercentEncode(c) {
      return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("|")]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    var extraComponentPercentEncodeSet = /* @__PURE__ */ new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
    function isComponentPercentEncode(c) {
      return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
    }
    var extraURLEncodedPercentEncodeSet = /* @__PURE__ */ new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
    function isURLEncodedPercentEncode(c) {
      return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
    }
    function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
      const bytes = utf8Encode(codePoint);
      let output = "";
      for (const byte of bytes) {
        if (!percentEncodePredicate(byte)) {
          output += String.fromCharCode(byte);
        } else {
          output += percentEncode(byte);
        }
      }
      return output;
    }
    function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
      return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
    }
    function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
      let output = "";
      for (const codePoint of input) {
        if (spaceAsPlus && codePoint === " ") {
          output += "+";
        } else {
          output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
        }
      }
      return output;
    }
    module.exports = {
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode,
      isURLEncodedPercentEncode,
      percentDecodeString,
      percentDecodeBytes,
      utf8PercentEncodeString,
      utf8PercentEncodeCodePoint
    };
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine2 = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var tr46 = require_tr462();
    var infra = require_infra();
    var { utf8DecodeWithoutBOM } = require_encoding();
    var {
      percentDecodeString,
      utf8PercentEncodeCodePoint,
      utf8PercentEncodeString,
      isC0ControlPercentEncode,
      isFragmentPercentEncode,
      isQueryPercentEncode,
      isSpecialQueryPercentEncode,
      isPathPercentEncode,
      isUserinfoPercentEncode
    } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return [...str].length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
    }
    function containsForbiddenDomainCodePoint(string) {
      return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url2) {
      return isSpecialScheme(url2.scheme);
    }
    function isNotSpecial(url2) {
      return !isSpecialScheme(url2.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function parseIPv4Number(input) {
      if (input === "") {
        return failure;
      }
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      let regex = /[^0-7]/u;
      if (R === 10) {
        regex = /[^0-9]/u;
      }
      if (R === 16) {
        regex = /[^0-9A-Fa-f]/u;
      }
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return failure;
      }
      const numbers = [];
      for (const part of parts) {
        const n = parseIPv4Number(part);
        if (n === failure) {
          return failure;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * 256 ** (3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = `.${output}`;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = Array.from(input, (c) => c.codePointAt(0));
      if (input[pointer] === p(":")) {
        if (input[pointer + 1] !== p(":")) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === p(":")) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && infra.isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === p(".")) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === p(".") && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!infra.isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (infra.isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === p(":")) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const compress = findTheIPv6AddressCompressedPieceIndex(address);
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isOpaque = false) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (isOpaque) {
        return parseOpaqueHost(input);
      }
      const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
      const asciiDomain = domainToASCII(domain);
      if (asciiDomain === failure) {
        return failure;
      }
      if (endsInANumber(asciiDomain)) {
        return parseIPv4(asciiDomain);
      }
      return asciiDomain;
    }
    function endsInANumber(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length === 1) {
          return false;
        }
        parts.pop();
      }
      const last = parts[parts.length - 1];
      if (parseIPv4Number(last) !== failure) {
        return true;
      }
      if (/^[0-9]+$/u.test(last)) {
        return true;
      }
      return false;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePoint(input)) {
        return failure;
      }
      return utf8PercentEncodeString(input, isC0ControlPercentEncode);
    }
    function findTheIPv6AddressCompressedPieceIndex(address) {
      let longestIndex = null;
      let longestSize = 1;
      let foundIndex = null;
      let foundSize = 0;
      for (let pieceIndex = 0; pieceIndex < address.length; ++pieceIndex) {
        if (address[pieceIndex] !== 0) {
          if (foundSize > longestSize) {
            longestIndex = foundIndex;
            longestSize = foundSize;
          }
          foundIndex = null;
          foundSize = 0;
        } else {
          if (foundIndex === null) {
            foundIndex = pieceIndex;
          }
          ++foundSize;
        }
      }
      if (foundSize > longestSize) {
        return foundIndex;
      }
      return longestIndex;
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return `[${serializeIPv6(host)}]`;
      }
      return host;
    }
    function domainToASCII(domain, beStrict = false) {
      const result = tr46.toASCII(domain, {
        checkHyphens: beStrict,
        checkBidi: true,
        checkJoiners: true,
        useSTD3ASCIIRules: beStrict,
        transitionalProcessing: false,
        verifyDNSLength: beStrict,
        ignoreInvalidPunycode: false
      });
      if (result === null) {
        return failure;
      }
      if (!beStrict) {
        if (result === "") {
          return failure;
        }
        if (containsForbiddenDomainCodePoint(result)) {
          return failure;
        }
      }
      return result;
    }
    function trimControlChars(string) {
      let start = 0;
      let end = string.length;
      for (; start < end; ++start) {
        if (string.charCodeAt(start) > 32) {
          break;
        }
      }
      for (; end > start; --end) {
        if (string.charCodeAt(end - 1) > 32) {
          break;
        }
      }
      return string.substring(start, end);
    }
    function trimTabAndNewline(url2) {
      return url2.replace(/\u0009|\u000A|\u000D/ug, "");
    }
    function shortenPath(url2) {
      const { path: path4 } = url2;
      if (path4.length === 0) {
        return;
      }
      if (url2.scheme === "file" && path4.length === 1 && isNormalizedWindowsDriveLetter(path4[0])) {
        return;
      }
      path4.pop();
    }
    function includesCredentials(url2) {
      return url2.username !== "" || url2.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url2) {
      return url2.host === null || url2.host === "" || url2.scheme === "file";
    }
    function hasAnOpaquePath(url2) {
      return typeof url2.path === "string";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/u.test(string);
    }
    function URLStateMachine(input, base2, encodingOverride, url2, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base2 || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url2;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = Array.from(this.input, (c) => c.codePointAt(0));
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this[`parse ${this.state}`](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (infra.isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
        this.buffer += cStr.toLowerCase();
      } else if (c === p(":")) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && this.url.host === "") {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        if (this.stateOverride) {
          if (this.url.port === defaultPort(this.url.scheme)) {
            this.url.port = null;
          }
          return false;
        }
        this.buffer = "";
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === p("/")) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.path = "";
          this.state = "opaque path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
        return failure;
      } else if (hasAnOpaquePath(this.base) && c === p("#")) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path;
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === p("/")) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (c === p("/")) {
        this.state = "relative slash";
      } else if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          this.url.path.pop();
          this.state = "path";
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === p("/")) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== p("/") && c !== p("\\")) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === p("@")) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = `%40${this.buffer}`;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === p(":") && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        if (this.stateOverride === "hostname") {
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === p("[")) {
          this.arrFlag = true;
        } else if (c === p("]")) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (infra.isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > 2 ** 16 - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([p("/"), p("\\"), p("?"), p("#")]);
    function startsWithWindowsDriveLetter(input, pointer) {
      const length = input.length - pointer;
      return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
    }
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      this.url.host = "";
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        } else if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (!isNaN(c)) {
          this.url.query = null;
          if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
            shortenPath(this.url);
          } else {
            this.parseError = true;
            this.url.path = [];
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === p("/") || c === p("\\")) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          }
          this.url.host = this.base.host;
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === p("\\")) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== p("/") && c !== p("\\")) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== p("/")) {
          --this.pointer;
        }
      } else if (this.stateOverride && this.url.host === null) {
        this.url.path.push("");
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
        if (isSpecial(this.url) && c === p("\\")) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            this.buffer = `${this.buffer[0]}:`;
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (c === p("?")) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c === p(" ")) {
        const remaining = this.input[this.pointer + 1];
        if (remaining === p("?") || remaining === p("#")) {
          this.url.path += "%20";
        } else {
          this.url.path += " ";
        }
      } else {
        if (!isNaN(c) && c !== p("%")) {
          this.parseError = true;
        }
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
        this.encodingOverride = "utf-8";
      }
      if (!this.stateOverride && c === p("#") || isNaN(c)) {
        const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
        this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
        this.buffer = "";
        if (c === p("#")) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (!isNaN(c)) {
        if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
      }
      return true;
    };
    function serializeURL(url2, excludeFragment) {
      let output = `${url2.scheme}:`;
      if (url2.host !== null) {
        output += "//";
        if (url2.username !== "" || url2.password !== "") {
          output += url2.username;
          if (url2.password !== "") {
            output += `:${url2.password}`;
          }
          output += "@";
        }
        output += serializeHost(url2.host);
        if (url2.port !== null) {
          output += `:${url2.port}`;
        }
      }
      if (url2.host === null && !hasAnOpaquePath(url2) && url2.path.length > 1 && url2.path[0] === "") {
        output += "/.";
      }
      output += serializePath(url2);
      if (url2.query !== null) {
        output += `?${url2.query}`;
      }
      if (!excludeFragment && url2.fragment !== null) {
        output += `#${url2.fragment}`;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = `${tuple.scheme}://`;
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += `:${tuple.port}`;
      }
      return result;
    }
    function serializePath(url2) {
      if (hasAnOpaquePath(url2)) {
        return url2.path;
      }
      let output = "";
      for (const segment of url2.path) {
        output += `/${segment}`;
      }
      return output;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializePath = serializePath;
    module.exports.serializeURLOrigin = function(url2) {
      switch (url2.scheme) {
        case "blob": {
          const pathURL = module.exports.parseURL(serializePath(url2));
          if (pathURL === null) {
            return "null";
          }
          if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
            return "null";
          }
          return module.exports.serializeURLOrigin(pathURL);
        }
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url2.scheme,
            host: url2.host,
            port: url2.port
          });
        case "file":
          return "null";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return null;
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url2, username) {
      url2.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
    };
    module.exports.setThePassword = function(url2, password) {
      url2.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.hasAnOpaquePath = hasAnOpaquePath;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/whatwg-url/lib/urlencoded.js"(exports, module) {
    "use strict";
    var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
    var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
    function p(char) {
      return char.codePointAt(0);
    }
    function parseUrlencoded(input) {
      const sequences = strictlySplitByteSequence(input, p("&"));
      const output = [];
      for (const bytes of sequences) {
        if (bytes.length === 0) {
          continue;
        }
        let name, value;
        const indexOfEqual = bytes.indexOf(p("="));
        if (indexOfEqual >= 0) {
          name = bytes.slice(0, indexOfEqual);
          value = bytes.slice(indexOfEqual + 1);
        } else {
          name = bytes;
          value = new Uint8Array(0);
        }
        name = replaceByteInByteSequence(name, 43, 32);
        value = replaceByteInByteSequence(value, 43, 32);
        const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
        const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
        output.push([nameString, valueString]);
      }
      return output;
    }
    function parseUrlencodedString(input) {
      return parseUrlencoded(utf8Encode(input));
    }
    function serializeUrlencoded(tuples) {
      let output = "";
      for (const [i, tuple] of tuples.entries()) {
        const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
        const value = utf8PercentEncodeString(tuple[1], isURLEncodedPercentEncode, true);
        if (i !== 0) {
          output += "&";
        }
        output += `${name}=${value}`;
      }
      return output;
    }
    function strictlySplitByteSequence(buf, cp) {
      const list = [];
      let last = 0;
      let i = buf.indexOf(cp);
      while (i >= 0) {
        list.push(buf.slice(last, i));
        last = i + 1;
        i = buf.indexOf(cp, last);
      }
      if (last !== buf.length) {
        list.push(buf.slice(last));
      }
      return list;
    }
    function replaceByteInByteSequence(buf, from, to) {
      let i = buf.indexOf(from);
      while (i >= 0) {
        buf[i] = to;
        i = buf.indexOf(from, i + 1);
      }
      return buf;
    }
    module.exports = {
      parseUrlencodedString,
      serializeUrlencoded
    };
  }
});

// node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS({
  "node_modules/whatwg-url/lib/Function.js"(exports) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils4();
    exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (typeof value !== "function") {
        throw new globalObject.TypeError(context + " is not a function");
      }
      function invokeTheCallbackFunction(...args) {
        const thisArg = utils.tryWrapperForImpl(this);
        let callResult;
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        callResult = Reflect.apply(value, thisArg, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      }
      invokeTheCallbackFunction.construct = (...args) => {
        for (let i = 0; i < args.length; i++) {
          args[i] = utils.tryWrapperForImpl(args[i]);
        }
        let callResult = Reflect.construct(value, args);
        callResult = conversions["any"](callResult, { context, globals: globalObject });
        return callResult;
      };
      invokeTheCallbackFunction[utils.wrapperSymbol] = value;
      invokeTheCallbackFunction.objectReference = value;
      return invokeTheCallbackFunction;
    };
  }
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS({
  "node_modules/whatwg-url/lib/URLSearchParams-impl.js"(exports) {
    "use strict";
    var urlencoded = require_urlencoded();
    exports.implementation = class URLSearchParamsImpl {
      constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
        let init = constructorArgs[0];
        this._list = [];
        this._url = null;
        if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
          init = init.slice(1);
        }
        if (Array.isArray(init)) {
          for (const pair of init) {
            if (pair.length !== 2) {
              throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
            }
            this._list.push([pair[0], pair[1]]);
          }
        } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
          for (const name of Object.keys(init)) {
            const value = init[name];
            this._list.push([name, value]);
          }
        } else {
          this._list = urlencoded.parseUrlencodedString(init);
        }
      }
      _updateSteps() {
        if (this._url !== null) {
          let serializedQuery = urlencoded.serializeUrlencoded(this._list);
          if (serializedQuery === "") {
            serializedQuery = null;
          }
          this._url._url.query = serializedQuery;
        }
      }
      get size() {
        return this._list.length;
      }
      append(name, value) {
        this._list.push([name, value]);
        this._updateSteps();
      }
      delete(name, value) {
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name && (value === void 0 || this._list[i][1] === value)) {
            this._list.splice(i, 1);
          } else {
            i++;
          }
        }
        this._updateSteps();
      }
      get(name) {
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            return tuple[1];
          }
        }
        return null;
      }
      getAll(name) {
        const output = [];
        for (const tuple of this._list) {
          if (tuple[0] === name) {
            output.push(tuple[1]);
          }
        }
        return output;
      }
      has(name, value) {
        for (const tuple of this._list) {
          if (tuple[0] === name && (value === void 0 || tuple[1] === value)) {
            return true;
          }
        }
        return false;
      }
      set(name, value) {
        let found = false;
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            if (found) {
              this._list.splice(i, 1);
            } else {
              found = true;
              this._list[i][1] = value;
              i++;
            }
          } else {
            i++;
          }
        }
        if (!found) {
          this._list.push([name, value]);
        }
        this._updateSteps();
      }
      sort() {
        this._list.sort((a, b) => {
          if (a[0] < b[0]) {
            return -1;
          }
          if (a[0] > b[0]) {
            return 1;
          }
          return 0;
        });
        this._updateSteps();
      }
      [Symbol.iterator]() {
        return this._list[Symbol.iterator]();
      }
      toString() {
        return urlencoded.serializeUrlencoded(this._list);
      }
    };
  }
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "node_modules/whatwg-url/lib/URLSearchParams.js"(exports) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils4();
    var Function2 = require_Function();
    var newObjectInRealm = utils.newObjectInRealm;
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URLSearchParams";
    exports.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
    };
    exports.createDefaultIterator = (globalObject, target, kind) => {
      const ctorRegistry = globalObject[ctorRegistrySymbol];
      const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
      const iterator2 = Object.create(iteratorPrototype);
      Object.defineProperty(iterator2, utils.iterInternalSymbol, {
        value: { target, kind, index: 0 },
        configurable: true
      });
      return iterator2;
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
      }
      return Object.create(proto);
    }
    exports.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports._internalSetup = (wrapper, globalObject) => {
    };
    exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URLSearchParams {
        constructor() {
          const args = [];
          {
            let curArg = arguments[0];
            if (curArg !== void 0) {
              if (utils.isObject(curArg)) {
                if (curArg[Symbol.iterator] !== void 0) {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                    );
                  } else {
                    const V = [];
                    const tmp = curArg;
                    for (let nextItem of tmp) {
                      if (!utils.isObject(nextItem)) {
                        throw new globalObject.TypeError(
                          "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                        );
                      } else {
                        const V2 = [];
                        const tmp2 = nextItem;
                        for (let nextItem2 of tmp2) {
                          nextItem2 = conversions["USVString"](nextItem2, {
                            context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                            globals: globalObject
                          });
                          V2.push(nextItem2);
                        }
                        nextItem = V2;
                      }
                      V.push(nextItem);
                    }
                    curArg = V;
                  }
                } else {
                  if (!utils.isObject(curArg)) {
                    throw new globalObject.TypeError(
                      "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                    );
                  } else {
                    const result = /* @__PURE__ */ Object.create(null);
                    for (const key of Reflect.ownKeys(curArg)) {
                      const desc = Object.getOwnPropertyDescriptor(curArg, key);
                      if (desc && desc.enumerable) {
                        let typedKey = key;
                        typedKey = conversions["USVString"](typedKey, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                          globals: globalObject
                        });
                        let typedValue = curArg[key];
                        typedValue = conversions["USVString"](typedValue, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                          globals: globalObject
                        });
                        result[typedKey] = typedValue;
                      }
                    }
                    curArg = result;
                  }
                }
              } else {
                curArg = conversions["USVString"](curArg, {
                  context: "Failed to construct 'URLSearchParams': parameter 1",
                  globals: globalObject
                });
              }
            } else {
              curArg = "";
            }
            args.push(curArg);
          }
          return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        append(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'append' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
        }
        delete(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'delete' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
        }
        get(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return esValue[implSymbol].get(...args);
        }
        getAll(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'getAll' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
        }
        has(name) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return esValue[implSymbol].has(...args);
        }
        set(name, value) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
          }
          if (arguments.length < 2) {
            throw new globalObject.TypeError(
              `Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
        }
        sort() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
          }
          return utils.tryWrapperForImpl(esValue[implSymbol].sort());
        }
        toString() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'toString' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol].toString();
        }
        keys() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
          }
          return exports.createDefaultIterator(globalObject, this, "key");
        }
        values() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'values' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports.createDefaultIterator(globalObject, this, "value");
        }
        entries() {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'entries' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return exports.createDefaultIterator(globalObject, this, "key+value");
        }
        forEach(callback) {
          if (!exports.is(this)) {
            throw new globalObject.TypeError(
              "'forEach' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              "Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present."
            );
          }
          callback = Function2.convert(globalObject, callback, {
            context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
          });
          const thisArg = arguments[1];
          let pairs = Array.from(this[implSymbol]);
          let i = 0;
          while (i < pairs.length) {
            const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
            callback.call(thisArg, value, key, this);
            pairs = Array.from(this[implSymbol]);
            i++;
          }
        }
        get size() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError(
              "'get size' called on an object that is not a valid instance of URLSearchParams."
            );
          }
          return esValue[implSymbol]["size"];
        }
      }
      Object.defineProperties(URLSearchParams.prototype, {
        append: { enumerable: true },
        delete: { enumerable: true },
        get: { enumerable: true },
        getAll: { enumerable: true },
        has: { enumerable: true },
        set: { enumerable: true },
        sort: { enumerable: true },
        toString: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
        forEach: { enumerable: true },
        size: { enumerable: true },
        [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
        [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
      });
      ctorRegistry[interfaceName] = URLSearchParams;
      ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
        [Symbol.toStringTag]: {
          configurable: true,
          value: "URLSearchParams Iterator"
        }
      });
      utils.define(ctorRegistry["URLSearchParams Iterator"], {
        next() {
          const internal = this && this[utils.iterInternalSymbol];
          if (!internal) {
            throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
          }
          const { target, kind, index } = internal;
          const values = Array.from(target[implSymbol]);
          const len = values.length;
          if (index >= len) {
            return newObjectInRealm(globalObject, { value: void 0, done: true });
          }
          const pair = values[index];
          internal.index = index + 1;
          return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
        }
      });
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URLSearchParams
      });
    };
    var Impl = require_URLSearchParams_impl();
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl2 = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine2();
    var urlencoded = require_urlencoded();
    var URLSearchParams = require_URLSearchParams();
    exports.implementation = class URLImpl {
      // Unlike the spec, we duplicate some code between the constructor and canParse, because we want to give useful error
      // messages in the constructor that distinguish between the different causes of failure.
      constructor(globalObject, [url2, base2]) {
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === null) {
            throw new TypeError(`Invalid base URL: ${base2}`);
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${url2}`);
        }
        const query2 = parsedURL.query !== null ? parsedURL.query : "";
        this._url = parsedURL;
        this._query = URLSearchParams.createImpl(globalObject, [query2], { doNotStripQMark: true });
        this._query._url = this;
      }
      static parse(globalObject, input, base2) {
        try {
          return new URLImpl(globalObject, [input, base2]);
        } catch {
          return null;
        }
      }
      static canParse(url2, base2) {
        let parsedBase = null;
        if (base2 !== void 0) {
          parsedBase = usm.basicURLParse(base2);
          if (parsedBase === null) {
            return false;
          }
        }
        const parsedURL = usm.basicURLParse(url2, { baseURL: parsedBase });
        if (parsedURL === null) {
          return false;
        }
        return true;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${v}`);
        }
        this._url = parsedURL;
        this._query._list.splice(0);
        const { query: query2 } = parsedURL;
        if (query2 !== null) {
          this._query._list = urlencoded.parseUrlencodedString(query2);
        }
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return `${this._url.scheme}:`;
      }
      set protocol(v) {
        usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url2 = this._url;
        if (url2.host === null) {
          return "";
        }
        if (url2.port === null) {
          return usm.serializeHost(url2.host);
        }
        return `${usm.serializeHost(url2.host)}:${usm.serializeInteger(url2.port)}`;
      }
      set host(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        return usm.serializePath(this._url);
      }
      set pathname(v) {
        if (usm.hasAnOpaquePath(this._url)) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return `?${this._url.query}`;
      }
      set search(v) {
        const url2 = this._url;
        if (v === "") {
          url2.query = null;
          this._query._list = [];
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url2.query = "";
        usm.basicURLParse(input, { url: url2, stateOverride: "query" });
        this._query._list = urlencoded.parseUrlencodedString(input);
      }
      get searchParams() {
        return this._query;
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return `#${this._url.fragment}`;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL2 = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports) {
    "use strict";
    var conversions = require_lib2();
    var utils = require_utils4();
    var implSymbol = utils.implSymbol;
    var ctorRegistrySymbol = utils.ctorRegistrySymbol;
    var interfaceName = "URL";
    exports.is = (value) => {
      return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
    };
    exports.isImpl = (value) => {
      return utils.isObject(value) && value instanceof Impl.implementation;
    };
    exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
      if (exports.is(value)) {
        return utils.implForWrapper(value);
      }
      throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
    };
    function makeWrapper(globalObject, newTarget) {
      let proto;
      if (newTarget !== void 0) {
        proto = newTarget.prototype;
      }
      if (!utils.isObject(proto)) {
        proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
      }
      return Object.create(proto);
    }
    exports.create = (globalObject, constructorArgs, privateData) => {
      const wrapper = makeWrapper(globalObject);
      return exports.setup(wrapper, globalObject, constructorArgs, privateData);
    };
    exports.createImpl = (globalObject, constructorArgs, privateData) => {
      const wrapper = exports.create(globalObject, constructorArgs, privateData);
      return utils.implForWrapper(wrapper);
    };
    exports._internalSetup = (wrapper, globalObject) => {
    };
    exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
      privateData.wrapper = wrapper;
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: new Impl.implementation(globalObject, constructorArgs, privateData),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper;
    };
    exports.new = (globalObject, newTarget) => {
      const wrapper = makeWrapper(globalObject, newTarget);
      exports._internalSetup(wrapper, globalObject);
      Object.defineProperty(wrapper, implSymbol, {
        value: Object.create(Impl.implementation.prototype),
        configurable: true
      });
      wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
      if (Impl.init) {
        Impl.init(wrapper[implSymbol]);
      }
      return wrapper[implSymbol];
    };
    var exposed = /* @__PURE__ */ new Set(["Window", "Worker"]);
    exports.install = (globalObject, globalNames) => {
      if (!globalNames.some((globalName) => exposed.has(globalName))) {
        return;
      }
      const ctorRegistry = utils.initCtorRegistry(globalObject);
      class URL3 {
        constructor(url2) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return exports.setup(Object.create(new.target.prototype), globalObject, args);
        }
        toJSON() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol].toJSON();
        }
        get href() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        set href(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'href' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["href"] = V;
        }
        toString() {
          const esValue = this;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["href"];
        }
        get origin() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["origin"];
        }
        get protocol() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["protocol"];
        }
        set protocol(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'protocol' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["protocol"] = V;
        }
        get username() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["username"];
        }
        set username(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'username' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["username"] = V;
        }
        get password() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["password"];
        }
        set password(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'password' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["password"] = V;
        }
        get host() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["host"];
        }
        set host(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'host' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["host"] = V;
        }
        get hostname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hostname"];
        }
        set hostname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hostname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hostname"] = V;
        }
        get port() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["port"];
        }
        set port(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'port' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["port"] = V;
        }
        get pathname() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["pathname"];
        }
        set pathname(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'pathname' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["pathname"] = V;
        }
        get search() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["search"];
        }
        set search(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'search' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["search"] = V;
        }
        get searchParams() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
          }
          return utils.getSameObject(this, "searchParams", () => {
            return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
          });
        }
        get hash() {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
          }
          return esValue[implSymbol]["hash"];
        }
        set hash(V) {
          const esValue = this !== null && this !== void 0 ? this : globalObject;
          if (!exports.is(esValue)) {
            throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
          }
          V = conversions["USVString"](V, {
            context: "Failed to set the 'hash' property on 'URL': The provided value",
            globals: globalObject
          });
          esValue[implSymbol]["hash"] = V;
        }
        static parse(url2) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'parse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'parse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return utils.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
        }
        static canParse(url2) {
          if (arguments.length < 1) {
            throw new globalObject.TypeError(
              `Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`
            );
          }
          const args = [];
          {
            let curArg = arguments[0];
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 1",
              globals: globalObject
            });
            args.push(curArg);
          }
          {
            let curArg = arguments[1];
            if (curArg !== void 0) {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to execute 'canParse' on 'URL': parameter 2",
                globals: globalObject
              });
            }
            args.push(curArg);
          }
          return Impl.implementation.canParse(...args);
        }
      }
      Object.defineProperties(URL3.prototype, {
        toJSON: { enumerable: true },
        href: { enumerable: true },
        toString: { enumerable: true },
        origin: { enumerable: true },
        protocol: { enumerable: true },
        username: { enumerable: true },
        password: { enumerable: true },
        host: { enumerable: true },
        hostname: { enumerable: true },
        port: { enumerable: true },
        pathname: { enumerable: true },
        search: { enumerable: true },
        searchParams: { enumerable: true },
        hash: { enumerable: true },
        [Symbol.toStringTag]: { value: "URL", configurable: true }
      });
      Object.defineProperties(URL3, { parse: { enumerable: true }, canParse: { enumerable: true } });
      ctorRegistry[interfaceName] = URL3;
      Object.defineProperty(globalObject, interfaceName, {
        configurable: true,
        writable: true,
        value: URL3
      });
      if (globalNames.includes("Window")) {
        Object.defineProperty(globalObject, "webkitURL", {
          configurable: true,
          writable: true,
          value: URL3
        });
      }
    };
    var Impl = require_URL_impl2();
  }
});

// node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS({
  "node_modules/whatwg-url/webidl2js-wrapper.js"(exports) {
    "use strict";
    var URL3 = require_URL2();
    var URLSearchParams = require_URLSearchParams();
    exports.URL = URL3;
    exports.URLSearchParams = URLSearchParams;
  }
});

// node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS({
  "node_modules/whatwg-url/index.js"(exports) {
    "use strict";
    var { URL: URL3, URLSearchParams } = require_webidl2js_wrapper();
    var urlStateMachine = require_url_state_machine2();
    var percentEncoding = require_percent_encoding();
    var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
    URL3.install(sharedGlobalObject, ["Window"]);
    URLSearchParams.install(sharedGlobalObject, ["Window"]);
    exports.URL = sharedGlobalObject.URL;
    exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
    exports.parseURL = urlStateMachine.parseURL;
    exports.basicURLParse = urlStateMachine.basicURLParse;
    exports.serializeURL = urlStateMachine.serializeURL;
    exports.serializePath = urlStateMachine.serializePath;
    exports.serializeHost = urlStateMachine.serializeHost;
    exports.serializeInteger = urlStateMachine.serializeInteger;
    exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
    exports.setTheUsername = urlStateMachine.setTheUsername;
    exports.setThePassword = urlStateMachine.setThePassword;
    exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
    exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
    exports.percentDecodeString = percentEncoding.percentDecodeString;
    exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
  }
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS({
  "node_modules/mongodb-connection-string-url/lib/redact.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.redactConnectionString = exports.redactValidConnectionString = void 0;
    var index_1 = __importStar(require_lib3());
    function redactValidConnectionString(inputUrl, options) {
      var _a, _b;
      const url2 = inputUrl.clone();
      const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : "_credentials_";
      const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
      if ((url2.username || url2.password) && redactUsernames) {
        url2.username = replacementString;
        url2.password = "";
      } else if (url2.password) {
        url2.password = replacementString;
      }
      if (url2.searchParams.has("authMechanismProperties")) {
        const props = new index_1.CommaAndColonSeparatedRecord(url2.searchParams.get("authMechanismProperties"));
        if (props.get("AWS_SESSION_TOKEN")) {
          props.set("AWS_SESSION_TOKEN", replacementString);
          url2.searchParams.set("authMechanismProperties", props.toString());
        }
      }
      if (url2.searchParams.has("tlsCertificateKeyFilePassword")) {
        url2.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
      }
      if (url2.searchParams.has("proxyUsername") && redactUsernames) {
        url2.searchParams.set("proxyUsername", replacementString);
      }
      if (url2.searchParams.has("proxyPassword")) {
        url2.searchParams.set("proxyPassword", replacementString);
      }
      return url2;
    }
    exports.redactValidConnectionString = redactValidConnectionString;
    function redactConnectionString(uri, options) {
      var _a, _b;
      const replacementString = (_a = options === null || options === void 0 ? void 0 : options.replacementString) !== null && _a !== void 0 ? _a : "<credentials>";
      const redactUsernames = (_b = options === null || options === void 0 ? void 0 : options.redactUsernames) !== null && _b !== void 0 ? _b : true;
      let parsed;
      try {
        parsed = new index_1.default(uri);
      } catch (_c) {
      }
      if (parsed) {
        options = { ...options, replacementString: "___credentials___" };
        return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
      }
      const R = replacementString;
      const replacements = [
        (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `$1${R}$3`),
        (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `$1${R}`),
        (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `$1${R}`),
        (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `$1${R}`) : uri2,
        (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `$1${R}`)
      ];
      for (const replacer of replacements) {
        uri = replacer(uri);
      }
      return uri;
    }
    exports.redactConnectionString = redactConnectionString;
  }
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mongodb-connection-string-url/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = void 0;
    var whatwg_url_1 = require_whatwg_url();
    var redact_1 = require_redact();
    Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function() {
      return redact_1.redactConnectionString;
    } });
    var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
    function connectionStringHasValidScheme(connectionString) {
      return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
    }
    var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;
    var CaseInsensitiveMap = class extends Map {
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      _normalizeKey(name) {
        name = `${name}`;
        for (const key of this.keys()) {
          if (key.toLowerCase() === name.toLowerCase()) {
            name = key;
            break;
          }
        }
        return name;
      }
    };
    function caseInsenstiveURLSearchParams(Ctor) {
      return class CaseInsenstiveURLSearchParams extends Ctor {
        append(name, value) {
          return super.append(this._normalizeKey(name), value);
        }
        delete(name) {
          return super.delete(this._normalizeKey(name));
        }
        get(name) {
          return super.get(this._normalizeKey(name));
        }
        getAll(name) {
          return super.getAll(this._normalizeKey(name));
        }
        has(name) {
          return super.has(this._normalizeKey(name));
        }
        set(name, value) {
          return super.set(this._normalizeKey(name), value);
        }
        keys() {
          return super.keys();
        }
        values() {
          return super.values();
        }
        entries() {
          return super.entries();
        }
        [Symbol.iterator]() {
          return super[Symbol.iterator]();
        }
        _normalizeKey(name) {
          return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
        }
      };
    }
    var URLWithoutHost = class extends whatwg_url_1.URL {
    };
    var MongoParseError = class extends Error {
      get name() {
        return "MongoParseError";
      }
    };
    var ConnectionString = class _ConnectionString extends URLWithoutHost {
      constructor(uri, options = {}) {
        var _a;
        const { looseValidation } = options;
        if (!looseValidation && !connectionStringHasValidScheme(uri)) {
          throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
        }
        const match = uri.match(HOSTS_REGEX);
        if (!match) {
          throw new MongoParseError(`Invalid connection string "${uri}"`);
        }
        const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== void 0 ? _a : {};
        if (!looseValidation) {
          if (!protocol || !hosts) {
            throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
          }
          try {
            decodeURIComponent(username !== null && username !== void 0 ? username : "");
            decodeURIComponent(password !== null && password !== void 0 ? password : "");
          } catch (err) {
            throw new MongoParseError(err.message);
          }
          const illegalCharacters = /[:/?#[\]@]/gi;
          if (username === null || username === void 0 ? void 0 : username.match(illegalCharacters)) {
            throw new MongoParseError(`Username contains unescaped characters ${username}`);
          }
          if (!username || !password) {
            const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
            if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
              throw new MongoParseError("URI contained empty userinfo section");
            }
          }
          if (password === null || password === void 0 ? void 0 : password.match(illegalCharacters)) {
            throw new MongoParseError("Password contains unescaped characters");
          }
        }
        let authString = "";
        if (typeof username === "string")
          authString += username;
        if (typeof password === "string")
          authString += `:${password}`;
        if (authString)
          authString += "@";
        try {
          super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
        } catch (err) {
          if (looseValidation) {
            new _ConnectionString(uri, {
              ...options,
              looseValidation: false
            });
          }
          if (typeof err.message === "string") {
            err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
          }
          throw err;
        }
        this._hosts = hosts.split(",");
        if (!looseValidation) {
          if (this.isSRV && this.hosts.length !== 1) {
            throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
          }
          if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
            throw new MongoParseError("mongodb+srv URI cannot have port number");
          }
        }
        if (!this.pathname) {
          this.pathname = "/";
        }
        Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
      }
      get host() {
        return DUMMY_HOSTNAME;
      }
      set host(_ignored) {
        throw new Error("No single host for connection string");
      }
      get hostname() {
        return DUMMY_HOSTNAME;
      }
      set hostname(_ignored) {
        throw new Error("No single host for connection string");
      }
      get port() {
        return "";
      }
      set port(_ignored) {
        throw new Error("No single host for connection string");
      }
      get href() {
        return this.toString();
      }
      set href(_ignored) {
        throw new Error("Cannot set href for connection strings");
      }
      get isSRV() {
        return this.protocol.includes("srv");
      }
      get hosts() {
        return this._hosts;
      }
      set hosts(list) {
        this._hosts = list;
      }
      toString() {
        return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
      }
      clone() {
        return new _ConnectionString(this.toString(), {
          looseValidation: true
        });
      }
      redact(options) {
        return (0, redact_1.redactValidConnectionString)(this, options);
      }
      typedSearchParams() {
        const sametype = false;
        return this.searchParams;
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        const { href, origin: origin2, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
        return { href, origin: origin2, protocol, username, password, hosts, pathname, search, searchParams, hash };
      }
    };
    exports.ConnectionString = ConnectionString;
    var CommaAndColonSeparatedRecord = class extends CaseInsensitiveMap {
      constructor(from) {
        super();
        for (const entry of (from !== null && from !== void 0 ? from : "").split(",")) {
          if (!entry)
            continue;
          const colonIndex = entry.indexOf(":");
          if (colonIndex === -1) {
            this.set(entry, "");
          } else {
            this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
          }
        }
      }
      toString() {
        return [...this].map((entry) => entry.join(":")).join(",");
      }
    };
    exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
    exports.default = ConnectionString;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports, module) {
    module.exports = {
      name: "mongodb",
      version: "6.16.0",
      description: "The official MongoDB driver for Node.js",
      main: "lib/index.js",
      files: [
        "lib",
        "src",
        "etc/prepare.js",
        "mongodb.d.ts",
        "tsconfig.json"
      ],
      types: "mongodb.d.ts",
      repository: {
        type: "git",
        url: "git@github.com:mongodb/node-mongodb-native.git"
      },
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      author: {
        name: "The MongoDB NodeJS Team",
        email: "dbx-node@mongodb.com"
      },
      dependencies: {
        "@mongodb-js/saslprep": "^1.1.9",
        bson: "^6.10.3",
        "mongodb-connection-string-url": "^3.0.0"
      },
      peerDependencies: {
        "@aws-sdk/credential-providers": "^3.188.0",
        "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
        "gcp-metadata": "^5.2.0",
        kerberos: "^2.0.1",
        "mongodb-client-encryption": ">=6.0.0 <7",
        snappy: "^7.2.2",
        socks: "^2.7.1"
      },
      peerDependenciesMeta: {
        "@aws-sdk/credential-providers": {
          optional: true
        },
        "@mongodb-js/zstd": {
          optional: true
        },
        kerberos: {
          optional: true
        },
        snappy: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "gcp-metadata": {
          optional: true
        },
        socks: {
          optional: true
        }
      },
      devDependencies: {
        "@aws-sdk/credential-providers": "^3.632.0",
        "@iarna/toml": "^2.2.5",
        "@istanbuljs/nyc-config-typescript": "^1.0.2",
        "@microsoft/api-extractor": "^7.49.2",
        "@microsoft/tsdoc-config": "^0.17.1",
        "@mongodb-js/zstd": "^2.0.0",
        "@types/chai": "^4.3.17",
        "@types/chai-subset": "^1.3.5",
        "@types/express": "^4.17.21",
        "@types/kerberos": "^1.1.5",
        "@types/mocha": "^10.0.9",
        "@types/node": "^22.13.0",
        "@types/saslprep": "^1.0.3",
        "@types/semver": "^7.5.8",
        "@types/sinon": "^17.0.3",
        "@types/sinon-chai": "^3.2.12",
        "@types/whatwg-url": "^11.0.5",
        "@typescript-eslint/eslint-plugin": "8.4.0",
        "@typescript-eslint/parser": "8.4.0",
        chai: "^4.4.1",
        "chai-subset": "^1.6.0",
        chalk: "^4.1.2",
        eslint: "9.9.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-mocha": "^10.4.1",
        "eslint-plugin-prettier": "^5.2.3",
        "eslint-plugin-simple-import-sort": "^12.1.1",
        "eslint-plugin-tsdoc": "^0.4.0",
        "eslint-plugin-unused-imports": "^4.1.4",
        express: "^4.21.2",
        "gcp-metadata": "^5.3.0",
        "js-yaml": "^4.1.0",
        mocha: "^10.8.2",
        "mocha-sinon": "^2.1.2",
        "mongodb-client-encryption": "^6.3.0",
        "mongodb-legacy": "^6.1.3",
        nyc: "^15.1.0",
        prettier: "^3.4.2",
        semver: "^7.7.0",
        sinon: "^18.0.0",
        "sinon-chai": "^3.7.0",
        snappy: "^7.2.2",
        socks: "^2.8.1",
        "source-map-support": "^0.5.21",
        "ts-node": "^10.9.2",
        tsd: "^0.31.2",
        typescript: "5.5",
        "typescript-cached-transpile": "^0.0.6",
        "v8-heapsnapshot": "^1.3.1",
        yargs: "^17.7.2"
      },
      license: "Apache-2.0",
      engines: {
        node: ">=16.20.1"
      },
      bugs: {
        url: "https://jira.mongodb.org/projects/NODE/issues/"
      },
      homepage: "https://github.com/mongodb/node-mongodb-native",
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:ts": "node ./node_modules/typescript/bin/tsc",
        "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && ESLINT_USE_FLAT_CONFIG=false eslint --no-ignore --fix mongodb.d.ts lib/beta.d.ts",
        "build:docs": "./etc/docs/build.ts",
        "build:typedoc": "typedoc",
        "build:nightly": "node ./.github/scripts/nightly.mjs",
        "check:bench": "npm --prefix test/benchmarks/driver_bench start",
        "check:coverage": "nyc npm run test:all",
        "check:integration-coverage": "nyc npm run check:test",
        "check:lambda": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/handler.test.js",
        "check:lambda:aws": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/aws_handler.test.js",
        "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
        "check:eslint": "npm run build:dts && ESLINT_USE_FLAT_CONFIG=false eslint -v && ESLINT_USE_FLAT_CONFIG=false eslint --max-warnings=0 --ext '.js,.ts' src test",
        "check:tsd": "tsd --version && tsd",
        "check:dependencies": "mocha test/action/dependency.test.ts",
        "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
        "check:search-indexes": "nyc mocha --config test/mocha_mongodb.js test/manual/search-index-management.prose.test.ts",
        "check:test": "mocha --config test/mocha_mongodb.js test/integration",
        "check:unit": "nyc mocha test/unit",
        "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
        "check:atlas": "nyc mocha --config test/manual/mocharc.js test/manual/atlas_connectivity.test.ts",
        "check:resource-management": "nyc mocha --config test/manual/mocharc.js test/manual/resource_management.test.ts",
        "check:drivers-atlas-testing": "nyc mocha --config test/mocha_mongodb.js test/atlas/drivers_atlas_testing.test.ts",
        "check:adl": "nyc mocha --config test/mocha_mongodb.js test/manual/atlas-data-lake-testing",
        "check:aws": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_aws.test.ts",
        "check:oidc-auth": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/auth.spec.test.ts",
        "check:oidc-test": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc.prose.test.ts",
        "check:oidc-azure": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_azure.prose.05.test.ts",
        "check:oidc-gcp": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_gcp.prose.06.test.ts",
        "check:oidc-k8s": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_k8s.prose.07.test.ts",
        "check:kerberos": "nyc mocha --config test/manual/mocharc.js test/manual/kerberos.test.ts",
        "check:tls": "nyc mocha --config test/manual/mocharc.js test/manual/tls_support.test.ts",
        "check:ldap": "nyc mocha --config test/manual/mocharc.js test/manual/ldap.test.ts",
        "check:socks5": "nyc mocha --config test/manual/mocharc.js test/manual/socks5.test.ts",
        "check:csfle": "nyc mocha --config test/mocha_mongodb.js test/integration/client-side-encryption",
        "check:snappy": "nyc mocha test/unit/assorted/snappy.test.js",
        "check:x509": "nyc mocha test/manual/x509_auth.test.ts",
        "fix:eslint": "npm run check:eslint -- --fix",
        prepare: "node etc/prepare.js",
        "preview:docs": "ts-node etc/docs/preview.ts",
        test: "npm run check:lint && npm run test:all",
        "test:all": "npm run check:unit && npm run check:test",
        "update:docs": "npm run build:docs -- --yes"
      },
      tsd: {
        directory: "test/types",
        compilerOptions: {
          strict: true,
          target: "esnext",
          module: "commonjs",
          moduleResolution: "node"
        }
      }
    };
  }
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS({
  "node_modules/mongodb/lib/cmap/handshake/client_metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LimitedSizeDocument = void 0;
    exports.makeClientMetadata = makeClientMetadata;
    exports.addContainerMetadata = addContainerMetadata;
    exports.getFAASEnv = getFAASEnv;
    var os = __require("os");
    var process2 = __require("process");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var NODE_DRIVER_VERSION = require_package().version;
    var LimitedSizeDocument = class {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.document = /* @__PURE__ */ new Map();
        this.documentSize = 5;
      }
      /** Only adds key/value if the bsonByteLength is less than MAX_SIZE */
      ifItFitsItSits(key, value) {
        const newElementSize = bson_1.BSON.serialize((/* @__PURE__ */ new Map()).set(key, value)).byteLength - 5;
        if (newElementSize + this.documentSize > this.maxSize) {
          return false;
        }
        this.documentSize += newElementSize;
        this.document.set(key, value);
        return true;
      }
      toObject() {
        return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
          promoteLongs: false,
          promoteBuffers: false,
          promoteValues: false,
          useBigInt64: false
        });
      }
    };
    exports.LimitedSizeDocument = LimitedSizeDocument;
    function makeClientMetadata(options) {
      const metadataDocument = new LimitedSizeDocument(512);
      const { appName = "" } = options;
      if (appName.length > 0) {
        const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
        metadataDocument.ifItFitsItSits("application", { name: name2 });
      }
      const { name = "", version = "", platform = "" } = options.driverInfo;
      const driverInfo = {
        name: name.length > 0 ? `nodejs|${name}` : "nodejs",
        version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
      };
      if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
      }
      let runtimeInfo = getRuntimeInfo();
      if (platform.length > 0) {
        runtimeInfo = `${runtimeInfo}|${platform}`;
      }
      if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
        throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
      }
      const osInfo = (/* @__PURE__ */ new Map()).set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
      if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
        for (const key of osInfo.keys()) {
          osInfo.delete(key);
          if (osInfo.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("os", osInfo))
            break;
        }
      }
      const faasEnv = getFAASEnv();
      if (faasEnv != null) {
        if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
          for (const key of faasEnv.keys()) {
            faasEnv.delete(key);
            if (faasEnv.size === 0)
              break;
            if (metadataDocument.ifItFitsItSits("env", faasEnv))
              break;
          }
        }
      }
      return metadataDocument.toObject();
    }
    var dockerPromise;
    async function getContainerMetadata() {
      const containerMetadata = {};
      dockerPromise ?? (dockerPromise = (0, utils_1.fileIsAccessible)("/.dockerenv"));
      const isDocker = await dockerPromise;
      const { KUBERNETES_SERVICE_HOST = "" } = process2.env;
      const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;
      if (isDocker)
        containerMetadata.runtime = "docker";
      if (isKubernetes)
        containerMetadata.orchestrator = "kubernetes";
      return containerMetadata;
    }
    async function addContainerMetadata(originalMetadata) {
      const containerMetadata = await getContainerMetadata();
      if (Object.keys(containerMetadata).length === 0)
        return originalMetadata;
      const extendedMetadata = new LimitedSizeDocument(512);
      const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };
      for (const [key, val] of Object.entries(originalMetadata)) {
        if (key !== "env") {
          extendedMetadata.ifItFitsItSits(key, val);
        } else {
          if (!extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata)) {
            extendedMetadata.ifItFitsItSits("env", val);
          }
        }
      }
      if (!("env" in originalMetadata)) {
        extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata);
      }
      return extendedMetadata.toObject();
    }
    function getFAASEnv() {
      const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
      const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
      const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
      const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
      const isVercelFaaS = VERCEL.length > 0;
      const faasEnv = /* @__PURE__ */ new Map();
      if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
        if (VERCEL_REGION.length > 0) {
          faasEnv.set("region", VERCEL_REGION);
        }
        faasEnv.set("name", "vercel");
        return faasEnv;
      }
      if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
        if (AWS_REGION.length > 0) {
          faasEnv.set("region", AWS_REGION);
        }
        if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
          faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
        }
        faasEnv.set("name", "aws.lambda");
        return faasEnv;
      }
      if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
        faasEnv.set("name", "azure.func");
        return faasEnv;
      }
      if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
        if (FUNCTION_REGION.length > 0) {
          faasEnv.set("region", FUNCTION_REGION);
        }
        if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
          faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
        }
        if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
          faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
        }
        faasEnv.set("name", "gcp.func");
        return faasEnv;
      }
      return null;
    }
    function getRuntimeInfo() {
      if ("Deno" in globalThis) {
        const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
        return `Deno v${version}, ${os.endianness()}`;
      }
      if ("Bun" in globalThis) {
        const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
        return `Bun v${version}, ${os.endianness()}`;
      }
      return `Node.js ${process2.version}, ${os.endianness()}`;
    }
  }
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/cmap/commands.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.DocumentSequence = exports.OpReply = exports.OpQueryRequest = void 0;
    var BSON = require_bson2();
    var error_1 = require_error();
    var compression_1 = require_compression();
    var constants_1 = require_constants();
    var _requestId = 0;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SECONDARY = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;
    var OpQueryRequest = class _OpQueryRequest {
      constructor(databaseName, query2, options) {
        this.databaseName = databaseName;
        this.query = query2;
        this.moreToCome = false;
        const ns = `${databaseName}.$cmd`;
        if (typeof databaseName !== "string") {
          throw new error_1.MongoRuntimeError("Database name must be a string for a query");
        }
        if (query2 == null)
          throw new error_1.MongoRuntimeError("A query document must be specified for query");
        if (ns.indexOf("\0") !== -1) {
          throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
        }
        this.ns = ns;
        this.numberToSkip = options.numberToSkip || 0;
        this.numberToReturn = options.numberToReturn || 0;
        this.returnFieldSelector = options.returnFieldSelector || void 0;
        this.requestId = options.requestId ?? _OpQueryRequest.getRequestId();
        this.pre32Limit = options.pre32Limit;
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.batchSize = this.numberToReturn;
        this.tailable = false;
        this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
        this.oplogReplay = false;
        this.noCursorTimeout = false;
        this.awaitData = false;
        this.exhaust = false;
        this.partial = false;
      }
      /** Assign next request Id. */
      incRequestId() {
        this.requestId = _requestId++;
      }
      /** Peek next request Id. */
      nextRequestId() {
        return _requestId + 1;
      }
      /** Increment then return next request Id. */
      static getRequestId() {
        return ++_requestId;
      }
      // Uses a single allocated buffer for the process, avoiding multiple memory allocations
      toBin() {
        const buffers = [];
        let projection = null;
        let flags = 0;
        if (this.tailable) {
          flags |= OPTS_TAILABLE_CURSOR;
        }
        if (this.secondaryOk) {
          flags |= OPTS_SECONDARY;
        }
        if (this.oplogReplay) {
          flags |= OPTS_OPLOG_REPLAY;
        }
        if (this.noCursorTimeout) {
          flags |= OPTS_NO_CURSOR_TIMEOUT;
        }
        if (this.awaitData) {
          flags |= OPTS_AWAIT_DATA;
        }
        if (this.exhaust) {
          flags |= OPTS_EXHAUST;
        }
        if (this.partial) {
          flags |= OPTS_PARTIAL;
        }
        if (this.batchSize !== this.numberToReturn)
          this.numberToReturn = this.batchSize;
        const header = Buffer.alloc(
          4 * 4 + // Header
          4 + // Flags
          Buffer.byteLength(this.ns) + 1 + // namespace
          4 + // numberToSkip
          4
          // numberToReturn
        );
        buffers.push(header);
        const query2 = BSON.serialize(this.query, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(query2);
        if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
          projection = BSON.serialize(this.returnFieldSelector, {
            checkKeys: this.checkKeys,
            serializeFunctions: this.serializeFunctions,
            ignoreUndefined: this.ignoreUndefined
          });
          buffers.push(projection);
        }
        const totalLength = header.length + query2.length + (projection ? projection.length : 0);
        let index = 4;
        header[3] = totalLength >> 24 & 255;
        header[2] = totalLength >> 16 & 255;
        header[1] = totalLength >> 8 & 255;
        header[0] = totalLength & 255;
        header[index + 3] = this.requestId >> 24 & 255;
        header[index + 2] = this.requestId >> 16 & 255;
        header[index + 1] = this.requestId >> 8 & 255;
        header[index] = this.requestId & 255;
        index = index + 4;
        header[index + 3] = 0 >> 24 & 255;
        header[index + 2] = 0 >> 16 & 255;
        header[index + 1] = 0 >> 8 & 255;
        header[index] = 0 & 255;
        index = index + 4;
        header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
        header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
        header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
        header[index] = constants_1.OP_QUERY & 255;
        index = index + 4;
        header[index + 3] = flags >> 24 & 255;
        header[index + 2] = flags >> 16 & 255;
        header[index + 1] = flags >> 8 & 255;
        header[index] = flags & 255;
        index = index + 4;
        index = index + header.write(this.ns, index, "utf8") + 1;
        header[index - 1] = 0;
        header[index + 3] = this.numberToSkip >> 24 & 255;
        header[index + 2] = this.numberToSkip >> 16 & 255;
        header[index + 1] = this.numberToSkip >> 8 & 255;
        header[index] = this.numberToSkip & 255;
        index = index + 4;
        header[index + 3] = this.numberToReturn >> 24 & 255;
        header[index + 2] = this.numberToReturn >> 16 & 255;
        header[index + 1] = this.numberToReturn >> 8 & 255;
        header[index] = this.numberToReturn & 255;
        index = index + 4;
        return buffers;
      }
    };
    exports.OpQueryRequest = OpQueryRequest;
    var OpReply = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        this.moreToCome = false;
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts ?? {
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      }
      isParsed() {
        return this.parsed;
      }
      parse() {
        if (this.parsed)
          return this.sections[0];
        this.index = 20;
        this.responseFlags = this.data.readInt32LE(0);
        this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
        this.startingFrom = this.data.readInt32LE(12);
        this.numberReturned = this.data.readInt32LE(16);
        if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {
          throw new RangeError(`OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`);
        }
        this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
        this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
        this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
        this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
        for (let i = 0; i < this.numberReturned; i++) {
          const bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
          const section = this.data.subarray(this.index, this.index + bsonSize);
          this.sections.push(section);
          this.index = this.index + bsonSize;
        }
        this.parsed = true;
        return this.sections[0];
      }
    };
    exports.OpReply = OpReply;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var DocumentSequence = class {
      /**
       * Create a new document sequence for the provided field.
       * @param field - The field it will replace.
       */
      constructor(field, documents) {
        this.field = field;
        this.documents = [];
        this.chunks = [];
        this.serializedDocumentsLength = 0;
        const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
        buffer[0] = 1;
        encodeUTF8Into(buffer, `${this.field}\0`, 5);
        this.chunks.push(buffer);
        this.header = buffer;
        if (documents) {
          for (const doc of documents) {
            this.push(doc, BSON.serialize(doc));
          }
        }
      }
      /**
       * Push a document to the document sequence. Will serialize the document
       * as well and return the current serialized length of all documents.
       * @param document - The document to add.
       * @param buffer - The serialized document in raw BSON.
       * @returns The new total document sequence length.
       */
      push(document2, buffer) {
        this.serializedDocumentsLength += buffer.length;
        this.documents.push(document2);
        this.chunks.push(buffer);
        this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
        return this.serializedDocumentsLength + this.header.length;
      }
      /**
       * Get the fully serialized bytes for the document sequence section.
       * @returns The section bytes.
       */
      toBin() {
        return Buffer.concat(this.chunks);
      }
    };
    exports.DocumentSequence = DocumentSequence;
    var OpMsgRequest = class _OpMsgRequest {
      constructor(databaseName, command, options) {
        this.databaseName = databaseName;
        this.command = command;
        this.options = options;
        if (command == null)
          throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
        this.command.$db = databaseName;
        this.options = options ?? {};
        this.requestId = options.requestId ? options.requestId : _OpMsgRequest.getRequestId();
        this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
        this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
        this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
        this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options.moreToCome ?? command.writeConcern?.w === 0;
        this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer.alloc(
          4 * 4 + // Header
          4
          // Flags
        );
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeSections(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(constants_1.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      /**
       * Add the sections to the OP_MSG request's buffers and returns the length.
       */
      makeSections(buffers, document2) {
        const sequencesBuffer = this.extractDocumentSequences(document2);
        const payloadTypeBuffer = Buffer.allocUnsafe(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        buffers.push(sequencesBuffer);
        return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
      }
      /**
       * Extracts the document sequences from the command document and returns
       * a buffer to be added as multiple sections after the initial type 0
       * section in the message.
       */
      extractDocumentSequences(document2) {
        const chunks = [];
        for (const [key, value] of Object.entries(document2)) {
          if (value instanceof DocumentSequence) {
            chunks.push(value.toBin());
            delete document2[key];
          }
        }
        if (chunks.length > 0) {
          return Buffer.concat(chunks);
        }
        return Buffer.alloc(0);
      }
      serializeBson(document2) {
        return BSON.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
      static getRequestId() {
        _requestId = _requestId + 1 & 2147483647;
        return _requestId;
      }
    };
    exports.OpMsgRequest = OpMsgRequest;
    var OpMsgResponse = class {
      constructor(message, msgHeader, msgBody, opts) {
        this.index = 0;
        this.sections = [];
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.opts = opts ?? {
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: false,
          bsonRegExp: false
        };
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
        this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
        this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
        this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
        this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      }
      isParsed() {
        return this.parsed;
      }
      parse() {
        if (this.parsed)
          return this.sections[0];
        this.index = 4;
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.subarray(this.index, this.index + bsonSize);
            this.sections.push(bin);
            this.index += bsonSize;
          } else if (payloadType === 1) {
            throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
          }
        }
        this.parsed = true;
        return this.sections[0];
      }
    };
    exports.OpMsgResponse = OpMsgResponse;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var OpCompressedRequest = class {
      constructor(command, options) {
        this.command = command;
        this.options = options;
      }
      // Return whether a command contains an uncompressible command term
      // Will return true if command contains no uncompressible command terms
      static canCompress(command) {
        const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
        const commandName = Object.keys(commandDoc)[0];
        return !compression_1.uncompressibleCommands.has(commandName);
      }
      async toBin() {
        const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(this.command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8);
        return [msgHeader, compressionDetails, compressedMessage];
      }
    };
    exports.OpCompressedRequest = OpCompressedRequest;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/compression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uncompressibleCommands = exports.Compressor = void 0;
    exports.compress = compress;
    exports.decompress = decompress;
    exports.compressCommand = compressCommand;
    exports.decompressResponse = decompressResponse;
    var util_1 = __require("util");
    var zlib3 = __require("zlib");
    var constants_1 = require_constants2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var commands_1 = require_commands();
    var constants_2 = require_constants();
    exports.Compressor = Object.freeze({
      none: 0,
      snappy: 1,
      zlib: 2,
      zstd: 3
    });
    exports.uncompressibleCommands = /* @__PURE__ */ new Set([
      constants_1.LEGACY_HELLO_COMMAND,
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    var ZSTD_COMPRESSION_LEVEL = 3;
    var zlibInflate = (0, util_1.promisify)(zlib3.inflate.bind(zlib3));
    var zlibDeflate = (0, util_1.promisify)(zlib3.deflate.bind(zlib3));
    var zstd;
    var Snappy = null;
    function loadSnappy() {
      if (Snappy == null) {
        const snappyImport = (0, deps_1.getSnappy)();
        if ("kModuleError" in snappyImport) {
          throw snappyImport.kModuleError;
        }
        Snappy = snappyImport;
      }
      return Snappy;
    }
    async function compress(options, dataToBeCompressed) {
      const zlibOptions2 = {};
      switch (options.agreedCompressor) {
        case "snappy": {
          Snappy ?? (Snappy = loadSnappy());
          return await Snappy.compress(dataToBeCompressed);
        }
        case "zstd": {
          loadZstd();
          if ("kModuleError" in zstd) {
            throw zstd["kModuleError"];
          }
          return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
        }
        case "zlib": {
          if (options.zlibCompressionLevel) {
            zlibOptions2.level = options.zlibCompressionLevel;
          }
          return await zlibDeflate(dataToBeCompressed, zlibOptions2);
        }
        default: {
          throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
        }
      }
    }
    async function decompress(compressorID, compressedData) {
      if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {
        throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
      }
      switch (compressorID) {
        case exports.Compressor.snappy: {
          Snappy ?? (Snappy = loadSnappy());
          return await Snappy.uncompress(compressedData, { asBuffer: true });
        }
        case exports.Compressor.zstd: {
          loadZstd();
          if ("kModuleError" in zstd) {
            throw zstd["kModuleError"];
          }
          return await zstd.decompress(compressedData);
        }
        case exports.Compressor.zlib: {
          return await zlibInflate(compressedData);
        }
        default: {
          return compressedData;
        }
      }
    }
    function loadZstd() {
      if (!zstd) {
        zstd = (0, deps_1.getZstdLibrary)();
      }
    }
    var MESSAGE_HEADER_SIZE = 16;
    async function compressCommand(command, description) {
      const finalCommand = description.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
        agreedCompressor: description.agreedCompressor ?? "none",
        zlibCompressionLevel: description.zlibCompressionLevel ?? 0
      });
      const data = await finalCommand.toBin();
      return Buffer.concat(data);
    }
    async function decompressResponse(message) {
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
        const ResponseType2 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
        const messageBody2 = message.subarray(MESSAGE_HEADER_SIZE);
        return new ResponseType2(message, messageHeader, messageBody2);
      }
      const header = {
        ...messageHeader,
        fromCompressed: true,
        opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
        length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
      };
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
      const messageBody = await decompress(compressorID, compressedBuffer);
      if (messageBody.length !== header.length) {
        throw new error_1.MongoDecompressionError("Message body and message header must be the same length");
      }
      return new ResponseType(message, header, messageBody);
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js
var require_crypto_callbacks = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmacSha256Hook = exports.hmacSha512Hook = exports.aes256CtrDecryptHook = exports.aes256CtrEncryptHook = exports.aes256CbcDecryptHook = exports.aes256CbcEncryptHook = void 0;
    exports.makeAES256Hook = makeAES256Hook;
    exports.randomHook = randomHook;
    exports.sha256Hook = sha256Hook;
    exports.makeHmacHook = makeHmacHook;
    exports.signRsaSha256Hook = signRsaSha256Hook;
    var crypto7 = __require("crypto");
    function makeAES256Hook(method, mode) {
      return function(key, iv, input, output) {
        let result;
        try {
          const cipher = crypto7[method](mode, key, iv);
          cipher.setAutoPadding(false);
          result = cipher.update(input);
          const final = cipher.final();
          if (final.length > 0) {
            result = Buffer.concat([result, final]);
          }
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function randomHook(buffer, count) {
      try {
        crypto7.randomFillSync(buffer, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto7.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto7.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto7.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    exports.aes256CbcEncryptHook = makeAES256Hook("createCipheriv", "aes-256-cbc");
    exports.aes256CbcDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-cbc");
    exports.aes256CtrEncryptHook = makeAES256Hook("createCipheriv", "aes-256-ctr");
    exports.aes256CtrDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-ctr");
    exports.hmacSha512Hook = makeHmacHook("sha512");
    exports.hmacSha256Hook = makeHmacHook("sha256");
  }
});

// node_modules/mongodb/lib/client-side-encryption/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptAzureKMSRequestError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = void 0;
    var error_1 = require_error();
    var MongoCryptError = class extends error_1.MongoError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, options = {}) {
        super(message, options);
      }
      get name() {
        return "MongoCryptError";
      }
    };
    exports.MongoCryptError = MongoCryptError;
    var MongoCryptInvalidArgumentError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message) {
        super(message);
      }
      get name() {
        return "MongoCryptInvalidArgumentError";
      }
    };
    exports.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;
    var MongoCryptCreateDataKeyError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(encryptedFields, { cause }) {
        super(`Unable to complete creating data keys: ${cause.message}`, { cause });
        this.encryptedFields = encryptedFields;
      }
      get name() {
        return "MongoCryptCreateDataKeyError";
      }
    };
    exports.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;
    var MongoCryptCreateEncryptedCollectionError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(encryptedFields, { cause }) {
        super(`Unable to create collection: ${cause.message}`, { cause });
        this.encryptedFields = encryptedFields;
      }
      get name() {
        return "MongoCryptCreateEncryptedCollectionError";
      }
    };
    exports.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;
    var MongoCryptAzureKMSRequestError = class extends MongoCryptError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, body3) {
        super(message);
        this.body = body3;
      }
      get name() {
        return "MongoCryptAzureKMSRequestError";
      }
    };
    exports.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;
    var MongoCryptKMSRequestNetworkTimeoutError = class extends MongoCryptError {
      get name() {
        return "MongoCryptKMSRequestNetworkTimeoutError";
      }
    };
    exports.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
  }
});

// node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js
var require_aws_temporary_credentials = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyAWSTemporaryCredentialProvider = exports.AWSSDKCredentialProvider = exports.AWSTemporaryCredentialProvider = void 0;
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var AWSTemporaryCredentialProvider = class _AWSTemporaryCredentialProvider {
      static get awsSDK() {
        _AWSTemporaryCredentialProvider._awsSDK ?? (_AWSTemporaryCredentialProvider._awsSDK = (0, deps_1.getAwsCredentialProvider)());
        return _AWSTemporaryCredentialProvider._awsSDK;
      }
      static get isAWSSDKInstalled() {
        return !("kModuleError" in _AWSTemporaryCredentialProvider.awsSDK);
      }
    };
    exports.AWSTemporaryCredentialProvider = AWSTemporaryCredentialProvider;
    var AWSSDKCredentialProvider = class extends AWSTemporaryCredentialProvider {
      /**
       * Create the SDK credentials provider.
       * @param credentialsProvider - The credentials provider.
       */
      constructor(credentialsProvider) {
        super();
        if (credentialsProvider) {
          this._provider = credentialsProvider;
        }
      }
      /**
       * The AWS SDK caches credentials automatically and handles refresh when the credentials have expired.
       * To ensure this occurs, we need to cache the `provider` returned by the AWS sdk and re-use it when fetching credentials.
       */
      get provider() {
        if ("kModuleError" in AWSTemporaryCredentialProvider.awsSDK) {
          throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;
        }
        if (this._provider) {
          return this._provider;
        }
        let { AWS_STS_REGIONAL_ENDPOINTS = "", AWS_REGION = "" } = process.env;
        AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
        AWS_REGION = AWS_REGION.toLowerCase();
        const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
        const LEGACY_REGIONS = /* @__PURE__ */ new Set([
          "ap-northeast-1",
          "ap-south-1",
          "ap-southeast-1",
          "ap-southeast-2",
          "aws-global",
          "ca-central-1",
          "eu-central-1",
          "eu-north-1",
          "eu-west-1",
          "eu-west-2",
          "eu-west-3",
          "sa-east-1",
          "us-east-1",
          "us-east-2",
          "us-west-1",
          "us-west-2"
        ]);
        const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === "regional" || AWS_STS_REGIONAL_ENDPOINTS === "legacy" && !LEGACY_REGIONS.has(AWS_REGION);
        this._provider = awsRegionSettingsExist && useRegionalSts ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({
          clientConfig: { region: AWS_REGION }
        }) : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();
        return this._provider;
      }
      async getCredentials() {
        try {
          const creds = await this.provider();
          return {
            AccessKeyId: creds.accessKeyId,
            SecretAccessKey: creds.secretAccessKey,
            Token: creds.sessionToken,
            Expiration: creds.expiration
          };
        } catch (error2) {
          throw new error_1.MongoAWSError(error2.message, { cause: error2 });
        }
      }
    };
    exports.AWSSDKCredentialProvider = AWSSDKCredentialProvider;
    var LegacyAWSTemporaryCredentialProvider = class extends AWSTemporaryCredentialProvider {
      async getCredentials() {
        if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
          return await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`);
        }
        const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
          method: "PUT",
          json: false,
          headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
        });
        const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
          json: false,
          headers: { "X-aws-ec2-metadata-token": token }
        });
        const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
          headers: { "X-aws-ec2-metadata-token": token }
        });
        return creds;
      }
    };
    exports.LegacyAWSTemporaryCredentialProvider = LegacyAWSTemporaryCredentialProvider;
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/aws.js
var require_aws = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/aws.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadAWSCredentials = loadAWSCredentials;
    var aws_temporary_credentials_1 = require_aws_temporary_credentials();
    async function loadAWSCredentials(kmsProviders, provider) {
      const credentialProvider = new aws_temporary_credentials_1.AWSSDKCredentialProvider(provider);
      const { SecretAccessKey = "", AccessKeyId = "", Token } = await credentialProvider.getCredentials();
      const aws = {
        secretAccessKey: SecretAccessKey,
        accessKeyId: AccessKeyId
      };
      Token != null && (aws.sessionToken = Token);
      return { ...kmsProviders, aws };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/azure.js
var require_azure = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/azure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenCache = exports.AzureCredentialCache = exports.AZURE_BASE_URL = void 0;
    exports.addAzureParams = addAzureParams;
    exports.prepareRequest = prepareRequest;
    exports.fetchAzureKMSToken = fetchAzureKMSToken;
    exports.loadAzureCredentials = loadAzureCredentials;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var errors_1 = require_errors();
    var MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6e3;
    exports.AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?";
    var AzureCredentialCache = class {
      constructor() {
        this.cachedToken = null;
      }
      async getToken() {
        if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
          this.cachedToken = await this._getToken();
        }
        return { accessToken: this.cachedToken.accessToken };
      }
      needsRefresh(token) {
        const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
        return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
      }
      /**
       * exposed for testing
       */
      resetCache() {
        this.cachedToken = null;
      }
      /**
       * exposed for testing
       */
      _getToken() {
        return fetchAzureKMSToken();
      }
    };
    exports.AzureCredentialCache = AzureCredentialCache;
    exports.tokenCache = new AzureCredentialCache();
    async function parseResponse(response) {
      const { status, body: rawBody } = response;
      const body3 = (() => {
        try {
          return JSON.parse(rawBody);
        } catch {
          throw new errors_1.MongoCryptAzureKMSRequestError("Malformed JSON body in GET request.");
        }
      })();
      if (status !== 200) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Unable to complete request.", body3);
      }
      if (!body3.access_token) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `access_token`.");
      }
      if (!body3.expires_in) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `expires_in`.");
      }
      const expiresInMS = Number(body3.expires_in) * 1e3;
      if (Number.isNaN(expiresInMS)) {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - unable to parse int from `expires_in` field.");
      }
      return {
        accessToken: body3.access_token,
        expiresOnTimestamp: Date.now() + expiresInMS
      };
    }
    function addAzureParams(url2, resource, username) {
      url2.searchParams.append("api-version", "2018-02-01");
      url2.searchParams.append("resource", resource);
      if (username) {
        url2.searchParams.append("client_id", username);
      }
      return url2;
    }
    function prepareRequest(options) {
      const url2 = new URL(options.url?.toString() ?? exports.AZURE_BASE_URL);
      addAzureParams(url2, "https://vault.azure.net");
      const headers = { ...options.headers, "Content-Type": "application/json", Metadata: true };
      return { headers, url: url2 };
    }
    async function fetchAzureKMSToken(options = {}) {
      const { headers, url: url2 } = prepareRequest(options);
      try {
        const response = await (0, utils_1.get)(url2, { headers });
        return await parseResponse(response);
      } catch (error2) {
        if (error2 instanceof error_1.MongoNetworkTimeoutError) {
          throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error2.message}`);
        }
        throw error2;
      }
    }
    async function loadAzureCredentials(kmsProviders) {
      const azure = await exports.tokenCache.getToken();
      return { ...kmsProviders, azure };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/gcp.js
var require_gcp = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/gcp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadGCPCredentials = loadGCPCredentials;
    var deps_1 = require_deps();
    async function loadGCPCredentials(kmsProviders) {
      const gcpMetadata = (0, deps_1.getGcpMetadata)();
      if ("kModuleError" in gcpMetadata) {
        return kmsProviders;
      }
      const { access_token: accessToken } = await gcpMetadata.instance({
        property: "service-accounts/default/token"
      });
      return { ...kmsProviders, gcp: { accessToken } };
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/index.js
var require_providers2 = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/providers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyCredentials = isEmptyCredentials;
    exports.refreshKMSCredentials = refreshKMSCredentials;
    var aws_1 = require_aws();
    var azure_1 = require_azure();
    var gcp_1 = require_gcp();
    function isEmptyCredentials(providerName, kmsProviders) {
      const provider = kmsProviders[providerName];
      if (provider == null) {
        return false;
      }
      return typeof provider === "object" && Object.keys(provider).length === 0;
    }
    async function refreshKMSCredentials(kmsProviders, credentialProviders) {
      let finalKMSProviders = kmsProviders;
      if (isEmptyCredentials("aws", kmsProviders)) {
        finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders, credentialProviders?.aws);
      }
      if (isEmptyCredentials("gcp", kmsProviders)) {
        finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
      }
      if (isEmptyCredentials("azure", kmsProviders)) {
        finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
      }
      return finalKMSProviders;
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/state_machine.js
var require_state_machine = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/state_machine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StateMachine = void 0;
    var fs2 = __require("fs/promises");
    var net = __require("net");
    var tls = __require("tls");
    var bson_1 = require_bson2();
    var abstract_cursor_1 = require_abstract_cursor();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var client_encryption_1 = require_client_encryption();
    var errors_1 = require_errors();
    var socks = null;
    function loadSocks() {
      if (socks == null) {
        const socksImport = (0, deps_1.getSocks)();
        if ("kModuleError" in socksImport) {
          throw socksImport.kModuleError;
        }
        socks = socksImport;
      }
      return socks;
    }
    var MONGOCRYPT_CTX_ERROR = 0;
    var MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
    var MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
    var MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
    var MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
    var MONGOCRYPT_CTX_NEED_KMS = 4;
    var MONGOCRYPT_CTX_READY = 5;
    var MONGOCRYPT_CTX_DONE = 6;
    var HTTPS_PORT = 443;
    var stateToString = /* @__PURE__ */ new Map([
      [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
      [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
      [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
      [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
      [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, "MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"],
      [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
      [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
      [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
    ]);
    var INSECURE_TLS_OPTIONS = [
      "tlsInsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      // These options are disallowed by the spec, so we explicitly filter them out if provided, even
      // though the StateMachine does not declare support for these options.
      "tlsDisableOCSPEndpointCheck",
      "tlsDisableCertificateRevocationCheck"
    ];
    function debug(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.error(msg);
      }
    }
    var EMPTY_V;
    var StateMachine = class {
      constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {
        this.options = options;
        this.bsonOptions = bsonOptions;
      }
      /**
       * Executes the state machine according to the specification
       */
      async execute(executor, context, options) {
        const keyVaultNamespace = executor._keyVaultNamespace;
        const keyVaultClient = executor._keyVaultClient;
        const metaDataClient = executor._metaDataClient;
        const mongocryptdClient = executor._mongocryptdClient;
        const mongocryptdManager = executor._mongocryptdManager;
        let result = null;
        const getStatus = () => context.status;
        const getState = () => context.state;
        while (getState() !== MONGOCRYPT_CTX_DONE && getState() !== MONGOCRYPT_CTX_ERROR) {
          options.signal?.throwIfAborted();
          debug(`[context#${context.id}] ${stateToString.get(getState()) || getState()}`);
          switch (getState()) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter2 = (0, bson_1.deserialize)(context.nextMongoOperation());
              if (!metaDataClient) {
                throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined");
              }
              const collInfoCursor = this.fetchCollectionInfo(metaDataClient, context.ns, filter2, options);
              for await (const collInfo of collInfoCursor) {
                context.addMongoOperationResponse((0, bson_1.serialize)(collInfo));
                if (getState() === MONGOCRYPT_CTX_ERROR)
                  break;
              }
              if (getState() === MONGOCRYPT_CTX_ERROR)
                break;
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command = context.nextMongoOperation();
              if (getState() === MONGOCRYPT_CTX_ERROR)
                break;
              if (!mongocryptdClient) {
                throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined");
              }
              const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command, options)) : await this.markCommand(mongocryptdClient, context.ns, command, options);
              context.addMongoOperationResponse(markedCommand);
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter2 = context.nextMongoOperation();
              const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter2, options);
              if (keys.length === 0) {
                result = EMPTY_V ?? (EMPTY_V = (0, bson_1.serialize)({ v: [] }));
              }
              for await (const key of keys) {
                context.addMongoOperationResponse((0, bson_1.serialize)(key));
              }
              context.finishMongoOperation();
              break;
            }
            case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
              const kmsProviders = await executor.askForKMSCredentials();
              context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
              break;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              await Promise.all(this.requests(context, options));
              context.finishKMSRequests();
              break;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (getState() === MONGOCRYPT_CTX_ERROR) {
                const message = getStatus().message || "Finalization error";
                throw new errors_1.MongoCryptError(message);
              }
              result = finalizedContext;
              break;
            }
            default:
              throw new errors_1.MongoCryptError(`Unknown state: ${getState()}`);
          }
        }
        if (getState() === MONGOCRYPT_CTX_ERROR || result == null) {
          const message = getStatus().message;
          if (!message) {
            debug(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
          }
          throw new errors_1.MongoCryptError(message ?? "unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.");
        }
        return result;
      }
      /**
       * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.
       * @param kmsContext - A C++ KMS context returned from the bindings
       * @returns A promise that resolves when the KMS reply has be fully parsed
       */
      async kmsRequest(request, options) {
        const parsedUrl = request.endpoint.split(":");
        const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
        const socketOptions = {
          host: parsedUrl[0],
          servername: parsedUrl[0],
          port,
          ...(0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {})
        };
        const message = request.message;
        const buffer = new utils_1.BufferPool();
        let netSocket;
        let socket;
        function destroySockets() {
          for (const sock of [socket, netSocket]) {
            if (sock) {
              sock.destroy();
            }
          }
        }
        function onerror(cause) {
          return new errors_1.MongoCryptError("KMS request failed", { cause });
        }
        function onclose() {
          return new errors_1.MongoCryptError("KMS request closed");
        }
        const tlsOptions = this.options.tlsOptions;
        if (tlsOptions) {
          const kmsProvider = request.kmsProvider;
          const providerTlsOptions = tlsOptions[kmsProvider];
          if (providerTlsOptions) {
            const error2 = this.validateTlsOptions(kmsProvider, providerTlsOptions);
            if (error2) {
              throw error2;
            }
            try {
              await this.setTlsOptions(providerTlsOptions, socketOptions);
            } catch (err) {
              throw onerror(err);
            }
          }
        }
        let abortListener;
        try {
          if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
            netSocket = new net.Socket();
            const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();
            netSocket.once("error", (err) => rejectOnNetSocketError(onerror(err))).once("close", () => rejectOnNetSocketError(onclose())).once("connect", () => resolveOnNetSocketConnect());
            const netSocketOptions = {
              ...socketOptions,
              host: this.options.proxyOptions.proxyHost,
              port: this.options.proxyOptions.proxyPort || 1080
            };
            netSocket.connect(netSocketOptions);
            await willConnect;
            try {
              socks ?? (socks = loadSocks());
              socketOptions.socket = (await socks.SocksClient.createConnection({
                existing_socket: netSocket,
                command: "connect",
                destination: { host: socketOptions.host, port: socketOptions.port },
                proxy: {
                  // host and port are ignored because we pass existing_socket
                  host: "iLoveJavaScript",
                  port: 0,
                  type: 5,
                  userId: this.options.proxyOptions.proxyUsername,
                  password: this.options.proxyOptions.proxyPassword
                }
              })).socket;
            } catch (err) {
              throw onerror(err);
            }
          }
          socket = tls.connect(socketOptions, () => {
            socket.write(message);
          });
          const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();
          abortListener = (0, utils_1.addAbortListener)(options?.signal, function() {
            destroySockets();
            rejectOnTlsSocketError(this.reason);
          });
          socket.once("error", (err) => rejectOnTlsSocketError(onerror(err))).once("close", () => rejectOnTlsSocketError(onclose())).on("data", (data) => {
            buffer.append(data);
            while (request.bytesNeeded > 0 && buffer.length) {
              const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
              request.addResponse(buffer.read(bytesNeeded));
            }
            if (request.bytesNeeded <= 0) {
              resolve();
            }
          });
          await (options?.timeoutContext?.csotEnabled() ? Promise.all([
            willResolveKmsRequest,
            timeout_1.Timeout.expires(options.timeoutContext?.remainingTimeMS)
          ]) : willResolveKmsRequest);
        } catch (error2) {
          if (error2 instanceof timeout_1.TimeoutError)
            throw new error_1.MongoOperationTimeoutError("KMS request timed out");
          throw error2;
        } finally {
          destroySockets();
          abortListener?.[utils_1.kDispose]();
        }
      }
      *requests(context, options) {
        for (let request = context.nextKMSRequest(); request != null; request = context.nextKMSRequest()) {
          yield this.kmsRequest(request, options);
        }
      }
      /**
       * Validates the provided TLS options are secure.
       *
       * @param kmsProvider - The KMS provider name.
       * @param tlsOptions - The client TLS options for the provider.
       *
       * @returns An error if any option is invalid.
       */
      validateTlsOptions(kmsProvider, tlsOptions) {
        const tlsOptionNames = Object.keys(tlsOptions);
        for (const option of INSECURE_TLS_OPTIONS) {
          if (tlsOptionNames.includes(option)) {
            return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
          }
        }
      }
      /**
       * Sets only the valid secure TLS options.
       *
       * @param tlsOptions - The client TLS options for the provider.
       * @param options - The existing connection options.
       */
      async setTlsOptions(tlsOptions, options) {
        if (tlsOptions.tlsCertificateKeyFile) {
          const cert = await fs2.readFile(tlsOptions.tlsCertificateKeyFile);
          options.cert = options.key = cert;
        }
        if (tlsOptions.tlsCAFile) {
          options.ca = await fs2.readFile(tlsOptions.tlsCAFile);
        }
        if (tlsOptions.tlsCertificateKeyFilePassword) {
          options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
        }
      }
      /**
       * Fetches collection info for a provided namespace, when libmongocrypt
       * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is
       * used to inform libmongocrypt of the schema associated with this
       * namespace. Exposed for testing purposes. Do not directly invoke.
       *
       * @param client - A MongoClient connected to the topology
       * @param ns - The namespace to list collections from
       * @param filter - A filter for the listCollections command
       * @param callback - Invoked with the info of the requested collection, or with an error
       */
      fetchCollectionInfo(client, ns, filter2, options) {
        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
        const cursor = client.db(db).listCollections(filter2, {
          promoteLongs: false,
          promoteValues: false,
          timeoutContext: options?.timeoutContext && new abstract_cursor_1.CursorTimeoutContext(options?.timeoutContext, Symbol()),
          signal: options?.signal,
          nameOnly: false
        });
        return cursor;
      }
      /**
       * Calls to the mongocryptd to provide markings for a command.
       * Exposed for testing purposes. Do not directly invoke.
       * @param client - A MongoClient connected to a mongocryptd
       * @param ns - The namespace (database.collection) the command is being executed on
       * @param command - The command to execute.
       * @param callback - Invoked with the serialized and marked bson command, or with an error
       */
      async markCommand(client, ns, command, options) {
        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
        const bsonOptions = { promoteLongs: false, promoteValues: false };
        const rawCommand = (0, bson_1.deserialize)(command, bsonOptions);
        const commandOptions = {
          timeoutMS: void 0,
          signal: void 0
        };
        if (options?.timeoutContext?.csotEnabled()) {
          commandOptions.timeoutMS = options.timeoutContext.remainingTimeMS;
        }
        if (options?.signal) {
          commandOptions.signal = options.signal;
        }
        const response = await client.db(db).command(rawCommand, {
          ...bsonOptions,
          ...commandOptions
        });
        return (0, bson_1.serialize)(response, this.bsonOptions);
      }
      /**
       * Requests keys from the keyVault collection on the topology.
       * Exposed for testing purposes. Do not directly invoke.
       * @param client - A MongoClient connected to the topology
       * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection
       * @param filter - The filter for the find query against the keyVault Collection
       * @param callback - Invoked with the found keys, or with an error
       */
      fetchKeys(client, keyVaultNamespace, filter2, options) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
        const commandOptions = {
          timeoutContext: void 0,
          signal: void 0
        };
        if (options?.timeoutContext != null) {
          commandOptions.timeoutContext = new abstract_cursor_1.CursorTimeoutContext(options.timeoutContext, Symbol());
        }
        if (options?.signal != null) {
          commandOptions.signal = options.signal;
        }
        return client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find((0, bson_1.deserialize)(filter2), commandOptions).toArray();
      }
    };
    exports.StateMachine = StateMachine;
  }
});

// node_modules/mongodb/lib/client-side-encryption/client_encryption.js
var require_client_encryption = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/client_encryption.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientEncryption = void 0;
    exports.autoSelectSocketOptions = autoSelectSocketOptions;
    var bson_1 = require_bson2();
    var deps_1 = require_deps();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var cryptoCallbacks = require_crypto_callbacks();
    var errors_1 = require_errors();
    var index_1 = require_providers2();
    var state_machine_1 = require_state_machine();
    var ClientEncryption = class _ClientEncryption {
      /** @internal */
      static getMongoCrypt() {
        const encryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in encryption) {
          throw encryption.kModuleError;
        }
        return encryption.MongoCrypt;
      }
      /**
       * Create a new encryption instance
       *
       * @example
       * ```ts
       * new ClientEncryption(mongoClient, {
       *   keyVaultNamespace: 'client.encryption',
       *   kmsProviders: {
       *     local: {
       *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer
       *     }
       *   }
       * });
       * ```
       *
       * @example
       * ```ts
       * new ClientEncryption(mongoClient, {
       *   keyVaultNamespace: 'client.encryption',
       *   kmsProviders: {
       *     aws: {
       *       accessKeyId: AWS_ACCESS_KEY,
       *       secretAccessKey: AWS_SECRET_KEY
       *     }
       *   }
       * });
       * ```
       */
      constructor(client, options) {
        this._client = client;
        this._proxyOptions = options.proxyOptions ?? {};
        this._tlsOptions = options.tlsOptions ?? {};
        this._kmsProviders = options.kmsProviders || {};
        const { timeoutMS } = (0, utils_1.resolveTimeoutOptions)(client, options);
        this._timeoutMS = timeoutMS;
        this._credentialProviders = options.credentialProviders;
        if (options.credentialProviders?.aws && !(0, index_1.isEmptyCredentials)("aws", this._kmsProviders)) {
          throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
        }
        if (options.keyVaultNamespace == null) {
          throw new errors_1.MongoCryptInvalidArgumentError("Missing required option `keyVaultNamespace`");
        }
        const mongoCryptOptions = {
          ...options,
          cryptoCallbacks,
          kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders
        };
        this._keyVaultNamespace = options.keyVaultNamespace;
        this._keyVaultClient = options.keyVaultClient || client;
        const MongoCrypt = _ClientEncryption.getMongoCrypt();
        this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
      }
      /**
       * Creates a data key used for explicit encryption and inserts it into the key vault namespace
       *
       * @example
       * ```ts
       * // Using async/await to create a local key
       * const dataKeyId = await clientEncryption.createDataKey('local');
       * ```
       *
       * @example
       * ```ts
       * // Using async/await to create an aws key
       * const dataKeyId = await clientEncryption.createDataKey('aws', {
       *   masterKey: {
       *     region: 'us-east-1',
       *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
       *   }
       * });
       * ```
       *
       * @example
       * ```ts
       * // Using async/await to create an aws key with a keyAltName
       * const dataKeyId = await clientEncryption.createDataKey('aws', {
       *   masterKey: {
       *     region: 'us-east-1',
       *     key: 'xxxxxxxxxxxxxx' // CMK ARN here
       *   },
       *   keyAltNames: [ 'mySpecialKey' ]
       * });
       * ```
       */
      async createDataKey(provider, options = {}) {
        if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {
          throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);
        }
        let keyAltNames = void 0;
        if (options.keyAltNames && options.keyAltNames.length > 0) {
          keyAltNames = options.keyAltNames.map((keyAltName, i) => {
            if (typeof keyAltName !== "string") {
              throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
            }
            return (0, bson_1.serialize)({ keyAltName });
          });
        }
        let keyMaterial = void 0;
        if (options.keyMaterial) {
          keyMaterial = (0, bson_1.serialize)({ keyMaterial: options.keyMaterial });
        }
        const dataKeyBson = (0, bson_1.serialize)({
          provider,
          ...options.masterKey
        });
        const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
          keyAltNames,
          keyMaterial
        });
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = options?.timeoutContext ?? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
        const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const { insertedId } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {
          writeConcern: { w: "majority" },
          timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : void 0
        });
        return insertedId;
      }
      /**
       * Searches the keyvault for any data keys matching the provided filter.  If there are matches, rewrapManyDataKey then attempts to re-wrap the data keys using the provided options.
       *
       * If no matches are found, then no bulk write is performed.
       *
       * @example
       * ```ts
       * // rewrapping all data data keys (using a filter that matches all documents)
       * const filter = {};
       *
       * const result = await clientEncryption.rewrapManyDataKey(filter);
       * if (result.bulkWriteResult != null) {
       *  // keys were re-wrapped, results will be available in the bulkWrite object.
       * }
       * ```
       *
       * @example
       * ```ts
       * // attempting to rewrap all data keys with no matches
       * const filter = { _id: new Binary() } // assume _id matches no documents in the database
       * const result = await clientEncryption.rewrapManyDataKey(filter);
       *
       * if (result.bulkWriteResult == null) {
       *  // no keys matched, `bulkWriteResult` does not exist on the result object
       * }
       * ```
       */
      async rewrapManyDataKey(filter2, options) {
        let keyEncryptionKeyBson = void 0;
        if (options) {
          const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);
          keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
        }
        const filterBson = (0, bson_1.serialize)(filter2);
        const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
        const { v: dataKeys } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        if (dataKeys.length === 0) {
          return {};
        }
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const replacements = dataKeys.map((key) => ({
          updateOne: {
            filter: { _id: key._id },
            update: {
              $set: {
                masterKey: key.masterKey,
                keyMaterial: key.keyMaterial
              },
              $currentDate: {
                updateDate: true
              }
            }
          }
        }));
        const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {
          writeConcern: { w: "majority" },
          timeoutMS: timeoutContext.csotEnabled() ? timeoutContext?.remainingTimeMS : void 0
        });
        return { bulkWriteResult: result };
      }
      /**
       * Deletes the key with the provided id from the keyvault, if it exists.
       *
       * @example
       * ```ts
       * // delete a key by _id
       * const id = new Binary(); // id is a bson binary subtype 4 object
       * const { deletedCount } = await clientEncryption.deleteKey(id);
       *
       * if (deletedCount != null && deletedCount > 0) {
       *   // successful deletion
       * }
       * ```
       *
       */
      async deleteKey(_id) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({ _id }, { writeConcern: { w: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds all the keys currently stored in the keyvault.
       *
       * This method will not throw.
       *
       * @returns a FindCursor over all keys in the keyvault.
       * @example
       * ```ts
       * // fetching all keys
       * const keys = await clientEncryption.getKeys().toArray();
       * ```
       */
      getKeys() {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return this._keyVaultClient.db(dbName).collection(collectionName).find({}, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds a key in the keyvault with the specified _id.
       *
       * Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // getting a key by id
       * const id = new Binary(); // id is a bson binary subtype 4 object
       * const key = await clientEncryption.getKey(id);
       * if (!key) {
       *  // key is null if there was no matching key
       * }
       * ```
       */
      async getKey(_id) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ _id }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Finds a key in the keyvault which has the specified keyAltName.
       *
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the keyAltName.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // get a key by alt name
       * const keyAltName = 'keyAltName';
       * const key = await clientEncryption.getKeyByAltName(keyAltName);
       * if (!key) {
       *  // key is null if there is no matching key
       * }
       * ```
       */
      async getKeyByAltName(keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ keyAltNames: keyAltName }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
      }
      /**
       * Adds a keyAltName to a key identified by the provided _id.
       *
       * This method resolves to/returns the *old* key value (prior to adding the new altKeyName).
       *
       * @param _id - The id of the document to update.
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // adding an keyAltName to a data key
       * const id = new Binary();  // id is a bson binary subtype 4 object
       * const keyAltName = 'keyAltName';
       * const oldKey = await clientEncryption.addKeyAltName(id, keyAltName);
       * if (!oldKey) {
       *  // null is returned if there is no matching document with an id matching the supplied id
       * }
       * ```
       */
      async addKeyAltName(_id, keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: "majority" }, returnDocument: "before", timeoutMS: this._timeoutMS });
        return value;
      }
      /**
       * Adds a keyAltName to a key identified by the provided _id.
       *
       * This method resolves to/returns the *old* key value (prior to removing the new altKeyName).
       *
       * If the removed keyAltName is the last keyAltName for that key, the `altKeyNames` property is unset from the document.
       *
       * @param _id - The id of the document to update.
       * @param keyAltName - a keyAltName to search for a key
       * @returns Returns a promise that either resolves to a {@link DataKey} if a document matches the key or null if no documents
       * match the id.  The promise rejects with an error if an error is thrown.
       * @example
       * ```ts
       * // removing a key alt name from a data key
       * const id = new Binary();  // id is a bson binary subtype 4 object
       * const keyAltName = 'keyAltName';
       * const oldKey = await clientEncryption.removeKeyAltName(id, keyAltName);
       *
       * if (!oldKey) {
       *  // null is returned if there is no matching document with an id matching the supplied id
       * }
       * ```
       */
      async removeKeyAltName(_id, keyAltName) {
        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
        const pipeline = [
          {
            $set: {
              keyAltNames: {
                $cond: [
                  {
                    $eq: ["$keyAltNames", [keyAltName]]
                  },
                  "$$REMOVE",
                  {
                    $filter: {
                      input: "$keyAltNames",
                      cond: {
                        $ne: ["$$this", keyAltName]
                      }
                    }
                  }
                ]
              }
            }
          }
        ];
        const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, pipeline, {
          writeConcern: { w: "majority" },
          returnDocument: "before",
          timeoutMS: this._timeoutMS
        });
        return value;
      }
      /**
       * A convenience method for creating an encrypted collection.
       * This method will create data keys for any encryptedFields that do not have a `keyId` defined
       * and then create a new collection with the full set of encryptedFields.
       *
       * @param db - A Node.js driver Db object with which to create the collection
       * @param name - The name of the collection to be created
       * @param options - Options for createDataKey and for createCollection
       * @returns created collection and generated encryptedFields
       * @throws MongoCryptCreateDataKeyError - If part way through the process a createDataKey invocation fails, an error will be rejected that has the partial `encryptedFields` that were created.
       * @throws MongoCryptCreateEncryptedCollectionError - If creating the collection fails, an error will be rejected that has the entire `encryptedFields` that were created.
       */
      async createEncryptedCollection(db, name, options) {
        const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options;
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        if (Array.isArray(encryptedFields.fields)) {
          const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== "object" || field.keyId != null ? field : {
            ...field,
            keyId: await this.createDataKey(provider, {
              masterKey,
              // clone the timeoutContext
              // in order to avoid sharing the same timeout for server selection and connection checkout across different concurrent operations
              timeoutContext: timeoutContext?.csotEnabled() ? timeoutContext?.clone() : void 0
            })
          });
          const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
          encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === "fulfilled" ? resolution.value : encryptedFields.fields[index]);
          const rejection = createDataKeyResolutions.find((result) => result.status === "rejected");
          if (rejection != null) {
            throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
          }
        }
        try {
          const collection = await db.createCollection(name, {
            ...createCollectionOptions,
            encryptedFields,
            timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : void 0
          });
          return { collection, encryptedFields };
        } catch (cause) {
          throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
        }
      }
      /**
       * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
       * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
       *
       * @param value - The value that you wish to serialize. Must be of a type that can be serialized into BSON
       * @param options -
       * @returns a Promise that either resolves with the encrypted value, or rejects with an error.
       *
       * @example
       * ```ts
       * // Encryption with async/await api
       * async function encryptMyData(value) {
       *   const keyId = await clientEncryption.createDataKey('local');
       *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
       * }
       * ```
       *
       * @example
       * ```ts
       * // Encryption using a keyAltName
       * async function encryptMyData(value) {
       *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });
       *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });
       * }
       * ```
       */
      async encrypt(value, options) {
        return await this._encrypt(value, false, options);
      }
      /**
       * Encrypts a Match Expression or Aggregate Expression to query a range index.
       *
       * Only supported when queryType is "range" and algorithm is "Range".
       *
       * @param expression - a BSON document of one of the following forms:
       *  1. A Match Expression of this form:
       *      `{$and: [{<field>: {$gt: <value1>}}, {<field>: {$lt: <value2> }}]}`
       *  2. An Aggregate Expression of this form:
       *      `{$and: [{$gt: [<fieldpath>, <value1>]}, {$lt: [<fieldpath>, <value2>]}]}`
       *
       *    `$gt` may also be `$gte`. `$lt` may also be `$lte`.
       *
       * @param options -
       * @returns Returns a Promise that either resolves with the encrypted value or rejects with an error.
       */
      async encryptExpression(expression, options) {
        return await this._encrypt(expression, true, options);
      }
      /**
       * Explicitly decrypt a provided encrypted value
       *
       * @param value - An encrypted value
       * @returns a Promise that either resolves with the decrypted value, or rejects with an error
       *
       * @example
       * ```ts
       * // Decrypting value with async/await API
       * async function decryptMyValue(value) {
       *   return clientEncryption.decrypt(value);
       * }
       * ```
       */
      async decrypt(value) {
        const valueBuffer = (0, bson_1.serialize)({ v: value });
        const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        return v;
      }
      /**
       * @internal
       * Ask the user for KMS credentials.
       *
       * This returns anything that looks like the kmsProviders original input
       * option. It can be empty, and any provider specified here will override
       * the original ones.
       */
      async askForKMSCredentials() {
        return await (0, index_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
      }
      static get libmongocryptVersion() {
        return _ClientEncryption.getMongoCrypt().libmongocryptVersion;
      }
      /**
       * @internal
       * A helper that perform explicit encryption of values and expressions.
       * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must
       * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.
       *
       * @param value - The value that you wish to encrypt. Must be of a type that can be serialized into BSON
       * @param expressionMode - a boolean that indicates whether or not to encrypt the value as an expression
       * @param options - options to pass to encrypt
       * @returns the raw result of the call to stateMachine.execute().  When expressionMode is set to true, the return
       *          value will be a bson document.  When false, the value will be a BSON Binary.
       *
       */
      async _encrypt(value, expressionMode, options) {
        const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;
        const contextOptions = {
          expressionMode,
          algorithm
        };
        if (keyId) {
          contextOptions.keyId = keyId.buffer;
        }
        if (keyAltName) {
          if (keyId) {
            throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
          }
          if (typeof keyAltName !== "string") {
            throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
          }
          contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
        }
        if (typeof contentionFactor === "number" || typeof contentionFactor === "bigint") {
          contextOptions.contentionFactor = contentionFactor;
        }
        if (typeof queryType === "string") {
          contextOptions.queryType = queryType;
        }
        if (typeof rangeOptions === "object") {
          contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
        }
        const valueBuffer = (0, bson_1.serialize)({ v: value });
        const stateMachine = new state_machine_1.StateMachine({
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: autoSelectSocketOptions(this._client.s.options)
        });
        const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
        const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : void 0;
        const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
        return v;
      }
    };
    exports.ClientEncryption = ClientEncryption;
    function autoSelectSocketOptions(baseOptions) {
      const options = { autoSelectFamily: true };
      if ("autoSelectFamily" in baseOptions) {
        options.autoSelectFamily = baseOptions.autoSelectFamily;
      }
      if ("autoSelectFamilyAttemptTimeout" in baseOptions) {
        options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;
      }
      return options;
    }
  }
});

// node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js
var require_mongocryptd_manager = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongocryptdManager = void 0;
    var error_1 = require_error();
    var MongocryptdManager = class _MongocryptdManager {
      constructor(extraOptions = {}) {
        this.spawnPath = "";
        this.spawnArgs = [];
        this.uri = typeof extraOptions.mongocryptdURI === "string" && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : _MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        if (Object.hasOwn(extraOptions, "mongocryptdSpawnPath") && extraOptions.mongocryptdSpawnPath) {
          this.spawnPath = extraOptions.mongocryptdSpawnPath;
        }
        if (Object.hasOwn(extraOptions, "mongocryptdSpawnArgs") && Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", "60");
        }
      }
      /**
       * Will check to see if a mongocryptd is up. If it is not up, it will attempt
       * to spawn a mongocryptd in a detached process, and then wait for it to be up.
       */
      async spawn() {
        const cmdName = this.spawnPath || "mongocryptd";
        const { spawn } = __require("child_process");
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
      }
      /**
       * @returns the result of `fn` or rejects with an error.
       */
      async withRespawn(fn) {
        try {
          const result2 = await fn();
          return result2;
        } catch (err) {
          const shouldSpawn = err instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
          if (!shouldSpawn) {
            throw err;
          }
        }
        await this.spawn();
        const result = await fn();
        return result;
      }
    };
    exports.MongocryptdManager = MongocryptdManager;
    MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = "mongodb://localhost:27020";
  }
});

// node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js
var require_auto_encrypter = __commonJS({
  "node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;
    var net = __require("net");
    var bson_1 = require_bson2();
    var constants_1 = require_constants2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var utils_1 = require_utils();
    var client_encryption_1 = require_client_encryption();
    var cryptoCallbacks = require_crypto_callbacks();
    var errors_1 = require_errors();
    var mongocryptd_manager_1 = require_mongocryptd_manager();
    var providers_1 = require_providers2();
    var state_machine_1 = require_state_machine();
    exports.AutoEncryptionLoggerLevel = Object.freeze({
      FatalError: 0,
      Error: 1,
      Warning: 2,
      Info: 3,
      Trace: 4
    });
    var AutoEncrypter = class _AutoEncrypter {
      /** @internal */
      static getMongoCrypt() {
        const encryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in encryption) {
          throw encryption.kModuleError;
        }
        return encryption.MongoCrypt;
      }
      /**
       * Create an AutoEncrypter
       *
       * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient
       *
       * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.
       * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.
       * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.
       * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.
       *
       * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>
       * ```ts
       * // Enabling autoEncryption via a MongoClient using mongocryptd
       * const { MongoClient } = require('mongodb');
       * const client = new MongoClient(URL, {
       *   autoEncryption: {
       *     kmsProviders: {
       *       aws: {
       *         accessKeyId: AWS_ACCESS_KEY,
       *         secretAccessKey: AWS_SECRET_KEY
       *       }
       *     }
       *   }
       * });
       * ```
       *
       * await client.connect();
       * // From here on, the client will be encrypting / decrypting automatically
       * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>
       * ```ts
       * // Enabling autoEncryption via a MongoClient using CSFLE shared library
       * const { MongoClient } = require('mongodb');
       * const client = new MongoClient(URL, {
       *   autoEncryption: {
       *     kmsProviders: {
       *       aws: {}
       *     },
       *     extraOptions: {
       *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',
       *       cryptSharedLibRequired: true
       *     }
       *   }
       * });
       * ```
       *
       * await client.connect();
       * // From here on, the client will be encrypting / decrypting automatically
       */
      constructor(client, options) {
        this[_a] = false;
        this._client = client;
        this._bypassEncryption = options.bypassAutoEncryption === true;
        this._keyVaultNamespace = options.keyVaultNamespace || "admin.datakeys";
        this._keyVaultClient = options.keyVaultClient || client;
        this._metaDataClient = options.metadataClient || client;
        this._proxyOptions = options.proxyOptions || {};
        this._tlsOptions = options.tlsOptions || {};
        this._kmsProviders = options.kmsProviders || {};
        this._credentialProviders = options.credentialProviders;
        if (options.credentialProviders?.aws && !(0, providers_1.isEmptyCredentials)("aws", this._kmsProviders)) {
          throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
        }
        const mongoCryptOptions = {
          enableMultipleCollinfo: true,
          cryptoCallbacks
        };
        if (options.schemaMap) {
          mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);
        }
        if (options.encryptedFieldsMap) {
          mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);
        }
        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;
        if (options.options?.logger) {
          mongoCryptOptions.logger = options.options.logger;
        }
        if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
          mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
        }
        if (options.bypassQueryAnalysis) {
          mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
        }
        this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
        if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
          mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
        } else if (!this._bypassMongocryptdAndCryptShared) {
          mongoCryptOptions.cryptSharedLibSearchPaths = ["$SYSTEM"];
        }
        const MongoCrypt = _AutoEncrypter.getMongoCrypt();
        this._mongocrypt = new MongoCrypt(mongoCryptOptions);
        this._contextCounter = 0;
        if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {
          throw new errors_1.MongoCryptInvalidArgumentError("`cryptSharedLibRequired` set but no crypt_shared library loaded");
        }
        if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
          this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
          const clientOptions = {
            serverSelectionTimeoutMS: 1e4
          };
          if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== "string") && !net.getDefaultAutoSelectFamily) {
            clientOptions.family = 4;
          }
          if (net.getDefaultAutoSelectFamily) {
            Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));
          }
          this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
        }
      }
      /**
       * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.
       *
       * This function is a no-op when bypassSpawn is set or the crypt shared library is used.
       */
      async init() {
        if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
          return;
        }
        if (!this._mongocryptdManager) {
          throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.");
        }
        if (!this._mongocryptdClient) {
          throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.");
        }
        if (!this._mongocryptdManager.bypassSpawn) {
          await this._mongocryptdManager.spawn();
        }
        try {
          const client = await this._mongocryptdClient.connect();
          return client;
        } catch (error2) {
          throw new error_1.MongoRuntimeError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn", { cause: error2 });
        }
      }
      /**
       * Cleans up the `_mongocryptdClient`, if present.
       */
      async teardown(force) {
        await this._mongocryptdClient?.close(force);
      }
      /**
       * Encrypt a command for a given namespace.
       */
      async encrypt(ns, cmd, options = {}) {
        options.signal?.throwIfAborted();
        if (this._bypassEncryption) {
          return cmd;
        }
        const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);
        const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
        context.id = this._contextCounter++;
        context.ns = ns;
        context.document = cmd;
        const stateMachine = new state_machine_1.StateMachine({
          promoteValues: false,
          promoteLongs: false,
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
        });
        return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options), {
          promoteValues: false,
          promoteLongs: false
        });
      }
      /**
       * Decrypt a command response
       */
      async decrypt(response, options = {}) {
        options.signal?.throwIfAborted();
        const context = this._mongocrypt.makeDecryptionContext(response);
        context.id = this._contextCounter++;
        const stateMachine = new state_machine_1.StateMachine({
          ...options,
          proxyOptions: this._proxyOptions,
          tlsOptions: this._tlsOptions,
          socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
        });
        return await stateMachine.execute(this, context, options);
      }
      /**
       * Ask the user for KMS credentials.
       *
       * This returns anything that looks like the kmsProviders original input
       * option. It can be empty, and any provider specified here will override
       * the original ones.
       */
      async askForKMSCredentials() {
        return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
      }
      /**
       * Return the current libmongocrypt's CSFLE shared library version
       * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE
       * shared library was loaded.
       */
      get cryptSharedLibVersionInfo() {
        return this._mongocrypt.cryptSharedLibVersionInfo;
      }
      static get libmongocryptVersion() {
        return _AutoEncrypter.getMongoCrypt().libmongocryptVersion;
      }
    };
    exports.AutoEncrypter = AutoEncrypter;
    _a = constants_1.kDecorateResult;
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encrypter = void 0;
    var util_1 = __require("util");
    var auto_encrypter_1 = require_auto_encrypter();
    var constants_1 = require_constants2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var Encrypter = class {
      constructor(client, uri, options) {
        if (typeof options.autoEncryption !== "object") {
          throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
        }
        this.internalClient = null;
        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = client;
        } else if (options.autoEncryption.keyVaultClient == null) {
          options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
        }
        if (this.bypassAutoEncryption) {
          options.autoEncryption.metadataClient = void 0;
        } else if (options.maxPoolSize === 0) {
          options.autoEncryption.metadataClient = client;
        } else {
          options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
        }
        if (options.proxyHost) {
          options.autoEncryption.proxyOptions = {
            proxyHost: options.proxyHost,
            proxyPort: options.proxyPort,
            proxyUsername: options.proxyUsername,
            proxyPassword: options.proxyPassword
          };
        }
        this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
      }
      getInternalClient(client, uri, options) {
        let internalClient = this.internalClient;
        if (internalClient == null) {
          const clonedOptions = {};
          for (const key of [
            ...Object.getOwnPropertyNames(options),
            ...Object.getOwnPropertySymbols(options)
          ]) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
              continue;
            Reflect.set(clonedOptions, key, Reflect.get(options, key));
          }
          clonedOptions.minPoolSize = 0;
          internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
          this.internalClient = internalClient;
          for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
            for (const listener of client.listeners(eventName)) {
              internalClient.on(eventName, listener);
            }
          }
          client.on("newListener", (eventName, listener) => {
            internalClient?.on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return internalClient;
      }
      async connectInternalClient() {
        const internalClient = this.internalClient;
        if (this.needsConnecting && internalClient != null) {
          this.needsConnecting = false;
          await internalClient.connect();
        }
      }
      closeCallback(client, force, callback) {
        (0, util_1.callbackify)(this.close.bind(this))(client, force, callback);
      }
      async close(client, force) {
        let error2;
        try {
          await this.autoEncrypter.teardown(force);
        } catch (autoEncrypterError) {
          error2 = autoEncrypterError;
        }
        const internalClient = this.internalClient;
        if (internalClient != null && client !== internalClient) {
          return await internalClient.close(force);
        }
        if (error2 != null) {
          throw error2;
        }
      }
      static checkForMongoCrypt() {
        const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
        if ("kModuleError" in mongodbClientEncryption) {
          throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project", {
            cause: mongodbClientEncryption["kModuleError"],
            dependencyName: "mongodb-client-encryption"
          });
        }
      }
    };
    exports.Encrypter = Encrypter;
  }
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS({
  "node_modules/mongodb/lib/cmap/metrics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionPoolMetrics = void 0;
    var ConnectionPoolMetrics = class _ConnectionPoolMetrics {
      constructor() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
      /**
       * Mark a connection as pinned for a specific operation.
       */
      markPinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections += 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections += 1;
        } else {
          this.otherConnections += 1;
        }
      }
      /**
       * Unmark a connection as pinned for an operation.
       */
      markUnpinned(pinType) {
        if (pinType === _ConnectionPoolMetrics.TXN) {
          this.txnConnections -= 1;
        } else if (pinType === _ConnectionPoolMetrics.CURSOR) {
          this.cursorConnections -= 1;
        } else {
          this.otherConnections -= 1;
        }
      }
      /**
       * Return information about the cmap metrics as a string.
       */
      info(maxPoolSize) {
        return `Timed out while checking out a connection from connection pool: maxPoolSize: ${maxPoolSize}, connections in use by cursors: ${this.cursorConnections}, connections in use by transactions: ${this.txnConnections}, connections in use by other operations: ${this.otherConnections}`;
      }
      /**
       * Reset the metrics to the initial values.
       */
      reset() {
        this.txnConnections = 0;
        this.cursorConnections = 0;
        this.otherConnections = 0;
      }
    };
    exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
    ConnectionPoolMetrics.TXN = "txn";
    ConnectionPoolMetrics.CURSOR = "cursor";
    ConnectionPoolMetrics.OTHER = "other";
  }
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/sdam/server_description.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerDescription = void 0;
    exports.parseServerType = parseServerType;
    exports.compareTopologyVersion = compareTopologyVersion;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var common_1 = require_common();
    var WRITABLE_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.Standalone,
      common_1.ServerType.Mongos,
      common_1.ServerType.LoadBalancer
    ]);
    var DATA_BEARING_SERVER_TYPES = /* @__PURE__ */ new Set([
      common_1.ServerType.RSPrimary,
      common_1.ServerType.RSSecondary,
      common_1.ServerType.Mongos,
      common_1.ServerType.Standalone,
      common_1.ServerType.LoadBalancer
    ]);
    var ServerDescription = class {
      /**
       * Create a ServerDescription
       * @internal
       *
       * @param address - The address of the server
       * @param hello - An optional hello response for this server
       */
      constructor(address, hello, options = {}) {
        if (address == null || address === "") {
          throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
        }
        this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
        this.type = parseServerType(hello, options);
        this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
        this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
        this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
        this.tags = hello?.tags ?? {};
        this.minWireVersion = hello?.minWireVersion ?? 0;
        this.maxWireVersion = hello?.maxWireVersion ?? 0;
        this.roundTripTime = options?.roundTripTime ?? -1;
        this.minRoundTripTime = options?.minRoundTripTime ?? 0;
        this.lastUpdateTime = (0, utils_1.now)();
        this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
        this.error = options.error ?? null;
        this.error?.stack;
        this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
        this.setName = hello?.setName ?? null;
        this.setVersion = hello?.setVersion ?? null;
        this.electionId = hello?.electionId ?? null;
        this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
        this.maxMessageSizeBytes = hello?.maxMessageSizeBytes ?? null;
        this.maxWriteBatchSize = hello?.maxWriteBatchSize ?? null;
        this.maxBsonObjectSize = hello?.maxBsonObjectSize ?? null;
        this.primary = hello?.primary ?? null;
        this.me = hello?.me?.toLowerCase() ?? null;
        this.$clusterTime = hello?.$clusterTime ?? null;
        this.iscryptd = Boolean(hello?.iscryptd);
      }
      get hostAddress() {
        return utils_1.HostAddress.fromString(this.address);
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      /** Is this server available for reads*/
      get isReadable() {
        return this.type === common_1.ServerType.RSSecondary || this.isWritable;
      }
      /** Is this server data bearing */
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      /** Is this server available for writes */
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port = this.address.split(":").pop();
        return port ? Number.parseInt(port, 10) : 27017;
      }
      /**
       * Determines if another `ServerDescription` is equal to this one per the rules defined in the SDAM specification.
       * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.md
       */
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
        const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
        return other != null && other.iscryptd === this.iscryptd && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    exports.ServerDescription = ServerDescription;
    function parseServerType(hello, options) {
      if (options?.loadBalanced) {
        return common_1.ServerType.LoadBalancer;
      }
      if (!hello || !hello.ok) {
        return common_1.ServerType.Unknown;
      }
      if (hello.isreplicaset) {
        return common_1.ServerType.RSGhost;
      }
      if (hello.msg && hello.msg === "isdbgrid") {
        return common_1.ServerType.Mongos;
      }
      if (hello.setName) {
        if (hello.hidden) {
          return common_1.ServerType.RSOther;
        } else if (hello.isWritablePrimary) {
          return common_1.ServerType.RSPrimary;
        } else if (hello.secondary) {
          return common_1.ServerType.RSSecondary;
        } else if (hello.arbiterOnly) {
          return common_1.ServerType.RSArbiter;
        } else {
          return common_1.ServerType.RSOther;
        }
      }
      return common_1.ServerType.Standalone;
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function compareTopologyVersion(currentTv, newTv) {
      if (currentTv == null || newTv == null) {
        return -1;
      }
      if (!currentTv.processId.equals(newTv.processId)) {
        return -1;
      }
      const currentCounter = typeof currentTv.counter === "bigint" ? bson_1.Long.fromBigInt(currentTv.counter) : bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
      const newCounter = typeof newTv.counter === "bigint" ? bson_1.Long.fromBigInt(newTv.counter) : bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
      return currentCounter.compare(newCounter);
    }
  }
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/sdam/topology_description.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TopologyDescription = void 0;
    var bson_1 = require_bson2();
    var WIRE_CONSTANTS = require_constants();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var common_1 = require_common();
    var server_description_1 = require_server_description();
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MONGOS_OR_UNKNOWN = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
    var MONGOS_OR_STANDALONE = /* @__PURE__ */ new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
    var NON_PRIMARY_RS_MEMBERS = /* @__PURE__ */ new Set([
      common_1.ServerType.RSSecondary,
      common_1.ServerType.RSArbiter,
      common_1.ServerType.RSOther
    ]);
    var TopologyDescription = class _TopologyDescription {
      /**
       * Create a TopologyDescription
       */
      constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
        options = options ?? {};
        this.type = topologyType ?? common_1.TopologyType.Unknown;
        this.servers = serverDescriptions ?? /* @__PURE__ */ new Map();
        this.stale = false;
        this.compatible = true;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
        this.localThresholdMS = options.localThresholdMS ?? 15;
        this.setName = setName ?? null;
        this.maxElectionId = maxElectionId ?? null;
        this.maxSetVersion = maxSetVersion ?? null;
        this.commonWireVersion = commonWireVersion ?? 0;
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
            continue;
          }
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const [, server2] of this.servers) {
          if (server2.isReadable) {
            if (server2.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server2.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server2.logicalSessionTimeoutMinutes);
          }
        }
      }
      /**
       * Returns a new TopologyDescription based on the SrvPollingEvent
       * @internal
       */
      updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
        const incomingHostnames = ev.hostnames();
        const currentHostnames = new Set(this.servers.keys());
        const hostnamesToAdd = new Set(incomingHostnames);
        const hostnamesToRemove = /* @__PURE__ */ new Set();
        for (const hostname of currentHostnames) {
          hostnamesToAdd.delete(hostname);
          if (!incomingHostnames.has(hostname)) {
            hostnamesToRemove.add(hostname);
          }
        }
        if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
          return this;
        }
        const serverDescriptions = new Map(this.servers);
        for (const removedHost of hostnamesToRemove) {
          serverDescriptions.delete(removedHost);
        }
        if (hostnamesToAdd.size > 0) {
          if (srvMaxHosts === 0) {
            for (const hostToAdd of hostnamesToAdd) {
              serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
            }
          } else if (serverDescriptions.size < srvMaxHosts) {
            const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
            for (const selectedHostToAdd of selectedHosts) {
              serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
            }
          }
        }
        return new _TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      /**
       * Returns a copy of this description updated with a given ServerDescription
       * @internal
       */
      update(serverDescription) {
        const address = serverDescription.address;
        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
        const serverType = serverDescription.type;
        const serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
          if (topologyType === common_1.TopologyType.Single) {
            serverDescription = new server_description_1.ServerDescription(address);
          } else {
            serverDescriptions.delete(address);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === common_1.TopologyType.Single) {
          return new _TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
        }
        if (topologyType === common_1.TopologyType.Unknown) {
          if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === common_1.TopologyType.Sharded) {
          if (!MONGOS_OR_UNKNOWN.has(serverType)) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
          }
          if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
            topologyType = result[0];
            setName = result[1];
          }
        }
        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
          if (MONGOS_OR_STANDALONE.has(serverType)) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === common_1.ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
            topologyType = result[0];
            setName = result[1];
            maxSetVersion = result[2];
            maxElectionId = result[3];
          } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new _TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return null;
      }
      /**
       * Determines if the topology description has any known servers
       */
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
      }
      /**
       * Determines if this topology description has a data-bearing server available.
       */
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      /**
       * Determines if the topology has a definition for the provided address
       * @internal
       */
      hasServer(address) {
        return this.servers.has(address);
      }
      /**
       * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily
       * intended for use with JSON.stringify().
       *
       * This method will not throw.
       */
      toJSON() {
        return bson_1.EJSON.serialize(this);
      }
    };
    exports.TopologyDescription = TopologyDescription;
    function topologyTypeForServerType(serverType) {
      switch (serverType) {
        case common_1.ServerType.Standalone:
          return common_1.TopologyType.Single;
        case common_1.ServerType.Mongos:
          return common_1.TopologyType.Sharded;
        case common_1.ServerType.RSPrimary:
          return common_1.TopologyType.ReplicaSetWithPrimary;
        case common_1.ServerType.RSOther:
        case common_1.ServerType.RSSecondary:
          return common_1.TopologyType.ReplicaSetNoPrimary;
        default:
          return common_1.TopologyType.Unknown;
      }
    }
    function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
      const setVersionElectionIdMismatch = (serverDescription2, maxSetVersion2, maxElectionId2) => {
        return `primary marked stale due to electionId/setVersion mismatch: server setVersion: ${serverDescription2.setVersion}, server electionId: ${serverDescription2.electionId}, topology setVersion: ${maxSetVersion2}, topology electionId: ${maxElectionId2}`;
      };
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      if (serverDescription.maxWireVersion >= 17) {
        const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
        const maxElectionIdIsEqual = electionIdComparison === 0;
        const maxElectionIdIsLess = electionIdComparison === -1;
        const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
        if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
          maxElectionId = serverDescription.electionId;
          maxSetVersion = serverDescription.setVersion;
        } else {
          serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, void 0, {
            error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
          }));
          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
        }
      } else {
        const electionId = serverDescription.electionId ? serverDescription.electionId : null;
        if (serverDescription.setVersion && electionId) {
          if (maxSetVersion && maxElectionId) {
            if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
              serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, void 0, {
                error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
              }));
              return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
            }
          }
          maxElectionId = serverDescription.electionId;
        }
        if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
          maxSetVersion = serverDescription.setVersion;
        }
      }
      for (const [address, server2] of serverDescriptions) {
        if (server2.type === common_1.ServerType.RSPrimary && server2.address !== serverDescription.address) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(server2.address, void 0, {
            error: new error_1.MongoStalePrimaryError("primary marked stale due to discovery of newer primary")
          }));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      if (setName == null) {
        throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
      const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
      setName = setName ?? serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new server_description_1.ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const serverDescription of serverDescriptions.values()) {
        if (serverDescription.type === common_1.ServerType.RSPrimary) {
          return common_1.TopologyType.ReplicaSetWithPrimary;
        }
      }
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/shared.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getReadPreference = getReadPreference;
    exports.isSharded = isSharded;
    var error_1 = require_error();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var topology_description_1 = require_topology_description();
    function getReadPreference(options) {
      let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
      if (typeof readPreference === "string") {
        readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      }
      if (!(readPreference instanceof read_preference_1.ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
      }
      return readPreference;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer == null) {
        return false;
      }
      if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server2) => server2.type === common_1.ServerType.Mongos);
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/transactions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = exports.TxnState = void 0;
    exports.isTransactionCommand = isTransactionCommand;
    var error_1 = require_error();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var write_concern_1 = require_write_concern();
    exports.TxnState = Object.freeze({
      NO_TRANSACTION: "NO_TRANSACTION",
      STARTING_TRANSACTION: "STARTING_TRANSACTION",
      TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
      TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
      TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
      TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
    });
    var stateMachine = {
      [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
      [exports.TxnState.STARTING_TRANSACTION]: [
        exports.TxnState.TRANSACTION_IN_PROGRESS,
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.TRANSACTION_ABORTED
      ],
      [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
        exports.TxnState.TRANSACTION_IN_PROGRESS,
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_ABORTED
      ],
      [exports.TxnState.TRANSACTION_COMMITTED]: [
        exports.TxnState.TRANSACTION_COMMITTED,
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.STARTING_TRANSACTION,
        exports.TxnState.NO_TRANSACTION
      ],
      [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
      [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
        exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
        exports.TxnState.NO_TRANSACTION
      ]
    };
    var ACTIVE_STATES = /* @__PURE__ */ new Set([
      exports.TxnState.STARTING_TRANSACTION,
      exports.TxnState.TRANSACTION_IN_PROGRESS
    ]);
    var COMMITTED_STATES = /* @__PURE__ */ new Set([
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.TRANSACTION_ABORTED
    ]);
    var Transaction2 = class {
      /** Create a transaction @internal */
      constructor(options) {
        options = options ?? {};
        this.state = exports.TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (writeConcern) {
          if (writeConcern.w === 0) {
            throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options.readConcern) {
          this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        }
        if (options.readPreference) {
          this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
        }
        if (options.maxCommitTimeMS) {
          this.options.maxTimeMS = options.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      /** @internal */
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      /** @returns Whether the transaction has started */
      get isStarting() {
        return this.state === exports.TxnState.STARTING_TRANSACTION;
      }
      /**
       * @returns Whether this session is presently in a transaction
       */
      get isActive() {
        return ACTIVE_STATES.has(this.state);
      }
      get isCommitted() {
        return COMMITTED_STATES.has(this.state);
      }
      /**
       * Transition the transaction in the state machine
       * @internal
       * @param nextState - The new state to transition to
       */
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.includes(nextState)) {
          this.state = nextState;
          if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
            this.unpinServer();
          }
          return;
        }
        throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      /** @internal */
      pinServer(server2) {
        if (this.isActive) {
          this._pinnedServer = server2;
        }
      }
      /** @internal */
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    exports.Transaction = Transaction2;
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
  }
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerSessionPool = exports.ServerSession = exports.ClientSession = void 0;
    exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
    exports.applySession = applySession;
    exports.updateSessionFromResponse = updateSessionFromResponse;
    var bson_1 = require_bson2();
    var metrics_1 = require_metrics();
    var shared_1 = require_shared();
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var run_command_1 = require_run_command();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var common_1 = require_common();
    var timeout_1 = require_timeout();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var minWireVersionForShardedTransactions = 8;
    var ClientSession = class _ClientSession extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a client session.
       * @internal
       * @param client - The current client
       * @param sessionPool - The server session pool (Internal Class)
       * @param options - Optional settings
       * @param clientOptions - Optional settings provided when creating a MongoClient
       */
      constructor(client, sessionPool, options, clientOptions) {
        super();
        this.timeoutContext = null;
        this.on("error", utils_1.noop);
        if (client == null) {
          throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
        }
        options = options ?? {};
        this.snapshotEnabled = options.snapshot === true;
        if (options.causalConsistency === true && this.snapshotEnabled) {
          throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
        }
        this.client = client;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;
        this.explicit = !!options.explicit;
        this._serverSession = this.explicit ? this.sessionPool.acquire() : null;
        this.txnNumberIncrement = 0;
        const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
        this.supports = {
          // if we can enable causal consistency, do so by default
          causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
        };
        this.clusterTime = options.initialClusterTime;
        this.operationTime = void 0;
        this.owner = options.owner;
        this.defaultTransactionOptions = { ...options.defaultTransactionOptions };
        this.transaction = new transactions_1.Transaction();
      }
      /** The server id associated with this session */
      get id() {
        return this.serverSession?.id;
      }
      get serverSession() {
        let serverSession = this._serverSession;
        if (serverSession == null) {
          if (this.explicit) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
          }
          if (this.hasEnded) {
            throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
          }
          serverSession = this.sessionPool.acquire();
          this._serverSession = serverSession;
        }
        return serverSession;
      }
      get loadBalanced() {
        return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
      }
      /** @internal */
      pin(conn) {
        if (this.pinnedConnection) {
          throw TypeError("Cannot pin multiple connections to the same session");
        }
        this.pinnedConnection = conn;
        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
      }
      /** @internal */
      unpin(options) {
        if (this.loadBalanced) {
          return maybeClearPinnedConnection(this, options);
        }
        this.transaction.unpinServer();
      }
      get isPinned() {
        return this.loadBalanced ? !!this.pinnedConnection : this.transaction.isPinned;
      }
      /**
       * Frees any client-side resources held by the current session.  If a session is in a transaction,
       * the transaction is aborted.
       *
       * Does not end the session on the server.
       *
       * @param options - Optional settings. Currently reserved for future use
       */
      async endSession(options) {
        try {
          if (this.inTransaction()) {
            await this.abortTransaction({ ...options, throwTimeout: true });
          }
        } catch (error2) {
          if (error2.name === "MongoOperationTimeoutError")
            throw error2;
          (0, utils_1.squashError)(error2);
        } finally {
          if (!this.hasEnded) {
            const serverSession = this.serverSession;
            if (serverSession != null) {
              this.sessionPool.release(serverSession);
              this._serverSession = new ServerSession(serverSession);
            }
            this.hasEnded = true;
            this.emit("ended", this);
          }
          maybeClearPinnedConnection(this, { force: true, ...options });
        }
      }
      /** @internal */
      async asyncDispose() {
        await this.endSession({ force: true });
      }
      /**
       * Advances the operationTime for a ClientSession.
       *
       * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
       */
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      /**
       * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
       *
       * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
       */
      advanceClusterTime(clusterTime) {
        if (!clusterTime || typeof clusterTime !== "object") {
          throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
        }
        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
          throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
        }
        if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
          throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
        }
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      /**
       * Used to determine if this session equals another
       *
       * @param session - The session to compare to
       */
      equals(session) {
        if (!(session instanceof _ClientSession)) {
          return false;
        }
        if (this.id == null || session.id == null) {
          return false;
        }
        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
      }
      /**
       * Increment the transaction number on the internal ServerSession
       *
       * @privateRemarks
       * This helper increments a value stored on the client session that will be
       * added to the serverSession's txnNumber upon applying it to a command.
       * This is because the serverSession is lazily acquired after a connection is obtained
       */
      incrementTransactionNumber() {
        this.txnNumberIncrement += 1;
      }
      /** @returns whether this session is currently in a transaction or not */
      inTransaction() {
        return this.transaction.isActive;
      }
      /**
       * Starts a new transaction with the given options.
       *
       * @remarks
       * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
       * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
       * undefined behaviour.
       *
       * @param options - Options for the transaction
       */
      startTransaction(options) {
        if (this.snapshotEnabled) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
        }
        if (this.inTransaction()) {
          throw new error_1.MongoTransactionError("Transaction already in progress");
        }
        if (this.isPinned && this.transaction.isCommitted) {
          this.unpin();
        }
        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
        if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.commitAttempted = false;
        this.incrementTransactionNumber();
        this.transaction = new transactions_1.Transaction({
          readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
          writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
          readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
          maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
        });
        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
      }
      /**
       * Commits the currently active transaction in this session.
       *
       * @param options - Optional options, can be used to override `defaultTimeoutMS`.
       */
      async commitTransaction(options) {
        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
          throw new error_1.MongoTransactionError("No transaction started");
        }
        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
          return;
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
          throw new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction");
        }
        const command = { commitTransaction: 1 };
        const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
        if (wc != null) {
          if (timeoutMS == null && this.timeoutContext == null) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
          } else {
            const wcKeys = Object.keys(wc);
            if (wcKeys.length > 2 || !wcKeys.includes("wtimeoutMS") && !wcKeys.includes("wTimeoutMS"))
              write_concern_1.WriteConcern.apply(command, { ...wc, wtimeoutMS: void 0 });
          }
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {
          if (timeoutMS == null && this.timeoutContext == null) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
          } else {
            write_concern_1.WriteConcern.apply(command, { w: "majority", ...wc, wtimeoutMS: void 0 });
          }
        }
        if (typeof this.transaction.options.maxTimeMS === "number") {
          command.maxTimeMS = this.transaction.options.maxTimeMS;
        }
        if (this.transaction.recoveryToken) {
          command.recoveryToken = this.transaction.recoveryToken;
        }
        const operation = new run_command_1.RunAdminCommandOperation(command, {
          session: this,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        });
        const timeoutContext = this.timeoutContext ?? (typeof timeoutMS === "number" ? timeout_1.TimeoutContext.create({
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS,
          timeoutMS
        }) : null);
        try {
          await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
          this.commitAttempted = void 0;
          return;
        } catch (firstCommitError) {
          this.commitAttempted = true;
          if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {
            write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
            this.unpin({ force: true });
            try {
              await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunAdminCommandOperation(command, {
                session: this,
                readPreference: read_preference_1.ReadPreference.primary,
                bypassPinningCheck: true
              }), timeoutContext);
              return;
            } catch (retryCommitError) {
              if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {
                retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
              }
              if (shouldUnpinAfterCommitError(retryCommitError)) {
                this.unpin({ error: retryCommitError });
              }
              throw retryCommitError;
            }
          }
          if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {
            firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
          }
          if (shouldUnpinAfterCommitError(firstCommitError)) {
            this.unpin({ error: firstCommitError });
          }
          throw firstCommitError;
        } finally {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
        }
      }
      async abortTransaction(options) {
        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
          throw new error_1.MongoTransactionError("No transaction started");
        }
        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          return;
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
          throw new error_1.MongoTransactionError("Cannot call abortTransaction twice");
        }
        if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
          throw new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction");
        }
        const command = { abortTransaction: 1 };
        const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : this.timeoutContext?.csotEnabled() ? this.timeoutContext.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
        const timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
          timeoutMS,
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS
        }) : null;
        const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
        if (wc != null && timeoutMS == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
        }
        if (this.transaction.recoveryToken) {
          command.recoveryToken = this.transaction.recoveryToken;
        }
        const operation = new run_command_1.RunAdminCommandOperation(command, {
          session: this,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        });
        try {
          await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
          this.unpin();
          return;
        } catch (firstAbortError) {
          this.unpin();
          if (firstAbortError.name === "MongoRuntimeError")
            throw firstAbortError;
          if (options?.throwTimeout && firstAbortError.name === "MongoOperationTimeoutError") {
            throw firstAbortError;
          }
          if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {
            try {
              await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
              return;
            } catch (secondAbortError) {
              if (secondAbortError.name === "MongoRuntimeError")
                throw secondAbortError;
              if (options?.throwTimeout && secondAbortError.name === "MongoOperationTimeoutError") {
                throw secondAbortError;
              }
            }
          }
        } finally {
          this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
          if (this.loadBalanced) {
            maybeClearPinnedConnection(this, { force: false });
          }
        }
      }
      /**
       * This is here to ensure that ClientSession is never serialized to BSON.
       */
      toBSON() {
        throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
      }
      /**
       * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.
       *
       * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.
       *
       * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,
       * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is
       * undefined behaviour.
       *
       * **IMPORTANT:** When running an operation inside a `withTransaction` callback, if it is not
       * provided the explicit session in its options, it will not be part of the transaction and it will not respect timeoutMS.
       *
       *
       * @remarks
       * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.
       * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.
       *   - If the transaction is manually aborted within the provided function it will not throw.
       * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.
       *
       * Checkout a descriptive example here:
       * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions
       *
       * If a command inside withTransaction fails:
       * - It may cause the transaction on the server to be aborted.
       * - This situation is normally handled transparently by the driver.
       * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.
       * - The driver will then retry the transaction indefinitely.
       *
       * To avoid this situation, the application must not silently handle errors within the provided function.
       * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.
       *
       * @param fn - callback to run within a transaction
       * @param options - optional settings for the transaction
       * @returns A raw command response or undefined
       */
      async withTransaction(fn, options) {
        const MAX_TIMEOUT = 12e4;
        const timeoutMS = options?.timeoutMS ?? this.timeoutMS ?? null;
        this.timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
          timeoutMS,
          serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
          socketTimeoutMS: this.clientOptions.socketTimeoutMS
        }) : null;
        const startTime = this.timeoutContext?.csotEnabled() ? this.timeoutContext.start : (0, utils_1.now)();
        let committed = false;
        let result;
        try {
          while (!committed) {
            this.startTransaction(options);
            try {
              const promise = fn(this);
              if (!(0, utils_1.isPromiseLike)(promise)) {
                throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
              }
              result = await promise;
              if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
                return result;
              }
            } catch (fnError) {
              if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {
                await this.abortTransaction();
                throw fnError;
              }
              if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {
                await this.abortTransaction();
              }
              if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                continue;
              }
              throw fnError;
            }
            while (!committed) {
              try {
                await this.commitTransaction();
                committed = true;
              } catch (commitError) {
                if (!isMaxTimeMSExpiredError(commitError) && commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                  continue;
                }
                if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                  break;
                }
                throw commitError;
              }
            }
          }
          return result;
        } finally {
          this.timeoutContext = null;
        }
      }
    };
    exports.ClientSession = ClientSession;
    (0, resource_management_1.configureResourceManagement)(ClientSession.prototype);
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = /* @__PURE__ */ new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function shouldUnpinAfterCommitError(commitError) {
      if (commitError instanceof error_1.MongoError) {
        if ((0, error_1.isRetryableWriteError)(commitError) || commitError instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(commitError)) {
          if (isUnknownTransactionCommitResult(commitError)) {
            return true;
          }
        } else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          return true;
        }
      }
      return false;
    }
    function shouldAddUnknownTransactionCommitResultLabel(commitError) {
      let ok = (0, error_1.isRetryableWriteError)(commitError);
      ok || (ok = commitError instanceof error_1.MongoWriteConcernError);
      ok || (ok = isMaxTimeMSExpiredError(commitError));
      ok && (ok = isUnknownTransactionCommitResult(commitError));
      return ok;
    }
    function isUnknownTransactionCommitResult(err) {
      const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
      return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
    }
    function maybeClearPinnedConnection(session, options) {
      const conn = session.pinnedConnection;
      const error2 = options?.error;
      if (session.inTransaction() && error2 && error2 instanceof error_1.MongoError && error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return;
      }
      const topology = session.client.topology;
      if (conn && topology != null) {
        const servers = Array.from(topology.s.servers.values());
        const loadBalancer = servers[0];
        if (options?.error == null || options?.force) {
          loadBalancer.pool.checkIn(conn);
          session.pinnedConnection = void 0;
          conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
          if (options?.forceClear) {
            loadBalancer.pool.clear({ serviceId: conn.serviceId });
          }
        }
      }
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null || !(err instanceof error_1.MongoServerError)) {
        return false;
      }
      return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
    }
    var ServerSession = class {
      /** @internal */
      constructor(cloned) {
        if (cloned != null) {
          const idBytes = Buffer.allocUnsafe(16);
          idBytes.set(cloned.id.id.buffer);
          this.id = { id: new bson_1.Binary(idBytes, cloned.id.id.sub_type) };
          this.lastUse = cloned.lastUse;
          this.txnNumber = cloned.txnNumber;
          this.isDirty = cloned.isDirty;
          return;
        }
        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
        this.lastUse = (0, utils_1.now)();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      /**
       * Determines if the server session has timed out.
       *
       * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
       */
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    exports.ServerSession = ServerSession;
    var ServerSessionPool = class {
      constructor(client) {
        if (client == null) {
          throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
        }
        this.client = client;
        this.sessions = new utils_1.List();
      }
      /**
       * Acquire a Server Session from the pool.
       * Iterates through each session in the pool, removing any stale sessions
       * along the way. The first non-stale session found is removed from the
       * pool and returned. If no non-stale session is found, a new ServerSession is created.
       */
      acquire() {
        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
        let session = null;
        while (this.sessions.length > 0) {
          const potentialSession = this.sessions.shift();
          if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
            session = potentialSession;
            break;
          }
        }
        if (session == null) {
          session = new ServerSession();
        }
        return session;
      }
      /**
       * Release a session to the session pool
       * Adds the session back to the session pool if the session has not timed out yet.
       * This method also removes any stale sessions from the pool.
       *
       * @param session - The session to release to the pool
       */
      release(session) {
        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
        if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
          this.sessions.unshift(session);
        }
        if (!sessionTimeoutMinutes) {
          return;
        }
        this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    exports.ServerSessionPool = ServerSessionPool;
    function applySession(session, command, options) {
      if (session.hasEnded) {
        return new error_1.MongoExpiredSessionError();
      }
      const serverSession = session.serverSession;
      if (serverSession == null) {
        return new error_1.MongoRuntimeError("Unable to acquire server session");
      }
      if (options.writeConcern?.w === 0) {
        if (session && session.explicit) {
          return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
        }
        return;
      }
      serverSession.lastUse = (0, utils_1.now)();
      command.lsid = serverSession.id;
      const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
      const isRetryableWrite = !!options.willRetryWrite;
      if (isRetryableWrite || inTxnOrTxnCommand) {
        serverSession.txnNumber += session.txnNumberIncrement;
        session.txnNumberIncrement = 0;
        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTxnOrTxnCommand) {
        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
          session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        } else if (session.snapshotEnabled) {
          command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
          if (session.snapshotTime != null) {
            Object.assign(command.readConcern, { atClusterTime: session.snapshotTime });
          }
        }
        return;
      }
      command.autocommit = false;
      if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
      return;
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
      if (session?.snapshotEnabled && session.snapshotTime == null) {
        const atClusterTime = document2.atClusterTime;
        if (atClusterTime) {
          session.snapshotTime = atClusterTime;
        }
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS({
  "node_modules/mongodb/lib/cmap/command_monitoring_events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    var commands_1 = require_commands();
    var CommandStartedEvent = class {
      /**
       * Create a started event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       */
      constructor(connection, command, serverConnectionId) {
        this.name = constants_1.COMMAND_STARTED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        if (exports.SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.databaseName = command.databaseName;
        this.commandName = commandName;
        this.command = maybeRedact(commandName, cmd, cmd);
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports.CommandStartedEvent = CommandStartedEvent;
    var CommandSucceededEvent = class {
      /**
       * Create a succeeded event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param reply - the reply for this command from the server
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, reply, started, serverConnectionId) {
        this.name = constants_1.COMMAND_SUCCEEDED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.reply = maybeRedact(commandName, cmd, extractReply(reply));
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports.CommandSucceededEvent = CommandSucceededEvent;
    var CommandFailedEvent = class {
      /**
       * Create a failure event
       *
       * @internal
       * @param pool - the pool that originated the command
       * @param command - the command
       * @param error - the generated error or a server error response
       * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration
       */
      constructor(connection, command, error2, started, serverConnectionId) {
        this.name = constants_1.COMMAND_FAILED;
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const { address, connectionId, serviceId } = extractConnectionDetails(connection);
        this.address = address;
        this.connectionId = connectionId;
        this.serviceId = serviceId;
        this.requestId = command.requestId;
        this.commandName = commandName;
        this.duration = (0, utils_1.calculateDurationInMs)(started);
        this.failure = maybeRedact(commandName, cmd, error2);
        this.serverConnectionId = serverConnectionId;
      }
      /* @internal */
      get hasServiceId() {
        return !!this.serviceId;
      }
    };
    exports.CommandFailedEvent = CommandFailedEvent;
    exports.SENSITIVE_COMMANDS = /* @__PURE__ */ new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var HELLO_COMMANDS = /* @__PURE__ */ new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var collectionName = (command) => command.ns.split(".")[1];
    var maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldSelector: "projection"
    };
    function extractCommand(command) {
      if (command instanceof commands_1.OpMsgRequest) {
        const cmd = { ...command.command };
        if (cmd.ops instanceof commands_1.DocumentSequence) {
          cmd.ops = cmd.ops.documents;
        }
        if (cmd.nsInfo instanceof commands_1.DocumentSequence) {
          cmd.nsInfo = cmd.nsInfo.documents;
        }
        return cmd;
      }
      if (command.query?.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (command.query[key] != null) {
              result[LEGACY_FIND_QUERY_MAP[key]] = { ...command.query[key] };
            }
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          const legacyKey = key;
          if (command[legacyKey] != null) {
            result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = command[legacyKey];
          }
        });
        return result;
      }
      let clonedQuery = {};
      const clonedCommand = { ...command };
      if (command.query) {
        clonedQuery = { ...command.query };
        clonedCommand.query = clonedQuery;
      }
      return command.query ? clonedQuery : clonedCommand;
    }
    function extractReply(reply) {
      if (!reply) {
        return reply;
      }
      return reply.result ? reply.result : reply;
    }
    function extractConnectionDetails(connection) {
      let connectionId;
      if ("id" in connection) {
        connectionId = connection.id;
      }
      return {
        address: connection.address,
        serviceId: connection.serviceId,
        connectionId
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamDescription = void 0;
    var bson_1 = require_bson2();
    var common_1 = require_common();
    var server_description_1 = require_server_description();
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "logicalSessionTimeoutMinutes"
    ];
    var StreamDescription = class {
      constructor(address, options) {
        this.hello = null;
        this.address = address;
        this.type = common_1.ServerType.Unknown;
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
        this.loadBalanced = !!options?.loadBalanced;
        this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
        this.serverConnectionId = null;
      }
      receiveResponse(response) {
        if (response == null) {
          return;
        }
        this.hello = response;
        this.type = (0, server_description_1.parseServerType)(response);
        if ("connectionId" in response) {
          this.serverConnectionId = this.parseServerConnectionID(response.connectionId);
        } else {
          this.serverConnectionId = null;
        }
        for (const field of RESPONSE_FIELDS) {
          if (response[field] != null) {
            this[field] = response[field];
          }
          if ("__nodejs_mock_server__" in response) {
            this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
          }
        }
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression?.includes(c))[0];
        }
      }
      /* @internal */
      parseServerConnectionID(serverConnectionId) {
        return bson_1.Long.isLong(serverConnectionId) ? serverConnectionId.toBigInt() : (
          // @ts-expect-error: Doubles are coercible to number
          BigInt(serverConnectionId)
        );
      }
    };
    exports.StreamDescription = StreamDescription;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_data.js
var require_on_data = __commonJS({
  "node_modules/mongodb/lib/cmap/wire_protocol/on_data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onData = onData;
    var utils_1 = require_utils();
    function onData(emitter, { timeoutContext, signal }) {
      signal?.throwIfAborted();
      const unconsumedEvents = new utils_1.List();
      const unconsumedPromises = new utils_1.List();
      let error2 = null;
      let finished = false;
      const iterator2 = {
        next() {
          const value = unconsumedEvents.shift();
          if (value != null) {
            return Promise.resolve({ value, done: false });
          }
          if (error2 != null) {
            const p = Promise.reject(error2);
            error2 = null;
            return p;
          }
          if (finished)
            return closeHandler();
          const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
          unconsumedPromises.push({ resolve, reject });
          return promise;
        },
        return() {
          return closeHandler();
        },
        throw(err) {
          errorHandler(err);
          return Promise.resolve({ value: void 0, done: true });
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
      emitter.on("data", eventHandler);
      emitter.on("error", errorHandler);
      const abortListener = (0, utils_1.addAbortListener)(signal, function() {
        errorHandler(this.reason);
      });
      const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;
      timeoutForSocketRead?.throwIfExpired();
      timeoutForSocketRead?.then(void 0, errorHandler);
      return iterator2;
      function eventHandler(value) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
          promise.resolve({ value, done: false });
        else
          unconsumedEvents.push(value);
      }
      function errorHandler(err) {
        const promise = unconsumedPromises.shift();
        if (promise != null)
          promise.reject(err);
        else
          error2 = err;
        void closeHandler();
      }
      function closeHandler() {
        emitter.off("data", eventHandler);
        emitter.off("error", errorHandler);
        abortListener?.[utils_1.kDispose]();
        finished = true;
        timeoutForSocketRead?.clear();
        const doneResult = { value: void 0, done: finished };
        for (const promise of unconsumedPromises) {
          promise.resolve(doneResult);
        }
        return Promise.resolve(doneResult);
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CryptoConnection = exports.SizedMessageTransform = exports.Connection = void 0;
    exports.hasSessionSupport = hasSessionSupport;
    var stream_1 = __require("stream");
    var timers_1 = __require("timers");
    var bson_1 = require_bson2();
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var common_1 = require_common();
    var sessions_1 = require_sessions();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var command_monitoring_events_1 = require_command_monitoring_events();
    var commands_1 = require_commands();
    var stream_description_1 = require_stream_description();
    var compression_1 = require_compression();
    var on_data_1 = require_on_data();
    var responses_1 = require_responses();
    var shared_1 = require_shared();
    function hasSessionSupport(conn) {
      const description = conn.description;
      return description.logicalSessionTimeoutMinutes != null;
    }
    function streamIdentifier(stream4, options) {
      if (options.proxyHost) {
        return options.hostAddress.toString();
      }
      const { remoteAddress, remotePort } = stream4;
      if (typeof remoteAddress === "string" && typeof remotePort === "number") {
        return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
      }
      return (0, utils_1.uuidV4)().toString("hex");
    }
    var Connection = class _Connection extends mongo_types_1.TypedEventEmitter {
      constructor(stream4, options) {
        super();
        this.lastHelloMS = -1;
        this.helloOk = false;
        this.delayedTimeoutId = null;
        this.closed = false;
        this.clusterTime = null;
        this.error = null;
        this.dataEvents = null;
        this.on("error", utils_1.noop);
        this.socket = stream4;
        this.id = options.id;
        this.address = streamIdentifier(stream4, options);
        this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
        this.monitorCommands = options.monitorCommands;
        this.serverApi = options.serverApi;
        this.mongoLogger = options.mongoLogger;
        this.established = false;
        this.description = new stream_description_1.StreamDescription(this.address, options);
        this.generation = options.generation;
        this.lastUseTime = (0, utils_1.now)();
        this.messageStream = this.socket.on("error", this.onError.bind(this)).pipe(new SizedMessageTransform({ connection: this })).on("error", this.onError.bind(this));
        this.socket.on("close", this.onClose.bind(this));
        this.socket.on("timeout", this.onTimeout.bind(this));
        this.messageStream.pause();
      }
      get hello() {
        return this.description.hello;
      }
      // the `connect` method stores the result of the handshake hello on the connection
      set hello(response) {
        this.description.receiveResponse(response);
        Object.freeze(this.description);
      }
      get serviceId() {
        return this.hello?.serviceId;
      }
      get loadBalanced() {
        return this.description.loadBalanced;
      }
      get idleTime() {
        return (0, utils_1.calculateDurationInMs)(this.lastUseTime);
      }
      get hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      get supportsOpMsg() {
        return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;
      }
      get shouldEmitAndLogCommand() {
        return (this.monitorCommands || this.established && !this.authContext?.reauthenticating && this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG)) ?? false;
      }
      markAvailable() {
        this.lastUseTime = (0, utils_1.now)();
      }
      onError(error2) {
        this.cleanup(error2);
      }
      onClose() {
        const message = `connection ${this.id} to ${this.address} closed`;
        this.cleanup(new error_1.MongoNetworkError(message));
      }
      onTimeout() {
        this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {
          const message = `connection ${this.id} to ${this.address} timed out`;
          const beforeHandshake = this.hello == null;
          this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
        }, 1).unref();
      }
      destroy() {
        if (this.closed) {
          return;
        }
        this.removeAllListeners(_Connection.PINNED);
        this.removeAllListeners(_Connection.UNPINNED);
        const message = `connection ${this.id} to ${this.address} closed`;
        this.cleanup(new error_1.MongoNetworkError(message));
      }
      /**
       * A method that cleans up the connection.  When `force` is true, this method
       * forcibly destroys the socket.
       *
       * If an error is provided, any in-flight operations will be closed with the error.
       *
       * This method does nothing if the connection is already closed.
       */
      cleanup(error2) {
        if (this.closed) {
          return;
        }
        this.socket.destroy();
        this.error = error2;
        this.dataEvents?.throw(error2).then(void 0, utils_1.squashError);
        this.closed = true;
        this.emit(_Connection.CLOSE);
      }
      prepareCommand(db, command, options) {
        let cmd = { ...command };
        const readPreference = (0, shared_1.getReadPreference)(options);
        const session = options?.session;
        let clusterTime = this.clusterTime;
        if (this.serverApi) {
          const { version, strict, deprecationErrors } = this.serverApi;
          cmd.apiVersion = version;
          if (strict != null)
            cmd.apiStrict = strict;
          if (deprecationErrors != null)
            cmd.apiDeprecationErrors = deprecationErrors;
        }
        if (this.hasSessionSupport && session) {
          if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
            clusterTime = session.clusterTime;
          }
          const sessionError = (0, sessions_1.applySession)(session, cmd, options);
          if (sessionError)
            throw sessionError;
        } else if (session?.explicit) {
          throw new error_1.MongoCompatibilityError("Current topology does not support sessions");
        }
        if (clusterTime) {
          cmd.$clusterTime = clusterTime;
        }
        if (this.description.type !== common_1.ServerType.Standalone) {
          if (!(0, shared_1.isSharded)(this) && !this.description.loadBalanced && this.supportsOpMsg && options.directConnection === true && readPreference?.mode === "primary") {
            cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();
          } else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== "primary") {
            cmd = {
              $query: cmd,
              $readPreference: readPreference.toJSON()
            };
          } else if (readPreference?.mode !== "primary") {
            cmd.$readPreference = readPreference.toJSON();
          }
        }
        const commandOptions = {
          numberToSkip: 0,
          numberToReturn: -1,
          checkKeys: false,
          // This value is not overridable
          secondaryOk: readPreference.secondaryOk(),
          ...options
        };
        options.timeoutContext?.addMaxTimeMSToCommand(cmd, options);
        const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(db, cmd, commandOptions) : new commands_1.OpQueryRequest(db, cmd, commandOptions);
        return message;
      }
      async *sendWire(message, options, responseType) {
        this.throwIfAborted();
        const timeout = options.socketTimeoutMS ?? options?.timeoutContext?.getSocketTimeoutMS() ?? this.socketTimeoutMS;
        this.socket.setTimeout(timeout);
        try {
          await this.writeCommand(message, {
            agreedCompressor: this.description.compressor ?? "none",
            zlibCompressionLevel: this.description.zlibCompressionLevel,
            timeoutContext: options.timeoutContext,
            signal: options.signal
          });
          if (options.noResponse || message.moreToCome) {
            yield responses_1.MongoDBResponse.empty;
            return;
          }
          this.throwIfAborted();
          if (options.timeoutContext?.csotEnabled() && options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
            throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
          }
          for await (const response of this.readMany(options)) {
            this.socket.setTimeout(0);
            const bson = response.parse();
            const document2 = (responseType ?? responses_1.MongoDBResponse).make(bson);
            yield document2;
            this.throwIfAborted();
            this.socket.setTimeout(timeout);
          }
        } finally {
          this.socket.setTimeout(0);
        }
      }
      async *sendCommand(ns, command, options, responseType) {
        options?.signal?.throwIfAborted();
        const message = this.prepareCommand(ns.db, command, options);
        let started = 0;
        if (this.shouldEmitAndLogCommand) {
          started = (0, utils_1.now)();
          this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));
        }
        const bsonOptions = options.documentsReturnedIn == null || !options.raw ? options : {
          ...options,
          raw: false,
          fieldsAsRaw: { [options.documentsReturnedIn]: true }
        };
        let document2 = void 0;
        let object = void 0;
        try {
          this.throwIfAborted();
          for await (document2 of this.sendWire(message, options, responseType)) {
            object = void 0;
            if (options.session != null) {
              (0, sessions_1.updateSessionFromResponse)(options.session, document2);
            }
            if (document2.$clusterTime) {
              this.clusterTime = document2.$clusterTime;
              this.emit(_Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
            }
            if (document2.ok === 0) {
              if (options.timeoutContext?.csotEnabled() && document2.isMaxTimeExpiredError) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(object ?? (object = document2.toObject(bsonOptions)))
                });
              }
              throw new error_1.MongoServerError(object ?? (object = document2.toObject(bsonOptions)));
            }
            if (this.shouldEmitAndLogCommand) {
              this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? void 0 : message.moreToCome ? { ok: 1 } : object ?? (object = document2.toObject(bsonOptions)), started, this.description.serverConnectionId));
            }
            if (responseType == null) {
              yield object ?? (object = document2.toObject(bsonOptions));
            } else {
              yield document2;
            }
            this.throwIfAborted();
          }
        } catch (error2) {
          if (this.shouldEmitAndLogCommand) {
            this.emitAndLogCommand(this.monitorCommands, _Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error2, started, this.description.serverConnectionId));
          }
          throw error2;
        }
      }
      async command(ns, command, options = {}, responseType) {
        this.throwIfAborted();
        options.signal?.throwIfAborted();
        for await (const document2 of this.sendCommand(ns, command, options, responseType)) {
          if (options.timeoutContext?.csotEnabled()) {
            if (responses_1.MongoDBResponse.is(document2)) {
              if (document2.isMaxTimeExpiredError) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(document2.toObject())
                });
              }
            } else {
              if (Array.isArray(document2?.writeErrors) && document2.writeErrors.some((error2) => error2?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) || document2?.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) {
                throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                  cause: new error_1.MongoServerError(document2)
                });
              }
            }
          }
          return document2;
        }
        throw new error_1.MongoUnexpectedServerResponseError("Unable to get response from server");
      }
      exhaustCommand(ns, command, options, replyListener) {
        const exhaustLoop = async () => {
          this.throwIfAborted();
          for await (const reply of this.sendCommand(ns, command, options)) {
            replyListener(void 0, reply);
            this.throwIfAborted();
          }
          throw new error_1.MongoUnexpectedServerResponseError("Server ended moreToCome unexpectedly");
        };
        exhaustLoop().then(void 0, replyListener);
      }
      throwIfAborted() {
        if (this.error)
          throw this.error;
      }
      /**
       * @internal
       *
       * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method
       * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).
       */
      async writeCommand(command, options) {
        const finalCommand = options.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
          agreedCompressor: options.agreedCompressor ?? "none",
          zlibCompressionLevel: options.zlibCompressionLevel ?? 0
        });
        const buffer = Buffer.concat(await finalCommand.toBin());
        if (options.timeoutContext?.csotEnabled()) {
          if (options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
            throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
          }
        }
        if (this.socket.write(buffer))
          return;
        const drainEvent = (0, utils_1.once)(this.socket, "drain", options);
        const timeout = options?.timeoutContext?.timeoutForSocketWrite;
        const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;
        try {
          return await drained;
        } catch (writeError) {
          if (timeout_1.TimeoutError.is(writeError)) {
            const timeoutError = new error_1.MongoOperationTimeoutError("Timed out at socket write");
            this.onError(timeoutError);
            throw timeoutError;
          } else if (writeError === options.signal?.reason) {
            this.onError(writeError);
          }
          throw writeError;
        } finally {
          timeout?.clear();
        }
      }
      /**
       * @internal
       *
       * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function
       * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request
       * by calling `return` on the generator.
       *
       * Note that `for-await` loops call `return` automatically when the loop is exited.
       */
      async *readMany(options) {
        try {
          this.dataEvents = (0, on_data_1.onData)(this.messageStream, options);
          this.messageStream.resume();
          for await (const message of this.dataEvents) {
            const response = await (0, compression_1.decompressResponse)(message);
            yield response;
            if (!response.moreToCome) {
              return;
            }
          }
        } catch (readError) {
          if (timeout_1.TimeoutError.is(readError)) {
            const timeoutError = new error_1.MongoOperationTimeoutError(`Timed out during socket read (${readError.duration}ms)`);
            this.dataEvents = null;
            this.onError(timeoutError);
            throw timeoutError;
          } else if (readError === options.signal?.reason) {
            this.onError(readError);
          }
          throw readError;
        } finally {
          this.dataEvents = null;
          this.messageStream.pause();
          this.throwIfAborted();
        }
      }
    };
    exports.Connection = Connection;
    Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
    Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
    Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
    Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
    Connection.CLOSE = constants_1.CLOSE;
    Connection.PINNED = constants_1.PINNED;
    Connection.UNPINNED = constants_1.UNPINNED;
    var SizedMessageTransform = class extends stream_1.Transform {
      constructor({ connection }) {
        super({ writableObjectMode: false, readableObjectMode: true });
        this.bufferPool = new utils_1.BufferPool();
        this.connection = connection;
      }
      _transform(chunk, encoding, callback) {
        if (this.connection.delayedTimeoutId != null) {
          (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);
          this.connection.delayedTimeoutId = null;
        }
        this.bufferPool.append(chunk);
        while (this.bufferPool.length) {
          const sizeOfMessage = this.bufferPool.getInt32();
          if (sizeOfMessage == null) {
            break;
          }
          if (sizeOfMessage < 0) {
            return callback(new error_1.MongoParseError(`Message size cannot be negative: ${sizeOfMessage}`));
          }
          if (sizeOfMessage > this.bufferPool.length) {
            break;
          }
          const message = this.bufferPool.read(sizeOfMessage);
          if (!this.push(message)) {
            return callback(new error_1.MongoRuntimeError(`SizedMessageTransform does not support backpressure`));
          }
        }
        callback();
      }
    };
    exports.SizedMessageTransform = SizedMessageTransform;
    var CryptoConnection = class extends Connection {
      constructor(stream4, options) {
        super(stream4, options);
        this.autoEncrypter = options.autoEncrypter;
      }
      async command(ns, cmd, options, responseType) {
        const { autoEncrypter } = this;
        if (!autoEncrypter) {
          throw new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption", {
            dependencyName: "n/a"
          });
        }
        const serverWireVersion = (0, utils_1.maxWireVersion)(this);
        if (serverWireVersion === 0) {
          return await super.command(ns, cmd, options, responseType);
        }
        if (serverWireVersion < 8) {
          throw new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2");
        }
        const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
        const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
        const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);
        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }
        if (indexKeys != null && cmd.createIndexes) {
          for (const [offset, index] of indexKeys.entries()) {
            encrypted.indexes[offset].key = index;
          }
        }
        const encryptedResponse = await super.command(
          ns,
          encrypted,
          options,
          // Eventually we want to require `responseType` which means we would satisfy `T` as the return type.
          // In the meantime, we want encryptedResponse to always be _at least_ a MongoDBResponse if not a more specific subclass
          // So that we can ensure we have access to the on-demand APIs for decorate response
          responseType ?? responses_1.MongoDBResponse
        );
        const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);
        const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options);
        if (autoEncrypter[constants_1.kDecorateResult]) {
          if (responseType == null) {
            (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);
          } else if (decryptedResponse instanceof responses_1.CursorResponse) {
            decryptedResponse.encryptedResponse = encryptedResponse;
          }
        }
        return decryptedResponse;
      }
    };
    exports.CryptoConnection = CryptoConnection;
  }
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/cmap/connect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = void 0;
    exports.connect = connect;
    exports.makeConnection = makeConnection;
    exports.performInitialHandshake = performInitialHandshake;
    exports.prepareHandshakeDocument = prepareHandshakeDocument;
    exports.makeSocket = makeSocket;
    var net = __require("net");
    var tls = __require("tls");
    var constants_1 = require_constants2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    var providers_1 = require_providers();
    var connection_1 = require_connection();
    var constants_2 = require_constants();
    async function connect(options) {
      let connection = null;
      try {
        const socket = await makeSocket(options);
        connection = makeConnection(options, socket);
        await performInitialHandshake(connection, options);
        return connection;
      } catch (error2) {
        connection?.destroy();
        throw error2;
      }
    }
    function makeConnection(options, socket) {
      let ConnectionType = options.connectionType ?? connection_1.Connection;
      if (options.autoEncrypter) {
        ConnectionType = connection_1.CryptoConnection;
      }
      return new ConnectionType(socket, options);
    }
    function checkSupportedServer(hello, options) {
      const maxWireVersion = Number(hello.maxWireVersion);
      const minWireVersion = Number(hello.minWireVersion);
      const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
        return new error_1.MongoCompatibilityError(message2);
      }
      const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message);
    }
    async function performInitialHandshake(conn, options) {
      const credentials = options.credentials;
      if (credentials) {
        if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
          throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
        }
      }
      const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
      conn.authContext = authContext;
      const handshakeDoc = await prepareHandshakeDocument(authContext);
      const handshakeOptions = { ...options, raw: false };
      if (typeof options.connectTimeoutMS === "number") {
        handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
      }
      const start = (/* @__PURE__ */ new Date()).getTime();
      const response = await executeHandshake(handshakeDoc, handshakeOptions);
      if (!("isWritablePrimary" in response)) {
        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
      }
      if (response.helloOk) {
        conn.helloOk = true;
      }
      const supportedServerErr = checkSupportedServer(response, options);
      if (supportedServerErr) {
        throw supportedServerErr;
      }
      if (options.loadBalanced) {
        if (!response.serviceId) {
          throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, but the server does not support this mode.");
        }
      }
      conn.hello = response;
      conn.lastHelloMS = (/* @__PURE__ */ new Date()).getTime() - start;
      if (!response.arbiterOnly && credentials) {
        authContext.response = response;
        const resolvedCredentials = credentials.resolveAuthMechanism(response);
        const provider = options.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
        }
        try {
          await provider.auth(authContext);
        } catch (error2) {
          if (error2 instanceof error_1.MongoError) {
            error2.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
            if ((0, error_1.needsRetryableWriteLabel)(error2, response.maxWireVersion, conn.description.type)) {
              error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
            }
          }
          throw error2;
        }
      }
      conn.established = true;
      async function executeHandshake(handshakeDoc2, handshakeOptions2) {
        try {
          const handshakeResponse = await conn.command((0, utils_1.ns)("admin.$cmd"), handshakeDoc2, handshakeOptions2);
          return handshakeResponse;
        } catch (error2) {
          if (error2 instanceof error_1.MongoError) {
            error2.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          }
          throw error2;
        }
      }
    }
    async function prepareHandshakeDocument(authContext) {
      const options = authContext.options;
      const compressors = options.compressors ? options.compressors : [];
      const { serverApi } = authContext.connection;
      const clientMetadata = await options.extendedMetadata;
      const handshakeDoc = {
        [serverApi?.version || options.loadBalanced === true ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        helloOk: true,
        client: clientMetadata,
        compression: compressors
      };
      if (options.loadBalanced === true) {
        handshakeDoc.loadBalanced = true;
      }
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
          handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
          const provider2 = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
          if (!provider2) {
            throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
          }
          return await provider2.prepare(handshakeDoc, authContext);
        }
        const provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
        }
        return await provider.prepare(handshakeDoc, authContext);
      }
      return handshakeDoc;
    }
    exports.LEGAL_TLS_SOCKET_OPTIONS = [
      "allowPartialTrustChain",
      "ALPNProtocols",
      "ca",
      "cert",
      "checkServerIdentity",
      "ciphers",
      "crl",
      "ecdhCurve",
      "key",
      "minDHSize",
      "passphrase",
      "pfx",
      "rejectUnauthorized",
      "secureContext",
      "secureProtocol",
      "servername",
      "session"
    ];
    exports.LEGAL_TCP_SOCKET_OPTIONS = [
      "autoSelectFamily",
      "autoSelectFamilyAttemptTimeout",
      "family",
      "hints",
      "localAddress",
      "localPort",
      "lookup"
    ];
    function parseConnectOptions(options) {
      const hostAddress = options.hostAddress;
      if (!hostAddress)
        throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
      const result = {};
      for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
        if (options[name] != null) {
          result[name] = options[name];
        }
      }
      if (typeof hostAddress.socketPath === "string") {
        result.path = hostAddress.socketPath;
        return result;
      } else if (typeof hostAddress.host === "string") {
        result.host = hostAddress.host;
        result.port = hostAddress.port;
        return result;
      } else {
        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
      }
    }
    function parseSslOptions(options) {
      const result = parseConnectOptions(options);
      for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
        if (options[name] != null) {
          result[name] = options[name];
        }
      }
      if (options.existingSocket) {
        result.socket = options.existingSocket;
      }
      if (result.servername == null && result.host && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    async function makeSocket(options) {
      const useTLS = options.tls ?? false;
      const noDelay = options.noDelay ?? true;
      const connectTimeoutMS = options.connectTimeoutMS ?? 3e4;
      const existingSocket = options.existingSocket;
      let socket;
      if (options.proxyHost != null) {
        return await makeSocks5Connection({
          ...options,
          connectTimeoutMS
          // Should always be present for Socks5
        });
      }
      if (useTLS) {
        const tlsSocket = tls.connect(parseSslOptions(options));
        if (typeof tlsSocket.disableRenegotiation === "function") {
          tlsSocket.disableRenegotiation();
        }
        socket = tlsSocket;
      } else if (existingSocket) {
        socket = existingSocket;
      } else {
        socket = net.createConnection(parseConnectOptions(options));
      }
      socket.setKeepAlive(true, 3e5);
      socket.setTimeout(connectTimeoutMS);
      socket.setNoDelay(noDelay);
      let cancellationHandler = null;
      const { promise: connectedSocket, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      if (existingSocket) {
        resolve(socket);
      } else {
        const start = performance.now();
        const connectEvent = useTLS ? "secureConnect" : "connect";
        socket.once(connectEvent, () => resolve(socket)).once("error", (cause) => reject(new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause }))).once("timeout", () => {
          reject(new error_1.MongoNetworkTimeoutError(`Socket '${connectEvent}' timed out after ${performance.now() - start | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`));
        }).once("close", () => reject(new error_1.MongoNetworkError(`Socket closed after ${performance.now() - start | 0} during connection establishment`)));
        if (options.cancellationToken != null) {
          cancellationHandler = () => reject(new error_1.MongoNetworkError(`Socket connection establishment was cancelled after ${performance.now() - start | 0}`));
          options.cancellationToken.once("cancel", cancellationHandler);
        }
      }
      try {
        socket = await connectedSocket;
        return socket;
      } catch (error2) {
        socket.destroy();
        throw error2;
      } finally {
        socket.setTimeout(0);
        if (cancellationHandler != null) {
          options.cancellationToken?.removeListener("cancel", cancellationHandler);
        }
      }
    }
    var socks = null;
    function loadSocks() {
      if (socks == null) {
        const socksImport = (0, deps_1.getSocks)();
        if ("kModuleError" in socksImport) {
          throw socksImport.kModuleError;
        }
        socks = socksImport;
      }
      return socks;
    }
    async function makeSocks5Connection(options) {
      const hostAddress = utils_1.HostAddress.fromHostPort(
        options.proxyHost ?? "",
        // proxyHost is guaranteed to set here
        options.proxyPort ?? 1080
      );
      const rawSocket = await makeSocket({
        ...options,
        hostAddress,
        tls: false,
        proxyHost: void 0
      });
      const destination = parseConnectOptions(options);
      if (typeof destination.host !== "string" || typeof destination.port !== "number") {
        throw new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts");
      }
      socks ?? (socks = loadSocks());
      let existingSocket;
      try {
        const connection = await socks.SocksClient.createConnection({
          existing_socket: rawSocket,
          timeout: options.connectTimeoutMS,
          command: "connect",
          destination: {
            host: destination.host,
            port: destination.port
          },
          proxy: {
            // host and port are ignored because we pass existing_socket
            host: "iLoveJavaScript",
            port: 0,
            type: 5,
            userId: options.proxyUsername || void 0,
            password: options.proxyPassword || void 0
          }
        });
        existingSocket = connection.socket;
      } catch (cause) {
        throw new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause });
      }
      return await makeSocket({ ...options, existingSocket, proxyHost: void 0 });
    }
  }
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/sdam/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = void 0;
    var constants_1 = require_constants2();
    var ServerDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, address, previousDescription, newDescription) {
        this.name = constants_1.SERVER_DESCRIPTION_CHANGED;
        this.topologyId = topologyId;
        this.address = address;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;
    var ServerOpeningEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.name = constants_1.SERVER_OPENING;
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports.ServerOpeningEvent = ServerOpeningEvent;
    var ServerClosedEvent = class {
      /** @internal */
      constructor(topologyId, address) {
        this.name = constants_1.SERVER_CLOSED;
        this.topologyId = topologyId;
        this.address = address;
      }
    };
    exports.ServerClosedEvent = ServerClosedEvent;
    var TopologyDescriptionChangedEvent = class {
      /** @internal */
      constructor(topologyId, previousDescription, newDescription) {
        this.name = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
        this.topologyId = topologyId;
        this.previousDescription = previousDescription;
        this.newDescription = newDescription;
      }
    };
    exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;
    var TopologyOpeningEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.name = constants_1.TOPOLOGY_OPENING;
        this.topologyId = topologyId;
      }
    };
    exports.TopologyOpeningEvent = TopologyOpeningEvent;
    var TopologyClosedEvent = class {
      /** @internal */
      constructor(topologyId) {
        this.name = constants_1.TOPOLOGY_CLOSED;
        this.topologyId = topologyId;
      }
    };
    exports.TopologyClosedEvent = TopologyClosedEvent;
    var ServerHeartbeatStartedEvent = class {
      /** @internal */
      constructor(connectionId, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_STARTED;
        this.connectionId = connectionId;
        this.awaited = awaited;
      }
    };
    exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = class {
      /** @internal */
      constructor(connectionId, duration, reply, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
        this.connectionId = connectionId;
        this.duration = duration;
        this.reply = reply ?? {};
        this.awaited = awaited;
      }
    };
    exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = class {
      /** @internal */
      constructor(connectionId, duration, failure, awaited) {
        this.name = constants_1.SERVER_HEARTBEAT_FAILED;
        this.connectionId = connectionId;
        this.duration = duration;
        this.failure = failure;
        this.awaited = awaited;
      }
    };
    exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
  }
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool_events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = void 0;
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    var ConnectionPoolMonitoringEvent = class {
      /** @internal */
      constructor(pool) {
        this.time = /* @__PURE__ */ new Date();
        this.address = pool.address;
      }
    };
    exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CREATED;
        const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
        this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
      }
    };
    exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;
    var ConnectionPoolReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_READY;
      }
    };
    exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CLOSED;
      }
    };
    exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.name = constants_1.CONNECTION_CREATED;
        this.connectionId = connection.id;
      }
    };
    exports.ConnectionCreatedEvent = ConnectionCreatedEvent;
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, connectionCreatedEventTime) {
        super(pool);
        this.name = constants_1.CONNECTION_READY;
        this.durationMS = (0, utils_1.now)() - connectionCreatedEventTime;
        this.connectionId = connection.id;
      }
    };
    exports.ConnectionReadyEvent = ConnectionReadyEvent;
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, reason, error2) {
        super(pool);
        this.name = constants_1.CONNECTION_CLOSED;
        this.connectionId = connection.id;
        this.reason = reason;
        this.serviceId = connection.serviceId;
        this.error = error2 ?? null;
      }
    };
    exports.ConnectionClosedEvent = ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
      }
    };
    exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, reason, checkoutTime, error2) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
        this.durationMS = (0, utils_1.now)() - checkoutTime;
        this.reason = reason;
        this.error = error2;
      }
    };
    exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection, checkoutTime) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECKED_OUT;
        this.durationMS = (0, utils_1.now)() - checkoutTime;
        this.connectionId = connection.id;
      }
    };
    exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, connection) {
        super(pool);
        this.name = constants_1.CONNECTION_CHECKED_IN;
        this.connectionId = connection.id;
      }
    };
    exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      /** @internal */
      constructor(pool, options = {}) {
        super(pool);
        this.name = constants_1.CONNECTION_POOL_CLEARED;
        this.serviceId = options.serviceId;
        this.interruptInUseConnections = options.interruptInUseConnections;
      }
    };
    exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors2 = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = void 0;
    var error_1 = require_error();
    var PoolClosedError = class extends error_1.MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.address = pool.address;
      }
      get name() {
        return "MongoPoolClosedError";
      }
    };
    exports.PoolClosedError = PoolClosedError;
    var PoolClearedError = class extends error_1.MongoNetworkError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool, message) {
        const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
        super(errorMessage, pool.serverError ? { cause: pool.serverError } : void 0);
        this.address = pool.address;
        this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
      }
      get name() {
        return "MongoPoolClearedError";
      }
    };
    exports.PoolClearedError = PoolClearedError;
    var PoolClearedOnNetworkError = class extends PoolClearedError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(pool) {
        super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
      }
      get name() {
        return "PoolClearedOnNetworkError";
      }
    };
    exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;
    var WaitQueueTimeoutError = class extends error_1.MongoDriverError {
      /**
       * **Do not use this constructor!**
       *
       * Meant for internal use only.
       *
       * @remarks
       * This class is only meant to be constructed within the driver. This constructor is
       * not subject to semantic versioning compatibility guarantees and may change at any time.
       *
       * @public
       **/
      constructor(message, address) {
        super(message);
        this.address = address;
      }
      get name() {
        return "MongoWaitQueueTimeoutError";
      }
    };
    exports.WaitQueueTimeoutError = WaitQueueTimeoutError;
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectionPool = exports.PoolState = void 0;
    var timers_1 = __require("timers");
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var connect_1 = require_connect();
    var connection_1 = require_connection();
    var connection_pool_events_1 = require_connection_pool_events();
    var errors_1 = require_errors2();
    var metrics_1 = require_metrics();
    exports.PoolState = Object.freeze({
      paused: "paused",
      ready: "ready",
      closed: "closed"
    });
    var ConnectionPool = class _ConnectionPool extends mongo_types_1.TypedEventEmitter {
      constructor(server2, options) {
        super();
        this.on("error", utils_1.noop);
        this.options = Object.freeze({
          connectionType: connection_1.Connection,
          ...options,
          maxPoolSize: options.maxPoolSize ?? 100,
          minPoolSize: options.minPoolSize ?? 0,
          maxConnecting: options.maxConnecting ?? 2,
          maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
          waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
          minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
          autoEncrypter: options.autoEncrypter
        });
        if (this.options.minPoolSize > this.options.maxPoolSize) {
          throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
        }
        this.poolState = exports.PoolState.paused;
        this.server = server2;
        this.connections = new utils_1.List();
        this.pending = 0;
        this.checkedOut = /* @__PURE__ */ new Set();
        this.minPoolSizeTimer = void 0;
        this.generation = 0;
        this.serviceGenerations = /* @__PURE__ */ new Map();
        this.connectionCounter = (0, utils_1.makeCounter)(1);
        this.cancellationToken = new mongo_types_1.CancellationToken();
        this.cancellationToken.setMaxListeners(Infinity);
        this.waitQueue = new utils_1.List();
        this.metrics = new metrics_1.ConnectionPoolMetrics();
        this.processingWaitQueue = false;
        this.mongoLogger = this.server.topology.client?.mongoLogger;
        this.component = "connection";
        process.nextTick(() => {
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
        });
      }
      /** The address of the endpoint the pool is connected to */
      get address() {
        return this.options.hostAddress.toString();
      }
      /**
       * Check if the pool has been closed
       *
       * TODO(NODE-3263): We can remove this property once shell no longer needs it
       */
      get closed() {
        return this.poolState === exports.PoolState.closed;
      }
      /** An integer expressing how many total connections (available + pending + in use) the pool currently has */
      get totalConnectionCount() {
        return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
      }
      /** An integer expressing how many connections are currently available in the pool. */
      get availableConnectionCount() {
        return this.connections.length;
      }
      get pendingConnectionCount() {
        return this.pending;
      }
      get currentCheckedOutCount() {
        return this.checkedOut.size;
      }
      get waitQueueSize() {
        return this.waitQueue.length;
      }
      get loadBalanced() {
        return this.options.loadBalanced;
      }
      get serverError() {
        return this.server.description.error;
      }
      /**
       * This is exposed ONLY for use in mongosh, to enable
       * killing all connections if a user quits the shell with
       * operations in progress.
       *
       * This property may be removed as a part of NODE-3263.
       */
      get checkedOutConnections() {
        return this.checkedOut;
      }
      /**
       * Get the metrics information for the pool when a wait queue timeout occurs.
       */
      waitQueueErrorMetrics() {
        return this.metrics.info(this.options.maxPoolSize);
      }
      /**
       * Set the pool state to "ready"
       */
      ready() {
        if (this.poolState !== exports.PoolState.paused) {
          return;
        }
        this.poolState = exports.PoolState.ready;
        this.emitAndLog(_ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
        (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
        this.ensureMinPoolSize();
      }
      /**
       * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
       * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
       * explicitly destroyed by the new owner.
       */
      async checkOut(options) {
        const checkoutTime = (0, utils_1.now)();
        this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        const timeout = options.timeoutContext.connectionCheckoutTimeout;
        const waitQueueMember = {
          resolve,
          reject,
          cancelled: false,
          checkoutTime
        };
        const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
          waitQueueMember.cancelled = true;
          reject(this.reason);
        });
        this.waitQueue.push(waitQueueMember);
        process.nextTick(() => this.processWaitQueue());
        try {
          timeout?.throwIfExpired();
          return await (timeout ? Promise.race([promise, timeout]) : promise);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            timeout?.clear();
            waitQueueMember.cancelled = true;
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout", waitQueueMember.checkoutTime));
            const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address);
            if (options.timeoutContext.csotEnabled()) {
              throw new error_1.MongoOperationTimeoutError("Timed out during connection checkout", {
                cause: timeoutError
              });
            }
            throw timeoutError;
          }
          throw error2;
        } finally {
          abortListener?.[utils_1.kDispose]();
          timeout?.clear();
        }
      }
      /**
       * Check a connection into the pool.
       *
       * @param connection - The connection to check in
       */
      checkIn(connection) {
        if (!this.checkedOut.has(connection)) {
          return;
        }
        const poolClosed = this.closed;
        const stale = this.connectionIsStale(connection);
        const willDestroy = !!(poolClosed || stale || connection.closed);
        if (!willDestroy) {
          connection.markAvailable();
          this.connections.unshift(connection);
        }
        this.checkedOut.delete(connection);
        this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
        if (willDestroy) {
          const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          this.destroyConnection(connection, reason);
        }
        process.nextTick(() => this.processWaitQueue());
      }
      /**
       * Clear the pool
       *
       * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
       * previous generation will eventually be pruned during subsequent checkouts.
       */
      clear(options = {}) {
        if (this.closed) {
          return;
        }
        if (this.loadBalanced) {
          const { serviceId } = options;
          if (!serviceId) {
            throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
          }
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          if (generation == null) {
            throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
          } else {
            this.serviceGenerations.set(sid, generation + 1);
          }
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
          return;
        }
        const interruptInUseConnections = options.interruptInUseConnections ?? false;
        const oldGeneration = this.generation;
        this.generation += 1;
        const alreadyPaused = this.poolState === exports.PoolState.paused;
        this.poolState = exports.PoolState.paused;
        this.clearMinPoolSizeTimer();
        if (!alreadyPaused) {
          this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
            interruptInUseConnections
          }));
        }
        if (interruptInUseConnections) {
          process.nextTick(() => this.interruptInUseConnections(oldGeneration));
        }
        this.processWaitQueue();
      }
      /**
       * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.
       *
       * Only connections where `connection.generation <= minGeneration` are killed.
       */
      interruptInUseConnections(minGeneration) {
        for (const connection of this.checkedOut) {
          if (connection.generation <= minGeneration) {
            connection.onError(new errors_1.PoolClearedOnNetworkError(this));
            this.checkIn(connection);
          }
        }
      }
      /** Close the pool */
      close() {
        if (this.closed) {
          return;
        }
        this.cancellationToken.emit("cancel");
        if (typeof this.connectionCounter.return === "function") {
          this.connectionCounter.return(void 0);
        }
        this.poolState = exports.PoolState.closed;
        this.clearMinPoolSizeTimer();
        this.processWaitQueue();
        for (const conn of this.connections) {
          this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy();
        }
        this.connections.clear();
        this.emitAndLog(_ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
      }
      /**
       * @internal
       * Reauthenticate a connection
       */
      async reauthenticate(connection) {
        const authContext = connection.authContext;
        if (!authContext) {
          throw new error_1.MongoRuntimeError("No auth context found on connection.");
        }
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate");
        }
        const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);
        const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
        if (!provider) {
          throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);
        }
        await provider.reauth(authContext);
        return;
      }
      /** Clear the min pool size timer */
      clearMinPoolSizeTimer() {
        const minPoolSizeTimer = this.minPoolSizeTimer;
        if (minPoolSizeTimer) {
          (0, timers_1.clearTimeout)(minPoolSizeTimer);
        }
      }
      destroyConnection(connection, reason) {
        this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
        connection.destroy();
      }
      connectionIsStale(connection) {
        const serviceId = connection.serviceId;
        if (this.loadBalanced && serviceId) {
          const sid = serviceId.toHexString();
          const generation = this.serviceGenerations.get(sid);
          return connection.generation !== generation;
        }
        return connection.generation !== this.generation;
      }
      connectionIsIdle(connection) {
        return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
      }
      /**
       * Destroys a connection if the connection is perished.
       *
       * @returns `true` if the connection was destroyed, `false` otherwise.
       */
      destroyConnectionIfPerished(connection) {
        const isStale = this.connectionIsStale(connection);
        const isIdle = this.connectionIsIdle(connection);
        if (!isStale && !isIdle && !connection.closed) {
          return false;
        }
        const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
        this.destroyConnection(connection, reason);
        return true;
      }
      createConnection(callback) {
        const connectOptions = {
          ...this.options,
          id: this.connectionCounter.next().value,
          generation: this.generation,
          cancellationToken: this.cancellationToken,
          mongoLogger: this.mongoLogger,
          authProviders: this.server.topology.client.s.authProviders
        };
        this.pending++;
        const connectionCreatedTime = (0, utils_1.now)();
        this.emitAndLog(_ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
        (0, connect_1.connect)(connectOptions).then((connection) => {
          if (this.poolState !== exports.PoolState.ready) {
            this.pending--;
            connection.destroy();
            callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
            return;
          }
          for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
            connection.on(event, (e) => this.emit(event, e));
          }
          if (this.loadBalanced) {
            connection.on(connection_1.Connection.PINNED, (pinType) => this.metrics.markPinned(pinType));
            connection.on(connection_1.Connection.UNPINNED, (pinType) => this.metrics.markUnpinned(pinType));
            const serviceId = connection.serviceId;
            if (serviceId) {
              let generation;
              const sid = serviceId.toHexString();
              if (generation = this.serviceGenerations.get(sid)) {
                connection.generation = generation;
              } else {
                this.serviceGenerations.set(sid, 0);
                connection.generation = 0;
              }
            }
          }
          connection.markAvailable();
          this.emitAndLog(_ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));
          this.pending--;
          callback(void 0, connection);
        }, (error2) => {
          this.pending--;
          this.server.handleError(error2);
          this.emitAndLog(_ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(
            this,
            { id: connectOptions.id, serviceId: void 0 },
            "error",
            // TODO(NODE-5192): Remove this cast
            error2
          ));
          if (error2 instanceof error_1.MongoNetworkError || error2 instanceof error_1.MongoServerError) {
            error2.connectionGeneration = connectOptions.generation;
          }
          callback(error2 ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
        });
      }
      ensureMinPoolSize() {
        const minPoolSize = this.options.minPoolSize;
        if (this.poolState !== exports.PoolState.ready || minPoolSize === 0) {
          return;
        }
        this.connections.prune((connection) => this.destroyConnectionIfPerished(connection));
        if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
          this.createConnection((err, connection) => {
            if (!err && connection) {
              this.connections.push(connection);
              process.nextTick(() => this.processWaitQueue());
            }
            if (this.poolState === exports.PoolState.ready) {
              (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
              this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
            }
          });
        } else {
          (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
          this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
        }
      }
      processWaitQueue() {
        if (this.processingWaitQueue) {
          return;
        }
        this.processingWaitQueue = true;
        while (this.waitQueueSize) {
          const waitQueueMember = this.waitQueue.first();
          if (!waitQueueMember) {
            this.waitQueue.shift();
            continue;
          }
          if (waitQueueMember.cancelled) {
            this.waitQueue.shift();
            continue;
          }
          if (this.poolState !== exports.PoolState.ready) {
            const reason = this.closed ? "poolClosed" : "connectionError";
            const error2 = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error2));
            this.waitQueue.shift();
            waitQueueMember.reject(error2);
            continue;
          }
          if (!this.availableConnectionCount) {
            break;
          }
          const connection = this.connections.shift();
          if (!connection) {
            break;
          }
          if (!this.destroyConnectionIfPerished(connection)) {
            this.checkedOut.add(connection);
            this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
            this.waitQueue.shift();
            waitQueueMember.resolve(connection);
          }
        }
        const { maxPoolSize, maxConnecting } = this.options;
        while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
          const waitQueueMember = this.waitQueue.shift();
          if (!waitQueueMember || waitQueueMember.cancelled) {
            continue;
          }
          this.createConnection((err, connection) => {
            if (waitQueueMember.cancelled) {
              if (!err && connection) {
                this.connections.push(connection);
              }
            } else {
              if (err) {
                this.emitAndLog(
                  _ConnectionPool.CONNECTION_CHECK_OUT_FAILED,
                  // TODO(NODE-5192): Remove this cast
                  new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", waitQueueMember.checkoutTime, err)
                );
                waitQueueMember.reject(err);
              } else if (connection) {
                this.checkedOut.add(connection);
                this.emitAndLog(_ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
                waitQueueMember.resolve(connection);
              }
            }
            process.nextTick(() => this.processWaitQueue());
          });
        }
        this.processingWaitQueue = false;
      }
    };
    exports.ConnectionPool = ConnectionPool;
    ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
    ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
    ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
    ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
    ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
    ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
    ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
    ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
    ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
    ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
    ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
  }
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/sdam/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Server = void 0;
    var connection_1 = require_connection();
    var connection_pool_1 = require_connection_pool();
    var errors_1 = require_errors2();
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var transactions_1 = require_transactions();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var common_1 = require_common();
    var monitor_1 = require_monitor();
    var server_description_1 = require_server_description();
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var Server = class _Server extends mongo_types_1.TypedEventEmitter {
      /**
       * Create a server
       */
      constructor(topology, description, options) {
        super();
        this.on("error", utils_1.noop);
        this.serverApi = options.serverApi;
        const poolOptions = { hostAddress: description.hostAddress, ...options };
        this.topology = topology;
        this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
        this.s = {
          description,
          options,
          state: common_1.STATE_CLOSED,
          operationCount: 0
        };
        for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
          this.pool.on(event, (e) => this.emit(event, e));
        }
        this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        if (this.loadBalanced) {
          this.monitor = null;
          return;
        }
        this.monitor = new monitor_1.Monitor(this, this.s.options);
        for (const event of constants_1.HEARTBEAT_EVENTS) {
          this.monitor.on(event, (e) => this.emit(event, e));
        }
        this.monitor.on("resetServer", (error2) => markServerUnknown(this, error2));
        this.monitor.on(_Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
          this.emit(_Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
            roundTripTime: this.monitor?.roundTripTime,
            minRoundTripTime: this.monitor?.minRoundTripTime
          }));
          if (this.s.state === common_1.STATE_CONNECTING) {
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(_Server.CONNECT, this);
          }
        });
      }
      get clusterTime() {
        return this.topology.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.topology.clusterTime = clusterTime;
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return;
      }
      get loadBalanced() {
        return this.topology.description.type === common_1.TopologyType.LoadBalanced;
      }
      /**
       * Initiate server connect
       */
      connect() {
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        if (!this.loadBalanced) {
          this.monitor?.connect();
        } else {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Server.CONNECT, this);
        }
      }
      /** Destroy the server connection */
      destroy() {
        if (this.s.state === common_1.STATE_CLOSED) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        if (!this.loadBalanced) {
          this.monitor?.close();
        }
        this.pool.close();
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit("closed");
      }
      /**
       * Immediately schedule monitoring of this server. If there already an attempt being made
       * this will be a no-op.
       */
      requestCheck() {
        if (!this.loadBalanced) {
          this.monitor?.requestCheck();
        }
      }
      async command(ns, cmd, { ...options }, responseType) {
        if (ns.db == null || typeof ns === "string") {
          throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
        }
        if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
          throw new error_1.MongoServerClosedError();
        }
        options.directConnection = this.topology.s.options.directConnection;
        if (options.omitReadPreference) {
          delete options.readPreference;
        }
        if (this.description.iscryptd) {
          options.omitMaxTimeMS = true;
        }
        const session = options.session;
        let conn = session?.pinnedConnection;
        this.incrementOperationCount();
        if (conn == null) {
          try {
            conn = await this.pool.checkOut(options);
            if (this.loadBalanced && isPinnableCommand(cmd, session)) {
              session?.pin(conn);
            }
          } catch (checkoutError) {
            this.decrementOperationCount();
            if (!(checkoutError instanceof errors_1.PoolClearedError))
              this.handleError(checkoutError);
            throw checkoutError;
          }
        }
        let reauthPromise = null;
        try {
          try {
            const res = await conn.command(ns, cmd, options, responseType);
            (0, write_concern_1.throwIfWriteConcernError)(res);
            return res;
          } catch (commandError) {
            throw this.decorateCommandError(conn, cmd, options, commandError);
          }
        } catch (operationError) {
          if (operationError instanceof error_1.MongoError && operationError.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
            reauthPromise = this.pool.reauthenticate(conn);
            reauthPromise.then(void 0, (error2) => {
              reauthPromise = null;
              (0, utils_1.squashError)(error2);
            });
            await (0, utils_1.abortable)(reauthPromise, options);
            reauthPromise = null;
            try {
              const res = await conn.command(ns, cmd, options, responseType);
              (0, write_concern_1.throwIfWriteConcernError)(res);
              return res;
            } catch (commandError) {
              throw this.decorateCommandError(conn, cmd, options, commandError);
            }
          } else {
            throw operationError;
          }
        } finally {
          this.decrementOperationCount();
          if (session?.pinnedConnection !== conn) {
            if (reauthPromise != null) {
              const checkBackIn = () => {
                this.pool.checkIn(conn);
              };
              void reauthPromise.then(checkBackIn, checkBackIn);
            } else {
              this.pool.checkIn(conn);
            }
          }
        }
      }
      /**
       * Handle SDAM error
       * @internal
       */
      handleError(error2, connection) {
        if (!(error2 instanceof error_1.MongoError)) {
          return;
        }
        const isStaleError = error2.connectionGeneration && error2.connectionGeneration < this.pool.generation;
        if (isStaleError) {
          return;
        }
        const isNetworkNonTimeoutError = error2 instanceof error_1.MongoNetworkError && !(error2 instanceof error_1.MongoNetworkTimeoutError);
        const isNetworkTimeoutBeforeHandshakeError = error2 instanceof error_1.MongoNetworkError && error2.beforeHandshake;
        const isAuthHandshakeError = error2.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
        if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
          if (!this.loadBalanced) {
            error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
            markServerUnknown(this, error2);
          } else if (connection) {
            this.pool.clear({ serviceId: connection.serviceId });
          }
        } else {
          if ((0, error_1.isSDAMUnrecoverableError)(error2)) {
            if (shouldHandleStateChangeError(this, error2)) {
              const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error2);
              if (this.loadBalanced && connection && shouldClearPool) {
                this.pool.clear({ serviceId: connection.serviceId });
              }
              if (!this.loadBalanced) {
                if (shouldClearPool) {
                  error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
                }
                markServerUnknown(this, error2);
                process.nextTick(() => this.requestCheck());
              }
            }
          }
        }
      }
      /**
       * Ensure that error is properly decorated and internal state is updated before throwing
       * @internal
       */
      decorateCommandError(connection, cmd, options, error2) {
        if (typeof error2 !== "object" || error2 == null || !("name" in error2)) {
          throw new error_1.MongoRuntimeError("An unexpected error type: " + typeof error2);
        }
        if (error2.name === "AbortError" && "cause" in error2 && error2.cause instanceof error_1.MongoError) {
          error2 = error2.cause;
        }
        if (!(error2 instanceof error_1.MongoError)) {
          return error2;
        }
        if (connectionIsStale(this.pool, connection)) {
          return error2;
        }
        const session = options?.session;
        if (error2 instanceof error_1.MongoNetworkError) {
          if (session && !session.hasEnded && session.serverSession) {
            session.serverSession.isDirty = true;
          }
          if (inActiveTransaction(session, cmd) && !error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
          }
          if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(this) && !inActiveTransaction(session, cmd)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        } else {
          if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error2, (0, utils_1.maxWireVersion)(this), this.description.type) && !inActiveTransaction(session, cmd)) {
            error2.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        if (session && session.isPinned && error2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          session.unpin({ force: true });
        }
        this.handleError(error2, connection);
        return error2;
      }
      /**
       * Decrement the operation count, returning the new count.
       */
      decrementOperationCount() {
        return this.s.operationCount -= 1;
      }
      /**
       * Increment the operation count, returning the new count.
       */
      incrementOperationCount() {
        return this.s.operationCount += 1;
      }
    };
    exports.Server = Server;
    Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
    Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
    Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
    Server.CONNECT = constants_1.CONNECT;
    Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
    Server.CLOSED = constants_1.CLOSED;
    Server.ENDED = constants_1.ENDED;
    function markServerUnknown(server2, error2) {
      if (server2.loadBalanced) {
        return;
      }
      if (error2 instanceof error_1.MongoNetworkError && !(error2 instanceof error_1.MongoNetworkTimeoutError)) {
        server2.monitor?.reset();
      }
      server2.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server2.description.hostAddress, void 0, { error: error2 }));
    }
    function isPinnableCommand(cmd, session) {
      if (session) {
        return session.inTransaction() || session.transaction.isCommitted && "commitTransaction" in cmd || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd || "bulkWrite" in cmd;
      }
      return false;
    }
    function connectionIsStale(pool, connection) {
      if (connection.serviceId) {
        return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
      }
      return connection.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server2, err) {
      const etv = err.topologyVersion;
      const stv = server2.description.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
    }
    function isRetryableWritesEnabled(topology) {
      return topology.s.options.retryWrites !== false;
    }
  }
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/sdam/monitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;
    var timers_1 = __require("timers");
    var bson_1 = require_bson2();
    var connect_1 = require_connect();
    var client_metadata_1 = require_client_metadata();
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils();
    var common_1 = require_common();
    var events_1 = require_events();
    var server_1 = require_server();
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = /* @__PURE__ */ new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
    }
    exports.ServerMonitoringMode = Object.freeze({
      auto: "auto",
      poll: "poll",
      stream: "stream"
    });
    var Monitor = class extends mongo_types_1.TypedEventEmitter {
      constructor(server2, options) {
        super();
        this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
        this.on("error", utils_1.noop);
        this.server = server2;
        this.connection = null;
        this.cancellationToken = new mongo_types_1.CancellationToken();
        this.cancellationToken.setMaxListeners(Infinity);
        this.monitorId = void 0;
        this.s = {
          state: common_1.STATE_CLOSED
        };
        this.address = server2.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: options.connectTimeoutMS ?? 1e4,
          heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 1e4,
          minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,
          serverMonitoringMode: options.serverMonitoringMode
        });
        this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
        this.mongoLogger = this.server.topology.client?.mongoLogger;
        this.rttSampler = new RTTSampler(10);
        const cancellationToken = this.cancellationToken;
        const connectOptions = {
          id: "<monitor>",
          generation: server2.pool.generation,
          cancellationToken,
          hostAddress: server2.description.hostAddress,
          ...options,
          // force BSON serialization options
          raw: false,
          useBigInt64: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true
        };
        delete connectOptions.credentials;
        if (connectOptions.autoEncrypter) {
          delete connectOptions.autoEncrypter;
        }
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== common_1.STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this.monitorId = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this.monitorId?.wake();
      }
      reset() {
        const topologyVersion = this.server.description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this.monitorId = new MonitorInterval(monitorServer(this), {
          heartbeatFrequencyMS,
          minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, common_1.STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, common_1.STATE_CLOSED);
      }
      get roundTripTime() {
        return this.rttSampler.average();
      }
      get minRoundTripTime() {
        return this.rttSampler.min();
      }
      get latestRtt() {
        return this.rttSampler.last;
      }
      addRttSample(rtt) {
        this.rttSampler.addSample(rtt);
      }
      clearRttSamples() {
        this.rttSampler.clear();
      }
    };
    exports.Monitor = Monitor;
    function resetMonitorState(monitor) {
      monitor.monitorId?.stop();
      monitor.monitorId = void 0;
      monitor.rttPinger?.close();
      monitor.rttPinger = void 0;
      monitor.cancellationToken.emit("cancel");
      monitor.connection?.destroy();
      monitor.connection = null;
      monitor.clearRttSamples();
    }
    function useStreamingProtocol(monitor, topologyVersion) {
      if (topologyVersion == null)
        return false;
      const serverMonitoringMode = monitor.options.serverMonitoringMode;
      if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
        return false;
      if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
        return true;
      if (monitor.isRunningInFaasEnv)
        return false;
      return true;
    }
    function checkServer(monitor, callback) {
      let start;
      let awaited;
      const topologyVersion = monitor.server.description.topologyVersion;
      const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
      function onHeartbeatFailed(err) {
        monitor.connection?.destroy();
        monitor.connection = null;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));
        const error2 = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err }) : err;
        error2.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
        if (error2 instanceof error_1.MongoNetworkTimeoutError) {
          error2.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
        }
        monitor.emit("resetServer", error2);
        callback(err);
      }
      function onHeartbeatSucceeded(hello) {
        if (!("isWritablePrimary" in hello)) {
          hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
        }
        const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start) : (0, utils_1.calculateDurationInMs)(start);
        monitor.addRttSample(duration);
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
        if (isAwaitable) {
          monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, void 0, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
          start = (0, utils_1.now)();
        } else {
          monitor.rttPinger?.close();
          monitor.rttPinger = void 0;
          callback(void 0, hello);
        }
      }
      const { connection } = monitor;
      if (connection && !connection.closed) {
        const { serverApi, helloOk } = connection;
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const cmd = {
          [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
          ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
        };
        const options = isAwaitable ? {
          socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
          exhaustAllowed: true
        } : { socketTimeoutMS: connectTimeoutMS };
        if (isAwaitable && monitor.rttPinger == null) {
          monitor.rttPinger = new RTTPinger(monitor);
        }
        start = (0, utils_1.now)();
        if (isAwaitable) {
          awaited = true;
          return connection.exhaustCommand((0, utils_1.ns)("admin.$cmd"), cmd, options, (error2, hello) => {
            if (error2)
              return onHeartbeatFailed(error2);
            return onHeartbeatSucceeded(hello);
          });
        }
        awaited = false;
        connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options).then(onHeartbeatSucceeded, onHeartbeatFailed);
        return;
      }
      (async () => {
        const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);
        const connection2 = (0, connect_1.makeConnection)(monitor.connectOptions, socket);
        start = (0, utils_1.now)();
        try {
          await (0, connect_1.performInitialHandshake)(connection2, monitor.connectOptions);
          return connection2;
        } catch (error2) {
          connection2.destroy();
          throw error2;
        }
      })().then((connection2) => {
        if (isInCloseState(monitor)) {
          connection2.destroy();
          return;
        }
        const duration = (0, utils_1.calculateDurationInMs)(start);
        monitor.addRttSample(duration);
        monitor.connection = connection2;
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, connection2.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection2.hello, useStreamingProtocol(monitor, connection2.hello?.topologyVersion)));
        callback(void 0, connection2.hello);
      }, (error2) => {
        monitor.connection = null;
        awaited = false;
        onHeartbeatFailed(error2);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        if (monitor.s.state === STATE_MONITORING) {
          process.nextTick(callback);
          return;
        }
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        checkServer(monitor, (err, hello) => {
          if (err) {
            if (monitor.server.description.type === common_1.ServerType.Unknown) {
              return done();
            }
          }
          if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
            (0, timers_1.setTimeout)(() => {
              if (!isInCloseState(monitor)) {
                monitor.monitorId?.wake();
              }
            }, 0);
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        // tests mock counter as just number, but in a real situation counter should always be a Long
        // TODO(NODE-2674): Preserve int64 sent from MongoDB
        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(monitor) {
        this.connection = void 0;
        this.cancellationToken = monitor.cancellationToken;
        this.closed = false;
        this.monitor = monitor;
        this.latestRtt = monitor.latestRtt ?? void 0;
        const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this.monitor.roundTripTime;
      }
      get minRoundTripTime() {
        return this.monitor.minRoundTripTime;
      }
      close() {
        this.closed = true;
        (0, timers_1.clearTimeout)(this.monitorId);
        this.connection?.destroy();
        this.connection = void 0;
      }
      measureAndReschedule(start, conn) {
        if (this.closed) {
          conn?.destroy();
          return;
        }
        if (this.connection == null) {
          this.connection = conn;
        }
        this.latestRtt = (0, utils_1.calculateDurationInMs)(start);
        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);
      }
      measureRoundTripTime() {
        const start = (0, utils_1.now)();
        if (this.closed) {
          return;
        }
        const connection = this.connection;
        if (connection == null) {
          (0, connect_1.connect)(this.monitor.connectOptions).then((connection2) => {
            this.measureAndReschedule(start, connection2);
          }, () => {
            this.connection = void 0;
          });
          return;
        }
        const commandName = connection.serverApi?.version || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
        connection.command((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, void 0).then(() => this.measureAndReschedule(start), () => {
          this.connection?.destroy();
          this.connection = void 0;
          return;
        });
      }
    };
    exports.RTTPinger = RTTPinger;
    var MonitorInterval = class {
      constructor(fn, options = {}) {
        this.isExpeditedCallToFnScheduled = false;
        this.stopped = false;
        this.isExecutionInProgress = false;
        this.hasExecutedOnce = false;
        this._executeAndReschedule = () => {
          if (this.stopped)
            return;
          if (this.timerId) {
            (0, timers_1.clearTimeout)(this.timerId);
          }
          this.isExpeditedCallToFnScheduled = false;
          this.isExecutionInProgress = true;
          this.fn(() => {
            this.lastExecutionEnded = (0, utils_1.now)();
            this.isExecutionInProgress = false;
            this._reschedule(this.heartbeatFrequencyMS);
          });
        };
        this.fn = fn;
        this.lastExecutionEnded = -Infinity;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e3;
        this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
        if (options.immediate) {
          this._executeAndReschedule();
        } else {
          this._reschedule(void 0);
        }
      }
      wake() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        if (timeSinceLastCall < 0) {
          return this._executeAndReschedule();
        }
        if (this.isExecutionInProgress) {
          return;
        }
        if (this.isExpeditedCallToFnScheduled) {
          return;
        }
        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
          this.isExpeditedCallToFnScheduled = true;
          this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
          return;
        }
        this._executeAndReschedule();
      }
      stop() {
        this.stopped = true;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
          this.timerId = void 0;
        }
        this.lastExecutionEnded = -Infinity;
        this.isExpeditedCallToFnScheduled = false;
      }
      toString() {
        return JSON.stringify(this);
      }
      toJSON() {
        const currentTime = (0, utils_1.now)();
        const timeSinceLastCall = currentTime - this.lastExecutionEnded;
        return {
          timerId: this.timerId != null ? "set" : "cleared",
          lastCallTime: this.lastExecutionEnded,
          isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
          stopped: this.stopped,
          heartbeatFrequencyMS: this.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
          currentTime,
          timeSinceLastCall
        };
      }
      _reschedule(ms) {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
      }
    };
    exports.MonitorInterval = MonitorInterval;
    var RTTSampler = class {
      constructor(windowSize = 10) {
        this.rttSamples = new Float64Array(windowSize);
        this.length = 0;
        this.writeIndex = 0;
      }
      /**
       * Adds an rtt sample to the end of the circular buffer
       * When `windowSize` samples have been collected, `addSample` overwrites the least recently added
       * sample
       */
      addSample(sample) {
        this.rttSamples[this.writeIndex++] = sample;
        if (this.length < this.rttSamples.length) {
          this.length++;
        }
        this.writeIndex %= this.rttSamples.length;
      }
      /**
       * When \< 2 samples have been collected, returns 0
       * Otherwise computes the minimum value samples contained in the buffer
       */
      min() {
        if (this.length < 2)
          return 0;
        let min = this.rttSamples[0];
        for (let i = 1; i < this.length; i++) {
          if (this.rttSamples[i] < min)
            min = this.rttSamples[i];
        }
        return min;
      }
      /**
       * Returns mean of samples contained in the buffer
       */
      average() {
        if (this.length === 0)
          return 0;
        let sum = 0;
        for (let i = 0; i < this.length; i++) {
          sum += this.rttSamples[i];
        }
        return sum / this.length;
      }
      /**
       * Returns most recently inserted element in the buffer
       * Returns null if the buffer is empty
       * */
      get last() {
        if (this.length === 0)
          return null;
        return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
      }
      /**
       * Clear the buffer
       * NOTE: this does not overwrite the data held in the internal array, just the pointers into
       * this array
       */
      clear() {
        this.length = 0;
        this.writeIndex = 0;
      }
    };
    exports.RTTSampler = RTTSampler;
  }
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS({
  "node_modules/mongodb/lib/connection_string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_OPTIONS = exports.OPTIONS = void 0;
    exports.resolveSRVRecord = resolveSRVRecord;
    exports.parseOptions = parseOptions2;
    var dns = __require("dns");
    var mongodb_connection_string_url_1 = require_lib3();
    var url_1 = __require("url");
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var client_metadata_1 = require_client_metadata();
    var compression_1 = require_compression();
    var encrypter_1 = require_encrypter();
    var error_1 = require_error();
    var mongo_client_1 = require_mongo_client();
    var mongo_logger_1 = require_mongo_logger();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var monitor_1 = require_monitor();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
    var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
    var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
    var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
    function retryDNSTimeoutFor(api) {
      return async function dnsReqRetryTimeout(lookupAddress) {
        try {
          return await dns.promises[api](lookupAddress);
        } catch (firstDNSError) {
          if (firstDNSError.code === dns.TIMEOUT) {
            return await dns.promises[api](lookupAddress);
          } else {
            throw firstDNSError;
          }
        }
      };
    }
    var resolveSrv = retryDNSTimeoutFor("resolveSrv");
    var resolveTxt = retryDNSTimeoutFor("resolveTxt");
    async function resolveSRVRecord(options) {
      if (typeof options.srvHost !== "string") {
        throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
      }
      const lookupAddress = options.srvHost;
      const txtResolutionPromise = resolveTxt(lookupAddress);
      txtResolutionPromise.then(void 0, utils_1.squashError);
      const hostname = `_${options.srvServiceName}._tcp.${lookupAddress}`;
      const addresses = await resolveSrv(hostname);
      if (addresses.length === 0) {
        throw new error_1.MongoAPIError("No addresses found at host");
      }
      for (const { name } of addresses) {
        (0, utils_1.checkParentDomainMatch)(name, lookupAddress);
      }
      const hostAddresses = addresses.map((r) => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
      validateLoadBalancedOptions(hostAddresses, options, true);
      let record;
      try {
        record = await txtResolutionPromise;
      } catch (error2) {
        if (error2.code !== "ENODATA" && error2.code !== "ENOTFOUND") {
          throw error2;
        }
        return hostAddresses;
      }
      if (record.length > 1) {
        throw new error_1.MongoParseError("Multiple text records not allowed");
      }
      const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
      const txtRecordOptionKeys = [...txtRecordOptions.keys()];
      if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
        throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
      }
      if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
        throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
      }
      const source = txtRecordOptions.get("authSource") ?? void 0;
      const replicaSet = txtRecordOptions.get("replicaSet") ?? void 0;
      const loadBalanced = txtRecordOptions.get("loadBalanced") ?? void 0;
      if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
        options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
      if (!options.userSpecifiedReplicaSet && replicaSet) {
        options.replicaSet = replicaSet;
      }
      if (loadBalanced === "true") {
        options.loadBalanced = true;
      }
      if (options.replicaSet && options.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
      }
      validateLoadBalancedOptions(hostAddresses, options, true);
      return hostAddresses;
    }
    function checkTLSOptions(allOptions) {
      if (!allOptions)
        return;
      const check = (a, b) => {
        if (allOptions.has(a) && allOptions.has(b)) {
          throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
        }
      };
      check("tlsInsecure", "tlsAllowInvalidCertificates");
      check("tlsInsecure", "tlsAllowInvalidHostnames");
      check("tlsInsecure", "tlsDisableCertificateRevocationCheck");
      check("tlsInsecure", "tlsDisableOCSPEndpointCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
      check("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
      check("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
    }
    function getBoolean(name, value) {
      if (typeof value === "boolean")
        return value;
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
      }
    }
    function getIntFromOptions(name, value) {
      const parsedInt = (0, utils_1.parseInteger)(value);
      if (parsedInt != null) {
        return parsedInt;
      }
      throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
    }
    function getUIntFromOptions(name, value) {
      const parsedValue = getIntFromOptions(name, value);
      if (parsedValue < 0) {
        throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
      }
      return parsedValue;
    }
    function* entriesFromString(value) {
      if (value === "") {
        return;
      }
      const keyValuePairs = value.split(",");
      for (const keyValue of keyValuePairs) {
        const [key, value2] = keyValue.split(/:(.*)/);
        if (value2 == null) {
          throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
        }
        yield [key, value2];
      }
    }
    var CaseInsensitiveMap = class extends Map {
      constructor(entries = []) {
        super(entries.map(([k, v]) => [k.toLowerCase(), v]));
      }
      has(k) {
        return super.has(k.toLowerCase());
      }
      get(k) {
        return super.get(k.toLowerCase());
      }
      set(k, v) {
        return super.set(k.toLowerCase(), v);
      }
      delete(k) {
        return super.delete(k.toLowerCase());
      }
    };
    function parseOptions2(uri, mongoClient = void 0, options = {}) {
      if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
        options = mongoClient;
        mongoClient = void 0;
      }
      if (options.useBigInt64 && typeof options.promoteLongs === "boolean" && !options.promoteLongs) {
        throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
      }
      if (options.useBigInt64 && typeof options.promoteValues === "boolean" && !options.promoteValues) {
        throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
      }
      const url2 = new mongodb_connection_string_url_1.default(uri);
      const { hosts, isSRV } = url2;
      const mongoOptions = /* @__PURE__ */ Object.create(null);
      mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
      const urlOptions = new CaseInsensitiveMap();
      if (url2.pathname !== "/" && url2.pathname !== "") {
        const dbName = decodeURIComponent(url2.pathname[0] === "/" ? url2.pathname.slice(1) : url2.pathname);
        if (dbName) {
          urlOptions.set("dbName", [dbName]);
        }
      }
      if (url2.username !== "") {
        const auth = {
          username: decodeURIComponent(url2.username)
        };
        if (typeof url2.password === "string") {
          auth.password = decodeURIComponent(url2.password);
        }
        urlOptions.set("auth", [auth]);
      }
      for (const key of url2.searchParams.keys()) {
        const values = url2.searchParams.getAll(key);
        const isReadPreferenceTags = /readPreferenceTags/i.test(key);
        if (!isReadPreferenceTags && values.length > 1) {
          throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
        }
        if (!isReadPreferenceTags && values.includes("")) {
          throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
        }
        if (!urlOptions.has(key)) {
          urlOptions.set(key, values);
        }
      }
      const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
      if (urlOptions.has("serverApi")) {
        throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
      }
      const uriMechanismProperties = urlOptions.get("authMechanismProperties");
      if (uriMechanismProperties) {
        for (const property2 of uriMechanismProperties) {
          if (/(^|,)ALLOWED_HOSTS:/.test(property2)) {
            throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
          }
        }
      }
      if (objectOptions.has("loadBalanced")) {
        throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
      }
      const allProvidedOptions = new CaseInsensitiveMap();
      const allProvidedKeys = /* @__PURE__ */ new Set([...urlOptions.keys(), ...objectOptions.keys()]);
      for (const key of allProvidedKeys) {
        const values = [];
        const objectOptionValue = objectOptions.get(key);
        if (objectOptionValue != null) {
          values.push(objectOptionValue);
        }
        const urlValues = urlOptions.get(key) ?? [];
        values.push(...urlValues);
        allProvidedOptions.set(key, values);
      }
      if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
        const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
        if (new Set(tlsAndSslOpts).size !== 1) {
          throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
        }
      }
      checkTLSOptions(allProvidedOptions);
      const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map((s) => s.toLowerCase()));
      if (unsupportedOptions.size !== 0) {
        const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
        const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
        throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
      }
      for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
        const values = allProvidedOptions.get(key);
        if (!values || values.length === 0) {
          if (exports.DEFAULT_OPTIONS.has(key)) {
            setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
          }
        } else {
          const { deprecated } = descriptor;
          if (deprecated) {
            const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
            (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
          }
          setOption(mongoOptions, key, descriptor, values);
        }
      }
      if (mongoOptions.credentials) {
        const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
        const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
        const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
        const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
        if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
          throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '$external'`);
        }
        if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
          mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
            source: mongoOptions.dbName
          });
        }
        if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
          throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
        }
        mongoOptions.credentials.validate();
        if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
          delete mongoOptions.credentials;
        }
      }
      if (!mongoOptions.dbName) {
        mongoOptions.dbName = "test";
      }
      validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
      if (mongoClient && mongoOptions.autoEncryption) {
        encrypter_1.Encrypter.checkForMongoCrypt();
        mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
        mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
      }
      mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
      mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
      if (isSRV) {
        mongoOptions.srvHost = hosts[0];
        if (mongoOptions.directConnection) {
          throw new error_1.MongoAPIError("SRV URI does not support directConnection");
        }
        if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
        }
        const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
        const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
        if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
          mongoOptions.tls = true;
        }
      } else {
        const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
        if (userSpecifiedSrvOptions) {
          throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
        }
      }
      if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
        throw new error_1.MongoParseError("directConnection option requires exactly one host");
      }
      if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
        throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
      }
      if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
        throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
      }
      const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
      if (proxyOptions.some((options2) => options2.length > 1)) {
        throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
      }
      mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions({
        MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
        MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
        MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
        MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
        MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
        MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
        MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
        MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
      }, {
        mongodbLogPath: mongoOptions.mongodbLogPath,
        mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
        mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
      });
      mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
      mongoOptions.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(mongoOptions.metadata).then(void 0, utils_1.squashError);
      return mongoOptions;
    }
    function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
      if (mongoOptions.loadBalanced) {
        if (hosts.length > 1) {
          throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
        }
        if (mongoOptions.replicaSet) {
          throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
        }
        if (mongoOptions.directConnection) {
          throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
        }
        if (isSrv && mongoOptions.srvMaxHosts > 0) {
          throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
        }
      }
      return;
    }
    function setOption(mongoOptions, key, descriptor, values) {
      const { target, type, transform } = descriptor;
      const name = target ?? key;
      switch (type) {
        case "boolean":
          mongoOptions[name] = getBoolean(name, values[0]);
          break;
        case "int":
          mongoOptions[name] = getIntFromOptions(name, values[0]);
          break;
        case "uint":
          mongoOptions[name] = getUIntFromOptions(name, values[0]);
          break;
        case "string":
          if (values[0] == null) {
            break;
          }
          mongoOptions[name] = String(values[0]);
          break;
        case "record":
          if (!(0, utils_1.isRecord)(values[0])) {
            throw new error_1.MongoParseError(`${name} must be an object`);
          }
          mongoOptions[name] = values[0];
          break;
        case "any":
          mongoOptions[name] = values[0];
          break;
        default: {
          if (!transform) {
            throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
          }
          const transformValue = transform({ name, options: mongoOptions, values });
          mongoOptions[name] = transformValue;
          break;
        }
      }
    }
    exports.OPTIONS = {
      appName: {
        type: "string"
      },
      auth: {
        target: "credentials",
        transform({ name, options, values: [value] }) {
          if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
            throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            username: value.username,
            password: value.password
          });
        }
      },
      authMechanism: {
        target: "credentials",
        transform({ options, values: [value] }) {
          const mechanisms = Object.values(providers_1.AuthMechanism);
          const [mechanism] = mechanisms.filter((m) => m.match(RegExp(String.raw`\b${value}\b`, "i")));
          if (!mechanism) {
            throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
          }
          let source = options.credentials?.source;
          if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
            source = "$external";
          }
          let password = options.credentials?.password;
          if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
            password = void 0;
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            mechanism,
            source,
            password
          });
        }
      },
      // Note that if the authMechanismProperties contain a TOKEN_RESOURCE that has a
      // comma in it, it MUST be supplied as a MongoClient option instead of in the
      // connection string.
      authMechanismProperties: {
        target: "credentials",
        transform({ options, values }) {
          let mechanismProperties = /* @__PURE__ */ Object.create(null);
          for (const optionValue of values) {
            if (typeof optionValue === "string") {
              for (const [key, value] of entriesFromString(optionValue)) {
                try {
                  mechanismProperties[key] = getBoolean(key, value);
                } catch {
                  mechanismProperties[key] = value;
                }
              }
            } else {
              if (!(0, utils_1.isRecord)(optionValue)) {
                throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
              }
              mechanismProperties = { ...optionValue };
            }
          }
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
            mechanismProperties
          });
        }
      },
      authSource: {
        target: "credentials",
        transform({ options, values: [value] }) {
          const source = String(value);
          return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
        }
      },
      autoEncryption: {
        type: "record"
      },
      autoSelectFamily: {
        type: "boolean",
        default: true
      },
      autoSelectFamilyAttemptTimeout: {
        type: "uint"
      },
      bsonRegExp: {
        type: "boolean"
      },
      serverApi: {
        target: "serverApi",
        transform({ values: [version] }) {
          const serverApiToValidate = typeof version === "string" ? { version } : version;
          const versionToValidate = serverApiToValidate && serverApiToValidate.version;
          if (!versionToValidate) {
            throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
            throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
          }
          return serverApiToValidate;
        }
      },
      checkKeys: {
        type: "boolean"
      },
      compressors: {
        default: "none",
        target: "compressors",
        transform({ values }) {
          const compressionList = /* @__PURE__ */ new Set();
          for (const compVal of values) {
            const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
            if (!Array.isArray(compValArray)) {
              throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
            }
            for (const c of compValArray) {
              if (Object.keys(compression_1.Compressor).includes(String(c))) {
                compressionList.add(String(c));
              } else {
                throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
              }
            }
          }
          return [...compressionList];
        }
      },
      connectTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      dbName: {
        type: "string"
      },
      directConnection: {
        default: false,
        type: "boolean"
      },
      driverInfo: {
        default: {},
        type: "record"
      },
      enableUtf8Validation: { type: "boolean", default: true },
      family: {
        transform({ name, values: [value] }) {
          const transformValue = getIntFromOptions(name, value);
          if (transformValue === 4 || transformValue === 6) {
            return transformValue;
          }
          throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
        }
      },
      fieldsAsRaw: {
        type: "record"
      },
      forceServerObjectId: {
        default: false,
        type: "boolean"
      },
      fsync: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              fsync: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
          return wc;
        }
      },
      heartbeatFrequencyMS: {
        default: 1e4,
        type: "uint"
      },
      ignoreUndefined: {
        type: "boolean"
      },
      j: {
        deprecated: "Please use journal instead",
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      journal: {
        target: "writeConcern",
        transform({ name, options, values: [value] }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              journal: getBoolean(name, value)
            }
          });
          if (!wc)
            throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
          return wc;
        }
      },
      loadBalanced: {
        default: false,
        type: "boolean"
      },
      localThresholdMS: {
        default: 15,
        type: "uint"
      },
      maxConnecting: {
        default: 2,
        transform({ name, values: [value] }) {
          const maxConnecting = getUIntFromOptions(name, value);
          if (maxConnecting === 0) {
            throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
          }
          return maxConnecting;
        }
      },
      maxIdleTimeMS: {
        default: 0,
        type: "uint"
      },
      maxPoolSize: {
        default: 100,
        type: "uint"
      },
      maxStalenessSeconds: {
        target: "readPreference",
        transform({ name, options, values: [value] }) {
          const maxStalenessSeconds = getUIntFromOptions(name, value);
          if (options.readPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, maxStalenessSeconds }
            });
          } else {
            return new read_preference_1.ReadPreference("secondary", void 0, { maxStalenessSeconds });
          }
        }
      },
      minInternalBufferSize: {
        type: "uint"
      },
      minPoolSize: {
        default: 0,
        type: "uint"
      },
      minHeartbeatFrequencyMS: {
        default: 500,
        type: "uint"
      },
      monitorCommands: {
        default: false,
        type: "boolean"
      },
      name: {
        target: "driverInfo",
        transform({ values: [value], options }) {
          return { ...options.driverInfo, name: String(value) };
        }
      },
      noDelay: {
        default: true,
        type: "boolean"
      },
      pkFactory: {
        default: utils_1.DEFAULT_PK_FACTORY,
        transform({ values: [value] }) {
          if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
            return value;
          }
          throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
        }
      },
      promoteBuffers: {
        type: "boolean"
      },
      promoteLongs: {
        type: "boolean"
      },
      promoteValues: {
        type: "boolean"
      },
      useBigInt64: {
        type: "boolean"
      },
      proxyHost: {
        type: "string"
      },
      proxyPassword: {
        type: "string"
      },
      proxyPort: {
        type: "uint"
      },
      proxyUsername: {
        type: "string"
      },
      raw: {
        default: false,
        type: "boolean"
      },
      readConcern: {
        transform({ values: [value], options }) {
          if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
            return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
          }
          throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
        }
      },
      readConcernLevel: {
        target: "readConcern",
        transform({ values: [level2], options }) {
          return read_concern_1.ReadConcern.fromOptions({
            ...options.readConcern,
            level: level2
          });
        }
      },
      readPreference: {
        default: read_preference_1.ReadPreference.primary,
        transform({ values: [value], options }) {
          if (value instanceof read_preference_1.ReadPreference) {
            return read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, ...value },
              ...value
            });
          }
          if ((0, utils_1.isRecord)(value, ["mode"])) {
            const rp = read_preference_1.ReadPreference.fromOptions({
              readPreference: { ...options.readPreference, ...value },
              ...value
            });
            if (rp)
              return rp;
            else
              throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
          }
          if (typeof value === "string") {
            const rpOpts = {
              hedge: options.readPreference?.hedge,
              maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
            };
            return new read_preference_1.ReadPreference(value, options.readPreference?.tags, rpOpts);
          }
          throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
        }
      },
      readPreferenceTags: {
        target: "readPreference",
        transform({ values, options }) {
          const tags = Array.isArray(values[0]) ? values[0] : values;
          const readPreferenceTags = [];
          for (const tag of tags) {
            const readPreferenceTag = /* @__PURE__ */ Object.create(null);
            if (typeof tag === "string") {
              for (const [k, v] of entriesFromString(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            if ((0, utils_1.isRecord)(tag)) {
              for (const [k, v] of Object.entries(tag)) {
                readPreferenceTag[k] = v;
              }
            }
            readPreferenceTags.push(readPreferenceTag);
          }
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: options.readPreference,
            readPreferenceTags
          });
        }
      },
      replicaSet: {
        type: "string"
      },
      retryReads: {
        default: true,
        type: "boolean"
      },
      retryWrites: {
        default: true,
        type: "boolean"
      },
      serializeFunctions: {
        type: "boolean"
      },
      serverMonitoringMode: {
        default: "auto",
        transform({ values: [value] }) {
          if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
            throw new error_1.MongoParseError("serverMonitoringMode must be one of `auto`, `poll`, or `stream`");
          }
          return value;
        }
      },
      serverSelectionTimeoutMS: {
        default: 3e4,
        type: "uint"
      },
      servername: {
        type: "string"
      },
      socketTimeoutMS: {
        // TODO(NODE-6491): deprecated: 'Please use timeoutMS instead',
        default: 0,
        type: "uint"
      },
      srvMaxHosts: {
        type: "uint",
        default: 0
      },
      srvServiceName: {
        type: "string",
        default: "mongodb"
      },
      ssl: {
        target: "tls",
        type: "boolean"
      },
      timeoutMS: {
        type: "uint"
      },
      tls: {
        type: "boolean"
      },
      tlsAllowInvalidCertificates: {
        target: "rejectUnauthorized",
        transform({ name, values: [value] }) {
          return !getBoolean(name, value);
        }
      },
      tlsAllowInvalidHostnames: {
        target: "checkServerIdentity",
        transform({ name, values: [value] }) {
          return getBoolean(name, value) ? () => void 0 : void 0;
        }
      },
      tlsCAFile: {
        type: "string"
      },
      tlsCRLFile: {
        type: "string"
      },
      tlsCertificateKeyFile: {
        type: "string"
      },
      tlsCertificateKeyFilePassword: {
        target: "passphrase",
        type: "any"
      },
      tlsInsecure: {
        transform({ name, options, values: [value] }) {
          const tlsInsecure = getBoolean(name, value);
          if (tlsInsecure) {
            options.checkServerIdentity = () => void 0;
            options.rejectUnauthorized = false;
          } else {
            options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => void 0 : void 0;
            options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
          }
          return tlsInsecure;
        }
      },
      w: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
        }
      },
      waitQueueTimeoutMS: {
        // TODO(NODE-6491): deprecated: 'Please use timeoutMS instead',
        default: 0,
        type: "uint"
      },
      writeConcern: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options.writeConcern,
                ...value
              }
            });
          } else if (value === "majority" || typeof value === "number") {
            return write_concern_1.WriteConcern.fromOptions({
              writeConcern: {
                ...options.writeConcern,
                w: value
              }
            });
          }
          throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
        }
      },
      wtimeout: {
        deprecated: "Please use wtimeoutMS instead",
        target: "writeConcern",
        transform({ values: [value], options }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              wtimeout: getUIntFromOptions("wtimeout", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      wtimeoutMS: {
        target: "writeConcern",
        transform({ values: [value], options }) {
          const wc = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
            }
          });
          if (wc)
            return wc;
          throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
        }
      },
      zlibCompressionLevel: {
        default: 0,
        type: "int"
      },
      mongodbLogPath: {
        transform({ values: [value] }) {
          if (!(typeof value === "string" && ["stderr", "stdout"].includes(value) || value && typeof value === "object" && "write" in value && typeof value.write === "function")) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable`);
          }
          return value;
        }
      },
      mongodbLogComponentSeverities: {
        transform({ values: [value] }) {
          if (typeof value !== "object" || !value) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' must be a non-null object`);
          }
          for (const [k, v] of Object.entries(value)) {
            if (typeof v !== "string" || typeof k !== "string") {
              throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value`);
            }
            if (!Object.values(mongo_logger_1.MongoLoggableComponent).some((val) => val === k) && k !== "default") {
              throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' contains invalid key: ${k}`);
            }
            if (!Object.values(mongo_logger_1.SeverityLevel).some((val) => val === v)) {
              throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' does not support ${v} as a value for ${k}`);
            }
          }
          return value;
        }
      },
      mongodbLogMaxDocumentLength: { type: "uint" },
      // Custom types for modifying core behavior
      connectionType: { type: "any" },
      srvPoller: { type: "any" },
      // Accepted Node.js Options
      allowPartialTrustChain: { type: "any" },
      minDHSize: { type: "any" },
      pskCallback: { type: "any" },
      secureContext: { type: "any" },
      enableTrace: { type: "any" },
      requestCert: { type: "any" },
      rejectUnauthorized: { type: "any" },
      checkServerIdentity: { type: "any" },
      ALPNProtocols: { type: "any" },
      SNICallback: { type: "any" },
      session: { type: "any" },
      requestOCSP: { type: "any" },
      localAddress: { type: "any" },
      localPort: { type: "any" },
      hints: { type: "any" },
      lookup: { type: "any" },
      ca: { type: "any" },
      cert: { type: "any" },
      ciphers: { type: "any" },
      crl: { type: "any" },
      ecdhCurve: { type: "any" },
      key: { type: "any" },
      passphrase: { type: "any" },
      pfx: { type: "any" },
      secureProtocol: { type: "any" },
      index: { type: "any" },
      // Legacy options from v3 era
      useNewUrlParser: {
        type: "boolean",
        deprecated: "useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
      },
      useUnifiedTopology: {
        type: "boolean",
        deprecated: "useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
      },
      __skipPingOnConnect: { type: "boolean" }
    };
    exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_aws.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoDBAWS = void 0;
    var BSON = require_bson2();
    var deps_1 = require_deps();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    var aws_temporary_credentials_1 = require_aws_temporary_credentials();
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var ASCII_N = 110;
    var bsonOptions = {
      useBigInt64: false,
      promoteLongs: true,
      promoteValues: true,
      promoteBuffers: false,
      bsonRegExp: false
    };
    var MongoDBAWS = class extends auth_provider_1.AuthProvider {
      constructor(credentialProvider) {
        super();
        this.credentialProvider = credentialProvider;
        this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled ? new aws_temporary_credentials_1.AWSSDKCredentialProvider(credentialProvider) : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider();
      }
      async auth(authContext) {
        const { connection } = authContext;
        if (!authContext.credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        if ("kModuleError" in deps_1.aws4) {
          throw deps_1.aws4["kModuleError"];
        }
        const { sign: sign2 } = deps_1.aws4;
        if ((0, utils_1.maxWireVersion)(connection) < 9) {
          throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
        }
        if (!authContext.credentials.username) {
          authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);
        }
        const { credentials } = authContext;
        const accessKeyId = credentials.username;
        const secretAccessKey = credentials.password;
        const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : void 0;
        const db = credentials.source;
        const nonce = await (0, utils_1.randomBytes)(32);
        const saslStart = {
          saslStart: 1,
          mechanism: "MONGODB-AWS",
          payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
        };
        const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, void 0);
        const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
        const host = serverResponse.h;
        const serverNonce = serverResponse.s.buffer;
        if (serverNonce.length !== 64) {
          throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
        }
        if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
          throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
        }
        if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
          throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
        }
        const body3 = "Action=GetCallerIdentity&Version=2011-06-15";
        const options = sign2({
          method: "POST",
          host,
          region: deriveRegion(serverResponse.h),
          service: "sts",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Content-Length": body3.length,
            "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
            "X-MongoDB-GS2-CB-Flag": "n"
          },
          path: "/",
          body: body3
        }, awsCredentials);
        const payload = {
          a: options.headers.Authorization,
          d: options.headers["X-Amz-Date"]
        };
        if (sessionToken) {
          payload.t = sessionToken;
        }
        const saslContinue = {
          saslContinue: 1,
          conversationId: saslStartResponse.conversationId,
          payload: BSON.serialize(payload, bsonOptions)
        };
        await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, void 0);
      }
    };
    exports.MongoDBAWS = MongoDBAWS;
    async function makeTempCredentials(credentials, awsCredentialFetcher) {
      function makeMongoCredentialsFromAWSTemp(creds) {
        if (!creds.AccessKeyId || !creds.SecretAccessKey) {
          throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
        }
        return new mongo_credentials_1.MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: providers_1.AuthMechanism.MONGODB_AWS,
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        });
      }
      const temporaryCredentials = await awsCredentialFetcher.getCredentials();
      return makeMongoCredentialsFromAWSTemp(temporaryCredentials);
    }
    function deriveRegion(host) {
      const parts = host.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js
var require_command_builders = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finishCommandDocument = finishCommandDocument;
    exports.startCommandDocument = startCommandDocument;
    var bson_1 = require_bson2();
    var providers_1 = require_providers();
    function finishCommandDocument(token, conversationId) {
      if (conversationId != null) {
        return {
          saslContinue: 1,
          conversationId,
          payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
        };
      }
      return {
        saslStart: 1,
        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    function startCommandDocument(credentials) {
      const payload = {};
      if (credentials.username) {
        payload.n = credentials.username;
      }
      return {
        saslStart: 1,
        autoAuthorize: 1,
        mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
        payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
      };
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/machine_workflow.js
var require_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/machine_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MachineWorkflow = void 0;
    var promises_1 = __require("timers/promises");
    var utils_1 = require_utils();
    var command_builders_1 = require_command_builders();
    var THROTTLE_MS = 100;
    var MachineWorkflow = class {
      /**
       * Instantiate the machine workflow.
       */
      constructor(cache) {
        this.cache = cache;
        this.callback = this.withLock(this.getToken.bind(this));
        this.lastExecutionTime = Date.now() - THROTTLE_MS;
      }
      /**
       * Execute the workflow. Gets the token from the subclass implementation.
       */
      async execute(connection, credentials) {
        const token = await this.getTokenFromCacheOrEnv(connection, credentials);
        const command = (0, command_builders_1.finishCommandDocument)(token);
        await connection.command((0, utils_1.ns)(credentials.source), command, void 0);
      }
      /**
       * Reauthenticate on a machine workflow just grabs the token again since the server
       * has said the current access token is invalid or expired.
       */
      async reauthenticate(connection, credentials) {
        if (this.cache.hasAccessToken) {
          if (connection.accessToken === this.cache.getAccessToken()) {
            this.cache.removeAccessToken();
            delete connection.accessToken;
          } else {
            connection.accessToken = this.cache.getAccessToken();
          }
        }
        await this.execute(connection, credentials);
      }
      /**
       * Get the document to add for speculative authentication.
       */
      async speculativeAuth(connection, credentials) {
        if (!this.cache.hasAccessToken) {
          return {};
        }
        const token = await this.getTokenFromCacheOrEnv(connection, credentials);
        const document2 = (0, command_builders_1.finishCommandDocument)(token);
        document2.db = credentials.source;
        return { speculativeAuthenticate: document2 };
      }
      /**
       * Get the token from the cache or environment.
       */
      async getTokenFromCacheOrEnv(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const token = this.cache.getAccessToken();
          if (!connection.accessToken) {
            connection.accessToken = token;
          }
          return token;
        } else {
          const token = await this.callback(credentials);
          this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });
          connection.accessToken = token.access_token;
          return token.access_token;
        }
      }
      /**
       * Ensure the callback is only executed one at a time, and throttled to
       * only once per 100ms.
       */
      withLock(callback) {
        let lock = Promise.resolve();
        return async (credentials) => {
          await lock;
          lock = lock.catch(() => null).then(async () => {
            const difference = Date.now() - this.lastExecutionTime;
            if (difference <= THROTTLE_MS) {
              await (0, promises_1.setTimeout)(THROTTLE_MS - difference);
            }
            this.lastExecutionTime = Date.now();
            return await callback(credentials);
          });
          return await lock;
        };
      }
    };
    exports.MachineWorkflow = MachineWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js
var require_azure_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AzureMachineWorkflow = void 0;
    var azure_1 = require_azure();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var machine_workflow_1 = require_machine_workflow();
    var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
    var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.";
    var AzureMachineWorkflow = class extends machine_workflow_1.MachineWorkflow {
      /**
       * Instantiate the machine workflow.
       */
      constructor(cache) {
        super(cache);
      }
      /**
       * Get the token from the environment.
       */
      async getToken(credentials) {
        const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
        const username = credentials?.username;
        if (!tokenAudience) {
          throw new error_1.MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);
        }
        const response = await getAzureTokenData(tokenAudience, username);
        if (!isEndpointResultValid(response)) {
          throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
        }
        return response;
      }
    };
    exports.AzureMachineWorkflow = AzureMachineWorkflow;
    async function getAzureTokenData(tokenAudience, username) {
      const url2 = new URL(azure_1.AZURE_BASE_URL);
      (0, azure_1.addAzureParams)(url2, tokenAudience, username);
      const response = await (0, utils_1.get)(url2, {
        headers: AZURE_HEADERS
      });
      if (response.status !== 200) {
        throw new error_1.MongoAzureError(`Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`);
      }
      const result = JSON.parse(response.body);
      return {
        access_token: result.access_token,
        expires_in: Number(result.expires_in)
      };
    }
    function isEndpointResultValid(token) {
      if (token == null || typeof token !== "object")
        return false;
      return "access_token" in token && typeof token.access_token === "string" && "expires_in" in token && typeof token.expires_in === "number";
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js
var require_gcp_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GCPMachineWorkflow = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var machine_workflow_1 = require_machine_workflow();
    var GCP_BASE_URL = "http://metadata/computeMetadata/v1/instance/service-accounts/default/identity";
    var GCP_HEADERS = Object.freeze({ "Metadata-Flavor": "Google" });
    var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.";
    var GCPMachineWorkflow = class extends machine_workflow_1.MachineWorkflow {
      /**
       * Instantiate the machine workflow.
       */
      constructor(cache) {
        super(cache);
      }
      /**
       * Get the token from the environment.
       */
      async getToken(credentials) {
        const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
        if (!tokenAudience) {
          throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
        }
        return await getGcpTokenData(tokenAudience);
      }
    };
    exports.GCPMachineWorkflow = GCPMachineWorkflow;
    async function getGcpTokenData(tokenAudience) {
      const url2 = new URL(GCP_BASE_URL);
      url2.searchParams.append("audience", tokenAudience);
      const response = await (0, utils_1.get)(url2, {
        headers: GCP_HEADERS
      });
      if (response.status !== 200) {
        throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
      }
      return { access_token: response.body };
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js
var require_k8s_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.K8SMachineWorkflow = void 0;
    var promises_1 = __require("fs/promises");
    var machine_workflow_1 = require_machine_workflow();
    var FALLBACK_FILENAME = "/var/run/secrets/kubernetes.io/serviceaccount/token";
    var AZURE_FILENAME = "AZURE_FEDERATED_TOKEN_FILE";
    var AWS_FILENAME = "AWS_WEB_IDENTITY_TOKEN_FILE";
    var K8SMachineWorkflow = class extends machine_workflow_1.MachineWorkflow {
      /**
       * Instantiate the machine workflow.
       */
      constructor(cache) {
        super(cache);
      }
      /**
       * Get the token from the environment.
       */
      async getToken() {
        let filename;
        if (process.env[AZURE_FILENAME]) {
          filename = process.env[AZURE_FILENAME];
        } else if (process.env[AWS_FILENAME]) {
          filename = process.env[AWS_FILENAME];
        } else {
          filename = FALLBACK_FILENAME;
        }
        const token = await (0, promises_1.readFile)(filename, "utf8");
        return { access_token: token };
      }
    };
    exports.K8SMachineWorkflow = K8SMachineWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js
var require_token_cache = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenCache = void 0;
    var error_1 = require_error();
    var MongoOIDCError = class extends error_1.MongoDriverError {
    };
    var TokenCache = class {
      get hasAccessToken() {
        return !!this.accessToken;
      }
      get hasRefreshToken() {
        return !!this.refreshToken;
      }
      get hasIdpInfo() {
        return !!this.idpInfo;
      }
      getAccessToken() {
        if (!this.accessToken) {
          throw new MongoOIDCError("Attempted to get an access token when none exists.");
        }
        return this.accessToken;
      }
      getRefreshToken() {
        if (!this.refreshToken) {
          throw new MongoOIDCError("Attempted to get a refresh token when none exists.");
        }
        return this.refreshToken;
      }
      getIdpInfo() {
        if (!this.idpInfo) {
          throw new MongoOIDCError("Attempted to get IDP information when none exists.");
        }
        return this.idpInfo;
      }
      put(response, idpInfo) {
        this.accessToken = response.accessToken;
        this.refreshToken = response.refreshToken;
        this.expiresInSeconds = response.expiresInSeconds;
        if (idpInfo) {
          this.idpInfo = idpInfo;
        }
      }
      removeAccessToken() {
        this.accessToken = void 0;
      }
      removeRefreshToken() {
        this.refreshToken = void 0;
      }
    };
    exports.TokenCache = TokenCache;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js
var require_token_machine_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenMachineWorkflow = void 0;
    var fs2 = __require("fs");
    var error_1 = require_error();
    var machine_workflow_1 = require_machine_workflow();
    var TOKEN_MISSING_ERROR = "OIDC_TOKEN_FILE must be set in the environment.";
    var TokenMachineWorkflow = class extends machine_workflow_1.MachineWorkflow {
      /**
       * Instantiate the machine workflow.
       */
      constructor(cache) {
        super(cache);
      }
      /**
       * Get the token from the environment.
       */
      async getToken() {
        const tokenFile = process.env.OIDC_TOKEN_FILE;
        if (!tokenFile) {
          throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
        }
        const token = await fs2.promises.readFile(tokenFile, "utf8");
        return { access_token: token };
      }
    };
    exports.TokenMachineWorkflow = TokenMachineWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = exports.OIDC_VERSION = void 0;
    var error_1 = require_error();
    var auth_provider_1 = require_auth_provider();
    var azure_machine_workflow_1 = require_azure_machine_workflow();
    var gcp_machine_workflow_1 = require_gcp_machine_workflow();
    var k8s_machine_workflow_1 = require_k8s_machine_workflow();
    var token_cache_1 = require_token_cache();
    var token_machine_workflow_1 = require_token_machine_workflow();
    var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
    exports.OIDC_VERSION = 1;
    exports.OIDC_WORKFLOWS = /* @__PURE__ */ new Map();
    exports.OIDC_WORKFLOWS.set("test", () => new token_machine_workflow_1.TokenMachineWorkflow(new token_cache_1.TokenCache()));
    exports.OIDC_WORKFLOWS.set("azure", () => new azure_machine_workflow_1.AzureMachineWorkflow(new token_cache_1.TokenCache()));
    exports.OIDC_WORKFLOWS.set("gcp", () => new gcp_machine_workflow_1.GCPMachineWorkflow(new token_cache_1.TokenCache()));
    exports.OIDC_WORKFLOWS.set("k8s", () => new k8s_machine_workflow_1.K8SMachineWorkflow(new token_cache_1.TokenCache()));
    var MongoDBOIDC = class extends auth_provider_1.AuthProvider {
      /**
       * Instantiate the auth provider.
       */
      constructor(workflow) {
        super();
        if (!workflow) {
          throw new error_1.MongoInvalidArgumentError("No workflow provided to the OIDC auth provider.");
        }
        this.workflow = workflow;
      }
      /**
       * Authenticate using OIDC
       */
      async auth(authContext) {
        const { connection, reauthenticating, response } = authContext;
        if (response?.speculativeAuthenticate?.done && !reauthenticating) {
          return;
        }
        const credentials = getCredentials(authContext);
        if (reauthenticating) {
          await this.workflow.reauthenticate(connection, credentials);
        } else {
          await this.workflow.execute(connection, credentials, response);
        }
      }
      /**
       * Add the speculative auth for the initial handshake.
       */
      async prepare(handshakeDoc, authContext) {
        const { connection } = authContext;
        const credentials = getCredentials(authContext);
        const result = await this.workflow.speculativeAuth(connection, credentials);
        return { ...handshakeDoc, ...result };
      }
    };
    exports.MongoDBOIDC = MongoDBOIDC;
    function getCredentials(authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
      }
      return credentials;
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallbackWorkflow = exports.AUTOMATED_TIMEOUT_MS = exports.HUMAN_TIMEOUT_MS = void 0;
    var promises_1 = __require("timers/promises");
    var error_1 = require_error();
    var utils_1 = require_utils();
    var command_builders_1 = require_command_builders();
    exports.HUMAN_TIMEOUT_MS = 3e5;
    exports.AUTOMATED_TIMEOUT_MS = 6e4;
    var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
    var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";
    var THROTTLE_MS = 100;
    var CallbackWorkflow = class {
      /**
       * Instantiate the callback workflow.
       */
      constructor(cache, callback) {
        this.cache = cache;
        this.callback = this.withLock(callback);
        this.lastExecutionTime = Date.now() - THROTTLE_MS;
      }
      /**
       * Get the document to add for speculative authentication. This also needs
       * to add a db field from the credentials source.
       */
      async speculativeAuth(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const accessToken = this.cache.getAccessToken();
          connection.accessToken = accessToken;
          const document2 = (0, command_builders_1.finishCommandDocument)(accessToken);
          document2.db = credentials.source;
          return { speculativeAuthenticate: document2 };
        }
        return {};
      }
      /**
       * Reauthenticate the callback workflow. For this we invalidated the access token
       * in the cache and run the authentication steps again. No initial handshake needs
       * to be sent.
       */
      async reauthenticate(connection, credentials) {
        if (this.cache.hasAccessToken) {
          if (connection.accessToken === this.cache.getAccessToken()) {
            this.cache.removeAccessToken();
            delete connection.accessToken;
          } else {
            connection.accessToken = this.cache.getAccessToken();
          }
        }
        await this.execute(connection, credentials);
      }
      /**
       * Starts the callback authentication process. If there is a speculative
       * authentication document from the initial handshake, then we will use that
       * value to get the issuer, otherwise we will send the saslStart command.
       */
      async startAuthentication(connection, credentials, response) {
        let result;
        if (response?.speculativeAuthenticate) {
          result = response.speculativeAuthenticate;
        } else {
          result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), void 0);
        }
        return result;
      }
      /**
       * Finishes the callback authentication process.
       */
      async finishAuthentication(connection, credentials, token, conversationId) {
        await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), void 0);
      }
      /**
       * Executes the callback and validates the output.
       */
      async executeAndValidateCallback(params) {
        const result = await this.callback(params);
        if (isCallbackResultInvalid(result)) {
          throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
        }
        return result;
      }
      /**
       * Ensure the callback is only executed one at a time and throttles the calls
       * to every 100ms.
       */
      withLock(callback) {
        let lock = Promise.resolve();
        return async (params) => {
          await lock;
          lock = lock.catch(() => null).then(async () => {
            const difference = Date.now() - this.lastExecutionTime;
            if (difference <= THROTTLE_MS) {
              await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
            }
            this.lastExecutionTime = Date.now();
            return await callback(params);
          });
          return await lock;
        };
      }
    };
    exports.CallbackWorkflow = CallbackWorkflow;
    function isCallbackResultInvalid(tokenResult) {
      if (tokenResult == null || typeof tokenResult !== "object")
        return true;
      if (!("accessToken" in tokenResult))
        return true;
      return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js
var require_automated_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutomatedCallbackWorkflow = void 0;
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var callback_workflow_1 = require_callback_workflow();
    var AutomatedCallbackWorkflow = class extends callback_workflow_1.CallbackWorkflow {
      /**
       * Instantiate the human callback workflow.
       */
      constructor(cache, callback) {
        super(cache, callback);
      }
      /**
       * Execute the OIDC callback workflow.
       */
      async execute(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const token = this.cache.getAccessToken();
          try {
            return await this.finishAuthentication(connection, credentials, token);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeAccessToken();
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        const response = await this.fetchAccessToken(credentials);
        this.cache.put(response);
        connection.accessToken = response.accessToken;
        await this.finishAuthentication(connection, credentials, response.accessToken);
      }
      /**
       * Fetches the access token using the callback.
       */
      async fetchAccessToken(credentials) {
        const controller = new AbortController();
        const params = {
          timeoutContext: controller.signal,
          version: mongodb_oidc_1.OIDC_VERSION
        };
        if (credentials.username) {
          params.username = credentials.username;
        }
        const timeout = timeout_1.Timeout.expires(callback_workflow_1.AUTOMATED_TIMEOUT_MS);
        try {
          return await Promise.race([this.executeAndValidateCallback(params), timeout]);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            controller.abort();
            throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.AUTOMATED_TIMEOUT_MS}ms.`);
          }
          throw error2;
        } finally {
          timeout.clear();
        }
      }
    };
    exports.AutomatedCallbackWorkflow = AutomatedCallbackWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js
var require_human_callback_workflow = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HumanCallbackWorkflow = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var callback_workflow_1 = require_callback_workflow();
    var HumanCallbackWorkflow = class extends callback_workflow_1.CallbackWorkflow {
      /**
       * Instantiate the human callback workflow.
       */
      constructor(cache, callback) {
        super(cache, callback);
      }
      /**
       * Execute the OIDC human callback workflow.
       */
      async execute(connection, credentials) {
        if (this.cache.hasAccessToken) {
          const token = this.cache.getAccessToken();
          connection.accessToken = token;
          try {
            return await this.finishAuthentication(connection, credentials, token);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeAccessToken();
              delete connection.accessToken;
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        if (this.cache.hasRefreshToken) {
          const refreshToken = this.cache.getRefreshToken();
          const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);
          this.cache.put(result);
          connection.accessToken = result.accessToken;
          try {
            return await this.finishAuthentication(connection, credentials, result.accessToken);
          } catch (error2) {
            if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
              this.cache.removeRefreshToken();
              delete connection.accessToken;
              return await this.execute(connection, credentials);
            } else {
              throw error2;
            }
          }
        }
        const startResponse = await this.startAuthentication(connection, credentials);
        const conversationId = startResponse.conversationId;
        const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);
        const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);
        this.cache.put(callbackResponse, idpInfo);
        connection.accessToken = callbackResponse.accessToken;
        return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);
      }
      /**
       * Fetches an access token using the callback.
       */
      async fetchAccessToken(idpInfo, credentials, refreshToken) {
        const controller = new AbortController();
        const params = {
          timeoutContext: controller.signal,
          version: mongodb_oidc_1.OIDC_VERSION,
          idpInfo
        };
        if (credentials.username) {
          params.username = credentials.username;
        }
        if (refreshToken) {
          params.refreshToken = refreshToken;
        }
        const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);
        try {
          return await Promise.race([this.executeAndValidateCallback(params), timeout]);
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            controller.abort();
            throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);
          }
          throw error2;
        } finally {
          timeout.clear();
        }
      }
    };
    exports.HumanCallbackWorkflow = HumanCallbackWorkflow;
  }
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/plain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Plain = void 0;
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    var Plain = class extends auth_provider_1.AuthProvider {
      async auth(authContext) {
        const { connection, credentials } = authContext;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const { username, password } = credentials;
        const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        await connection.command((0, utils_1.ns)("$external.$cmd"), command, void 0);
      }
    };
    exports.Plain = Plain;
  }
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/index.js"(exports, module) {
    "use strict";
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
      const mapping2space = non_ASCII_space_characters;
      const mapping2nothing = commonly_mapped_to_nothing;
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module.exports = saslprep;
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports, module) {
    module.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager)) return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page) {
      while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
        page.deduplicate++;
        if (page.deduplicate === this.deduplicate.length) {
          page.deduplicate = 0;
          if (page.buffer.equals && page.buffer.equals(this.deduplicate)) page.buffer = this.deduplicate;
          break;
        }
      }
      if (page.updated || !this.updates) return;
      page.updated = true;
      this.updates.push(page);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length) return null;
      var page = this.updates.pop();
      page.updated = false;
      return page;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate) return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate) return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page = arr && arr[first];
      if (!page && !noAllocate) {
        page = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length) this.length = i + 1;
      }
      if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page.buffer = copy(page.buffer);
        page.deduplicate = 0;
      }
      return page;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length) this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page) page.buffer = b;
      else arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list = new Array(this.length);
      var empty = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list.length; i++) {
          list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
        }
      }
      return Buffer.concat(list);
    };
    function grow(pager, index) {
      while (pager.maxPages < index) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len) return buf;
      if (buf.length > len) return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc) return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports, module) {
    var pager = require_memory_pager();
    module.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield)) return new Bitfield(opts);
      if (!opts) opts = {};
      if (Buffer.isBuffer(opts)) opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize)) throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, true);
      return page ? page.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all3 = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next) next.buffer.copy(all3, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all3;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page = this.pages.get(j, false);
      o += this.pageOffset;
      if (page.buffer[o] === b) return false;
      page.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates) this.pages.updated(page);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc) return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/memory-code-points.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoryCodePoints = createMemoryCodePoints;
    var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
    function createMemoryCodePoints(data) {
      let offset = 0;
      function read() {
        const size = data.readUInt32BE(offset);
        offset += 4;
        const codepoints = data.slice(offset, offset + size);
        offset += size;
        return (0, sparse_bitfield_1.default)({ buffer: codepoints });
      }
      const unassigned_code_points = read();
      const commonly_mapped_to_nothing = read();
      const non_ASCII_space_characters = read();
      const prohibited_characters = read();
      const bidirectional_r_al = read();
      const bidirectional_l = read();
      return {
        unassigned_code_points,
        commonly_mapped_to_nothing,
        non_ASCII_space_characters,
        prohibited_characters,
        bidirectional_r_al,
        bidirectional_l
      };
    }
  }
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/code-points-data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var zlib_1 = __require("zlib");
    exports.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA", "base64"));
  }
});

// node_modules/@mongodb-js/saslprep/dist/node.js
var require_node2 = __commonJS({
  "node_modules/@mongodb-js/saslprep/dist/node.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var index_1 = __importDefault(require_dist2());
    var memory_code_points_1 = require_memory_code_points();
    var code_points_data_1 = __importDefault(require_code_points_data());
    var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
    function saslprep(input, opts) {
      return (0, index_1.default)(codePoints, input, opts);
    }
    saslprep.saslprep = saslprep;
    saslprep.default = saslprep;
    module.exports = saslprep;
  }
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/scram.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScramSHA256 = exports.ScramSHA1 = void 0;
    var saslprep_1 = require_node2();
    var crypto7 = __require("crypto");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    var providers_1 = require_providers();
    var ScramSHA = class extends auth_provider_1.AuthProvider {
      constructor(cryptoMethod) {
        super();
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      async prepare(handshakeDoc, authContext) {
        const cryptoMethod = this.cryptoMethod;
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const nonce = await (0, utils_1.randomBytes)(24);
        authContext.nonce = nonce;
        const request = {
          ...handshakeDoc,
          speculativeAuthenticate: {
            ...makeFirstMessage(cryptoMethod, credentials, nonce),
            db: credentials.source
          }
        };
        return request;
      }
      async auth(authContext) {
        const { reauthenticating, response } = authContext;
        if (response?.speculativeAuthenticate && !reauthenticating) {
          return await continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
        }
        return await executeScram(this.cryptoMethod, authContext);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer.concat([
        Buffer.from("n=", "utf8"),
        Buffer.from(username, "utf8"),
        Buffer.from(",r=", "utf8"),
        Buffer.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
      return {
        saslStart: 1,
        mechanism,
        payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    async function executeScram(cryptoMethod, authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if (!authContext.nonce) {
        throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      const response = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, void 0);
      await continueScramConversation(cryptoMethod, response, authContext);
    }
    async function continueScramConversation(cryptoMethod, response, authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if (!authContext.nonce) {
        throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
      }
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      const processedPassword = cryptoMethod === "sha256" ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
      const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
      const dict = parsePayload(payload);
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.toString("utf8"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new bson_1.Binary(Buffer.from(clientFinal))
      };
      const r = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, void 0);
      const parsedResponse = parsePayload(r.payload);
      if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
        throw new error_1.MongoRuntimeError("Server returned an invalid signature");
      }
      if (r.done !== false) {
        return;
      }
      const retrySaslContinueCmd = {
        saslContinue: 1,
        conversationId: r.conversationId,
        payload: Buffer.alloc(0)
      };
      await connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, void 0);
    }
    function parsePayload(payload) {
      const payloadStr = payload.toString("utf8");
      const dict = {};
      const parts = payloadStr.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new error_1.MongoInvalidArgumentError("Username must be a string");
      }
      if (typeof password !== "string") {
        throw new error_1.MongoInvalidArgumentError("Password must be a string");
      }
      if (password.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
      }
      let md5;
      try {
        md5 = crypto7.createHash("md5");
      } catch (err) {
        if (crypto7.getFips()) {
          throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
        }
        throw err;
      }
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer.isBuffer(a)) {
        a = Buffer.from(a);
      }
      if (!Buffer.isBuffer(b)) {
        b = Buffer.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto7.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto7.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] != null) {
        return _hiCache[key];
      }
      const saltedData = crypto7.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto7.timingSafeEqual === "function") {
        return crypto7.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor() {
        super("sha1");
      }
    };
    exports.ScramSHA1 = ScramSHA1;
    var ScramSHA256 = class extends ScramSHA {
      constructor() {
        super("sha256");
      }
    };
    exports.ScramSHA256 = ScramSHA256;
  }
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/cmap/auth/x509.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.X509 = void 0;
    var error_1 = require_error();
    var utils_1 = require_utils();
    var auth_provider_1 = require_auth_provider();
    var X509 = class extends auth_provider_1.AuthProvider {
      async prepare(handshakeDoc, authContext) {
        const { credentials } = authContext;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
      }
      async auth(authContext) {
        const connection = authContext.connection;
        const credentials = authContext.credentials;
        if (!credentials) {
          throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
        }
        const response = authContext.response;
        if (response?.speculativeAuthenticate) {
          return;
        }
        await connection.command((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), void 0);
      }
    };
    exports.X509 = X509;
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        command.user = credentials.username;
      }
      return command;
    }
  }
});

// node_modules/mongodb/lib/mongo_client_auth_providers.js
var require_mongo_client_auth_providers = __commonJS({
  "node_modules/mongodb/lib/mongo_client_auth_providers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoClientAuthProviders = void 0;
    var gssapi_1 = require_gssapi();
    var mongodb_aws_1 = require_mongodb_aws();
    var mongodb_oidc_1 = require_mongodb_oidc();
    var automated_callback_workflow_1 = require_automated_callback_workflow();
    var human_callback_workflow_1 = require_human_callback_workflow();
    var token_cache_1 = require_token_cache();
    var plain_1 = require_plain();
    var providers_1 = require_providers();
    var scram_1 = require_scram();
    var x509_1 = require_x509();
    var error_1 = require_error();
    var AUTH_PROVIDERS = /* @__PURE__ */ new Map([
      [
        providers_1.AuthMechanism.MONGODB_AWS,
        ({ AWS_CREDENTIAL_PROVIDER }) => new mongodb_aws_1.MongoDBAWS(AWS_CREDENTIAL_PROVIDER)
      ],
      [
        providers_1.AuthMechanism.MONGODB_CR,
        () => {
          throw new error_1.MongoInvalidArgumentError("MONGODB-CR is no longer a supported auth mechanism in MongoDB 4.0+");
        }
      ],
      [providers_1.AuthMechanism.MONGODB_GSSAPI, () => new gssapi_1.GSSAPI()],
      [providers_1.AuthMechanism.MONGODB_OIDC, (properties) => new mongodb_oidc_1.MongoDBOIDC(getWorkflow(properties))],
      [providers_1.AuthMechanism.MONGODB_PLAIN, () => new plain_1.Plain()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, () => new scram_1.ScramSHA1()],
      [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, () => new scram_1.ScramSHA256()],
      [providers_1.AuthMechanism.MONGODB_X509, () => new x509_1.X509()]
    ]);
    var MongoClientAuthProviders = class {
      constructor() {
        this.existingProviders = /* @__PURE__ */ new Map();
      }
      /**
       * Get or create an authentication provider based on the provided mechanism.
       * We don't want to create all providers at once, as some providers may not be used.
       * @param name - The name of the provider to get or create.
       * @param credentials - The credentials.
       * @returns The provider.
       * @throws MongoInvalidArgumentError if the mechanism is not supported.
       * @internal
       */
      getOrCreateProvider(name, authMechanismProperties) {
        const authProvider = this.existingProviders.get(name);
        if (authProvider) {
          return authProvider;
        }
        const providerFunction = AUTH_PROVIDERS.get(name);
        if (!providerFunction) {
          throw new error_1.MongoInvalidArgumentError(`authMechanism ${name} not supported`);
        }
        const provider = providerFunction(authMechanismProperties);
        this.existingProviders.set(name, provider);
        return provider;
      }
    };
    exports.MongoClientAuthProviders = MongoClientAuthProviders;
    function getWorkflow(authMechanismProperties) {
      if (authMechanismProperties.OIDC_HUMAN_CALLBACK) {
        return new human_callback_workflow_1.HumanCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_HUMAN_CALLBACK);
      } else if (authMechanismProperties.OIDC_CALLBACK) {
        return new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache(), authMechanismProperties.OIDC_CALLBACK);
      } else {
        const environment = authMechanismProperties.ENVIRONMENT;
        const workflow = mongodb_oidc_1.OIDC_WORKFLOWS.get(environment)?.();
        if (!workflow) {
          throw new error_1.MongoInvalidArgumentError(`Could not load workflow for environment ${authMechanismProperties.ENVIRONMENT}`);
        }
        return workflow;
      }
    }
  }
});

// node_modules/mongodb/lib/beta.js
var require_beta = __commonJS({
  "node_modules/mongodb/lib/beta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_lib4(), exports);
    function __exportStar(mod) {
      for (const key of Object.keys(mod)) {
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function() {
            return mod[key];
          }
        });
      }
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js
var require_client_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientBulkWriteOperation = void 0;
    var beta_1 = require_beta();
    var responses_1 = require_responses();
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ClientBulkWriteOperation = class extends command_1.CommandOperation {
      get commandName() {
        return "bulkWrite";
      }
      constructor(commandBuilder, options) {
        super(void 0, options);
        this.commandBuilder = commandBuilder;
        this.options = options;
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      resetBatch() {
        return this.commandBuilder.resetBatch();
      }
      get canRetryWrite() {
        return this.commandBuilder.isBatchRetryable;
      }
      /**
       * Execute the command. Superclass will handle write concern, etc.
       * @param server - The server.
       * @param session - The session.
       * @returns The response.
       */
      async execute(server2, session, timeoutContext) {
        let command;
        if (server2.description.type === beta_1.ServerType.LoadBalancer) {
          if (session) {
            let connection;
            if (!session.pinnedConnection) {
              connection = await server2.pool.checkOut({ timeoutContext });
              session.pin(connection);
            } else {
              connection = session.pinnedConnection;
            }
            command = this.commandBuilder.buildBatch(connection.hello?.maxMessageSizeBytes, connection.hello?.maxWriteBatchSize, connection.hello?.maxBsonObjectSize);
          } else {
            throw new beta_1.MongoClientBulkWriteExecutionError("Session provided to the client bulk write operation must be present.");
          }
        } else {
          if (!server2.description.maxWriteBatchSize || !server2.description.maxMessageSizeBytes || !server2.description.maxBsonObjectSize) {
            throw new beta_1.MongoClientBulkWriteExecutionError("In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.");
          }
          command = this.commandBuilder.buildBatch(server2.description.maxMessageSizeBytes, server2.description.maxWriteBatchSize, server2.description.maxBsonObjectSize);
        }
        if (!this.canRetryWrite) {
          this.options.willRetryWrite = false;
        }
        return await super.executeCommand(server2, session, command, timeoutContext, responses_1.ClientBulkWriteCursorResponse);
      }
    };
    exports.ClientBulkWriteOperation = ClientBulkWriteOperation;
    (0, operation_1.defineAspects)(ClientBulkWriteOperation, [
      operation_1.Aspect.WRITE_OPERATION,
      operation_1.Aspect.SKIP_COLLATION,
      operation_1.Aspect.CURSOR_CREATING,
      operation_1.Aspect.RETRYABLE,
      operation_1.Aspect.COMMAND_BATCHING
    ]);
  }
});

// node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js
var require_client_bulk_write_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientBulkWriteCursor = void 0;
    var client_bulk_write_1 = require_client_bulk_write();
    var execute_operation_1 = require_execute_operation();
    var utils_1 = require_utils();
    var abstract_cursor_1 = require_abstract_cursor();
    var ClientBulkWriteCursor = class _ClientBulkWriteCursor extends abstract_cursor_1.AbstractCursor {
      /** @internal */
      constructor(client, commandBuilder, options = {}) {
        super(client, new utils_1.MongoDBNamespace("admin", "$cmd"), options);
        this.commandBuilder = commandBuilder;
        this.clientBulkWriteOptions = options;
      }
      /**
       * We need a way to get the top level cursor response fields for
       * generating the bulk write result, so we expose this here.
       */
      get response() {
        if (this.cursorResponse)
          return this.cursorResponse;
        return null;
      }
      get operations() {
        return this.commandBuilder.lastOperations;
      }
      clone() {
        const clonedOptions = (0, utils_1.mergeOptions)({}, this.clientBulkWriteOptions);
        delete clonedOptions.session;
        return new _ClientBulkWriteCursor(this.client, this.commandBuilder, {
          ...clonedOptions
        });
      }
      /** @internal */
      async _initialize(session) {
        const clientBulkWriteOperation = new client_bulk_write_1.ClientBulkWriteOperation(this.commandBuilder, {
          ...this.clientBulkWriteOptions,
          ...this.cursorOptions,
          session
        });
        const response = await (0, execute_operation_1.executeOperation)(this.client, clientBulkWriteOperation, this.timeoutContext);
        this.cursorResponse = response;
        return { server: clientBulkWriteOperation.server, session, response };
      }
    };
    exports.ClientBulkWriteCursor = ClientBulkWriteCursor;
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js
var require_command_builder = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = void 0;
    exports.buildOperation = buildOperation;
    var bson_1 = require_bson2();
    var commands_1 = require_commands();
    var error_1 = require_error();
    var utils_1 = require_utils();
    var MESSAGE_OVERHEAD_BYTES = 1e3;
    var ClientBulkWriteCommandBuilder = class {
      /**
       * Create the command builder.
       * @param models - The client write models.
       */
      constructor(models, options, pkFactory) {
        this.models = models;
        this.options = options;
        this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
        this.currentModelIndex = 0;
        this.previousModelIndex = 0;
        this.lastOperations = [];
        this.isBatchRetryable = true;
      }
      /**
       * Gets the errorsOnly value for the command, which is the inverse of the
       * user provided verboseResults option. Defaults to true.
       */
      get errorsOnly() {
        if ("verboseResults" in this.options) {
          return !this.options.verboseResults;
        }
        return true;
      }
      /**
       * Determines if there is another batch to process.
       * @returns True if not all batches have been built.
       */
      hasNextBatch() {
        return this.currentModelIndex < this.models.length;
      }
      /**
       * When we need to retry a command we need to set the current
       * model index back to its previous value.
       */
      resetBatch() {
        this.currentModelIndex = this.previousModelIndex;
        return true;
      }
      /**
       * Build a single batch of a client bulk write command.
       * @param maxMessageSizeBytes - The max message size in bytes.
       * @param maxWriteBatchSize - The max write batch size.
       * @returns The client bulk write command.
       */
      buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {
        this.isBatchRetryable = true;
        let commandLength = 0;
        let currentNamespaceIndex = 0;
        const command = this.baseCommand();
        const namespaces = /* @__PURE__ */ new Map();
        this.previousModelIndex = this.currentModelIndex;
        while (this.currentModelIndex < this.models.length) {
          const model5 = this.models[this.currentModelIndex];
          const ns = model5.namespace;
          const nsIndex = namespaces.get(ns);
          if (model5.name === "deleteMany" || model5.name === "updateMany") {
            this.isBatchRetryable = false;
          }
          if (nsIndex != null) {
            const operation = buildOperation(model5, nsIndex, this.pkFactory);
            let operationBuffer;
            try {
              operationBuffer = bson_1.BSON.serialize(operation);
            } catch (cause) {
              throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
            }
            validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
            if (commandLength + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
              commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
              this.currentModelIndex++;
            } else {
              break;
            }
          } else {
            namespaces.set(ns, currentNamespaceIndex);
            const nsInfo = { ns };
            const operation = buildOperation(model5, currentNamespaceIndex, this.pkFactory);
            let nsInfoBuffer;
            let operationBuffer;
            try {
              nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
              operationBuffer = bson_1.BSON.serialize(operation);
            } catch (cause) {
              throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
            }
            validateBufferSize("nsInfo", nsInfoBuffer, maxBsonObjectSize);
            validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
            if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
              commandLength = MESSAGE_OVERHEAD_BYTES + command.nsInfo.push(nsInfo, nsInfoBuffer) + command.ops.push(operation, operationBuffer);
              currentNamespaceIndex++;
              this.currentModelIndex++;
            } else {
              break;
            }
          }
        }
        this.lastOperations = command.ops.documents;
        return command;
      }
      baseCommand() {
        const command = {
          bulkWrite: 1,
          errorsOnly: this.errorsOnly,
          ordered: this.options.ordered ?? true,
          ops: new commands_1.DocumentSequence("ops"),
          nsInfo: new commands_1.DocumentSequence("nsInfo")
        };
        if (this.options.bypassDocumentValidation != null) {
          command.bypassDocumentValidation = this.options.bypassDocumentValidation;
        }
        if (this.options.let) {
          command.let = this.options.let;
        }
        if (this.options.comment !== void 0) {
          command.comment = this.options.comment;
        }
        return command;
      }
    };
    exports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
    function validateBufferSize(name, buffer, maxBsonObjectSize) {
      if (buffer.length > maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);
      }
    }
    var buildInsertOneOperation = (model5, index, pkFactory) => {
      const document2 = {
        insert: index,
        document: model5.document
      };
      document2.document._id = model5.document._id ?? pkFactory.createPk();
      return document2;
    };
    exports.buildInsertOneOperation = buildInsertOneOperation;
    var buildDeleteOneOperation = (model5, index) => {
      return createDeleteOperation(model5, index, false);
    };
    exports.buildDeleteOneOperation = buildDeleteOneOperation;
    var buildDeleteManyOperation = (model5, index) => {
      return createDeleteOperation(model5, index, true);
    };
    exports.buildDeleteManyOperation = buildDeleteManyOperation;
    function createDeleteOperation(model5, index, multi) {
      const document2 = {
        delete: index,
        multi,
        filter: model5.filter
      };
      if (model5.hint) {
        document2.hint = model5.hint;
      }
      if (model5.collation) {
        document2.collation = model5.collation;
      }
      return document2;
    }
    var buildUpdateOneOperation = (model5, index) => {
      return createUpdateOperation(model5, index, false);
    };
    exports.buildUpdateOneOperation = buildUpdateOneOperation;
    var buildUpdateManyOperation = (model5, index) => {
      return createUpdateOperation(model5, index, true);
    };
    exports.buildUpdateManyOperation = buildUpdateManyOperation;
    function validateUpdate(update) {
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoAPIError("Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.");
      }
    }
    function createUpdateOperation(model5, index, multi) {
      validateUpdate(model5.update);
      const document2 = {
        update: index,
        multi,
        filter: model5.filter,
        updateMods: model5.update
      };
      if (model5.hint) {
        document2.hint = model5.hint;
      }
      if (model5.upsert) {
        document2.upsert = model5.upsert;
      }
      if (model5.arrayFilters) {
        document2.arrayFilters = model5.arrayFilters;
      }
      if (model5.collation) {
        document2.collation = model5.collation;
      }
      return document2;
    }
    var buildReplaceOneOperation = (model5, index) => {
      if ((0, utils_1.hasAtomicOperators)(model5.replacement)) {
        throw new error_1.MongoAPIError("Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.");
      }
      const document2 = {
        update: index,
        multi: false,
        filter: model5.filter,
        updateMods: model5.replacement
      };
      if (model5.hint) {
        document2.hint = model5.hint;
      }
      if (model5.upsert) {
        document2.upsert = model5.upsert;
      }
      if (model5.collation) {
        document2.collation = model5.collation;
      }
      return document2;
    };
    exports.buildReplaceOneOperation = buildReplaceOneOperation;
    function buildOperation(model5, index, pkFactory) {
      switch (model5.name) {
        case "insertOne":
          return (0, exports.buildInsertOneOperation)(model5, index, pkFactory);
        case "deleteOne":
          return (0, exports.buildDeleteOneOperation)(model5, index);
        case "deleteMany":
          return (0, exports.buildDeleteManyOperation)(model5, index);
        case "updateOne":
          return (0, exports.buildUpdateOneOperation)(model5, index);
        case "updateMany":
          return (0, exports.buildUpdateManyOperation)(model5, index);
        case "replaceOne":
          return (0, exports.buildReplaceOneOperation)(model5, index);
      }
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js
var require_results_merger = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientBulkWriteResultsMerger = void 0;
    var __1 = require_lib4();
    var error_1 = require_error();
    var UNACKNOWLEDGED = {
      acknowledged: false,
      insertedCount: 0,
      upsertedCount: 0,
      matchedCount: 0,
      modifiedCount: 0,
      deletedCount: 0,
      insertResults: void 0,
      updateResults: void 0,
      deleteResults: void 0
    };
    var ClientBulkWriteResultsMerger = class {
      /**
       * @returns The standard unacknowledged bulk write result.
       */
      static unacknowledged() {
        return UNACKNOWLEDGED;
      }
      /**
       * Instantiate the merger.
       * @param options - The options.
       */
      constructor(options) {
        this.options = options;
        this.currentBatchOffset = 0;
        this.writeConcernErrors = [];
        this.writeErrors = /* @__PURE__ */ new Map();
        this.result = {
          acknowledged: true,
          insertedCount: 0,
          upsertedCount: 0,
          matchedCount: 0,
          modifiedCount: 0,
          deletedCount: 0,
          insertResults: void 0,
          updateResults: void 0,
          deleteResults: void 0
        };
        if (options.verboseResults) {
          this.result.insertResults = /* @__PURE__ */ new Map();
          this.result.updateResults = /* @__PURE__ */ new Map();
          this.result.deleteResults = /* @__PURE__ */ new Map();
        }
      }
      /**
       * Get the bulk write result object.
       */
      get bulkWriteResult() {
        return {
          acknowledged: this.result.acknowledged,
          insertedCount: this.result.insertedCount,
          upsertedCount: this.result.upsertedCount,
          matchedCount: this.result.matchedCount,
          modifiedCount: this.result.modifiedCount,
          deletedCount: this.result.deletedCount,
          insertResults: this.result.insertResults,
          updateResults: this.result.updateResults,
          deleteResults: this.result.deleteResults
        };
      }
      /**
       * Merge the results in the cursor to the existing result.
       * @param currentBatchOffset - The offset index to the original models.
       * @param response - The cursor response.
       * @param documents - The documents in the cursor.
       * @returns The current result.
       */
      async merge(cursor) {
        let writeConcernErrorResult;
        try {
          for await (const document2 of cursor) {
            if (document2.ok === 1) {
              if (this.options.verboseResults) {
                this.processDocument(cursor, document2);
              }
            } else {
              if (this.options.ordered) {
                const error2 = new error_1.MongoClientBulkWriteError({
                  message: "Mongo client ordered bulk write encountered a write error."
                });
                error2.writeErrors.set(document2.idx + this.currentBatchOffset, {
                  code: document2.code,
                  message: document2.errmsg
                });
                error2.partialResult = this.result;
                throw error2;
              } else {
                this.writeErrors.set(document2.idx + this.currentBatchOffset, {
                  code: document2.code,
                  message: document2.errmsg
                });
              }
            }
          }
        } catch (error2) {
          if (error2 instanceof __1.MongoWriteConcernError) {
            const result = error2.result;
            writeConcernErrorResult = {
              insertedCount: result.nInserted,
              upsertedCount: result.nUpserted,
              matchedCount: result.nMatched,
              modifiedCount: result.nModified,
              deletedCount: result.nDeleted,
              writeConcernError: result.writeConcernError
            };
            if (this.options.verboseResults && result.cursor.firstBatch) {
              for (const document2 of result.cursor.firstBatch) {
                if (document2.ok === 1) {
                  this.processDocument(cursor, document2);
                }
              }
            }
          } else {
            throw error2;
          }
        } finally {
          if (cursor.response) {
            const response = cursor.response;
            this.incrementCounts(response);
          }
          this.currentBatchOffset += cursor.operations.length;
        }
        if (writeConcernErrorResult) {
          const writeConcernError = writeConcernErrorResult.writeConcernError;
          this.incrementCounts(writeConcernErrorResult);
          this.writeConcernErrors.push({
            code: writeConcernError.code,
            message: writeConcernError.errmsg
          });
        }
        return this.result;
      }
      /**
       * Process an individual document in the results.
       * @param cursor - The cursor.
       * @param document - The document to process.
       */
      processDocument(cursor, document2) {
        const operation = cursor.operations[document2.idx];
        if ("insert" in operation) {
          this.result.insertResults?.set(document2.idx + this.currentBatchOffset, {
            insertedId: operation.document._id
          });
        }
        if ("update" in operation) {
          const result = {
            matchedCount: document2.n,
            modifiedCount: document2.nModified ?? 0,
            // Check if the bulk did actually upsert.
            didUpsert: document2.upserted != null
          };
          if (document2.upserted) {
            result.upsertedId = document2.upserted._id;
          }
          this.result.updateResults?.set(document2.idx + this.currentBatchOffset, result);
        }
        if ("delete" in operation) {
          this.result.deleteResults?.set(document2.idx + this.currentBatchOffset, {
            deletedCount: document2.n
          });
        }
      }
      /**
       * Increment the result counts.
       * @param document - The document with the results.
       */
      incrementCounts(document2) {
        this.result.insertedCount += document2.insertedCount;
        this.result.upsertedCount += document2.upsertedCount;
        this.result.matchedCount += document2.matchedCount;
        this.result.modifiedCount += document2.modifiedCount;
        this.result.deletedCount += document2.deletedCount;
      }
    };
    exports.ClientBulkWriteResultsMerger = ClientBulkWriteResultsMerger;
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/executor.js
var require_executor = __commonJS({
  "node_modules/mongodb/lib/operations/client_bulk_write/executor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientBulkWriteExecutor = void 0;
    var abstract_cursor_1 = require_abstract_cursor();
    var client_bulk_write_cursor_1 = require_client_bulk_write_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var execute_operation_1 = require_execute_operation();
    var client_bulk_write_1 = require_client_bulk_write();
    var command_builder_1 = require_command_builder();
    var results_merger_1 = require_results_merger();
    var ClientBulkWriteExecutor = class {
      /**
       * Instantiate the executor.
       * @param client - The mongo client.
       * @param operations - The user supplied bulk write models.
       * @param options - The bulk write options.
       */
      constructor(client, operations, options) {
        if (operations.length === 0) {
          throw new error_1.MongoClientBulkWriteExecutionError("No client bulk write models were provided.");
        }
        this.client = client;
        this.operations = operations;
        this.options = {
          ordered: true,
          bypassDocumentValidation: false,
          verboseResults: false,
          ...options
        };
        if (!this.options.writeConcern) {
          this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.s.options);
        }
        if (this.options.writeConcern?.w === 0) {
          if (this.options.verboseResults) {
            throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and verbose results");
          }
          if (this.options.ordered) {
            throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and ordered writes");
          }
        }
      }
      /**
       * Execute the client bulk write. Will split commands into batches and exhaust the cursors
       * for each, then merge the results into one.
       * @returns The result.
       */
      async execute() {
        const pkFactory = this.client.s.options.pkFactory;
        const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);
        const resolvedOptions = (0, utils_1.resolveTimeoutOptions)(this.client, this.options);
        const context = timeout_1.TimeoutContext.create(resolvedOptions);
        if (this.options.writeConcern?.w === 0) {
          while (commandBuilder.hasNextBatch()) {
            const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);
            await (0, execute_operation_1.executeOperation)(this.client, operation, context);
          }
          return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();
        } else {
          const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);
          while (commandBuilder.hasNextBatch()) {
            const cursorContext = new abstract_cursor_1.CursorTimeoutContext(context, Symbol());
            const options = {
              ...this.options,
              timeoutContext: cursorContext,
              ...resolvedOptions.timeoutMS != null && { timeoutMode: abstract_cursor_1.CursorTimeoutMode.LIFETIME }
            };
            const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, options);
            try {
              await resultsMerger.merge(cursor);
            } catch (error2) {
              if (error2 instanceof error_1.MongoServerError && !(error2 instanceof error_1.MongoClientBulkWriteError)) {
                const bulkWriteError = new error_1.MongoClientBulkWriteError({
                  message: "Mongo client bulk write encountered an error during execution"
                });
                bulkWriteError.cause = error2;
                bulkWriteError.partialResult = resultsMerger.bulkWriteResult;
                throw bulkWriteError;
              } else {
                throw error2;
              }
            }
          }
          if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {
            const error2 = new error_1.MongoClientBulkWriteError({
              message: "Mongo client bulk write encountered errors during execution."
            });
            error2.writeConcernErrors = resultsMerger.writeConcernErrors;
            error2.writeErrors = resultsMerger.writeErrors;
            error2.partialResult = resultsMerger.bulkWriteResult;
            throw error2;
          }
          return resultsMerger.bulkWriteResult;
        }
      }
    };
    exports.ClientBulkWriteExecutor = ClientBulkWriteExecutor;
  }
});

// node_modules/mongodb/lib/sdam/server_selection_events.js
var require_server_selection_events = __commonJS({
  "node_modules/mongodb/lib/sdam/server_selection_events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionEvent = void 0;
    var utils_1 = require_utils();
    var constants_1 = require_constants2();
    var ServerSelectionEvent = class {
      /** @internal */
      constructor(selector, topologyDescription, operation) {
        this.selector = selector;
        this.operation = operation;
        this.topologyDescription = topologyDescription;
      }
    };
    exports.ServerSelectionEvent = ServerSelectionEvent;
    var ServerSelectionStartedEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_STARTED;
        this.message = "Server selection started";
      }
    };
    exports.ServerSelectionStartedEvent = ServerSelectionStartedEvent;
    var ServerSelectionFailedEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, error2, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_FAILED;
        this.message = "Server selection failed";
        this.failure = error2;
      }
    };
    exports.ServerSelectionFailedEvent = ServerSelectionFailedEvent;
    var ServerSelectionSucceededEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, address, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.SERVER_SELECTION_SUCCEEDED;
        this.message = "Server selection succeeded";
        const { host, port } = utils_1.HostAddress.fromString(address).toHostPort();
        this.serverHost = host;
        this.serverPort = port;
      }
    };
    exports.ServerSelectionSucceededEvent = ServerSelectionSucceededEvent;
    var WaitingForSuitableServerEvent = class extends ServerSelectionEvent {
      /** @internal */
      constructor(selector, topologyDescription, remainingTimeMS, operation) {
        super(selector, topologyDescription, operation);
        this.name = constants_1.WAITING_FOR_SUITABLE_SERVER;
        this.message = "Waiting for suitable server to become available";
        this.remainingTimeMS = remainingTimeMS;
      }
    };
    exports.WaitingForSuitableServerEvent = WaitingForSuitableServerEvent;
  }
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/sdam/srv_polling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SrvPoller = exports.SrvPollingEvent = void 0;
    var dns = __require("dns");
    var timers_1 = __require("timers");
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var utils_1 = require_utils();
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      hostnames() {
        return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
      }
    };
    exports.SrvPollingEvent = SrvPollingEvent;
    var SrvPoller = class _SrvPoller extends mongo_types_1.TypedEventEmitter {
      constructor(options) {
        super();
        this.on("error", utils_1.noop);
        if (!options || !options.srvHost) {
          throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options.srvHost;
        this.srvMaxHosts = options.srvMaxHosts ?? 0;
        this.srvServiceName = options.srvServiceName ?? "mongodb";
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e4;
        this.haMode = false;
        this.generation = 0;
        this._timeout = void 0;
      }
      get srvAddress() {
        return `_${this.srvServiceName}._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
          this.generation += 1;
          this._timeout = void 0;
        }
      }
      // TODO(NODE-4994): implement new logging logic for SrvPoller failures
      schedule() {
        if (this._timeout) {
          (0, timers_1.clearTimeout)(this._timeout);
        }
        this._timeout = (0, timers_1.setTimeout)(() => {
          this._poll().then(void 0, utils_1.squashError);
        }, this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit(_SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
      }
      failure() {
        this.haMode = true;
        this.schedule();
      }
      async _poll() {
        const generation = this.generation;
        let srvRecords;
        try {
          srvRecords = await dns.promises.resolveSrv(this.srvAddress);
        } catch {
          this.failure();
          return;
        }
        if (generation !== this.generation) {
          return;
        }
        const finalAddresses = [];
        for (const record of srvRecords) {
          try {
            (0, utils_1.checkParentDomainMatch)(record.name, this.srvHost);
            finalAddresses.push(record);
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
        if (!finalAddresses.length) {
          this.failure();
          return;
        }
        this.success(finalAddresses);
      }
    };
    exports.SrvPoller = SrvPoller;
    SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
  }
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/sdam/topology.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerCapabilities = exports.Topology = void 0;
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants2();
    var error_1 = require_error();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var read_preference_1 = require_read_preference();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var common_1 = require_common();
    var events_1 = require_events();
    var server_1 = require_server();
    var server_description_1 = require_server_description();
    var server_selection_1 = require_server_selection();
    var server_selection_events_1 = require_server_selection_events();
    var srv_polling_1 = require_srv_polling();
    var topology_description_1 = require_topology_description();
    var globalTopologyCounter = 0;
    var stateTransition = (0, utils_1.makeStateMachine)({
      [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
      [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
      [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
      [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
    });
    var Topology = class _Topology extends mongo_types_1.TypedEventEmitter {
      /**
       * @param seedlist - a list of HostAddress instances to connect to
       */
      constructor(client, seeds, options) {
        super();
        this.on("error", utils_1.noop);
        this.client = client;
        options = options ?? {
          hosts: [utils_1.HostAddress.fromString("localhost:27017")],
          ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())
        };
        if (typeof seeds === "string") {
          seeds = [utils_1.HostAddress.fromString(seeds)];
        } else if (!Array.isArray(seeds)) {
          seeds = [seeds];
        }
        const seedlist = [];
        for (const seed of seeds) {
          if (typeof seed === "string") {
            seedlist.push(utils_1.HostAddress.fromString(seed));
          } else if (seed instanceof utils_1.HostAddress) {
            seedlist.push(seed);
          } else {
            throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
          }
        }
        const topologyType = topologyTypeFromOptions(options);
        const topologyId = globalTopologyCounter++;
        const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
        const serverDescriptions = /* @__PURE__ */ new Map();
        for (const hostAddress of selectedHosts) {
          serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
        }
        this.waitQueue = new utils_1.List();
        this.s = {
          // the id of this topology
          id: topologyId,
          // passed in options
          options,
          // initial seedlist of servers to connect to
          seedlist,
          // initial state
          state: common_1.STATE_CLOSED,
          // the topology description
          description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, void 0, void 0, void 0, options),
          serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
          // a map of server instances to normalized addresses
          servers: /* @__PURE__ */ new Map(),
          credentials: options?.credentials,
          clusterTime: void 0,
          detectShardedTopology: (ev) => this.detectShardedTopology(ev),
          detectSrvRecords: (ev) => this.detectSrvRecords(ev)
        };
        this.mongoLogger = client.mongoLogger;
        this.component = "topology";
        if (options.srvHost && !options.loadBalanced) {
          this.s.srvPoller = options.srvPoller ?? new srv_polling_1.SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options.srvHost,
            srvMaxHosts: options.srvMaxHosts,
            srvServiceName: options.srvServiceName
          });
          this.on(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        }
        this.connectionLock = void 0;
      }
      detectShardedTopology(event) {
        const previousType = event.previousDescription.type;
        const newType = event.newDescription.type;
        const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
        const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
        const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
        if (transitionToSharded && !listeningToSrvPolling) {
          this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
          this.s.srvPoller?.start();
        }
      }
      detectSrvRecords(ev) {
        const previousTopologyDescription = this.s.description;
        this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
        if (this.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(this);
        this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
      /**
       * @returns A `TopologyDescription` for this topology
       */
      get description() {
        return this.s.description;
      }
      get loadBalanced() {
        return this.s.options.loadBalanced;
      }
      get serverApi() {
        return this.s.options.serverApi;
      }
      get capabilities() {
        return new ServerCapabilities(this.lastHello());
      }
      /** Initiate server connect */
      async connect(options) {
        this.connectionLock ?? (this.connectionLock = this._connect(options));
        try {
          await this.connectionLock;
          return this;
        } finally {
          this.connectionLock = void 0;
        }
      }
      async _connect(options) {
        options = options ?? {};
        if (this.s.state === common_1.STATE_CONNECTED) {
          return this;
        }
        stateTransition(this, common_1.STATE_CONNECTING);
        this.emitAndLog(_Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
        this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(
          this.s.id,
          new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown),
          // initial is always Unknown
          this.s.description
        ));
        const serverDescriptions = Array.from(this.s.description.servers.values());
        this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
          serverDescription.address,
          createAndConnectServer(this, serverDescription)
        ]));
        if (this.s.options.loadBalanced) {
          for (const description of serverDescriptions) {
            const newDescription = new server_description_1.ServerDescription(description.hostAddress, void 0, {
              loadBalanced: this.s.options.loadBalanced
            });
            this.serverUpdateHandler(newDescription);
          }
        }
        const serverSelectionTimeoutMS = this.client.s.options.serverSelectionTimeoutMS;
        const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
        const timeoutContext = timeout_1.TimeoutContext.create({
          // TODO(NODE-6448): auto-connect ignores timeoutMS; potential future feature
          timeoutMS: void 0,
          serverSelectionTimeoutMS,
          waitQueueTimeoutMS: this.client.s.options.waitQueueTimeoutMS
        });
        const selectServerOptions = {
          operationName: "ping",
          ...options,
          timeoutContext
        };
        try {
          const server2 = await this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), selectServerOptions);
          const skipPingOnConnect = this.s.options.__skipPingOnConnect === true;
          if (!skipPingOnConnect && this.s.credentials) {
            await server2.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, { timeoutContext });
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(_Topology.OPEN, this);
            this.emit(_Topology.CONNECT, this);
            return this;
          }
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(_Topology.OPEN, this);
          this.emit(_Topology.CONNECT, this);
          return this;
        } catch (error2) {
          this.close();
          throw error2;
        }
      }
      /** Close this topology */
      close() {
        if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
          return;
        }
        for (const server2 of this.s.servers.values()) {
          destroyServer(server2, this);
        }
        this.s.servers.clear();
        stateTransition(this, common_1.STATE_CLOSING);
        drainWaitQueue(this.waitQueue, new error_1.MongoTopologyClosedError());
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        }
        this.removeListener(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        stateTransition(this, common_1.STATE_CLOSED);
        this.emitAndLog(_Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
      }
      /**
       * Selects a server according to the selection predicate provided
       *
       * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
       * @param options - Optional settings related to server selection
       * @param callback - The callback used to indicate success or failure
       * @returns An instance of a `Server` meeting the criteria of the predicate provided
       */
      async selectServer(selector, options) {
        let serverSelector;
        if (typeof selector !== "function") {
          if (typeof selector === "string") {
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
          } else {
            let readPreference;
            if (selector instanceof read_preference_1.ReadPreference) {
              readPreference = selector;
            } else {
              read_preference_1.ReadPreference.translate(options);
              readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
            }
            serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
          }
        } else {
          serverSelector = selector;
        }
        options = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options };
        if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options.operationName));
        }
        let timeout;
        if (options.timeoutContext)
          timeout = options.timeoutContext.serverSelectionTimeout;
        else {
          timeout = timeout_1.Timeout.expires(options.serverSelectionTimeoutMS ?? 0);
        }
        const isSharded = this.description.type === common_1.TopologyType.Sharded;
        const session = options.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options.operationName));
          }
          if (options.timeoutContext?.clearServerSelectionTimeout)
            timeout?.clear();
          return transaction.server;
        }
        const { promise: serverPromise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        const waitQueueMember = {
          serverSelector,
          topologyDescription: this.description,
          mongoLogger: this.client.mongoLogger,
          transaction,
          resolve,
          reject,
          cancelled: false,
          startTime: (0, utils_1.now)(),
          operationName: options.operationName,
          waitingLogged: false,
          previousServer: options.previousServer
        };
        const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
          waitQueueMember.cancelled = true;
          reject(this.reason);
        });
        this.waitQueue.push(waitQueueMember);
        processWaitQueue(this);
        try {
          timeout?.throwIfExpired();
          const server2 = await (timeout ? Promise.race([serverPromise, timeout]) : serverPromise);
          if (options.timeoutContext?.csotEnabled() && server2.description.minRoundTripTime !== 0) {
            options.timeoutContext.minRoundTripTime = server2.description.minRoundTripTime;
          }
          return server2;
        } catch (error2) {
          if (timeout_1.TimeoutError.is(error2)) {
            waitQueueMember.cancelled = true;
            const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${timeout?.duration} ms`, this.description);
            if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
              this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options.operationName));
            }
            if (options.timeoutContext?.csotEnabled()) {
              throw new error_1.MongoOperationTimeoutError("Timed out during server selection", {
                cause: timeoutError
              });
            }
            throw timeoutError;
          }
          throw error2;
        } finally {
          abortListener?.[utils_1.kDispose]();
          if (options.timeoutContext?.clearServerSelectionTimeout)
            timeout?.clear();
        }
      }
      /**
       * Update the internal TopologyDescription with a ServerDescription
       *
       * @param serverDescription - The server to update in the internal list of server descriptions
       */
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        if (!previousServerDescription) {
          return;
        }
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          (0, common_1._advanceClusterTime)(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit(_Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          const newDescription = this.s.description.servers.get(serverDescription.address);
          if (newDescription) {
            this.emit(_Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
          }
        }
        updateServers(this, serverDescription);
        if (this.waitQueue.length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emitAndLog(_Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = void 0;
        if (typeof callback === "function")
          callback(void 0, true);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === common_1.STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === common_1.STATE_CLOSED;
      }
      // NOTE: There are many places in code where we explicitly check the last hello
      //       to do feature support detection. This should be done any other way, but for
      //       now we will just return the first hello seen, which should suffice.
      lastHello() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get commonWireVersion() {
        return this.description.commonWireVersion;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get clusterTime() {
        return this.s.clusterTime;
      }
      set clusterTime(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    };
    exports.Topology = Topology;
    Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
    Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
    Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
    Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
    Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
    Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
    Topology.ERROR = constants_1.ERROR;
    Topology.OPEN = constants_1.OPEN;
    Topology.CONNECT = constants_1.CONNECT;
    Topology.CLOSE = constants_1.CLOSE;
    Topology.TIMEOUT = constants_1.TIMEOUT;
    function destroyServer(server2, topology) {
      for (const event of constants_1.LOCAL_SERVER_EVENTS) {
        server2.removeAllListeners(event);
      }
      server2.destroy();
      topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server2.description.address));
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server2.removeAllListeners(event);
      }
    }
    function topologyTypeFromOptions(options) {
      if (options?.directConnection) {
        return common_1.TopologyType.Single;
      }
      if (options?.replicaSet) {
        return common_1.TopologyType.ReplicaSetNoPrimary;
      }
      if (options?.loadBalanced) {
        return common_1.TopologyType.LoadBalanced;
      }
      return common_1.TopologyType.Unknown;
    }
    function createAndConnectServer(topology, serverDescription) {
      topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server2 = new server_1.Server(topology, serverDescription, topology.s.options);
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server2.on(event, (e) => topology.emit(event, e));
      }
      server2.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
      server2.connect();
      return server2;
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server2 = topology.s.servers.get(incomingServerDescription.address);
        if (server2) {
          server2.s.description = incomingServerDescription;
          if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
            const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
            server2.pool.clear({ interruptInUseConnections });
          } else if (incomingServerDescription.error == null) {
            const newTopologyType = topology.s.description.type;
            const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
            if (shouldMarkPoolReady) {
              server2.pool.ready();
            }
          }
        }
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server2 = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server2);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        if (!topology.s.servers.has(serverAddress)) {
          continue;
        }
        const server2 = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        if (server2) {
          destroyServer(server2, topology);
        }
      }
    }
    function drainWaitQueue(queue, drainError) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        if (!waitQueueMember) {
          continue;
        }
        if (!waitQueueMember.cancelled) {
          if (waitQueueMember.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            waitQueueMember.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(drainError);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === common_1.STATE_CLOSED) {
        drainWaitQueue(topology.waitQueue, new error_1.MongoTopologyClosedError());
        return;
      }
      const isSharded = topology.description.type === common_1.TopologyType.Sharded;
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology.waitQueue.length;
      for (let i = 0; i < membersToProcess; ++i) {
        const waitQueueMember = topology.waitQueue.shift();
        if (!waitQueueMember) {
          continue;
        }
        if (waitQueueMember.cancelled) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          const previousServer = waitQueueMember.previousServer;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : []) : serverDescriptions;
        } catch (selectorError) {
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(selectorError);
          continue;
        }
        let selectedServer;
        if (selectedDescriptions.length === 0) {
          if (!waitQueueMember.waitingLogged) {
            if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
              topology.client.mongoLogger?.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0 ? topology.s.serverSelectionTimeoutMS - ((0, utils_1.now)() - waitQueueMember.startTime) : -1, waitQueueMember.operationName));
            }
            waitQueueMember.waitingLogged = true;
          }
          topology.waitQueue.push(waitQueueMember);
          continue;
        } else if (selectedDescriptions.length === 1) {
          selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
        } else {
          const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
          const server1 = topology.s.servers.get(descriptions[0].address);
          const server2 = topology.s.servers.get(descriptions[1].address);
          selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
        }
        if (!selectedServer) {
          const serverSelectionError = new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description);
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
          }
          waitQueueMember.reject(serverSelectionError);
          return;
        }
        const transaction = waitQueueMember.transaction;
        if (isSharded && transaction && transaction.isActive && selectedServer) {
          transaction.pinServer(selectedServer);
        }
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
        }
        waitQueueMember.resolve(selectedServer);
      }
      if (topology.waitQueue.length > 0) {
        for (const [, server2] of topology.s.servers) {
          process.nextTick(function scheduleServerCheck() {
            return server2.requestCheck();
          });
        }
      }
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription?.topologyVersion;
      return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    var ServerCapabilities = class {
      constructor(hello) {
        this.minWireVersion = hello.minWireVersion || 0;
        this.maxWireVersion = hello.maxWireVersion || 0;
      }
      get hasAggregationCursor() {
        return this.maxWireVersion >= 1;
      }
      get hasWriteCommands() {
        return this.maxWireVersion >= 2;
      }
      get hasTextSearch() {
        return this.minWireVersion >= 0;
      }
      get hasAuthCommands() {
        return this.maxWireVersion >= 1;
      }
      get hasListCollectionsCommand() {
        return this.maxWireVersion >= 3;
      }
      get hasListIndexesCommand() {
        return this.maxWireVersion >= 3;
      }
      get supportsSnapshotReads() {
        return this.maxWireVersion >= 13;
      }
      get commandsTakeWriteConcern() {
        return this.maxWireVersion >= 5;
      }
      get commandsTakeCollation() {
        return this.maxWireVersion >= 5;
      }
    };
    exports.ServerCapabilities = ServerCapabilities;
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoClient = exports.ServerApiVersion = void 0;
    var fs_1 = __require("fs");
    var bson_1 = require_bson2();
    var change_stream_1 = require_change_stream();
    var mongo_credentials_1 = require_mongo_credentials();
    var providers_1 = require_providers();
    var connection_string_1 = require_connection_string();
    var constants_1 = require_constants2();
    var db_1 = require_db();
    var error_1 = require_error();
    var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
    var mongo_logger_1 = require_mongo_logger();
    var mongo_types_1 = require_mongo_types();
    var executor_1 = require_executor();
    var execute_operation_1 = require_execute_operation();
    var run_command_1 = require_run_command();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var server_selection_1 = require_server_selection();
    var topology_1 = require_topology();
    var sessions_1 = require_sessions();
    var utils_1 = require_utils();
    exports.ServerApiVersion = Object.freeze({
      v1: "1"
    });
    var MongoClient = class extends mongo_types_1.TypedEventEmitter {
      constructor(url2, options) {
        super();
        this.on("error", utils_1.noop);
        this.options = (0, connection_string_1.parseOptions)(url2, this, options);
        const shouldSetLogger = Object.values(this.options.mongoLoggerOptions.componentSeverities).some((value) => value !== mongo_logger_1.SeverityLevel.OFF);
        this.mongoLogger = shouldSetLogger ? new mongo_logger_1.MongoLogger(this.options.mongoLoggerOptions) : void 0;
        const client = this;
        this.s = {
          url: url2,
          bsonOptions: (0, bson_1.resolveBSONOptions)(this.options),
          namespace: (0, utils_1.ns)("admin"),
          hasBeenClosed: false,
          sessionPool: new sessions_1.ServerSessionPool(this),
          activeSessions: /* @__PURE__ */ new Set(),
          activeCursors: /* @__PURE__ */ new Set(),
          authProviders: new mongo_client_auth_providers_1.MongoClientAuthProviders(),
          get options() {
            return client.options;
          },
          get readConcern() {
            return client.options.readConcern;
          },
          get writeConcern() {
            return client.options.writeConcern;
          },
          get readPreference() {
            return client.options.readPreference;
          },
          get isMongoClient() {
            return true;
          }
        };
        this.checkForNonGenuineHosts();
      }
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /** @internal */
      checkForNonGenuineHosts() {
        const documentDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
        const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this.options.srvHost);
        const cosmosDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
        const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this.options.srvHost);
        if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
          this.mongoLogger?.info("client", utils_1.DOCUMENT_DB_MSG);
        } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
          this.mongoLogger?.info("client", utils_1.COSMOS_DB_MSG);
        }
      }
      get serverApi() {
        return this.options.serverApi && Object.freeze({ ...this.options.serverApi });
      }
      /**
       * Intended for APM use only
       * @internal
       */
      get monitorCommands() {
        return this.options.monitorCommands;
      }
      set monitorCommands(value) {
        this.options.monitorCommands = value;
      }
      /** @internal */
      get autoEncrypter() {
        return this.options.autoEncrypter;
      }
      get readConcern() {
        return this.s.readConcern;
      }
      get writeConcern() {
        return this.s.writeConcern;
      }
      get readPreference() {
        return this.s.readPreference;
      }
      get bsonOptions() {
        return this.s.bsonOptions;
      }
      get timeoutMS() {
        return this.s.options.timeoutMS;
      }
      /**
       * Executes a client bulk write operation, available on server 8.0+.
       * @param models - The client bulk write models.
       * @param options - The client bulk write options.
       * @returns A ClientBulkWriteResult for acknowledged writes and ok: 1 for unacknowledged writes.
       */
      async bulkWrite(models, options) {
        if (this.autoEncrypter) {
          throw new error_1.MongoInvalidArgumentError("MongoClient bulkWrite does not currently support automatic encryption.");
        }
        return await new executor_1.ClientBulkWriteExecutor(this, models, (0, utils_1.resolveOptions)(this, options)).execute();
      }
      /**
       * Connect to MongoDB using a url
       *
       * @remarks
       * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.
       * `timeoutMS` will bound the time any operation can take before throwing a timeout error.
       * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.
       * This means the time to setup the `MongoClient` does not count against `timeoutMS`.
       * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.
       *
       * @remarks
       * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.
       * If those look ups throw a DNS Timeout error, the driver will retry the look up once.
       *
       * @see docs.mongodb.org/manual/reference/connection-string/
       */
      async connect() {
        if (this.connectionLock) {
          return await this.connectionLock;
        }
        try {
          this.connectionLock = this._connect();
          await this.connectionLock;
        } finally {
          this.connectionLock = void 0;
        }
        return this;
      }
      /**
       * Create a topology to open the connection, must be locked to avoid topology leaks in concurrency scenario.
       * Locking is enforced by the connect method.
       *
       * @internal
       */
      async _connect() {
        if (this.topology && this.topology.isConnected()) {
          return this;
        }
        const options = this.options;
        if (options.tls) {
          if (typeof options.tlsCAFile === "string") {
            options.ca ?? (options.ca = await fs_1.promises.readFile(options.tlsCAFile));
          }
          if (typeof options.tlsCRLFile === "string") {
            options.crl ?? (options.crl = await fs_1.promises.readFile(options.tlsCRLFile));
          }
          if (typeof options.tlsCertificateKeyFile === "string") {
            if (!options.key || !options.cert) {
              const contents = await fs_1.promises.readFile(options.tlsCertificateKeyFile);
              options.key ?? (options.key = contents);
              options.cert ?? (options.cert = contents);
            }
          }
        }
        if (typeof options.srvHost === "string") {
          const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
          for (const [index, host] of hosts.entries()) {
            options.hosts[index] = host;
          }
        }
        if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
          const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
          const isServiceAuth = !!options.credentials?.mechanismProperties?.ENVIRONMENT;
          if (!isServiceAuth) {
            for (const host of options.hosts) {
              if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
                throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
              }
            }
          }
        }
        this.topology = new topology_1.Topology(this, options.hosts, options);
        this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
        for (const event of constants_1.MONGO_CLIENT_EVENTS) {
          this.topology.on(event, (...args) => this.emit(event, ...args));
        }
        const topologyConnect = async () => {
          try {
            await this.topology?.connect(options);
          } catch (error2) {
            this.topology?.close();
            throw error2;
          }
        };
        if (this.autoEncrypter) {
          await this.autoEncrypter?.init();
          await topologyConnect();
          await options.encrypter.connectInternalClient();
        } else {
          await topologyConnect();
        }
        return this;
      }
      /**
       * Cleans up client-side resources used by the MongoCLient and .  This includes:
       *
       * - Closes all open, unused connections (see note).
       * - Ends all in-use sessions with {@link ClientSession#endSession|ClientSession.endSession()}.
       * - Ends all unused sessions server-side.
       * - Cleans up any resources being used for auto encryption if auto encryption is enabled.
       *
       * @remarks Any in-progress operations are not killed and any connections used by in progress operations
       * will be cleaned up lazily as operations finish.
       *
       * @param force - Force close, emitting no events
       */
      async close(force = false) {
        if (this.closeLock) {
          return await this.closeLock;
        }
        try {
          this.closeLock = this._close(force);
          await this.closeLock;
        } finally {
          this.closeLock = void 0;
        }
      }
      /* @internal */
      async _close(force = false) {
        Object.defineProperty(this.s, "hasBeenClosed", {
          value: true,
          enumerable: true,
          configurable: false,
          writable: false
        });
        const activeCursorCloses = Array.from(this.s.activeCursors, (cursor) => cursor.close());
        this.s.activeCursors.clear();
        await Promise.all(activeCursorCloses);
        const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
        this.s.activeSessions.clear();
        await Promise.all(activeSessionEnds);
        if (this.topology == null) {
          return;
        }
        const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
        const topologyDescription = this.topology.description;
        const serverDescriptions = Array.from(topologyDescription.servers.values());
        const servers = selector(topologyDescription, serverDescriptions);
        if (servers.length !== 0) {
          const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
          if (endSessions.length !== 0) {
            try {
              await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }));
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
          }
        }
        const topology = this.topology;
        this.topology = void 0;
        topology.close();
        const { encrypter } = this.options;
        if (encrypter) {
          await encrypter.close(this, force);
        }
      }
      /**
       * Create a new Db instance sharing the current socket connections.
       *
       * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.
       * @param options - Optional settings for Db construction
       */
      db(dbName, options) {
        options = options ?? {};
        if (!dbName) {
          dbName = this.s.options.dbName;
        }
        const finalOptions = Object.assign({}, this.options, options);
        const db = new db_1.Db(this, dbName, finalOptions);
        return db;
      }
      /**
       * Connect to MongoDB using a url
       *
       * @remarks
       * Calling `connect` is optional since the first operation you perform will call `connect` if it's needed.
       * `timeoutMS` will bound the time any operation can take before throwing a timeout error.
       * However, when the operation being run is automatically connecting your `MongoClient` the `timeoutMS` will not apply to the time taken to connect the MongoClient.
       * This means the time to setup the `MongoClient` does not count against `timeoutMS`.
       * If you are using `timeoutMS` we recommend connecting your client explicitly in advance of any operation to avoid this inconsistent execution time.
       *
       * @remarks
       * The programmatically provided options take precedence over the URI options.
       *
       * @remarks
       * The driver will look up corresponding SRV and TXT records if the connection string starts with `mongodb+srv://`.
       * If those look ups throw a DNS Timeout error, the driver will retry the look up once.
       *
       * @see https://www.mongodb.com/docs/manual/reference/connection-string/
       */
      static async connect(url2, options) {
        const client = new this(url2, options);
        return await client.connect();
      }
      /**
       * Creates a new ClientSession. When using the returned session in an operation
       * a corresponding ServerSession will be created.
       *
       * @remarks
       * A ClientSession instance may only be passed to operations being performed on the same
       * MongoClient it was started from.
       */
      startSession(options) {
        const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this.options);
        this.s.activeSessions.add(session);
        session.once("ended", () => {
          this.s.activeSessions.delete(session);
        });
        return session;
      }
      async withSession(optionsOrExecutor, executor) {
        const options = {
          // Always define an owner
          owner: Symbol(),
          // If it's an object inherit the options
          ...typeof optionsOrExecutor === "object" ? optionsOrExecutor : {}
        };
        const withSessionCallback = typeof optionsOrExecutor === "function" ? optionsOrExecutor : executor;
        if (withSessionCallback == null) {
          throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
        }
        const session = this.startSession(options);
        try {
          return await withSessionCallback(session);
        } finally {
          try {
            await session.endSession();
          } catch (error2) {
            (0, utils_1.squashError)(error2);
          }
        }
      }
      /**
       * Create a new Change Stream, watching for new changes (insertions, updates,
       * replacements, deletions, and invalidations) in this cluster. Will ignore all
       * changes to system collections, as well as the local, admin, and config databases.
       *
       * @remarks
       * watch() accepts two generic arguments for distinct use cases:
       * - The first is to provide the schema that may be defined for all the data within the current cluster
       * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
       *
       * @remarks
       * When `timeoutMS` is configured for a change stream, it will have different behaviour depending
       * on whether the change stream is in iterator mode or emitter mode. In both cases, a change
       * stream will time out if it does not receive a change event within `timeoutMS` of the last change
       * event.
       *
       * Note that if a change stream is consistently timing out when watching a collection, database or
       * client that is being changed, then this may be due to the server timing out before it can finish
       * processing the existing oplog. To address this, restart the change stream with a higher
       * `timeoutMS`.
       *
       * If the change stream times out the initial aggregate operation to establish the change stream on
       * the server, then the client will close the change stream. If the getMore calls to the server
       * time out, then the change stream will be left open, but will throw a MongoOperationTimeoutError
       * when in iterator mode and emit an error event that returns a MongoOperationTimeoutError in
       * emitter mode.
       *
       * To determine whether or not the change stream is still open following a timeout, check the
       * {@link ChangeStream.closed} getter.
       *
       * @example
       * In iterator mode, if a next() call throws a timeout error, it will attempt to resume the change stream.
       * The next call can just be retried after this succeeds.
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * try {
       *     await changeStream.next();
       * } catch (e) {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *       await changeStream.next();
       *     }
       *     throw e;
       * }
       * ```
       *
       * @example
       * In emitter mode, if the change stream goes `timeoutMS` without emitting a change event, it will
       * emit an error event that returns a MongoOperationTimeoutError, but will not close the change
       * stream unless the resume attempt fails. There is no need to re-establish change listeners as
       * this will automatically continue emitting change events once the resume attempt completes.
       *
       * ```ts
       * const changeStream = collection.watch([], { timeoutMS: 100 });
       * changeStream.on('change', console.log);
       * changeStream.on('error', e => {
       *     if (e instanceof MongoOperationTimeoutError && !changeStream.closed) {
       *         // do nothing
       *     } else {
       *         changeStream.close();
       *     }
       * });
       * ```
       * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
       * @param options - Optional settings for the command
       * @typeParam TSchema - Type of the data being detected by the change stream
       * @typeParam TChange - Type of the whole change stream document emitted
       */
      watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
          options = pipeline;
          pipeline = [];
        }
        return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
      }
    };
    exports.MongoClient = MongoClient;
    (0, resource_management_1.configureResourceManagement)(MongoClient.prototype);
  }
});

// node_modules/mongodb/lib/resource_management.js
var require_resource_management = __commonJS({
  "node_modules/mongodb/lib/resource_management.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configureResourceManagement = configureResourceManagement;
    exports.configureExplicitResourceManagement = configureExplicitResourceManagement;
    function configureResourceManagement(target) {
      Symbol.asyncDispose && Object.defineProperty(target, Symbol.asyncDispose, {
        value: async function asyncDispose() {
          await this.asyncDispose();
        },
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    function configureExplicitResourceManagement() {
      const { MongoClient } = require_mongo_client();
      const { ClientSession } = require_sessions();
      const { AbstractCursor } = require_abstract_cursor();
      const { ChangeStream } = require_change_stream();
      configureResourceManagement(MongoClient.prototype);
      configureResourceManagement(ClientSession.prototype);
      configureResourceManagement(AbstractCursor.prototype);
      configureResourceManagement(ChangeStream.prototype);
    }
  }
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS({
  "node_modules/mongodb/lib/cursor/abstract_cursor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = void 0;
    var stream_1 = __require("stream");
    var bson_1 = require_bson2();
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var execute_operation_1 = require_execute_operation();
    var get_more_1 = require_get_more();
    var kill_cursors_1 = require_kill_cursors();
    var read_concern_1 = require_read_concern();
    var read_preference_1 = require_read_preference();
    var resource_management_1 = require_resource_management();
    var sessions_1 = require_sessions();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    exports.CURSOR_FLAGS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "exhaust",
      "partial"
    ];
    function removeActiveCursor() {
      this.client.s.activeCursors.delete(this);
    }
    exports.CursorTimeoutMode = Object.freeze({
      ITERATION: "iteration",
      LIFETIME: "cursorLifetime"
    });
    var AbstractCursor = class extends mongo_types_1.TypedEventEmitter {
      /** @internal */
      constructor(client, namespace2, options = {}) {
        super();
        this.documents = null;
        this.hasEmittedClose = false;
        this.on("error", utils_1.noop);
        if (!client.s.isMongoClient) {
          throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
        }
        this.cursorClient = client;
        this.cursorNamespace = namespace2;
        this.cursorId = null;
        this.initialized = false;
        this.isClosed = false;
        this.isKilled = false;
        this.cursorOptions = {
          readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
          ...(0, bson_1.pluckBSONSerializeOptions)(options),
          timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,
          tailable: options.tailable,
          awaitData: options.awaitData
        };
        if (this.cursorOptions.timeoutMS != null) {
          if (options.timeoutMode == null) {
            if (options.tailable) {
              if (options.awaitData) {
                if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS)
                  throw new error_1.MongoInvalidArgumentError("Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor");
              }
              this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;
            } else {
              this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;
            }
          } else {
            if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {
              throw new error_1.MongoInvalidArgumentError("Cannot set tailable cursor's timeoutMode to LIFETIME");
            }
            this.cursorOptions.timeoutMode = options.timeoutMode;
          }
        } else {
          if (options.timeoutMode != null)
            throw new error_1.MongoInvalidArgumentError("Cannot set timeoutMode without setting timeoutMS");
        }
        this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);
        const readConcern = read_concern_1.ReadConcern.fromOptions(options);
        if (readConcern) {
          this.cursorOptions.readConcern = readConcern;
        }
        if (typeof options.batchSize === "number") {
          this.cursorOptions.batchSize = options.batchSize;
        }
        if (options.comment !== void 0) {
          this.cursorOptions.comment = options.comment;
        }
        if (typeof options.maxTimeMS === "number") {
          this.cursorOptions.maxTimeMS = options.maxTimeMS;
        }
        if (typeof options.maxAwaitTimeMS === "number") {
          this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;
        }
        if (options.session instanceof sessions_1.ClientSession) {
          this.cursorSession = options.session;
        } else {
          this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
        }
        this.deserializationOptions = {
          ...this.cursorOptions,
          validation: {
            utf8: options?.enableUtf8Validation === false ? false : true
          }
        };
        this.timeoutContext = options.timeoutContext;
        this.signal = options.signal;
        this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(void 0, utils_1.squashError));
        this.trackCursor();
      }
      /**
       * The cursor has no id until it receives a response from the initial cursor creating command.
       *
       * It is non-zero for as long as the database has an open cursor.
       *
       * The initiating command may receive a zero id if the entire result is in the `firstBatch`.
       */
      get id() {
        return this.cursorId ?? void 0;
      }
      /** @internal */
      get isDead() {
        return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;
      }
      /** @internal */
      get client() {
        return this.cursorClient;
      }
      /** @internal */
      get server() {
        return this.selectedServer;
      }
      get namespace() {
        return this.cursorNamespace;
      }
      get readPreference() {
        return this.cursorOptions.readPreference;
      }
      get readConcern() {
        return this.cursorOptions.readConcern;
      }
      /** @internal */
      get session() {
        return this.cursorSession;
      }
      set session(clientSession) {
        this.cursorSession = clientSession;
      }
      /**
       * The cursor is closed and all remaining locally buffered documents have been iterated.
       */
      get closed() {
        return this.isClosed && (this.documents?.length ?? 0) === 0;
      }
      /**
       * A `killCursors` command was attempted on this cursor.
       * This is performed if the cursor id is non zero.
       */
      get killed() {
        return this.isKilled;
      }
      get loadBalanced() {
        return !!this.cursorClient.topology?.loadBalanced;
      }
      /** @internal */
      async asyncDispose() {
        await this.close();
      }
      /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */
      trackCursor() {
        this.cursorClient.s.activeCursors.add(this);
        if (!this.listeners("close").includes(removeActiveCursor)) {
          this.once("close", removeActiveCursor);
        }
      }
      /** Returns current buffered documents length */
      bufferedCount() {
        return this.documents?.length ?? 0;
      }
      /** Returns current buffered documents */
      readBufferedDocuments(number) {
        const bufferedDocs = [];
        const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);
        for (let count = 0; count < documentsToRead; count++) {
          const document2 = this.documents?.shift(this.deserializationOptions);
          if (document2 != null) {
            bufferedDocs.push(document2);
          }
        }
        return bufferedDocs;
      }
      async *[Symbol.asyncIterator]() {
        this.signal?.throwIfAborted();
        if (this.closed) {
          return;
        }
        try {
          while (true) {
            if (this.isKilled) {
              return;
            }
            if (this.closed) {
              return;
            }
            if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {
              return;
            }
            const document2 = await this.next();
            if (document2 === null) {
              return;
            }
            yield document2;
            this.signal?.throwIfAborted();
          }
        } finally {
          if (!this.isClosed) {
            try {
              await this.close();
            } catch (error2) {
              (0, utils_1.squashError)(error2);
            }
          }
        }
      }
      stream(options) {
        const readable = new ReadableCursorStream(this);
        const abortListener = (0, utils_1.addAbortListener)(this.signal, function() {
          readable.destroy(this.reason);
        });
        readable.once("end", () => {
          abortListener?.[utils_1.kDispose]();
        });
        if (options?.transform) {
          const transform = options.transform;
          const transformedStream = readable.pipe(new stream_1.Transform({
            objectMode: true,
            highWaterMark: 1,
            transform(chunk, _, callback) {
              try {
                const transformed = transform(chunk);
                callback(void 0, transformed);
              } catch (err) {
                callback(err);
              }
            }
          }));
          readable.on("error", (err) => transformedStream.emit("error", err));
          return transformedStream;
        }
        return readable;
      }
      async hasNext() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          return false;
        }
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          do {
            if ((this.documents?.length ?? 0) !== 0) {
              return true;
            }
            await this.fetchBatch();
          } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
        } finally {
          if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return false;
      }
      /** Get the next available document from the cursor, returns null if no more documents are available. */
      async next() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          throw new error_1.MongoCursorExhaustedError();
        }
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          do {
            const doc = this.documents?.shift(this.deserializationOptions);
            if (doc != null) {
              if (this.transform != null)
                return await this.transformDocument(doc);
              return doc;
            }
            await this.fetchBatch();
          } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
        } finally {
          if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return null;
      }
      /**
       * Try to get the next available document from the cursor or `null` if an empty batch is returned
       */
      async tryNext() {
        this.signal?.throwIfAborted();
        if (this.cursorId === bson_1.Long.ZERO) {
          throw new error_1.MongoCursorExhaustedError();
        }
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
          this.timeoutContext?.refresh();
        }
        try {
          let doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
          await this.fetchBatch();
          doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
        } finally {
          if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
            this.timeoutContext?.clear();
          }
        }
        return null;
      }
      /**
       * Iterates over all the documents for this cursor using the iterator, callback pattern.
       *
       * If the iterator returns `false`, iteration will stop.
       *
       * @param iterator - The iteration callback.
       * @deprecated - Will be removed in a future release. Use for await...of instead.
       */
      async forEach(iterator2) {
        this.signal?.throwIfAborted();
        if (typeof iterator2 !== "function") {
          throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
        }
        for await (const document2 of this) {
          const result = iterator2(document2);
          if (result === false) {
            break;
          }
        }
      }
      /**
       * Frees any client-side resources used by the cursor.
       */
      async close(options) {
        await this.cleanup(options?.timeoutMS);
      }
      /**
       * Returns an array of documents. The caller is responsible for making sure that there
       * is enough memory to store the results. Note that the array only contains partial
       * results when this cursor had been previously accessed. In that case,
       * cursor.rewind() can be used to reset the cursor.
       */
      async toArray() {
        this.signal?.throwIfAborted();
        const array = [];
        for await (const document2 of this) {
          array.push(document2);
          const docs = this.readBufferedDocuments();
          if (this.transform != null) {
            for (const doc of docs) {
              array.push(await this.transformDocument(doc));
            }
          } else {
            array.push(...docs);
          }
        }
        return array;
      }
      /**
       * Add a cursor flag to the cursor
       *
       * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
       * @param value - The flag boolean value.
       */
      addCursorFlag(flag, value) {
        this.throwIfInitialized();
        if (!exports.CURSOR_FLAGS.includes(flag)) {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
        }
        if (typeof value !== "boolean") {
          throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
        }
        this.cursorOptions[flag] = value;
        return this;
      }
      /**
       * Map all documents using the provided function
       * If there is a transform set on the cursor, that will be called first and the result passed to
       * this function's transform.
       *
       * @remarks
       *
       * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping
       * function that maps values to `null` will result in the cursor closing itself before it has finished iterating
       * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => null);
       *
       * const documents = await cursor.toArray();
       * // documents is always [], regardless of how many documents are in the collection.
       * ```
       *
       * Other falsey values are allowed:
       *
       * ```typescript
       * const cursor = collection.find({});
       * cursor.map(() => '');
       *
       * const documents = await cursor.toArray();
       * // documents is now an array of empty strings
       * ```
       *
       * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
       * it **does not** return a new instance of a cursor. This means when calling map,
       * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
       * Take note of the following example:
       *
       * @example
       * ```typescript
       * const cursor: FindCursor<Document> = coll.find();
       * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
       * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
       * ```
       * @param transform - The mapping transformation method.
       */
      map(transform) {
        this.throwIfInitialized();
        const oldTransform = this.transform;
        if (oldTransform) {
          this.transform = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.transform = transform;
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadPreference(readPreference) {
        this.throwIfInitialized();
        if (readPreference instanceof read_preference_1.ReadPreference) {
          this.cursorOptions.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
        } else {
          throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
        }
        return this;
      }
      /**
       * Set the ReadPreference for the cursor.
       *
       * @param readPreference - The new read preference for the cursor.
       */
      withReadConcern(readConcern) {
        this.throwIfInitialized();
        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
        if (resolvedReadConcern) {
          this.cursorOptions.readConcern = resolvedReadConcern;
        }
        return this;
      }
      /**
       * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
       *
       * @param value - Number of milliseconds to wait before aborting the query.
       */
      maxTimeMS(value) {
        this.throwIfInitialized();
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
        }
        this.cursorOptions.maxTimeMS = value;
        return this;
      }
      /**
       * Set the batch size for the cursor.
       *
       * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.
       */
      batchSize(value) {
        this.throwIfInitialized();
        if (this.cursorOptions.tailable) {
          throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
        }
        if (typeof value !== "number") {
          throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
        }
        this.cursorOptions.batchSize = value;
        return this;
      }
      /**
       * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
       * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
       * if the resultant data has already been retrieved by this cursor.
       */
      rewind() {
        if (this.timeoutContext && this.timeoutContext.owner !== this) {
          throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);
        }
        if (!this.initialized) {
          return;
        }
        this.cursorId = null;
        this.documents?.clear();
        this.timeoutContext?.clear();
        this.timeoutContext = void 0;
        this.isClosed = false;
        this.isKilled = false;
        this.initialized = false;
        this.hasEmittedClose = false;
        this.trackCursor();
        if (this.cursorSession.explicit === false) {
          if (!this.cursorSession.hasEnded) {
            this.cursorSession.endSession().then(void 0, utils_1.squashError);
          }
          this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
        }
      }
      /** @internal */
      async getMore(batchSize) {
        if (this.cursorId == null) {
          throw new error_1.MongoRuntimeError("Unexpected null cursor id. A cursor creating command should have set this");
        }
        if (this.selectedServer == null) {
          throw new error_1.MongoRuntimeError("Unexpected null selectedServer. A cursor creating command should have set this");
        }
        const getMoreOptions = {
          ...this.cursorOptions,
          session: this.cursorSession,
          batchSize
        };
        const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);
        return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);
      }
      /**
       * @internal
       *
       * This function is exposed for the unified test runner's createChangeStream
       * operation.  We cannot refactor to use the abstract _initialize method without
       * a significant refactor.
       */
      async cursorInit() {
        if (this.cursorOptions.timeoutMS != null) {
          this.timeoutContext ?? (this.timeoutContext = new CursorTimeoutContext(timeout_1.TimeoutContext.create({
            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
            timeoutMS: this.cursorOptions.timeoutMS
          }), this));
        }
        try {
          const state = await this._initialize(this.cursorSession);
          this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;
          const response = state.response;
          this.selectedServer = state.server;
          this.cursorId = response.id;
          this.cursorNamespace = response.ns ?? this.namespace;
          this.documents = response;
          this.initialized = true;
        } catch (error2) {
          this.initialized = true;
          await this.cleanup(void 0, error2);
          throw error2;
        }
        if (this.isDead) {
          await this.cleanup();
        }
        return;
      }
      /** @internal Attempt to obtain more documents */
      async fetchBatch() {
        if (this.isClosed) {
          return;
        }
        if (this.isDead) {
          await this.cleanup();
          return;
        }
        if (this.cursorId == null) {
          await this.cursorInit();
          if ((this.documents?.length ?? 0) !== 0 || this.isDead)
            return;
        }
        const batchSize = this.cursorOptions.batchSize || 1e3;
        try {
          const response = await this.getMore(batchSize);
          this.cursorId = response.id;
          this.documents = response;
        } catch (error2) {
          try {
            await this.cleanup(void 0, error2);
          } catch (cleanupError) {
            (0, utils_1.squashError)(cleanupError);
          }
          throw error2;
        }
        if (this.isDead) {
          await this.cleanup();
        }
      }
      /** @internal */
      async cleanup(timeoutMS, error2) {
        this.abortListener?.[utils_1.kDispose]();
        this.isClosed = true;
        const timeoutContextForKillCursors = () => {
          if (timeoutMS != null) {
            this.timeoutContext?.clear();
            return new CursorTimeoutContext(timeout_1.TimeoutContext.create({
              serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
              timeoutMS
            }), this);
          } else {
            return this.timeoutContext?.refreshed();
          }
        };
        try {
          if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !this.cursorSession.hasEnded) {
            this.isKilled = true;
            const cursorId = this.cursorId;
            this.cursorId = bson_1.Long.ZERO;
            await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
              session: this.cursorSession
            }), timeoutContextForKillCursors());
          }
        } catch (error3) {
          (0, utils_1.squashError)(error3);
        } finally {
          try {
            if (this.cursorSession?.owner === this) {
              await this.cursorSession.endSession({ error: error2 });
            }
            if (!this.cursorSession?.inTransaction()) {
              (0, sessions_1.maybeClearPinnedConnection)(this.cursorSession, { error: error2 });
            }
          } finally {
            this.emitClose();
          }
        }
      }
      /** @internal */
      emitClose() {
        try {
          if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {
            this.emit("close");
          }
        } finally {
          this.hasEmittedClose = true;
        }
      }
      /** @internal */
      async transformDocument(document2) {
        if (this.transform == null)
          return document2;
        try {
          const transformedDocument = this.transform(document2);
          if (transformedDocument === null) {
            const TRANSFORM_TO_NULL_ERROR = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
            throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
          }
          return transformedDocument;
        } catch (transformError) {
          try {
            await this.close();
          } catch (closeError) {
            (0, utils_1.squashError)(closeError);
          }
          throw transformError;
        }
      }
      /** @internal */
      throwIfInitialized() {
        if (this.initialized)
          throw new error_1.MongoCursorInUseError();
      }
    };
    exports.AbstractCursor = AbstractCursor;
    AbstractCursor.CLOSE = "close";
    var ReadableCursorStream = class extends stream_1.Readable {
      constructor(cursor) {
        super({
          objectMode: true,
          autoDestroy: false,
          highWaterMark: 1
        });
        this._readInProgress = false;
        this._cursor = cursor;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _read(size) {
        if (!this._readInProgress) {
          this._readInProgress = true;
          this._readNext();
        }
      }
      _destroy(error2, callback) {
        this._cursor.close().then(() => callback(error2), (closeError) => callback(closeError));
      }
      _readNext() {
        if (this._cursor.id === bson_1.Long.ZERO) {
          this.push(null);
          return;
        }
        this._cursor.next().then(
          // result from next()
          (result) => {
            if (result == null) {
              this.push(null);
            } else if (this.destroyed) {
              this._cursor.close().then(void 0, utils_1.squashError);
            } else {
              if (this.push(result)) {
                return this._readNext();
              }
              this._readInProgress = false;
            }
          },
          // error from next()
          (err) => {
            if (err.message.match(/server is closed/)) {
              this._cursor.close().then(void 0, utils_1.squashError);
              return this.push(null);
            }
            if (err.message.match(/operation was interrupted/)) {
              return this.push(null);
            }
            return this.destroy(err);
          }
        ).catch((error2) => {
          this._readInProgress = false;
          this.destroy(error2);
        });
      }
    };
    (0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);
    var CursorTimeoutContext = class _CursorTimeoutContext extends timeout_1.TimeoutContext {
      constructor(timeoutContext, owner) {
        super();
        this.timeoutContext = timeoutContext;
        this.owner = owner;
      }
      get serverSelectionTimeout() {
        return this.timeoutContext.serverSelectionTimeout;
      }
      get connectionCheckoutTimeout() {
        return this.timeoutContext.connectionCheckoutTimeout;
      }
      get clearServerSelectionTimeout() {
        return this.timeoutContext.clearServerSelectionTimeout;
      }
      get timeoutForSocketWrite() {
        return this.timeoutContext.timeoutForSocketWrite;
      }
      get timeoutForSocketRead() {
        return this.timeoutContext.timeoutForSocketRead;
      }
      csotEnabled() {
        return this.timeoutContext.csotEnabled();
      }
      refresh() {
        if (typeof this.owner !== "symbol")
          return this.timeoutContext.refresh();
      }
      clear() {
        if (typeof this.owner !== "symbol")
          return this.timeoutContext.clear();
      }
      get maxTimeMS() {
        return this.timeoutContext.maxTimeMS;
      }
      get timeoutMS() {
        return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;
      }
      refreshed() {
        return new _CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);
      }
      addMaxTimeMSToCommand(command, options) {
        this.timeoutContext.addMaxTimeMSToCommand(command, options);
      }
      getSocketTimeoutMS() {
        return this.timeoutContext.getSocketTimeoutMS();
      }
    };
    exports.CursorTimeoutContext = CursorTimeoutContext;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExplainableCursor = exports.Explain = exports.ExplainVerbosity = void 0;
    exports.validateExplainTimeoutOptions = validateExplainTimeoutOptions;
    exports.decorateWithExplain = decorateWithExplain;
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    exports.ExplainVerbosity = Object.freeze({
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    });
    var Explain = class _Explain {
      constructor(verbosity, maxTimeMS) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
        } else {
          this.verbosity = verbosity;
        }
        this.maxTimeMS = maxTimeMS;
      }
      static fromOptions({ explain } = {}) {
        if (explain == null)
          return;
        if (typeof explain === "boolean" || typeof explain === "string") {
          return new _Explain(explain);
        }
        const { verbosity, maxTimeMS } = explain;
        return new _Explain(verbosity, maxTimeMS);
      }
    };
    exports.Explain = Explain;
    function validateExplainTimeoutOptions(options, explain) {
      const { maxTimeMS, timeoutMS } = options;
      if (timeoutMS != null && (maxTimeMS != null || explain?.maxTimeMS != null)) {
        throw new error_1.MongoAPIError("Cannot use maxTimeMS with timeoutMS for explain commands.");
      }
    }
    function decorateWithExplain(command, explain) {
      const { verbosity, maxTimeMS } = explain;
      const baseCommand = { explain: command, verbosity };
      if (typeof maxTimeMS === "number") {
        baseCommand.maxTimeMS = maxTimeMS;
      }
      return baseCommand;
    }
    var ExplainableCursor = class extends abstract_cursor_1.AbstractCursor {
      resolveExplainTimeoutOptions(verbosity, options) {
        let explain;
        let timeout;
        if (verbosity == null && options == null) {
          explain = void 0;
          timeout = void 0;
        } else if (verbosity != null && options == null) {
          explain = typeof verbosity !== "object" ? verbosity : "verbosity" in verbosity ? verbosity : void 0;
          timeout = typeof verbosity === "object" && "timeoutMS" in verbosity ? verbosity : void 0;
        } else {
          explain = verbosity;
          timeout = options;
        }
        return { timeout, explain };
      }
    };
    exports.ExplainableCursor = ExplainableCursor;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommandOperation = void 0;
    var error_1 = require_error();
    var explain_1 = require_explain();
    var read_concern_1 = require_read_concern();
    var server_selection_1 = require_server_selection();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var operation_1 = require_operation();
    var CommandOperation = class extends operation_1.AbstractOperation {
      constructor(parent, options) {
        super(options);
        this.options = options ?? {};
        const dbNameOverride = options?.dbName || options?.authdb;
        if (dbNameOverride) {
          this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
        } else {
          this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
        }
        this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          this.explain = explain_1.Explain.fromOptions(options);
          if (this.explain)
            (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
        } else if (options?.explain != null) {
          throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
        }
      }
      get canRetryWrite() {
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
          return this.explain == null;
        }
        return super.canRetryWrite;
      }
      async executeCommand(server2, session, cmd, timeoutContext, responseType) {
        this.server = server2;
        const options = {
          ...this.options,
          ...this.bsonOptions,
          timeoutContext,
          readPreference: this.readPreference,
          session
        };
        const serverWireVersion = (0, utils_1.maxWireVersion)(server2);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
          options.omitReadPreference = true;
        }
        if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
          write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
        }
        if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
          Object.assign(cmd, { collation: options.collation });
        }
        if (typeof options.maxTimeMS === "number") {
          cmd.maxTimeMS = options.maxTimeMS;
        }
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
          cmd = (0, explain_1.decorateWithExplain)(cmd, this.explain);
        }
        return await server2.command(this.ns, cmd, options, responseType);
      }
    };
    exports.CommandOperation = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListDatabasesOperation = void 0;
    var utils_1 = require_utils();
    var command_1 = require_command();
    var operation_1 = require_operation();
    var ListDatabasesOperation = class extends command_1.CommandOperation {
      constructor(db, options) {
        super(db, options);
        this.options = options ?? {};
        this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      get commandName() {
        return "listDatabases";
      }
      async execute(server2, session, timeoutContext) {
        const cmd = { listDatabases: 1 };
        if (typeof this.options.nameOnly === "boolean") {
          cmd.nameOnly = this.options.nameOnly;
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        if ((0, utils_1.maxWireVersion)(server2) >= 9 && this.options.comment !== void 0) {
          cmd.comment = this.options.comment;
        }
        return await super.executeCommand(server2, session, cmd, timeoutContext);
      }
    };
    exports.ListDatabasesOperation = ListDatabasesOperation;
    (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidateCollectionOperation = void 0;
    var error_1 = require_error();
    var command_1 = require_command();
    var ValidateCollectionOperation = class extends command_1.CommandOperation {
      constructor(admin2, collectionName, options) {
        const command = { validate: collectionName };
        const keys = Object.keys(options);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options[keys[i]];
          }
        }
        super(admin2.s.db, options);
        this.options = options;
        this.command = command;
        this.collectionName = collectionName;
      }
      get commandName() {
        return "validate";
      }
      async execute(server2, session, timeoutContext) {
        const collectionName = this.collectionName;
        const doc = await super.executeCommand(server2, session, this.command, timeoutContext);
        if (doc.result != null && typeof doc.result !== "string")
          throw new error_1.MongoUnexpectedServerResponseError("Error with validation data");
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
          throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
        if (doc.valid != null && !doc.valid)
          throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
        return doc;
      }
    };
    exports.ValidateCollectionOperation = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Admin = void 0;
    var bson_1 = require_bson2();
    var execute_operation_1 = require_execute_operation();
    var list_databases_1 = require_list_databases();
    var remove_user_1 = require_remove_user();
    var run_command_1 = require_run_command();
    var validate_collection_1 = require_validate_collection();
    var Admin = class {
      /**
       * Create a new Admin instance
       * @internal
       */
      constructor(db) {
        this.s = { db };
      }
      /**
       * Execute a command
       *
       * The driver will ensure the following fields are attached to the command sent to the server:
       * - `lsid` - sourced from an implicit session or options.session
       * - `$readPreference` - defaults to primary or can be configured by options.readPreference
       * - `$db` - sourced from the name of this database
       *
       * If the client has a serverApi setting:
       * - `apiVersion`
       * - `apiStrict`
       * - `apiDeprecationErrors`
       *
       * When in a transaction:
       * - `readConcern` - sourced from readConcern set on the TransactionOptions
       * - `writeConcern` - sourced from writeConcern set on the TransactionOptions
       *
       * Attaching any of the above fields to the command will have no effect as the driver will overwrite the value.
       *
       * @param command - The command to execute
       * @param options - Optional settings for the command
       */
      async command(command, options) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
          ...(0, bson_1.resolveBSONOptions)(options),
          session: options?.session,
          readPreference: options?.readPreference,
          timeoutMS: options?.timeoutMS ?? this.s.db.timeoutMS
        }));
      }
      /**
       * Retrieve the server build information
       *
       * @param options - Optional settings for the command
       */
      async buildInfo(options) {
        return await this.command({ buildinfo: 1 }, options);
      }
      /**
       * Retrieve the server build information
       *
       * @param options - Optional settings for the command
       */
      async serverInfo(options) {
        return await this.command({ buildinfo: 1 }, options);
      }
      /**
       * Retrieve this db's server status.
       *
       * @param options - Optional settings for the command
       */
      async serverStatus(options) {
        return await this.command({ serverStatus: 1 }, options);
      }
      /**
       * Ping the MongoDB server and retrieve results
       *
       * @param options - Optional settings for the command
       */
      async ping(options) {
        return await this.command({ ping: 1 }, options);
      }
      /**
       * Remove a user from a database
       *
       * @param username - The username to remove
       * @param options - Optional settings for the command
       */
      async removeUser(username, options) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options }));
      }
      /**
       * Validate an existing collection
       *
       * @param collectionName - The name of the collection to validate.
       * @param options - Optional settings for the command
       */
      async validateCollection(collectionName, options = {}) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
      }
      /**
       * List the available databases
       *
       * @param options - Optional settings for the command
       */
      async listDatabases(options) {
        return await (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, { timeoutMS: this.s.db.timeoutMS, ...options }));
      }
      /**
       * Get ReplicaSet status
       *
       * @param options - Optional settings for the command
       */
      async replSetGetStatus(options) {
        return await this.command({ replSetGetStatus: 1 }, options);
      }
    };
    exports.Admin = Admin;
  }
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs/download.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFSBucketReadStream = void 0;
    var stream_1 = __require("stream");
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var GridFSBucketReadStream = class extends stream_1.Readable {
      /**
       * @param chunks - Handle for chunks collection
       * @param files - Handle for files collection
       * @param readPreference - The read preference to use
       * @param filter - The filter to use to find the file document
       * @internal
       */
      constructor(chunks, files, readPreference, filter2, options) {
        super({ emitClose: true });
        this.s = {
          bytesToTrim: 0,
          bytesToSkip: 0,
          bytesRead: 0,
          chunks,
          expected: 0,
          files,
          filter: filter2,
          init: false,
          expectedEnd: 0,
          options: {
            start: 0,
            end: 0,
            ...options
          },
          readPreference,
          timeoutContext: options?.timeoutMS != null ? new timeout_1.CSOTTimeoutContext({ timeoutMS: options.timeoutMS, serverSelectionTimeoutMS: 0 }) : void 0
        };
      }
      /**
       * Reads from the cursor and pushes to the stream.
       * Private Impl, do not call directly
       * @internal
       */
      _read() {
        if (this.destroyed)
          return;
        waitForFile(this, () => doRead(this));
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param start - 0-based offset in bytes to start streaming from
       */
      start(start = 0) {
        throwIfInitialized(this);
        this.s.options.start = start;
        return this;
      }
      /**
       * Sets the 0-based offset in bytes to start streaming from. Throws
       * an error if this stream has entered flowing mode
       * (e.g. if you've already called `on('data')`)
       *
       * @param end - Offset in bytes to stop reading at
       */
      end(end = 0) {
        throwIfInitialized(this);
        this.s.options.end = end;
        return this;
      }
      /**
       * Marks this stream as aborted (will never push another `data` event)
       * and kills the underlying cursor. Will emit the 'end' event, and then
       * the 'close' event once the cursor is successfully killed.
       */
      async abort() {
        this.push(null);
        this.destroy();
        const remainingTimeMS = this.s.timeoutContext?.getRemainingTimeMSOrThrow();
        await this.s.cursor?.close({ timeoutMS: remainingTimeMS });
      }
    };
    exports.GridFSBucketReadStream = GridFSBucketReadStream;
    GridFSBucketReadStream.FILE = "file";
    function throwIfInitialized(stream4) {
      if (stream4.s.init) {
        throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
      }
    }
    function doRead(stream4) {
      if (stream4.destroyed)
        return;
      if (!stream4.s.cursor)
        return;
      if (!stream4.s.file)
        return;
      const handleReadResult = (doc) => {
        if (stream4.destroyed)
          return;
        if (!doc) {
          stream4.push(null);
          stream4.s.cursor?.close().then(void 0, (error2) => stream4.destroy(error2));
          return;
        }
        if (!stream4.s.file)
          return;
        const bytesRemaining = stream4.s.file.length - stream4.s.bytesRead;
        const expectedN = stream4.s.expected++;
        const expectedLength = Math.min(stream4.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          return stream4.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        if (doc.n < expectedN) {
          return stream4.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
        }
        let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.byteLength !== expectedLength) {
          if (bytesRemaining <= 0) {
            return stream4.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream4.s.file.length} bytes but already read ${stream4.s.bytesRead} bytes`));
          }
          return stream4.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
        }
        stream4.s.bytesRead += buf.byteLength;
        if (buf.byteLength === 0) {
          return stream4.push(null);
        }
        let sliceStart = null;
        let sliceEnd = null;
        if (stream4.s.bytesToSkip != null) {
          sliceStart = stream4.s.bytesToSkip;
          stream4.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === stream4.s.expectedEnd - 1;
        const bytesLeftToRead = stream4.s.options.end - stream4.s.bytesToSkip;
        if (atEndOfStream && stream4.s.bytesToTrim != null) {
          sliceEnd = stream4.s.file.chunkSize - stream4.s.bytesToTrim;
        } else if (stream4.s.options.end && bytesLeftToRead < doc.data.byteLength) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
        }
        stream4.push(buf);
        return;
      };
      stream4.s.cursor.next().then(handleReadResult, (error2) => {
        if (stream4.destroyed)
          return;
        stream4.destroy(error2);
      });
    }
    function init(stream4) {
      const findOneOptions = {};
      if (stream4.s.readPreference) {
        findOneOptions.readPreference = stream4.s.readPreference;
      }
      if (stream4.s.options && stream4.s.options.sort) {
        findOneOptions.sort = stream4.s.options.sort;
      }
      if (stream4.s.options && stream4.s.options.skip) {
        findOneOptions.skip = stream4.s.options.skip;
      }
      const handleReadResult = (doc) => {
        if (stream4.destroyed)
          return;
        if (!doc) {
          const identifier = stream4.s.filter._id ? stream4.s.filter._id.toString() : stream4.s.filter.filename;
          const errmsg = `FileNotFound: file ${identifier} was not found`;
          const err = new error_1.MongoRuntimeError(errmsg);
          err.code = "ENOENT";
          return stream4.destroy(err);
        }
        if (doc.length <= 0) {
          stream4.push(null);
          return;
        }
        if (stream4.destroyed) {
          stream4.destroy();
          return;
        }
        try {
          stream4.s.bytesToSkip = handleStartOption(stream4, doc, stream4.s.options);
        } catch (error2) {
          return stream4.destroy(error2);
        }
        const filter2 = { files_id: doc._id };
        if (stream4.s.options && stream4.s.options.start != null) {
          const skip = Math.floor(stream4.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter2["n"] = { $gte: skip };
          }
        }
        let remainingTimeMS2;
        try {
          remainingTimeMS2 = stream4.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream4.s.timeoutContext?.timeoutMS}ms`);
        } catch (error2) {
          return stream4.destroy(error2);
        }
        stream4.s.cursor = stream4.s.chunks.find(filter2, {
          timeoutMode: stream4.s.options.timeoutMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
          timeoutMS: remainingTimeMS2
        }).sort({ n: 1 });
        if (stream4.s.readPreference) {
          stream4.s.cursor.withReadPreference(stream4.s.readPreference);
        }
        stream4.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        stream4.s.file = doc;
        try {
          stream4.s.bytesToTrim = handleEndOption(stream4, doc, stream4.s.cursor, stream4.s.options);
        } catch (error2) {
          return stream4.destroy(error2);
        }
        stream4.emit(GridFSBucketReadStream.FILE, doc);
        return;
      };
      let remainingTimeMS;
      try {
        remainingTimeMS = stream4.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream4.s.timeoutContext?.timeoutMS}ms`);
      } catch (error2) {
        if (!stream4.destroyed)
          stream4.destroy(error2);
        return;
      }
      findOneOptions.timeoutMS = remainingTimeMS;
      stream4.s.files.findOne(stream4.s.filter, findOneOptions).then(handleReadResult, (error2) => {
        if (stream4.destroyed)
          return;
        stream4.destroy(error2);
      });
    }
    function waitForFile(stream4, callback) {
      if (stream4.s.file) {
        return callback();
      }
      if (!stream4.s.init) {
        init(stream4);
        stream4.s.init = true;
      }
      stream4.once("file", () => {
        callback();
      });
    }
    function handleStartOption(stream4, doc, options) {
      if (options && options.start != null) {
        if (options.start > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
        }
        if (options.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
        }
        if (options.end != null && options.end < options.start) {
          throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
        }
        stream4.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
        stream4.s.expected = Math.floor(options.start / doc.chunkSize);
        return options.start - stream4.s.bytesRead;
      }
      throw new error_1.MongoInvalidArgumentError("Start option must be defined");
    }
    function handleEndOption(stream4, doc, cursor, options) {
      if (options && options.end != null) {
        if (options.end > doc.length) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
        }
        if (options.start == null || options.start < 0) {
          throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
        }
        const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
        stream4.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
        return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
      }
      throw new error_1.MongoInvalidArgumentError("End option must be defined");
    }
  }
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs/upload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFSBucketWriteStream = void 0;
    var stream_1 = __require("stream");
    var bson_1 = require_bson2();
    var abstract_cursor_1 = require_abstract_cursor();
    var error_1 = require_error();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var GridFSBucketWriteStream = class extends stream_1.Writable {
      /**
       * @param bucket - Handle for this stream's corresponding bucket
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       * @internal
       */
      constructor(bucket, filename, options) {
        super();
        this.gridFSFile = null;
        options = options ?? {};
        this.bucket = bucket;
        this.chunks = bucket.s._chunksCollection;
        this.filename = filename;
        this.files = bucket.s._filesCollection;
        this.options = options;
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
        this.done = false;
        this.id = options.id ? options.id : new bson_1.ObjectId();
        this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
        this.length = 0;
        this.n = 0;
        this.pos = 0;
        this.state = {
          streamEnd: false,
          outstandingRequests: 0,
          errored: false,
          aborted: false
        };
        if (options.timeoutMS != null)
          this.timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS: options.timeoutMS,
            serverSelectionTimeoutMS: (0, utils_1.resolveTimeoutOptions)(this.bucket.s.db.client, {}).serverSelectionTimeoutMS
          });
      }
      /**
       * @internal
       *
       * The stream is considered constructed when the indexes are done being created
       */
      _construct(callback) {
        if (!this.bucket.s.calledOpenUploadStream) {
          this.bucket.s.calledOpenUploadStream = true;
          checkIndexes(this).then(() => {
            this.bucket.s.checkedIndexes = true;
            this.bucket.emit("index");
            callback();
          }, (error2) => {
            if (error2 instanceof error_1.MongoOperationTimeoutError) {
              return handleError(this, error2, callback);
            }
            (0, utils_1.squashError)(error2);
            callback();
          });
        } else {
          return process.nextTick(callback);
        }
      }
      /**
       * @internal
       * Write a buffer to the stream.
       *
       * @param chunk - Buffer to write
       * @param encoding - Optional encoding for the buffer
       * @param callback - Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.
       */
      _write(chunk, encoding, callback) {
        doWrite(this, chunk, encoding, callback);
      }
      /** @internal */
      _final(callback) {
        if (this.state.streamEnd) {
          return process.nextTick(callback);
        }
        this.state.streamEnd = true;
        writeRemnant(this, callback);
      }
      /**
       * Places this write stream into an aborted state (all future writes fail)
       * and deletes all chunks that have already been written.
       */
      async abort() {
        if (this.state.streamEnd) {
          throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
        }
        if (this.state.aborted) {
          throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
        }
        this.state.aborted = true;
        const remainingTimeMS = this.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${this.timeoutContext?.timeoutMS}ms`);
        await this.chunks.deleteMany({ files_id: this.id }, { timeoutMS: remainingTimeMS });
      }
    };
    exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
    function handleError(stream4, error2, callback) {
      if (stream4.state.errored) {
        process.nextTick(callback);
        return;
      }
      stream4.state.errored = true;
      process.nextTick(callback, error2);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: new bson_1.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    async function checkChunksIndex(stream4) {
      const index = { files_id: 1, n: 1 };
      let remainingTimeMS;
      remainingTimeMS = stream4.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`);
      let indexes;
      try {
        indexes = await stream4.chunks.listIndexes({
          timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
          timeoutMS: remainingTimeMS
        }).toArray();
      } catch (error2) {
        if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          indexes = [];
        } else {
          throw error2;
        }
      }
      const hasChunksIndex = !!indexes.find((index2) => {
        const keys = Object.keys(index2.key);
        if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
          return true;
        }
        return false;
      });
      if (!hasChunksIndex) {
        remainingTimeMS = stream4.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`);
        await stream4.chunks.createIndex(index, {
          ...stream4.writeConcern,
          background: true,
          unique: true,
          timeoutMS: remainingTimeMS
        });
      }
    }
    function checkDone(stream4, callback) {
      if (stream4.done) {
        return process.nextTick(callback);
      }
      if (stream4.state.streamEnd && stream4.state.outstandingRequests === 0 && !stream4.state.errored) {
        stream4.done = true;
        const gridFSFile = createFilesDoc(stream4.id, stream4.length, stream4.chunkSizeBytes, stream4.filename, stream4.options.contentType, stream4.options.aliases, stream4.options.metadata);
        if (isAborted(stream4, callback)) {
          return;
        }
        const remainingTimeMS = stream4.timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0) {
          return handleError(stream4, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`), callback);
        }
        stream4.files.insertOne(gridFSFile, { writeConcern: stream4.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
          stream4.gridFSFile = gridFSFile;
          callback();
        }, (error2) => {
          return handleError(stream4, error2, callback);
        });
        return;
      }
      process.nextTick(callback);
    }
    async function checkIndexes(stream4) {
      let remainingTimeMS = stream4.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`);
      const doc = await stream4.files.findOne({}, {
        projection: { _id: 1 },
        timeoutMS: remainingTimeMS
      });
      if (doc != null) {
        return;
      }
      const index = { filename: 1, uploadDate: 1 };
      let indexes;
      remainingTimeMS = stream4.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`);
      const listIndexesOptions = {
        timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : void 0,
        timeoutMS: remainingTimeMS
      };
      try {
        indexes = await stream4.files.listIndexes(listIndexesOptions).toArray();
      } catch (error2) {
        if (error2 instanceof error_1.MongoError && error2.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          indexes = [];
        } else {
          throw error2;
        }
      }
      const hasFileIndex = !!indexes.find((index2) => {
        const keys = Object.keys(index2.key);
        if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
          return true;
        }
        return false;
      });
      if (!hasFileIndex) {
        remainingTimeMS = stream4.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`);
        await stream4.files.createIndex(index, { background: false, timeoutMS: remainingTimeMS });
      }
      await checkChunksIndex(stream4);
    }
    function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
      const ret = {
        _id,
        length,
        chunkSize,
        uploadDate: /* @__PURE__ */ new Date(),
        filename
      };
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(stream4, chunk, encoding, callback) {
      if (isAborted(stream4, callback)) {
        return;
      }
      const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
      stream4.length += inputBuf.length;
      if (stream4.pos + inputBuf.length < stream4.chunkSizeBytes) {
        inputBuf.copy(stream4.bufToStore, stream4.pos);
        stream4.pos += inputBuf.length;
        process.nextTick(callback);
        return;
      }
      let inputBufRemaining = inputBuf.length;
      let spaceRemaining = stream4.chunkSizeBytes - stream4.pos;
      let numToCopy = Math.min(spaceRemaining, inputBuf.length);
      let outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        const inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(stream4.bufToStore, stream4.pos, inputBufPos, inputBufPos + numToCopy);
        stream4.pos += numToCopy;
        spaceRemaining -= numToCopy;
        let doc;
        if (spaceRemaining === 0) {
          doc = createChunkDoc(stream4.id, stream4.n, Buffer.from(stream4.bufToStore));
          const remainingTimeMS = stream4.timeoutContext?.remainingTimeMS;
          if (remainingTimeMS != null && remainingTimeMS <= 0) {
            return handleError(stream4, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`), callback);
          }
          ++stream4.state.outstandingRequests;
          ++outstandingRequests;
          if (isAborted(stream4, callback)) {
            return;
          }
          stream4.chunks.insertOne(doc, { writeConcern: stream4.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
            --stream4.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              checkDone(stream4, callback);
            }
          }, (error2) => {
            return handleError(stream4, error2, callback);
          });
          spaceRemaining = stream4.chunkSizeBytes;
          stream4.pos = 0;
          ++stream4.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
    }
    function writeRemnant(stream4, callback) {
      if (stream4.pos === 0) {
        return checkDone(stream4, callback);
      }
      const remnant = Buffer.alloc(stream4.pos);
      stream4.bufToStore.copy(remnant, 0, 0, stream4.pos);
      const doc = createChunkDoc(stream4.id, stream4.n, remnant);
      if (isAborted(stream4, callback)) {
        return;
      }
      const remainingTimeMS = stream4.timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0) {
        return handleError(stream4, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream4.timeoutContext?.timeoutMS}ms`), callback);
      }
      ++stream4.state.outstandingRequests;
      stream4.chunks.insertOne(doc, { writeConcern: stream4.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
        --stream4.state.outstandingRequests;
        checkDone(stream4, callback);
      }, (error2) => {
        return handleError(stream4, error2, callback);
      });
    }
    function isAborted(stream4, callback) {
      if (stream4.state.aborted) {
        process.nextTick(callback, new error_1.MongoAPIError("Stream has been aborted"));
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS({
  "node_modules/mongodb/lib/gridfs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridFSBucket = void 0;
    var error_1 = require_error();
    var mongo_types_1 = require_mongo_types();
    var timeout_1 = require_timeout();
    var utils_1 = require_utils();
    var write_concern_1 = require_write_concern();
    var download_1 = require_download();
    var upload_1 = require_upload();
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    var GridFSBucket = class extends mongo_types_1.TypedEventEmitter {
      constructor(db, options) {
        super();
        this.on("error", utils_1.noop);
        this.setMaxListeners(0);
        const privateOptions = (0, utils_1.resolveOptions)(db, {
          ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
          ...options,
          writeConcern: write_concern_1.WriteConcern.fromOptions(options)
        });
        this.s = {
          db,
          options: privateOptions,
          _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
          _filesCollection: db.collection(privateOptions.bucketName + ".files"),
          checkedIndexes: false,
          calledOpenUploadStream: false
        };
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS. The stream's 'id' property contains the resulting
       * file's id.
       *
       * @param filename - The value of the 'filename' key in the files doc
       * @param options - Optional settings.
       */
      openUploadStream(filename, options) {
        return new upload_1.GridFSBucketWriteStream(this, filename, {
          timeoutMS: this.s.options.timeoutMS,
          ...options
        });
      }
      /**
       * Returns a writable stream (GridFSBucketWriteStream) for writing
       * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
       * file's id.
       */
      openUploadStreamWithId(id, filename, options) {
        return new upload_1.GridFSBucketWriteStream(this, filename, {
          timeoutMS: this.s.options.timeoutMS,
          ...options,
          id
        });
      }
      /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */
      openDownloadStream(id, options) {
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, { timeoutMS: this.s.options.timeoutMS, ...options });
      }
      /**
       * Deletes a file with the given id
       *
       * @param id - The id of the file doc
       */
      async delete(id, options) {
        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
        let timeoutContext = void 0;
        if (timeoutMS) {
          timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS,
            serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
          });
        }
        const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id }, { timeoutMS: timeoutContext?.remainingTimeMS });
        const remainingTimeMS = timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0)
          throw new error_1.MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);
        await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });
        if (deletedCount === 0) {
          throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
        }
      }
      /** Convenience wrapper around find on the files collection */
      find(filter2 = {}, options = {}) {
        return this.s._filesCollection.find(filter2, options);
      }
      /**
       * Returns a readable stream (GridFSBucketReadStream) for streaming the
       * file with the given name from GridFS. If there are multiple files with
       * the same name, this will stream the most recent file with the given name
       * (as determined by the `uploadDate` field). You can set the `revision`
       * option to change this behavior.
       */
      openDownloadStreamByName(filename, options) {
        let sort = { uploadDate: -1 };
        let skip = void 0;
        if (options && options.revision != null) {
          if (options.revision >= 0) {
            sort = { uploadDate: 1 };
            skip = options.revision;
          } else {
            skip = -options.revision - 1;
          }
        }
        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { timeoutMS: this.s.options.timeoutMS, ...options, sort, skip });
      }
      /**
       * Renames the file with the given _id to the given string
       *
       * @param id - the id of the file to rename
       * @param filename - new name for the file
       */
      async rename(id, filename, options) {
        const filter2 = { _id: id };
        const update = { $set: { filename } };
        const { matchedCount } = await this.s._filesCollection.updateOne(filter2, update, options);
        if (matchedCount === 0) {
          throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
        }
      }
      /** Removes this bucket's files collection, followed by its chunks collection. */
      async drop(options) {
        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
        let timeoutContext = void 0;
        if (timeoutMS) {
          timeoutContext = new timeout_1.CSOTTimeoutContext({
            timeoutMS,
            serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
          });
        }
        if (timeoutContext) {
          await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });
          const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(`Timed out after ${timeoutMS}ms`);
          await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });
        } else {
          await this.s._filesCollection.drop();
          await this.s._chunksCollection.drop();
        }
      }
    };
    exports.GridFSBucket = GridFSBucket;
    GridFSBucket.INDEX = "index";
  }
});

// node_modules/mongodb/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/mongodb/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoOperationTimeoutError = exports.MongoOIDCError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoGCPError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteError = exports.MongoClientBulkWriteCursorError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.ClientEncryption = exports.MongoBulkWriteError = exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = void 0;
    exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.SeverityLevel = exports.MongoLoggableComponent = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.AutoEncryptionLoggerLevel = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.ExplainableCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = exports.AbstractCursor = exports.configureExplicitResourceManagement = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoStalePrimaryError = exports.MongoServerSelectionError = void 0;
    exports.MongoClientAuthProviders = exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptAzureKMSRequestError = exports.SrvPollingEvent = exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = void 0;
    var admin_1 = require_admin();
    Object.defineProperty(exports, "Admin", { enumerable: true, get: function() {
      return admin_1.Admin;
    } });
    var ordered_1 = require_ordered();
    Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function() {
      return ordered_1.OrderedBulkOperation;
    } });
    var unordered_1 = require_unordered();
    Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function() {
      return unordered_1.UnorderedBulkOperation;
    } });
    var change_stream_1 = require_change_stream();
    Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function() {
      return change_stream_1.ChangeStream;
    } });
    var collection_1 = require_collection();
    Object.defineProperty(exports, "Collection", { enumerable: true, get: function() {
      return collection_1.Collection;
    } });
    var abstract_cursor_1 = require_abstract_cursor();
    Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function() {
      return abstract_cursor_1.AbstractCursor;
    } });
    var aggregation_cursor_1 = require_aggregation_cursor();
    Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function() {
      return aggregation_cursor_1.AggregationCursor;
    } });
    var find_cursor_1 = require_find_cursor();
    Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function() {
      return find_cursor_1.FindCursor;
    } });
    var list_collections_cursor_1 = require_list_collections_cursor();
    Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function() {
      return list_collections_cursor_1.ListCollectionsCursor;
    } });
    var list_indexes_cursor_1 = require_list_indexes_cursor();
    Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function() {
      return list_indexes_cursor_1.ListIndexesCursor;
    } });
    var db_1 = require_db();
    Object.defineProperty(exports, "Db", { enumerable: true, get: function() {
      return db_1.Db;
    } });
    var explain_1 = require_explain();
    Object.defineProperty(exports, "ExplainableCursor", { enumerable: true, get: function() {
      return explain_1.ExplainableCursor;
    } });
    var gridfs_1 = require_gridfs();
    Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function() {
      return gridfs_1.GridFSBucket;
    } });
    var download_1 = require_download();
    Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function() {
      return download_1.GridFSBucketReadStream;
    } });
    var upload_1 = require_upload();
    Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function() {
      return upload_1.GridFSBucketWriteStream;
    } });
    var mongo_client_1 = require_mongo_client();
    Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function() {
      return mongo_client_1.MongoClient;
    } });
    var mongo_types_1 = require_mongo_types();
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return mongo_types_1.CancellationToken;
    } });
    var sessions_1 = require_sessions();
    Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function() {
      return sessions_1.ClientSession;
    } });
    var bson_1 = require_bson2();
    Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
      return bson_1.BSON;
    } });
    var bson_2 = require_bson2();
    Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
      return bson_2.Binary;
    } });
    Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
      return bson_2.BSONRegExp;
    } });
    Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
      return bson_2.BSONSymbol;
    } });
    Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
      return bson_2.BSONType;
    } });
    Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
      return bson_2.Code;
    } });
    Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
      return bson_2.DBRef;
    } });
    Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
      return bson_2.Decimal128;
    } });
    Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
      return bson_2.Double;
    } });
    Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
      return bson_2.Int32;
    } });
    Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
      return bson_2.Long;
    } });
    Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
      return bson_2.MaxKey;
    } });
    Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
      return bson_2.MinKey;
    } });
    Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
      return bson_2.ObjectId;
    } });
    Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
      return bson_2.Timestamp;
    } });
    Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
      return bson_2.UUID;
    } });
    var common_1 = require_common2();
    Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function() {
      return common_1.MongoBulkWriteError;
    } });
    var client_encryption_1 = require_client_encryption();
    Object.defineProperty(exports, "ClientEncryption", { enumerable: true, get: function() {
      return client_encryption_1.ClientEncryption;
    } });
    var change_stream_cursor_1 = require_change_stream_cursor();
    Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function() {
      return change_stream_cursor_1.ChangeStreamCursor;
    } });
    var error_1 = require_error();
    Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function() {
      return error_1.MongoAPIError;
    } });
    Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function() {
      return error_1.MongoAWSError;
    } });
    Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function() {
      return error_1.MongoAzureError;
    } });
    Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function() {
      return error_1.MongoBatchReExecutionError;
    } });
    Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function() {
      return error_1.MongoChangeStreamError;
    } });
    Object.defineProperty(exports, "MongoClientBulkWriteCursorError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteCursorError;
    } });
    Object.defineProperty(exports, "MongoClientBulkWriteError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteError;
    } });
    Object.defineProperty(exports, "MongoClientBulkWriteExecutionError", { enumerable: true, get: function() {
      return error_1.MongoClientBulkWriteExecutionError;
    } });
    Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function() {
      return error_1.MongoCompatibilityError;
    } });
    Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function() {
      return error_1.MongoCursorExhaustedError;
    } });
    Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function() {
      return error_1.MongoCursorInUseError;
    } });
    Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function() {
      return error_1.MongoDecompressionError;
    } });
    Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function() {
      return error_1.MongoDriverError;
    } });
    Object.defineProperty(exports, "MongoError", { enumerable: true, get: function() {
      return error_1.MongoError;
    } });
    Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function() {
      return error_1.MongoExpiredSessionError;
    } });
    Object.defineProperty(exports, "MongoGCPError", { enumerable: true, get: function() {
      return error_1.MongoGCPError;
    } });
    Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function() {
      return error_1.MongoGridFSChunkError;
    } });
    Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function() {
      return error_1.MongoGridFSStreamError;
    } });
    Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function() {
      return error_1.MongoInvalidArgumentError;
    } });
    Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function() {
      return error_1.MongoKerberosError;
    } });
    Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function() {
      return error_1.MongoMissingCredentialsError;
    } });
    Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function() {
      return error_1.MongoMissingDependencyError;
    } });
    Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function() {
      return error_1.MongoNetworkError;
    } });
    Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
      return error_1.MongoNetworkTimeoutError;
    } });
    Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function() {
      return error_1.MongoNotConnectedError;
    } });
    Object.defineProperty(exports, "MongoOIDCError", { enumerable: true, get: function() {
      return error_1.MongoOIDCError;
    } });
    Object.defineProperty(exports, "MongoOperationTimeoutError", { enumerable: true, get: function() {
      return error_1.MongoOperationTimeoutError;
    } });
    Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function() {
      return error_1.MongoParseError;
    } });
    Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function() {
      return error_1.MongoRuntimeError;
    } });
    Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function() {
      return error_1.MongoServerClosedError;
    } });
    Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function() {
      return error_1.MongoServerError;
    } });
    Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function() {
      return error_1.MongoServerSelectionError;
    } });
    Object.defineProperty(exports, "MongoStalePrimaryError", { enumerable: true, get: function() {
      return error_1.MongoStalePrimaryError;
    } });
    Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function() {
      return error_1.MongoSystemError;
    } });
    Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function() {
      return error_1.MongoTailableCursorError;
    } });
    Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function() {
      return error_1.MongoTopologyClosedError;
    } });
    Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function() {
      return error_1.MongoTransactionError;
    } });
    Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
      return error_1.MongoUnexpectedServerResponseError;
    } });
    Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function() {
      return error_1.MongoWriteConcernError;
    } });
    var resource_management_1 = require_resource_management();
    Object.defineProperty(exports, "configureExplicitResourceManagement", { enumerable: true, get: function() {
      return resource_management_1.configureExplicitResourceManagement;
    } });
    var common_2 = require_common2();
    Object.defineProperty(exports, "BatchType", { enumerable: true, get: function() {
      return common_2.BatchType;
    } });
    var auto_encrypter_1 = require_auto_encrypter();
    Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
      return auto_encrypter_1.AutoEncryptionLoggerLevel;
    } });
    var gssapi_1 = require_gssapi();
    Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
      return gssapi_1.GSSAPICanonicalizationValue;
    } });
    var providers_1 = require_providers();
    Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function() {
      return providers_1.AuthMechanism;
    } });
    var compression_1 = require_compression();
    Object.defineProperty(exports, "Compressor", { enumerable: true, get: function() {
      return compression_1.Compressor;
    } });
    var abstract_cursor_2 = require_abstract_cursor();
    Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function() {
      return abstract_cursor_2.CURSOR_FLAGS;
    } });
    Object.defineProperty(exports, "CursorTimeoutMode", { enumerable: true, get: function() {
      return abstract_cursor_2.CursorTimeoutMode;
    } });
    var error_2 = require_error();
    Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function() {
      return error_2.MongoErrorLabel;
    } });
    var explain_2 = require_explain();
    Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function() {
      return explain_2.ExplainVerbosity;
    } });
    var mongo_client_2 = require_mongo_client();
    Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function() {
      return mongo_client_2.ServerApiVersion;
    } });
    var mongo_logger_1 = require_mongo_logger();
    Object.defineProperty(exports, "MongoLoggableComponent", { enumerable: true, get: function() {
      return mongo_logger_1.MongoLoggableComponent;
    } });
    Object.defineProperty(exports, "SeverityLevel", { enumerable: true, get: function() {
      return mongo_logger_1.SeverityLevel;
    } });
    var find_and_modify_1 = require_find_and_modify();
    Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function() {
      return find_and_modify_1.ReturnDocument;
    } });
    var set_profiling_level_1 = require_set_profiling_level();
    Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function() {
      return set_profiling_level_1.ProfilingLevel;
    } });
    var read_concern_1 = require_read_concern();
    Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function() {
      return read_concern_1.ReadConcernLevel;
    } });
    var read_preference_1 = require_read_preference();
    Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function() {
      return read_preference_1.ReadPreferenceMode;
    } });
    var common_3 = require_common();
    Object.defineProperty(exports, "ServerType", { enumerable: true, get: function() {
      return common_3.ServerType;
    } });
    Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function() {
      return common_3.TopologyType;
    } });
    var read_concern_2 = require_read_concern();
    Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function() {
      return read_concern_2.ReadConcern;
    } });
    var read_preference_2 = require_read_preference();
    Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function() {
      return read_preference_2.ReadPreference;
    } });
    var write_concern_1 = require_write_concern();
    Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function() {
      return write_concern_1.WriteConcern;
    } });
    var command_monitoring_events_1 = require_command_monitoring_events();
    Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandFailedEvent;
    } });
    Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandStartedEvent;
    } });
    Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function() {
      return command_monitoring_events_1.CommandSucceededEvent;
    } });
    var connection_pool_events_1 = require_connection_pool_events();
    Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedInEvent;
    } });
    Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckedOutEvent;
    } });
    Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutFailedEvent;
    } });
    Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCheckOutStartedEvent;
    } });
    Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionClosedEvent;
    } });
    Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionCreatedEvent;
    } });
    Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClearedEvent;
    } });
    Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolClosedEvent;
    } });
    Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolCreatedEvent;
    } });
    Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolMonitoringEvent;
    } });
    Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionPoolReadyEvent;
    } });
    Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function() {
      return connection_pool_events_1.ConnectionReadyEvent;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function() {
      return events_1.ServerClosedEvent;
    } });
    Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.ServerDescriptionChangedEvent;
    } });
    Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatFailedEvent;
    } });
    Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatStartedEvent;
    } });
    Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
      return events_1.ServerHeartbeatSucceededEvent;
    } });
    Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function() {
      return events_1.ServerOpeningEvent;
    } });
    Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function() {
      return events_1.TopologyClosedEvent;
    } });
    Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
      return events_1.TopologyDescriptionChangedEvent;
    } });
    Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function() {
      return events_1.TopologyOpeningEvent;
    } });
    var server_selection_events_1 = require_server_selection_events();
    Object.defineProperty(exports, "ServerSelectionEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionEvent;
    } });
    Object.defineProperty(exports, "ServerSelectionFailedEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionFailedEvent;
    } });
    Object.defineProperty(exports, "ServerSelectionStartedEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionStartedEvent;
    } });
    Object.defineProperty(exports, "ServerSelectionSucceededEvent", { enumerable: true, get: function() {
      return server_selection_events_1.ServerSelectionSucceededEvent;
    } });
    Object.defineProperty(exports, "WaitingForSuitableServerEvent", { enumerable: true, get: function() {
      return server_selection_events_1.WaitingForSuitableServerEvent;
    } });
    var srv_polling_1 = require_srv_polling();
    Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function() {
      return srv_polling_1.SrvPollingEvent;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function() {
      return errors_1.MongoCryptAzureKMSRequestError;
    } });
    Object.defineProperty(exports, "MongoCryptCreateDataKeyError", { enumerable: true, get: function() {
      return errors_1.MongoCryptCreateDataKeyError;
    } });
    Object.defineProperty(exports, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function() {
      return errors_1.MongoCryptCreateEncryptedCollectionError;
    } });
    Object.defineProperty(exports, "MongoCryptError", { enumerable: true, get: function() {
      return errors_1.MongoCryptError;
    } });
    Object.defineProperty(exports, "MongoCryptInvalidArgumentError", { enumerable: true, get: function() {
      return errors_1.MongoCryptInvalidArgumentError;
    } });
    Object.defineProperty(exports, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function() {
      return errors_1.MongoCryptKMSRequestNetworkTimeoutError;
    } });
    var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
    Object.defineProperty(exports, "MongoClientAuthProviders", { enumerable: true, get: function() {
      return mongo_client_auth_providers_1.MongoClientAuthProviders;
    } });
  }
});

// src/security/type/auditType.ts
var SecurityEventType, AuditEventSeverity;
var init_auditType = __esm({
  "src/security/type/auditType.ts"() {
    SecurityEventType = /* @__PURE__ */ ((SecurityEventType2) => {
      SecurityEventType2["USER_REGISTERED"] = "USER_REGISTERED";
      SecurityEventType2["SUCCESSFUL_LOGIN"] = "SUCCESSFUL_LOGIN";
      SecurityEventType2["FAILED_LOGIN"] = "FAILED_LOGIN";
      SecurityEventType2["USER_LOGOUT"] = "USER_LOGOUT";
      SecurityEventType2["PASSWORD_CHANGED"] = "PASSWORD_CHANGED";
      SecurityEventType2["PASSWORD_RESET_REQUESTED"] = "PASSWORD_RESET_REQUESTED";
      SecurityEventType2["PASSWORD_RESET_COMPLETED"] = "PASSWORD_RESET_COMPLETED";
      SecurityEventType2["EMAIL_VERIFICATION_SENT"] = "EMAIL_VERIFICATION_SENT";
      SecurityEventType2["VERIFICATION_EMAIL_RESENT"] = "VERIFICATION_EMAIL_RESENT";
      SecurityEventType2["EMAIL_VERIFIED"] = "EMAIL_VERIFIED";
      SecurityEventType2["EMAIL_CHANGED"] = "EMAIL_CHANGED";
      SecurityEventType2["TWO_FACTOR_ENABLED"] = "TWO_FACTOR_ENABLED";
      SecurityEventType2["TWO_FACTOR_DISABLED"] = "TWO_FACTOR_DISABLED";
      SecurityEventType2["TWO_FACTOR_SETUP_INITIATED"] = "TWO_FACTOR_SETUP_INITIATED";
      SecurityEventType2["SUCCESSFUL_2FA"] = "SUCCESSFUL_2FA";
      SecurityEventType2["FAILED_2FA"] = "FAILED_2FA";
      SecurityEventType2["SESSION_CREATED"] = "SESSION_CREATED";
      SecurityEventType2["SESSION_EXPIRED"] = "SESSION_EXPIRED";
      SecurityEventType2["SESSION_REVOKED"] = "SESSION_REVOKED";
      SecurityEventType2["PROFILE_UPDATED"] = "PROFILE_UPDATED";
      SecurityEventType2["SECURITY_SETTINGS_CHANGED"] = "SECURITY_SETTINGS_CHANGED";
      SecurityEventType2["ACCOUNT_DELETED"] = "ACCOUNT_DELETED";
      SecurityEventType2["PROFILE_PICTURE_UPDATED"] = "PROFILE_PICTURE_UPDATED";
      SecurityEventType2["API_ACCESS"] = "API_ACCESS";
      SecurityEventType2["UNAUTHORIZED_ACCESS_ATTEMPT"] = "UNAUTHORIZED_ACCESS_ATTEMPT";
      SecurityEventType2["SUSPICIOUS_ACTIVITY_DETECTED"] = "SUSPICIOUS_ACTIVITY_DETECTED";
      SecurityEventType2["ACCOUNT_LOCKED"] = "ACCOUNT_LOCKED";
      SecurityEventType2["ACCOUNT_UNLOCKED"] = "ACCOUNT_UNLOCKED";
      SecurityEventType2["ADMIN_ACTION"] = "ADMIN_ACTION";
      SecurityEventType2["PERMISSION_CHANGED"] = "PERMISSION_CHANGED";
      SecurityEventType2["ROLE_ASSIGNED"] = "ROLE_ASSIGNED";
      SecurityEventType2["API_KEY_CREATED"] = "API_KEY_CREATED";
      SecurityEventType2["API_KEY_REVOKED"] = "API_KEY_REVOKED";
      SecurityEventType2["DATA_EXPORT"] = "DATA_EXPORT";
      SecurityEventType2["RESTORE_MESSAGE"] = "MESSAGE RESTORE";
      SecurityEventType2["CONVERSATION_ARCHIVED"] = "CONVERSATION_ARCHIVED";
      SecurityEventType2["CONVERSATION_UNARCHIVED"] = "CONVERSATION_UNARCHIVED";
      return SecurityEventType2;
    })(SecurityEventType || {});
    AuditEventSeverity = /* @__PURE__ */ ((AuditEventSeverity2) => {
      AuditEventSeverity2["INFO"] = "info";
      AuditEventSeverity2["WARNING"] = "warning";
      AuditEventSeverity2["ERROR"] = "error";
      AuditEventSeverity2["CRITICAL"] = "critical";
      return AuditEventSeverity2;
    })(AuditEventSeverity || {});
  }
});

// src/security/models/securityAuditModel.ts
import { Schema as Schema8, model as model3 } from "mongoose";
var import_mongodb, SecurityAuditSchema, SecurityAuditModel;
var init_securityAuditModel = __esm({
  "src/security/models/securityAuditModel.ts"() {
    import_mongodb = __toESM(require_lib4());
    init_auditType();
    SecurityAuditSchema = new Schema8({
      eventType: {
        type: String,
        required: true,
        enum: Object.values(SecurityEventType),
        index: true
      },
      timestamp: {
        type: Date,
        default: Date.now,
        required: true,
        index: true
      },
      userId: {
        type: Schema8.Types.ObjectId,
        ref: "User",
        index: true
      },
      ipAddress: {
        type: String,
        required: true,
        index: true
      },
      userAgent: {
        type: String,
        required: true
      },
      details: {
        type: Schema8.Types.Mixed,
        default: {},
        // On peut définir des sous-schémas pour les champs courants
        description: String,
        status: {
          type: String,
          enum: ["success", "failure", "warning", "info"]
        },
        severity: {
          type: String,
          enum: ["low", "medium", "high", "critical"]
        },
        email: String,
        loginMethod: {
          type: String,
          enum: ["password", "oauth", "sso", "api_key"]
        },
        failureReason: String,
        sessionId: String,
        sessionDuration: Number,
        changedFields: [String],
        oldValues: Schema8.Types.Mixed,
        newValues: Schema8.Types.Mixed,
        targetResource: String,
        requiredPermissions: [String],
        adminId: String,
        targetUserId: String,
        actionTaken: String,
        geolocation: {
          country: String,
          city: String,
          latitude: Number,
          longitude: Number
        },
        deviceInfo: {
          type: String,
          osName: String,
          osVersion: String,
          browser: String,
          browserVersion: String
        }
      },
      severity: {
        type: String,
        enum: Object.values(AuditEventSeverity),
        default: "info" /* INFO */,
        required: true,
        index: true
      },
      targetResource: {
        type: String,
        index: true
      },
      targetUserId: {
        type: Schema8.Types.ObjectId,
        ref: "User",
        index: true
      },
      sessionId: {
        type: String,
        index: true
      }
    }, {
      timestamps: true,
      // Ajoute createdAt et updatedAt
      collection: "security_audit_events"
    });
    SecurityAuditSchema.index({ userId: 1, timestamp: -1 });
    SecurityAuditSchema.index({ eventType: 1, timestamp: -1 });
    SecurityAuditSchema.index({ timestamp: -1, severity: 1 });
    SecurityAuditSchema.index({ sessionId: 1, timestamp: 1 });
    SecurityAuditSchema.static("findByUserAndDateRange", function findByUserAndDateRange(userId, startDate, endDate) {
      return this.find({
        userId: new import_mongodb.ObjectId(userId),
        timestamp: { $gte: startDate, $lte: endDate }
      }).sort({ timestamp: -1 });
    });
    SecurityAuditSchema.static("getRecentActivityByIp", function getRecentActivityByIp(ipAddress, limit = 20) {
      return this.find({ ipAddress }).sort({ timestamp: -1 }).limit(limit);
    });
    SecurityAuditSchema.static("countEventsByType", async function countEventsByType(startDate, endDate) {
      const results = await this.aggregate([
        {
          $match: {
            timestamp: { $gte: startDate, $lte: endDate }
          }
        },
        {
          $group: {
            _id: "$eventType",
            count: { $sum: 1 }
          }
        }
      ]);
      const counts = {};
      results.forEach((item) => {
        counts[item._id] = item.count;
      });
      return counts;
    });
    SecurityAuditModel = model3(
      "SecurityAudit",
      SecurityAuditSchema
    );
  }
});

// src/security/services/securityAuditServices.ts
var import_mongodb2, _SecurityAuditService, SecurityAuditService;
var init_securityAuditServices = __esm({
  "src/security/services/securityAuditServices.ts"() {
    import_mongodb2 = __toESM(require_lib4());
    init_logger();
    init_securityAuditModel();
    init_auditType();
    init_auditType();
    _SecurityAuditService = class _SecurityAuditService {
      /**
       * Constructeur privé pour le pattern Singleton
       */
      constructor() {
        __publicField(this, "logger", createLogger2("SecurityAuditService"));
        // Seuils configurables pour la détection d'activités suspectes
        __publicField(this, "suspiciousActivityThresholds", {
          failedLoginCount: 5,
          distinctIpAddressCount: 3,
          sensitiveEventCount: 2,
          timeWindow: 24 * 60 * 60 * 1e3
          // 24 heures en millisecondes
        });
      }
      /**
       * Obtient l'instance unique du service (pattern Singleton)
       */
      static getInstance() {
        if (!_SecurityAuditService.instance) {
          _SecurityAuditService.instance = new _SecurityAuditService();
        }
        return _SecurityAuditService.instance;
      }
      /**
       * Configure les seuils de détection d'activité suspecte
       * @param thresholds Les nouveaux seuils à appliquer
       */
      configureSuspiciousActivityThresholds(thresholds) {
        this.suspiciousActivityThresholds = {
          ...this.suspiciousActivityThresholds,
          ...thresholds
        };
        this.logger.info("Seuils de d\xE9tection d'activit\xE9 suspecte mis \xE0 jour", { newThresholds: this.suspiciousActivityThresholds });
      }
      /**
       * Enregistre un événement de sécurité dans la base de données
       * @param eventData Les données de l'événement à enregistrer
       * @returns L'événement enregistré
       */
      async logEvent(eventData) {
        try {
          const {
            eventType,
            userId,
            ipAddress,
            userAgent,
            details,
            severity = "info" /* INFO */,
            targetResource,
            targetUserId,
            sessionId
          } = eventData;
          const eventObject = {
            eventType,
            timestamp: /* @__PURE__ */ new Date(),
            ipAddress: ipAddress || "unknown",
            userAgent: userAgent || "unknown",
            details: details || {},
            severity,
            targetResource,
            sessionId
          };
          if (userId) {
            eventObject.userId = new import_mongodb2.ObjectId(userId);
          }
          if (targetUserId) {
            eventObject.targetUserId = new import_mongodb2.ObjectId(targetUserId);
          }
          const auditEvent = await SecurityAuditModel.create(eventObject);
          this.logger.info(`\xC9v\xE9nement de s\xE9curit\xE9 enregistr\xE9: ${eventType}`, {
            eventId: auditEvent._id.toString(),
            userId,
            eventType,
            severity
          });
          if (severity === "critical" /* CRITICAL */) {
            await this.triggerSecurityAlert(auditEvent);
          }
          return auditEvent;
        } catch (error2) {
          this.logger.error("Erreur lors de l'enregistrement d'un \xE9v\xE9nement de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            eventType: eventData.eventType,
            userId: eventData.userId
          });
          return {
            _id: new import_mongodb2.ObjectId(),
            eventType: eventData.eventType,
            timestamp: /* @__PURE__ */ new Date(),
            ipAddress: eventData.ipAddress || "unknown",
            userAgent: eventData.userAgent || "unknown",
            severity: eventData.severity || "info" /* INFO */,
            details: {
              error: "Failed to save audit event",
              originalDetails: eventData.details
            }
          };
        }
      }
      /**
       * Déclenche une alerte de sécurité pour les événements critiques
       * @param event L'événement critique qui déclenche l'alerte
       */
      async triggerSecurityAlert(event) {
        try {
          this.logger.warn("ALERTE DE S\xC9CURIT\xC9 CRITIQUE D\xC9TECT\xC9E", {
            eventId: event._id.toString(),
            eventType: event.eventType,
            userId: event.userId?.toString(),
            timestamp: event.timestamp
          });
        } catch (error2) {
          this.logger.error("Erreur lors du d\xE9clenchement d'une alerte de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            eventId: event._id.toString()
          });
        }
      }
      /**
       * Récupère l'historique des événements de sécurité pour un utilisateur
       * @param userId ID de l'utilisateur
       * @param limit Nombre maximum d'événements à récupérer
       * @param skip Nombre d'événements à sauter (pour pagination)
       * @returns Liste des événements de sécurité
       */
      async getUserSecurityHistory(userId, limit = 50, skip = 0) {
        try {
          if (!userId) {
            throw new Error("userId is required");
          }
          const events = await SecurityAuditModel.find({ userId: new import_mongodb2.ObjectId(userId) }).sort({ timestamp: -1 }).skip(skip).limit(limit);
          return events;
        } catch (error2) {
          this.logger.error("Erreur lors de la r\xE9cup\xE9ration de l'historique de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            userId
          });
          return [];
        }
      }
      /**
       * Récupère les événements de sécurité associés à une session spécifique
       * @param sessionId ID de la session
       * @returns Liste des événements de sécurité pour cette session
       */
      async getSessionSecurityEvents(sessionId) {
        try {
          if (!sessionId) {
            throw new Error("sessionId is required");
          }
          const events = await SecurityAuditModel.find({ sessionId }).sort({ timestamp: 1 });
          return events;
        } catch (error2) {
          this.logger.error("Erreur lors de la r\xE9cup\xE9ration des \xE9v\xE9nements de session", {
            error: error2 instanceof Error ? error2.message : String(error2),
            sessionId
          });
          return [];
        }
      }
      /**
       * Recherche avancée des événements de sécurité avec options flexibles
       * @param options Options de recherche
       * @returns Résultats de la recherche avec pagination
       */
      async searchSecurityEvents(options = {}) {
        try {
          const {
            userId,
            eventType,
            startDate,
            endDate,
            ipAddress,
            severity,
            targetResource,
            targetUserId,
            sessionId,
            sort = { field: "timestamp", order: "desc" },
            limit = 100,
            skip = 0
          } = options;
          const query2 = {};
          if (userId) {
            query2.userId = new import_mongodb2.ObjectId(userId);
          }
          if (targetUserId) {
            query2.targetUserId = new import_mongodb2.ObjectId(targetUserId);
          }
          if (eventType) {
            if (Array.isArray(eventType)) {
              query2.eventType = { $in: eventType };
            } else {
              query2.eventType = eventType;
            }
          }
          if (startDate || endDate) {
            query2.timestamp = {};
            if (startDate) {
              query2.timestamp.$gte = new Date(startDate);
            }
            if (endDate) {
              query2.timestamp.$lte = new Date(endDate);
            }
          }
          if (ipAddress) {
            query2.ipAddress = ipAddress;
          }
          if (severity) {
            query2.severity = severity;
          }
          if (targetResource) {
            query2.targetResource = targetResource;
          }
          if (sessionId) {
            query2.sessionId = sessionId;
          }
          const sortOption = {};
          sortOption[sort.field] = sort.order === "asc" ? 1 : -1;
          const [events, total] = await Promise.all([
            SecurityAuditModel.find(query2).sort(sortOption).skip(skip).limit(limit),
            SecurityAuditModel.countDocuments(query2)
          ]);
          return { events, total };
        } catch (error2) {
          this.logger.error("Erreur lors de la recherche d'\xE9v\xE9nements de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            options
          });
          return { events: [], total: 0 };
        }
      }
      /**
       * Détecte les activités suspectes pour un utilisateur avec analyse de risque améliorée
       * @param userId ID de l'utilisateur
       * @returns Résultat détaillé de l'analyse d'activité suspecte
       */
      async detectSuspiciousActivity(userId) {
        try {
          if (!userId) {
            throw new Error("userId is required");
          }
          const suspiciousActivities = [];
          const recommendations = [];
          const timeWindow = new Date(Date.now() - this.suspiciousActivityThresholds.timeWindow);
          const failedLogins = await SecurityAuditModel.countDocuments({
            userId: new import_mongodb2.ObjectId(userId),
            eventType: "FAILED_LOGIN" /* FAILED_LOGIN */,
            timestamp: { $gte: timeWindow }
          });
          if (failedLogins >= this.suspiciousActivityThresholds.failedLoginCount) {
            suspiciousActivities.push("multiple_failed_logins");
            recommendations.push("V\xE9rifier les tentatives d'acc\xE8s non autoris\xE9es et envisager de renforcer le mot de passe");
          }
          const distinctIpAddresses = await SecurityAuditModel.distinct("ipAddress", {
            userId: new import_mongodb2.ObjectId(userId),
            eventType: "SUCCESSFUL_LOGIN" /* SUCCESSFUL_LOGIN */,
            timestamp: { $gte: timeWindow }
          });
          if (distinctIpAddresses.length >= this.suspiciousActivityThresholds.distinctIpAddressCount) {
            suspiciousActivities.push("multiple_ip_addresses");
            recommendations.push("Activer l'authentification \xE0 deux facteurs et v\xE9rifier les appareils connect\xE9s");
          }
          const sensitiveEventTypes = [
            "PASSWORD_CHANGED" /* PASSWORD_CHANGED */,
            "EMAIL_CHANGED" /* EMAIL_CHANGED */,
            "TWO_FACTOR_DISABLED" /* TWO_FACTOR_DISABLED */,
            "PASSWORD_RESET_REQUESTED" /* PASSWORD_RESET_REQUESTED */,
            "SECURITY_SETTINGS_CHANGED" /* SECURITY_SETTINGS_CHANGED */
          ];
          const sensitiveEvents = await SecurityAuditModel.find({
            userId: new import_mongodb2.ObjectId(userId),
            eventType: { $in: sensitiveEventTypes },
            timestamp: { $gte: timeWindow }
          });
          if (sensitiveEvents.length >= this.suspiciousActivityThresholds.sensitiveEventCount) {
            suspiciousActivities.push("multiple_sensitive_changes");
            recommendations.push("V\xE9rifier les changements r\xE9cents aux param\xE8tres de s\xE9curit\xE9 du compte");
          }
          const adminActionEvents = await SecurityAuditModel.countDocuments({
            userId: new import_mongodb2.ObjectId(userId),
            eventType: "ADMIN_ACTION" /* ADMIN_ACTION */,
            timestamp: { $gte: timeWindow }
          });
          if (adminActionEvents > 0) {
            suspiciousActivities.push("unexpected_admin_actions");
            recommendations.push("V\xE9rifier les privil\xE8ges administratifs de l'utilisateur");
          }
          let riskLevel = "low";
          if (suspiciousActivities.length >= 3) {
            riskLevel = "high";
          } else if (suspiciousActivities.length >= 1) {
            riskLevel = "medium";
          }
          if (riskLevel === "high") {
            recommendations.push("Envisager de bloquer temporairement le compte pour enqu\xEAte de s\xE9curit\xE9");
            await this.logEvent({
              eventType: "SECURITY_ALERT",
              userId,
              severity: "warning" /* WARNING */,
              details: {
                reason: "High risk suspicious activity detected",
                activities: suspiciousActivities
              }
            });
          }
          return {
            detected: suspiciousActivities.length > 0,
            activities: suspiciousActivities,
            riskLevel,
            recommendations
          };
        } catch (error2) {
          this.logger.error("Erreur lors de la d\xE9tection d'activit\xE9s suspectes", {
            error: error2 instanceof Error ? error2.message : String(error2),
            userId
          });
          return {
            detected: false,
            activities: [],
            riskLevel: "low",
            recommendations: ["Erreur lors de l'analyse, v\xE9rification manuelle recommand\xE9e"]
          };
        }
      }
      /**
       * Récupère les statistiques d'événements de sécurité avec options avancées
       * @param startDate Date de début de la période
       * @param endDate Date de fin de la période
       * @param groupBy Champ par lequel grouper les statistiques (eventType par défaut)
       * @param filter Filtres additionnels pour les statistiques
       * @returns Statistiques des événements de sécurité
       */
      async getSecurityStats(startDate, endDate, groupBy = "eventType", filter2 = {}) {
        try {
          const baseMatch = {
            timestamp: {
              $gte: startDate,
              $lte: endDate
            },
            ...filter2
          };
          const pipeline = [
            {
              $match: {
                timestamp: {
                  $gte: startDate,
                  $lte: endDate
                }
              }
            },
            {
              $group: {
                _id: "$eventType",
                count: { $sum: 1 }
              }
            },
            {
              $sort: {
                count: -1
              }
            }
          ];
          const stats = await SecurityAuditModel.aggregate(pipeline);
          const formattedStats = {};
          stats.forEach((item) => {
            formattedStats[item._id] = item.count;
          });
          return formattedStats;
        } catch (error2) {
          this.logger.error("Erreur lors de la r\xE9cup\xE9ration des statistiques de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            startDate,
            endDate,
            groupBy,
            filter: filter2
          });
          return {};
        }
      }
      /**
       * Récupère les statistiques de sécurité par jour sur une période
       * @param startDate Date de début de la période
       * @param endDate Date de fin de la période
       * @param eventType Type d'événement à analyser (optionnel)
       * @returns Statistiques journalières
       */
      async getSecurityStatsByDay(startDate, endDate, eventType) {
        try {
          const match = {
            timestamp: {
              $gte: startDate,
              $lte: endDate
            }
          };
          if (eventType) {
            match.eventType = eventType;
          }
          const pipeline = [
            {
              $match: match
            },
            {
              $group: {
                _id: {
                  year: { $year: "$timestamp" },
                  month: { $month: "$timestamp" },
                  day: { $dayOfMonth: "$timestamp" }
                },
                count: { $sum: 1 }
              }
            },
            {
              $sort: {
                "_id.year": 1,
                "_id.month": 1,
                "_id.day": 1
              }
            }
          ];
          const stats = await SecurityAuditModel.aggregate(pipeline);
          return stats.map((item) => {
            const { year, month, day } = item._id;
            return {
              date: `${year}-${month.toString().padStart(2, "0")}-${day.toString().padStart(2, "0")}`,
              count: item.count
            };
          });
        } catch (error2) {
          this.logger.error("Erreur lors de la r\xE9cup\xE9ration des statistiques journali\xE8res", {
            error: error2 instanceof Error ? error2.message : String(error2),
            startDate,
            endDate,
            eventType
          });
          return [];
        }
      }
      /**
       * Supprime les événements d'audit plus anciens qu'une certaine date
       * Utile pour la conformité RGPD et la gestion de l'espace de stockage
       * @param olderThan Date avant laquelle supprimer les événements
       * @param options Options avancées pour la purge
       * @returns Nombre d'événements supprimés
       */
      async purgeOldAuditEvents(olderThan, options = {}) {
        try {
          const { excludeEventTypes = [], backupBeforeDelete = false, dryRun = false } = options;
          const deleteQuery = {
            timestamp: { $lt: olderThan }
          };
          if (excludeEventTypes.length > 0) {
            deleteQuery.eventType = { $nin: excludeEventTypes };
          }
          if (backupBeforeDelete) {
            await this.backupEventsBeforeDelete(deleteQuery);
          }
          if (dryRun) {
            const count = await SecurityAuditModel.countDocuments(deleteQuery);
            this.logger.info(`Simulation de suppression d'\xE9v\xE9nements d'audit anciens`, {
              count,
              olderThan,
              excludeEventTypes
            });
            return count;
          }
          const result = await SecurityAuditModel.deleteMany(deleteQuery);
          this.logger.info(`\xC9v\xE9nements d'audit anciens supprim\xE9s`, {
            count: result.deletedCount,
            olderThan,
            excludeEventTypes
          });
          return result.deletedCount || 0;
        } catch (error2) {
          this.logger.error("Erreur lors de la suppression d'anciens \xE9v\xE9nements d'audit", {
            error: error2 instanceof Error ? error2.message : String(error2),
            olderThan
          });
          return 0;
        }
      }
      /**
       * Sauvegarde les événements avant leur suppression
       * @param query La requête identifiant les événements à sauvegarder
       */
      async backupEventsBeforeDelete(query2) {
        try {
          this.logger.info("Sauvegarde des \xE9v\xE9nements avant suppression", { query: query2 });
        } catch (error2) {
          this.logger.error("Erreur lors de la sauvegarde des \xE9v\xE9nements avant suppression", {
            error: error2 instanceof Error ? error2.message : String(error2),
            query: query2
          });
        }
      }
      /**
       * Analyse les tendances de sécurité sur une période donnée
       * @param startDate Date de début de l'analyse
       * @param endDate Date de fin de l'analyse
       * @returns Analyse des tendances de sécurité
       */
      async analyzeSecurityTrends(startDate, endDate) {
        try {
          const stats = await this.getSecurityStats(startDate, endDate);
          const dailyStats = await this.getSecurityStatsByDay(startDate, endDate);
          const topIpAddresses = await SecurityAuditModel.aggregate([
            {
              $match: {
                timestamp: { $gte: startDate, $lte: endDate }
              }
            },
            {
              $group: {
                _id: "$ipAddress",
                count: { $sum: 1 }
              }
            },
            {
              $sort: { count: -1 }
            },
            {
              $limit: 10
            }
          ]);
          const loginAttempts = stats["SUCCESSFUL_LOGIN" /* SUCCESSFUL_LOGIN */] || 0;
          const loginFailures = stats["FAILED_LOGIN" /* FAILED_LOGIN */] || 0;
          const totalLoginAttempts = loginAttempts + loginFailures;
          const failureRatio = totalLoginAttempts > 0 ? loginFailures / totalLoginAttempts : 0;
          return {
            period: { startDate, endDate },
            totalEvents: Object.values(stats).reduce((sum, val) => sum + val, 0),
            eventTypeDistribution: stats,
            dailyActivity: dailyStats,
            topIpAddresses: topIpAddresses.map((ip) => ({
              address: ip._id,
              eventCount: ip.count
            })),
            loginStats: {
              successCount: loginAttempts,
              failureCount: loginFailures,
              failureRatio: parseFloat(failureRatio.toFixed(4))
            },
            securityIncidents: await this.countSecurityIncidents(startDate, endDate)
          };
        } catch (error2) {
          this.logger.error("Erreur lors de l'analyse des tendances de s\xE9curit\xE9", {
            error: error2 instanceof Error ? error2.message : String(error2),
            startDate,
            endDate
          });
          return { error: "Failed to analyze security trends" };
        }
      }
      /**
       * Compte les incidents de sécurité sur une période donnée
       * @param startDate Date de début
       * @param endDate Date de fin
       * @returns Décompte des incidents par type
       */
      async countSecurityIncidents(startDate, endDate) {
        const securityIncidents = await SecurityAuditModel.aggregate([
          {
            $match: {
              timestamp: { $gte: startDate, $lte: endDate },
              severity: { $in: ["error" /* ERROR */, "critical" /* CRITICAL */] }
            }
          },
          {
            $group: {
              _id: "$eventType",
              count: { $sum: 1 }
            }
          }
        ]);
        const incidents = {};
        securityIncidents.forEach((incident) => {
          incidents[incident._id] = incident.count;
        });
        return incidents;
      }
      /**
       * Génère un résumé de sécurité pour un intervalle de temps
       * @param startDate Date de début
       * @param endDate Date de fin
       * @returns Résumé des événements de sécurité
       */
      // First, create proper types for populated documents
      // Then use this in your method
      async generateSecuritySummary(startDate, endDate) {
        try {
          const periodDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
          const [stats, trends] = await Promise.all([
            this.getSecurityStats(startDate, endDate),
            this.analyzeSecurityTrends(startDate, endDate)
          ]);
          const criticalIncidents = await SecurityAuditModel.find({
            timestamp: { $gte: startDate, $lte: endDate },
            severity: "critical" /* CRITICAL */
          }).populate("userId", "email name").populate("targetUserId", "email name").sort({ timestamp: -1 });
          const summary = {
            period: {
              start: startDate,
              end: endDate,
              days: periodDays
            },
            stats,
            trends,
            criticalIncidents: criticalIncidents.map((incident) => ({
              id: incident._id,
              eventType: incident.eventType,
              timestamp: incident.timestamp,
              severity: incident.severity,
              ipAddress: incident.ipAddress,
              userAgent: incident.userAgent,
              // User information (now properly typed)
              user: incident.userId ? {
                id: incident.userId._id,
                email: incident.userId.email,
                name: incident.userId.name
              } : null,
              // Target user if applicable
              targetUser: incident.targetUserId ? {
                id: incident.targetUserId._id,
                email: incident.targetUserId.email,
                name: incident.targetUserId.name
              } : null,
              // Description from details
              description: incident.details?.description || `Critical ${incident.eventType} event`,
              // Status and additional info
              status: incident.details?.status,
              failureReason: incident.details?.failureReason,
              targetResource: incident.targetResource || incident.details?.targetResource,
              // Admin action info if applicable
              adminAction: incident.details?.actionTaken,
              adminId: incident.details?.adminId,
              // Geolocation and device info
              location: incident.details?.geolocation,
              device: incident.details?.deviceInfo,
              // Session information
              sessionId: incident.sessionId
            })),
            totalCritical: criticalIncidents.length,
            // Add summary statistics
            summaryStats: {
              avgIncidentsPerDay: Math.round(criticalIncidents.length / periodDays * 100) / 100,
              mostCommonEventType: this.getMostCommonEventType(criticalIncidents),
              topRiskyIPs: this.getTopRiskyIPs(criticalIncidents),
              affectedUsersCount: this.getUniqueUsersCount(criticalIncidents)
            }
          };
          return summary;
        } catch (error2) {
          console.error("Erreur lors de la g\xE9n\xE9ration du r\xE9sum\xE9 de s\xE9curit\xE9:", error2);
          throw new Error("Impossible de g\xE9n\xE9rer le r\xE9sum\xE9 de s\xE9curit\xE9.");
        }
      }
      /**
       * Récupère les journaux d'activité d'un utilisateur avec pagination et filtres
       * @param userId ID de l'utilisateur
       * @param options Options de pagination et filtres
       * @returns Journaux d'activité avec métadonnées de pagination
       */
      async getUserActivityLogs(userId, options = {}) {
        try {
          if (!userId) {
            throw new Error("userId is required");
          }
          const {
            page = 1,
            limit = 50,
            eventType,
            startDate,
            endDate,
            severity
          } = options;
          const skip = (page - 1) * limit;
          const query2 = {
            userId: new import_mongodb2.ObjectId(userId)
          };
          if (eventType) {
            query2.eventType = eventType;
          }
          if (severity) {
            query2.severity = severity;
          }
          if (startDate || endDate) {
            query2.timestamp = {};
            if (startDate) {
              query2.timestamp.$gte = startDate;
            }
            if (endDate) {
              query2.timestamp.$lte = endDate;
            }
          }
          const [logs, totalItems] = await Promise.all([
            SecurityAuditModel.find(query2).sort({ timestamp: -1 }).skip(skip).limit(limit),
            SecurityAuditModel.countDocuments(query2)
          ]);
          const totalPages = Math.ceil(totalItems / limit);
          const hasNext = page < totalPages;
          const hasPrevious = page > 1;
          const result = {
            data: logs,
            total: totalItems,
            page,
            limit,
            totalPages,
            hasNext,
            hasPrevious
          };
          this.logger.info(`R\xE9cup\xE9ration des journaux d'activit\xE9 utilisateur`, {
            userId,
            page,
            limit,
            totalItems,
            eventType,
            severity
          });
          return result;
        } catch (error2) {
          this.logger.error("Erreur lors de la r\xE9cup\xE9ration des journaux d'activit\xE9 utilisateur", {
            error: error2 instanceof Error ? error2.message : String(error2),
            userId,
            options
          });
          return {
            data: [],
            total: 0,
            page: options.page || 1,
            limit: options.limit || 50,
            totalPages: 0,
            hasNext: false,
            hasPrevious: false
          };
        }
      }
      // Helper methods with proper typing
      getMostCommonEventType(incidents) {
        if (incidents.length === 0) return null;
        const eventCounts = incidents.reduce((acc, incident) => {
          acc[incident.eventType] = (acc[incident.eventType] || 0) + 1;
          return acc;
        }, {});
        return Object.keys(eventCounts).reduce(
          (a, b) => eventCounts[a] > eventCounts[b] ? a : b
        );
      }
      getTopRiskyIPs(incidents, limit = 5) {
        const ipCounts = incidents.reduce((acc, incident) => {
          acc[incident.ipAddress] = (acc[incident.ipAddress] || 0) + 1;
          return acc;
        }, {});
        return Object.entries(ipCounts).sort(([, a], [, b]) => b - a).slice(0, limit).map(([ip]) => ip);
      }
      getUniqueUsersCount(incidents) {
        const uniqueUsers = /* @__PURE__ */ new Set();
        incidents.forEach((incident) => {
          if (incident.userId) uniqueUsers.add(incident.userId._id.toString());
          if (incident.targetUserId) uniqueUsers.add(incident.targetUserId._id.toString());
        });
        return uniqueUsers.size;
      }
    };
    __publicField(_SecurityAuditService, "instance");
    SecurityAuditService = _SecurityAuditService;
  }
});

// src/property/types/propertyType.ts
var PropertyStatus;
var init_propertyType = __esm({
  "src/property/types/propertyType.ts"() {
    PropertyStatus = /* @__PURE__ */ ((PropertyStatus2) => {
      PropertyStatus2["AVAILABLE"] = "disponible";
      PropertyStatus2["RESERVED"] = "reserver";
      PropertyStatus2["RENTED"] = "lou\xE9";
      PropertyStatus2["MAINTENANCE"] = "en maintenance";
      PropertyStatus2["REMOVED"] = "retir\xE9";
      PropertyStatus2["SOLD"] = "sold";
      return PropertyStatus2;
    })(PropertyStatus || {});
  }
});

// src/notification/types/notificationTypes.ts
var NotificationType, NotificationPriority, NotificationChannel, NotificationStatus;
var init_notificationTypes = __esm({
  "src/notification/types/notificationTypes.ts"() {
    NotificationType = /* @__PURE__ */ ((NotificationType2) => {
      NotificationType2["USER_REGISTRATION"] = "user_registration";
      NotificationType2["USER_VERIFICATION"] = "user_verification";
      NotificationType2["PASSWORD_RESET"] = "password_reset";
      NotificationType2["PASSWORD_CHANGED"] = "password_changed";
      NotificationType2["ACCOUNT_LOCKED"] = "account_locked";
      NotificationType2["ACCOUNT_UNLOCKED"] = "account_unlocked";
      NotificationType2["SECURITY_ALERT"] = "security_alert";
      NotificationType2["PROPERTY_APPROVED"] = "property_approved";
      NotificationType2["PROPERTY_REJECTED"] = "property_rejected";
      NotificationType2["PROPERTY_PUBLISHED"] = "property_published";
      NotificationType2["PROPERTY_RENTED"] = "property_rented";
      NotificationType2["PROPERTY_AVAILABLE"] = "property_available";
      NotificationType2["BOOKING_REQUEST"] = "booking_request";
      NotificationType2["BOOKING_CONFIRMED"] = "booking_confirmed";
      NotificationType2["BOOKING_CANCELLED"] = "booking_cancelled";
      NotificationType2["VISIT_SCHEDULED"] = "visit_scheduled";
      NotificationType2["VISIT_CANCELLED"] = "visit_cancelled";
      NotificationType2["VISIT_REMINDER"] = "visit_reminder";
      NotificationType2["PAYMENT_RECEIVED"] = "payment_received";
      NotificationType2["PAYMENT_FAILED"] = "payment_failed";
      NotificationType2["PAYMENT_REFUND"] = "payment_refund";
      NotificationType2["SUBSCRIPTION_EXPIRED"] = "subscription_expired";
      NotificationType2["INVOICE_GENERATED"] = "invoice_generated";
      NotificationType2["MESSAGE_RECEIVED"] = "message_received";
      NotificationType2["REVIEW_RECEIVED"] = "review_received";
      NotificationType2["SUPPORT_TICKET"] = "support_ticket";
      NotificationType2["MAINTENANCE_NOTICE"] = "maintenance_notice";
      NotificationType2["FEATURE_UPDATE"] = "feature_update";
      NotificationType2["SYSTEM_ALERT"] = "system_alert";
      NotificationType2["CUSTOM"] = "custom";
      return NotificationType2;
    })(NotificationType || {});
    NotificationPriority = /* @__PURE__ */ ((NotificationPriority2) => {
      NotificationPriority2["LOW"] = "low";
      NotificationPriority2["NORMAL"] = "normal";
      NotificationPriority2["HIGH"] = "high";
      NotificationPriority2["URGENT"] = "urgent";
      return NotificationPriority2;
    })(NotificationPriority || {});
    NotificationChannel = /* @__PURE__ */ ((NotificationChannel2) => {
      NotificationChannel2["EMAIL"] = "email";
      NotificationChannel2["SMS"] = "sms";
      NotificationChannel2["IN_APP"] = "in_app";
      NotificationChannel2["PUSH"] = "push";
      NotificationChannel2["WEBHOOK"] = "webhook";
      return NotificationChannel2;
    })(NotificationChannel || {});
    NotificationStatus = /* @__PURE__ */ ((NotificationStatus2) => {
      NotificationStatus2["PENDING"] = "pending";
      NotificationStatus2["SENT"] = "sent";
      NotificationStatus2["DELIVERED"] = "delivered";
      NotificationStatus2["FAILED"] = "failed";
      NotificationStatus2["READ"] = "read";
      NotificationStatus2["CLICKED"] = "clicked";
      NotificationStatus2["EXPIRED"] = "expired";
      return NotificationStatus2;
    })(NotificationStatus || {});
  }
});

// src/notification/models/Notification.ts
import mongoose3, { Schema as Schema9 } from "mongoose";
var notificationMetadataSchema, notificationSchema, Notification, notificationHistorySchema, NotificationHistory;
var init_Notification = __esm({
  "src/notification/models/Notification.ts"() {
    init_notificationTypes();
    notificationMetadataSchema = new Schema9({
      source: { type: String },
      campaign: { type: String },
      channel: [{ type: String, enum: Object.values(NotificationChannel) }],
      tags: [{ type: String }],
      deliveryAttempts: { type: Number, default: 0 },
      lastAttemptAt: { type: Date },
      deliveredAt: { type: Date },
      readAt: { type: Date },
      clickedAt: { type: Date }
    }, { _id: false });
    notificationSchema = new Schema9({
      userId: {
        type: Schema9.Types.ObjectId,
        ref: "User",
        required: true,
        index: true
      },
      type: {
        type: String,
        enum: Object.values(NotificationType),
        required: true,
        index: true
      },
      title: {
        type: String,
        required: true,
        maxlength: 255
      },
      message: {
        type: String,
        required: true,
        maxlength: 2e3
      },
      data: {
        type: Schema9.Types.Mixed,
        default: {}
      },
      priority: {
        type: String,
        enum: Object.values(NotificationPriority),
        default: "normal" /* NORMAL */,
        index: true
      },
      isRead: {
        type: Boolean,
        default: false,
        index: true
      },
      scheduledAt: {
        type: Date,
        index: true
      },
      expiresAt: {
        type: Date,
        index: true
      },
      metadata: {
        type: notificationMetadataSchema,
        default: {}
      }
    }, {
      timestamps: true,
      collection: "notifications"
    });
    notificationSchema.index({ userId: 1, isRead: 1 });
    notificationSchema.index({ userId: 1, createdAt: -1 });
    notificationSchema.index({ userId: 1, type: 1 });
    notificationSchema.index({ userId: 1, priority: 1, createdAt: -1 });
    notificationSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
    notificationSchema.index({ scheduledAt: 1 });
    notificationSchema.methods.markAsRead = function() {
      this.isRead = true;
      this.metadata = this.metadata || {};
      this.metadata.readAt = /* @__PURE__ */ new Date();
      return this.save();
    };
    notificationSchema.methods.markAsClicked = function() {
      this.metadata = this.metadata || {};
      this.metadata.clickedAt = /* @__PURE__ */ new Date();
      if (!this.isRead) {
        this.isRead = true;
        this.metadata.readAt = /* @__PURE__ */ new Date();
      }
      return this.save();
    };
    notificationSchema.methods.isExpired = function() {
      return this.expiresAt ? /* @__PURE__ */ new Date() > this.expiresAt : false;
    };
    notificationSchema.statics.findUnread = function(userId, limit) {
      const query2 = this.find({ userId, isRead: false }).sort({ createdAt: -1 });
      return limit ? query2.limit(limit) : query2;
    };
    notificationSchema.statics.findByType = function(userId, type) {
      return this.find({ userId, type }).sort({ createdAt: -1 });
    };
    notificationSchema.statics.markAllAsRead = function(userId) {
      return this.updateMany(
        { userId, isRead: false },
        {
          isRead: true,
          "metadata.readAt": /* @__PURE__ */ new Date()
        }
      );
    };
    notificationSchema.statics.getUnreadCount = function(userId) {
      return this.countDocuments({ userId, isRead: false });
    };
    notificationSchema.statics.cleanupExpired = function() {
      return this.deleteMany({
        expiresAt: { $lt: /* @__PURE__ */ new Date() }
      });
    };
    notificationSchema.virtual("timeAgo").get(function() {
      const now = /* @__PURE__ */ new Date();
      const created = this.createdAt;
      if (!created) return "\xC0 l'instant";
      const diffMs = now.getTime() - created.getTime();
      const diffMins = Math.floor(diffMs / (1e3 * 60));
      const diffHours = Math.floor(diffMs / (1e3 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1e3 * 60 * 60 * 24));
      if (diffMins < 1) return "\xC0 l'instant";
      if (diffMins < 60) return `Il y a ${diffMins} minute${diffMins > 1 ? "s" : ""}`;
      if (diffHours < 24) return `Il y a ${diffHours} heure${diffHours > 1 ? "s" : ""}`;
      if (diffDays < 7) return `Il y a ${diffDays} jour${diffDays > 1 ? "s" : ""}`;
      return created.toLocaleDateString("fr-FR");
    });
    notificationSchema.set("toJSON", {
      virtuals: true,
      transform: function(doc, ret) {
        delete ret.__v;
        return ret;
      }
    });
    Notification = mongoose3.model("Notification", notificationSchema);
    notificationHistorySchema = new Schema9({
      notificationId: {
        type: Schema9.Types.ObjectId,
        ref: "Notification",
        required: true,
        index: true
      },
      userId: {
        type: Schema9.Types.ObjectId,
        ref: "User",
        required: true,
        index: true
      },
      channel: {
        type: String,
        enum: Object.values(NotificationChannel),
        required: true,
        index: true
      },
      status: {
        type: String,
        enum: Object.values(NotificationStatus),
        required: true,
        index: true
      },
      attempts: {
        type: Number,
        default: 1
      },
      lastAttemptAt: {
        type: Date,
        default: Date.now
      },
      deliveredAt: Date,
      readAt: Date,
      clickedAt: Date,
      errorMessage: String,
      providerId: String,
      metadata: Schema9.Types.Mixed
    }, {
      timestamps: true,
      collection: "notification_history"
    });
    notificationHistorySchema.index({ userId: 1, createdAt: -1 });
    notificationHistorySchema.index({ notificationId: 1, channel: 1 });
    notificationHistorySchema.index({ status: 1, createdAt: -1 });
    NotificationHistory = mongoose3.model("NotificationHistory", notificationHistorySchema);
  }
});

// src/notification/services/EmailNotificationService.ts
var logger13, EmailNotificationService;
var init_EmailNotificationService = __esm({
  "src/notification/services/EmailNotificationService.ts"() {
    init_notificationServices();
    init_notificationTypes();
    init_Notification();
    init_logger();
    logger13 = createLogger2("EmailNotificationService");
    EmailNotificationService = class {
      constructor() {
        __publicField(this, "notificationService");
        this.notificationService = new NotificationService();
      }
      async sendEmail(data, userId, notificationId) {
        try {
          const recipients = Array.isArray(data.to) ? data.to : [data.to];
          const results = await Promise.all(
            recipients.map(async (email) => {
              const success = await this.notificationService.sendemail({
                to: email,
                subject: data.subject,
                html: data.htmlContent || "",
                text: data.textContent
              });
              await this.recordDeliveryHistory(
                notificationId || "direct",
                userId,
                email,
                success ? "sent" /* SENT */ : "failed" /* FAILED */
              );
              return success;
            })
          );
          return results.some((result) => result);
        } catch (error2) {
          logger13.error("Erreur lors de l'envoi d'email", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            userId,
            notificationId
          });
          return false;
        }
      }
      async sendTemplateEmail(templateId, data, userId, notificationId) {
        try {
          const templateContent = await this.getEmailTemplate(templateId, data.templateData);
          const emailData = {
            ...data,
            htmlContent: templateContent.html,
            textContent: templateContent.text
          };
          return await this.sendEmail(emailData, userId, notificationId);
        } catch (error2) {
          logger13.error("Erreur lors de l'envoi d'email avec template", {
            templateId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            userId,
            notificationId
          });
          return false;
        }
      }
      async sendBulkEmail(emails) {
        let success = 0;
        let failed = 0;
        const batchSize = 50;
        for (let i = 0; i < emails.length; i += batchSize) {
          const batch = emails.slice(i, i + batchSize);
          const results = await Promise.all(
            batch.map(async ({ to, data, userId, notificationId }) => {
              const result = await this.sendEmail({ ...data, to }, userId, notificationId);
              return result;
            })
          );
          success += results.filter((r) => r).length;
          failed += results.filter((r) => !r).length;
          if (i + batchSize < emails.length) {
            await this.delay(1e3);
          }
        }
        logger13.info("Envoi d'emails en masse termin\xE9", {
          total: emails.length,
          success,
          failed
        });
        return { success, failed };
      }
      async getEmailTemplate(templateId, templateData = {}) {
        const templates = {
          welcome: {
            html: this.getWelcomeTemplate(templateData),
            text: `Bienvenue ${templateData.firstName || "cher utilisateur"} ! Votre compte a \xE9t\xE9 cr\xE9\xE9 avec succ\xE8s.`
          },
          verification: {
            html: this.getVerificationTemplate(templateData),
            text: `Code de v\xE9rification: ${templateData.code || "N/A"}`
          },
          password_reset: {
            html: this.getPasswordResetTemplate(templateData),
            text: `R\xE9initialisez votre mot de passe: ${templateData.resetLink || "N/A"}`
          },
          booking_confirmation: {
            html: this.getBookingConfirmationTemplate(templateData),
            text: `Votre r\xE9servation a \xE9t\xE9 confirm\xE9e.`
          },
          payment_confirmation: {
            html: this.getPaymentConfirmationTemplate(templateData),
            text: `Votre paiement de ${templateData.amount || "N/A"} a \xE9t\xE9 confirm\xE9.`
          }
        };
        const template = templates[templateId];
        if (!template) {
          throw new Error(`Template non trouv\xE9: ${templateId}`);
        }
        return template;
      }
      getWelcomeTemplate(data) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center;">
          <h1 style="color: #28a745;">Bienvenue sur EasyRent, ${data.firstName || "cher utilisateur"} !</h1>
          <p style="font-size: 16px;">
            Votre compte a \xE9t\xE9 cr\xE9\xE9 avec succ\xE8s. Nous sommes ravis de vous compter parmi nos utilisateurs.
          </p>
          <div style="margin: 30px 0;">
            <a href="${data.dashboardUrl || "#"}"
               style="background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none;
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              Acc\xE9der \xE0 mon compte
            </a>
          </div>
        </div>
      </div>
    `;
      }
      getVerificationTemplate(data) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center;">
          <h1 style="color: #007bff;">Code de v\xE9rification</h1>
          <p>Voici votre code de v\xE9rification :</p>
          <div style="background-color: #007bff; color: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h2 style="margin: 0; font-size: 32px; letter-spacing: 8px;">${data.code || "N/A"}</h2>
          </div>
          <p style="color: #666;">Ce code expire dans 15 minutes.</p>
        </div>
      </div>
    `;
      }
      getPasswordResetTemplate(data) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
          <h1 style="color: #dc3545;">R\xE9initialisation de mot de passe</h1>
          <p>Cliquez sur le lien ci-dessous pour r\xE9initialiser votre mot de passe :</p>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${data.resetLink || "#"}"
               style="background-color: #dc3545; color: white; padding: 15px 30px; text-decoration: none;
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              R\xE9initialiser
            </a>
          </div>
          <p style="color: #666;">Ce lien expire dans 1 heure.</p>
        </div>
      </div>
    `;
      }
      getBookingConfirmationTemplate(data) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
          <h1 style="color: #28a745;">R\xE9servation confirm\xE9e</h1>
          <p>Votre r\xE9servation a \xE9t\xE9 confirm\xE9e avec succ\xE8s !</p>
          <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3>D\xE9tails de la r\xE9servation :</h3>
            <p><strong>Propri\xE9t\xE9 :</strong> ${data.propertyName || "N/A"}</p>
            <p><strong>Date d'arriv\xE9e :</strong> ${data.checkIn || "N/A"}</p>
            <p><strong>Date de d\xE9part :</strong> ${data.checkOut || "N/A"}</p>
            <p><strong>Montant total :</strong> ${data.totalAmount || "N/A"} \u20AC</p>
          </div>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${data.bookingUrl || "#"}"
               style="background-color: #28a745; color: white; padding: 15px 30px; text-decoration: none;
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              Voir ma r\xE9servation
            </a>
          </div>
        </div>
      </div>
    `;
      }
      getPaymentConfirmationTemplate(data) {
        return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
        <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
          <h1 style="color: #28a745;">Paiement confirm\xE9</h1>
          <p>Votre paiement a \xE9t\xE9 trait\xE9 avec succ\xE8s !</p>
          <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <h3>D\xE9tails du paiement :</h3>
            <p><strong>Montant :</strong> ${data.amount || "N/A"} \u20AC</p>
            <p><strong>R\xE9f\xE9rence :</strong> ${data.reference || "N/A"}</p>
            <p><strong>Date :</strong> ${data.date || (/* @__PURE__ */ new Date()).toLocaleDateString("fr-FR")}</p>
            <p><strong>M\xE9thode :</strong> ${data.paymentMethod || "N/A"}</p>
          </div>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${data.invoiceUrl || "#"}"
               style="background-color: #007bff; color: white; padding: 15px 30px; text-decoration: none;
                      border-radius: 5px; display: inline-block; font-weight: bold;">
              T\xE9l\xE9charger la facture
            </a>
          </div>
        </div>
      </div>
    `;
      }
      async recordDeliveryHistory(notificationId, userId, email, status) {
        try {
          const history = new NotificationHistory({
            notificationId,
            userId,
            channel: "email" /* EMAIL */,
            status,
            attempts: 1,
            lastAttemptAt: /* @__PURE__ */ new Date(),
            deliveredAt: status === "sent" /* SENT */ ? /* @__PURE__ */ new Date() : void 0,
            metadata: {
              email,
              provider: "internal"
            }
          });
          await history.save();
        } catch (error2) {
          logger13.error("Erreur lors de l'enregistrement de l'historique", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            notificationId,
            userId
          });
        }
      }
      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async getProviderStatus() {
        const status = this.notificationService.getServicesStatus();
        return {
          name: "Email Service",
          type: "email" /* EMAIL */,
          isEnabled: status.email.sendgrid || status.email.smtp,
          config: {
            primaryService: status.email.primary,
            sendgridEnabled: status.email.sendgrid,
            smtpEnabled: status.email.smtp
          }
        };
      }
      async testConfiguration() {
        try {
          const testResult = await this.notificationService.testEmailConfiguration();
          return testResult.overall;
        } catch (error2) {
          logger13.error("Erreur lors du test de configuration email", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
    };
  }
});

// src/notification/services/SmsNotificationService.ts
import twilio from "twilio";
var logger14, SmsNotificationService;
var init_SmsNotificationService = __esm({
  "src/notification/services/SmsNotificationService.ts"() {
    init_notificationTypes();
    init_Notification();
    init_logger();
    init_config();
    logger14 = createLogger2("SmsNotificationService");
    SmsNotificationService = class {
      constructor() {
        __publicField(this, "twilioClient", null);
        __publicField(this, "isEnabled", false);
        __publicField(this, "fromNumber");
        __publicField(this, "rateLimiter", {
          requests: 0,
          resetTime: Date.now() + 6e4,
          // Reset every minute
          limit: 100
          // Twilio allows many SMS per minute
        });
        this.fromNumber = config_default.twilio?.fromNumber || "";
        this.initializeTwilio();
      }
      initializeTwilio() {
        if (!config_default.twilio?.enabled || !config_default.twilio.accountSid || !config_default.twilio.authToken) {
          logger14.warn("Twilio SMS non configur\xE9", {
            enabled: config_default.twilio?.enabled,
            hasAccountSid: !!config_default.twilio?.accountSid,
            hasAuthToken: !!config_default.twilio?.authToken,
            hasFromNumber: !!this.fromNumber
          });
          return;
        }
        try {
          this.twilioClient = twilio(config_default.twilio.accountSid, config_default.twilio.authToken);
          this.isEnabled = true;
          logger14.info("Twilio SMS initialis\xE9 avec succ\xE8s", {
            fromNumber: this.fromNumber
          });
        } catch (error2) {
          logger14.error("Erreur lors de l'initialisation de Twilio", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
      async sendSms(data, userId, notificationId) {
        if (!this.isEnabled || !this.twilioClient) {
          logger14.warn("Service SMS non disponible");
          return false;
        }
        if (!this.canSendSms()) {
          logger14.warn("Limite de taux SMS atteinte");
          return false;
        }
        try {
          const recipients = Array.isArray(data.to) ? data.to : [data.to];
          const validNumbers = recipients.filter((number) => this.isValidPhoneNumber(number));
          if (validNumbers.length === 0) {
            logger14.warn("Aucun num\xE9ro de t\xE9l\xE9phone valide fourni");
            return false;
          }
          const results = await Promise.all(
            validNumbers.map(async (phoneNumber) => {
              try {
                const message = await this.twilioClient.messages.create({
                  body: data.message,
                  from: data.from || this.fromNumber,
                  to: phoneNumber,
                  mediaUrl: data.mediaUrls
                });
                this.updateRateLimit();
                await this.recordDeliveryHistory(
                  notificationId || "direct",
                  userId,
                  phoneNumber,
                  "sent" /* SENT */,
                  message.sid
                );
                logger14.info("SMS envoy\xE9 avec succ\xE8s", {
                  to: this.maskPhoneNumber(phoneNumber),
                  messageSid: message.sid,
                  status: message.status
                });
                return true;
              } catch (error2) {
                logger14.error("Erreur lors de l'envoi SMS", {
                  to: this.maskPhoneNumber(phoneNumber),
                  error: error2.message,
                  code: error2.code
                });
                await this.recordDeliveryHistory(
                  notificationId || "direct",
                  userId,
                  phoneNumber,
                  "failed" /* FAILED */,
                  void 0,
                  error2.message
                );
                return false;
              }
            })
          );
          return results.some((result) => result);
        } catch (error2) {
          logger14.error("Erreur g\xE9n\xE9rale lors de l'envoi SMS", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            userId,
            notificationId
          });
          return false;
        }
      }
      async sendTemplateSms(templateId, data, userId, notificationId) {
        try {
          const templateContent = this.getSmsTemplate(templateId, data.templateData);
          const smsData = {
            ...data,
            message: templateContent
          };
          return await this.sendSms(smsData, userId, notificationId);
        } catch (error2) {
          logger14.error("Erreur lors de l'envoi SMS avec template", {
            templateId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            userId,
            notificationId
          });
          return false;
        }
      }
      async sendBulkSms(messages) {
        let success = 0;
        let failed = 0;
        const batchSize = 20;
        for (let i = 0; i < messages.length; i += batchSize) {
          const batch = messages.slice(i, i + batchSize);
          const results = await Promise.all(
            batch.map(async ({ to, data, userId, notificationId }) => {
              const result = await this.sendSms({ ...data, to }, userId, notificationId);
              return result;
            })
          );
          success += results.filter((r) => r).length;
          failed += results.filter((r) => !r).length;
          if (i + batchSize < messages.length) {
            await this.delay(2e3);
          }
        }
        logger14.info("Envoi SMS en masse termin\xE9", {
          total: messages.length,
          success,
          failed
        });
        return { success, failed };
      }
      async sendVerificationSms(phoneNumber, code, userId) {
        const message = `Votre code de v\xE9rification EasyRent est : ${code}. Ce code expire dans 15 minutes.`;
        return await this.sendSms({
          to: phoneNumber,
          message
        }, userId, "verification");
      }
      async sendBookingNotificationSms(phoneNumber, bookingDetails, userId) {
        const message = `EasyRent: R\xE9servation confirm\xE9e pour ${bookingDetails.propertyName} du ${bookingDetails.checkIn} au ${bookingDetails.checkOut}. Montant: ${bookingDetails.totalAmount}\u20AC. D\xE9tails sur votre compte.`;
        return await this.sendSms({
          to: phoneNumber,
          message
        }, userId, "booking_confirmation");
      }
      async sendPaymentNotificationSms(phoneNumber, paymentDetails, userId) {
        const message = paymentDetails.status === "success" ? `EasyRent: Paiement de ${paymentDetails.amount}\u20AC confirm\xE9. R\xE9f: ${paymentDetails.reference}` : `EasyRent: \xC9chec du paiement de ${paymentDetails.amount}\u20AC. R\xE9f: ${paymentDetails.reference}. Veuillez r\xE9essayer.`;
        return await this.sendSms({
          to: phoneNumber,
          message
        }, userId, "payment_notification");
      }
      getSmsTemplate(templateId, templateData = {}) {
        const templates = {
          verification: `EasyRent: Votre code de v\xE9rification est ${templateData.code || "N/A"}. Expire dans 15 min.`,
          welcome: `Bienvenue sur EasyRent ${templateData.firstName || ""}! Votre compte est activ\xE9. Commencez \xE0 explorer nos propri\xE9t\xE9s.`,
          password_reset: `EasyRent: Code de r\xE9initialisation: ${templateData.code || "N/A"}. Utilisez ce code pour changer votre mot de passe.`,
          booking_reminder: `EasyRent: Rappel - Votre s\xE9jour chez ${templateData.propertyName || "N/A"} commence ${templateData.checkIn || "bient\xF4t"}.`,
          payment_reminder: `EasyRent: Paiement de ${templateData.amount || "N/A"}\u20AC d\xFB le ${templateData.dueDate || "N/A"}. Payez sur votre compte.`,
          visit_reminder: `EasyRent: Visite pr\xE9vue ${templateData.visitDate || "N/A"} \xE0 ${templateData.visitTime || "N/A"} pour ${templateData.propertyName || "N/A"}.`,
          emergency_alert: `EasyRent URGENT: ${templateData.message || "V\xE9rifiez votre compte imm\xE9diatement"}.`
        };
        const template = templates[templateId];
        if (!template) {
          throw new Error(`Template SMS non trouv\xE9: ${templateId}`);
        }
        return template;
      }
      isValidPhoneNumber(phoneNumber) {
        const phoneRegex = /^\+?[1-9]\d{1,14}$/;
        return phoneRegex.test(phoneNumber.replace(/[\s-()]/g, ""));
      }
      maskPhoneNumber(phoneNumber) {
        if (phoneNumber.length < 6) return "***";
        return phoneNumber.substring(0, 3) + "***" + phoneNumber.substring(phoneNumber.length - 2);
      }
      canSendSms() {
        const now = Date.now();
        if (now > this.rateLimiter.resetTime) {
          this.rateLimiter.requests = 0;
          this.rateLimiter.resetTime = now + 6e4;
        }
        return this.rateLimiter.requests < this.rateLimiter.limit;
      }
      updateRateLimit() {
        this.rateLimiter.requests++;
      }
      async recordDeliveryHistory(notificationId, userId, phoneNumber, status, providerId, errorMessage) {
        try {
          const history = new NotificationHistory({
            notificationId,
            userId,
            channel: "sms" /* SMS */,
            status,
            attempts: 1,
            lastAttemptAt: /* @__PURE__ */ new Date(),
            deliveredAt: status === "sent" /* SENT */ ? /* @__PURE__ */ new Date() : void 0,
            providerId,
            errorMessage,
            metadata: {
              phoneNumber: this.maskPhoneNumber(phoneNumber),
              provider: "twilio"
            }
          });
          await history.save();
        } catch (error2) {
          logger14.error("Erreur lors de l'enregistrement de l'historique SMS", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            notificationId,
            userId
          });
        }
      }
      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async getProviderStatus() {
        return {
          name: "Twilio SMS",
          type: "sms" /* SMS */,
          isEnabled: this.isEnabled,
          config: {
            fromNumber: this.fromNumber,
            accountSid: config_default.twilio?.accountSid ? "***" + config_default.twilio.accountSid.slice(-4) : "N/A"
          },
          rateLimit: {
            requests: this.rateLimiter.requests,
            window: 60,
            resetTime: new Date(this.rateLimiter.resetTime)
          }
        };
      }
      async testConfiguration() {
        if (!this.isEnabled || !this.twilioClient) {
          return false;
        }
        try {
          const account = await this.twilioClient.api.accounts(config_default.twilio.accountSid).fetch();
          logger14.info("Test configuration SMS r\xE9ussi", {
            accountStatus: account.status,
            accountSid: account.sid
          });
          return account.status === "active";
        } catch (error2) {
          logger14.error("Test configuration SMS \xE9chou\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      // Get SMS delivery status from Twilio
      async getMessageStatus(messageSid) {
        if (!this.isEnabled || !this.twilioClient) {
          return null;
        }
        try {
          const message = await this.twilioClient.messages(messageSid).fetch();
          return message.status;
        } catch (error2) {
          logger14.error("Erreur lors de la r\xE9cup\xE9ration du statut SMS", {
            messageSid,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return null;
        }
      }
      // Get SMS usage statistics from Twilio
      async getUsageStats(startDate, endDate) {
        if (!this.isEnabled || !this.twilioClient) {
          return null;
        }
        try {
          const usage = await this.twilioClient.usage.records.list({
            category: "sms",
            startDate: startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            // Last 30 days
            endDate: endDate || /* @__PURE__ */ new Date()
          });
          return {
            totalMessages: usage.reduce((sum, record) => sum + parseInt(record.count.toString()), 0),
            totalCost: usage.reduce((sum, record) => sum + parseFloat(record.price.toString()), 0),
            records: usage.map((record) => ({
              date: record.startDate,
              count: record.count,
              price: record.price,
              priceUnit: record.priceUnit
            }))
          };
        } catch (error2) {
          logger14.error("Erreur lors de la r\xE9cup\xE9ration des statistiques SMS", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return null;
        }
      }
    };
  }
});

// src/notification/services/InAppNotificationService.ts
var logger15, InAppNotificationService;
var init_InAppNotificationService = __esm({
  "src/notification/services/InAppNotificationService.ts"() {
    init_Notification();
    init_notificationTypes();
    init_logger();
    logger15 = createLogger2("InAppNotificationService");
    InAppNotificationService = class {
      // socketId -> userId
      constructor(io) {
        __publicField(this, "io", null);
        __publicField(this, "connectedUsers", /* @__PURE__ */ new Map());
        // userId -> Set of socketIds
        __publicField(this, "userSockets", /* @__PURE__ */ new Map());
        if (io) {
          this.initializeSocketIO(io);
        }
      }
      initializeSocketIO(io) {
        this.io = io;
        this.io.on("connection", (socket) => {
          logger15.debug("Nouvelle connexion socket", { socketId: socket.id });
          socket.on("authenticate", async (data) => {
            try {
              if (data.token) {
              }
              const userId = data.userId;
              this.registerUserConnection(userId, socket.id);
              socket.join(`user_${userId}`);
              logger15.info("Utilisateur authentifi\xE9", { userId, socketId: socket.id });
              await this.sendUnreadNotifications(userId, socket.id);
              socket.emit("authenticated", { success: true, userId });
            } catch (error2) {
              logger15.error("Erreur d'authentification socket", {
                error: error2 instanceof Error ? error2.message : "Erreur inconnue",
                socketId: socket.id
              });
              socket.emit("authentication_error", { message: "\xC9chec de l'authentification" });
            }
          });
          socket.on("mark_as_read", async (data) => {
            try {
              const userId = this.userSockets.get(socket.id);
              if (!userId) {
                socket.emit("error", { message: "Non authentifi\xE9" });
                return;
              }
              await this.markAsRead(data.notificationId, userId);
              socket.emit("notification_read", { notificationId: data.notificationId });
              const unreadCount = await this.getUnreadCount(userId);
              socket.emit("unread_count_updated", { count: unreadCount });
            } catch (error2) {
              logger15.error("Erreur lors du marquage comme lu", {
                error: error2 instanceof Error ? error2.message : "Erreur inconnue",
                notificationId: data.notificationId
              });
              socket.emit("error", { message: "Erreur lors du marquage" });
            }
          });
          socket.on("mark_all_as_read", async () => {
            try {
              const userId = this.userSockets.get(socket.id);
              if (!userId) {
                socket.emit("error", { message: "Non authentifi\xE9" });
                return;
              }
              await this.markAllAsRead(userId);
              socket.emit("all_notifications_read");
              socket.emit("unread_count_updated", { count: 0 });
            } catch (error2) {
              logger15.error("Erreur lors du marquage de toutes les notifications", {
                error: error2 instanceof Error ? error2.message : "Erreur inconnue"
              });
              socket.emit("error", { message: "Erreur lors du marquage" });
            }
          });
          socket.on("get_notifications", async (data) => {
            try {
              const userId = this.userSockets.get(socket.id);
              if (!userId) {
                socket.emit("error", { message: "Non authentifi\xE9" });
                return;
              }
              const notifications = await this.getNotifications(userId, {
                page: data.page || 1,
                limit: data.limit || 20,
                type: data.type
              });
              socket.emit("notifications_list", notifications);
            } catch (error2) {
              logger15.error("Erreur lors de la r\xE9cup\xE9ration des notifications", {
                error: error2 instanceof Error ? error2.message : "Erreur inconnue"
              });
              socket.emit("error", { message: "Erreur lors de la r\xE9cup\xE9ration" });
            }
          });
          socket.on("disconnect", () => {
            this.unregisterUserConnection(socket.id);
            logger15.debug("D\xE9connexion socket", { socketId: socket.id });
          });
        });
        logger15.info("Service de notifications in-app initialis\xE9 avec Socket.IO");
      }
      async sendNotification(data, notificationId) {
        try {
          const userIds = Array.isArray(data.userId) ? data.userId : [data.userId];
          let successCount = 0;
          for (const userId of userIds) {
            const notification = new Notification({
              userId,
              type: "custom" /* CUSTOM */,
              title: data.title,
              message: data.message,
              data: {
                icon: data.icon,
                image: data.image,
                actionUrl: data.actionUrl,
                actionLabel: data.actionLabel,
                category: data.category
              },
              priority: "normal" /* NORMAL */,
              isRead: false,
              ...data.persistent === false && { expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1e3) }
              // 24h par défaut
            });
            const savedNotification = await notification.save();
            const delivered = await this.sendRealTimeNotification(userId, {
              id: savedNotification._id.toString(),
              title: data.title,
              message: data.message,
              type: "custom" /* CUSTOM */,
              icon: data.icon,
              image: data.image,
              actionUrl: data.actionUrl,
              actionLabel: data.actionLabel,
              category: data.category,
              createdAt: savedNotification.createdAt,
              isRead: false
            });
            await this.recordDeliveryHistory(
              savedNotification._id.toString(),
              userId,
              delivered ? "delivered" /* DELIVERED */ : "sent" /* SENT */
            );
            if (delivered) {
              successCount++;
            }
          }
          return successCount > 0;
        } catch (error2) {
          logger15.error("Erreur lors de l'envoi de notification in-app", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            notificationId
          });
          return false;
        }
      }
      async sendRealTimeNotification(userId, notificationData) {
        if (!this.io) {
          logger15.warn("Socket.IO non initialis\xE9");
          return false;
        }
        try {
          this.io.to(`user_${userId}`).emit("new_notification", notificationData);
          const unreadCount = await this.getUnreadCount(userId);
          this.io.to(`user_${userId}`).emit("unread_count_updated", { count: unreadCount });
          const userConnections = this.connectedUsers.get(userId);
          const isConnected = userConnections && userConnections.size > 0;
          logger15.info("Notification temps r\xE9el envoy\xE9e", {
            userId,
            connected: isConnected,
            connections: userConnections?.size || 0,
            title: notificationData.title
          });
          return isConnected || false;
        } catch (error2) {
          logger15.error("Erreur lors de l'envoi en temps r\xE9el", {
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async sendSystemNotification(userIds, title, message, priority = "high" /* HIGH */) {
        let success = 0;
        let failed = 0;
        for (const userId of userIds) {
          try {
            const result = await this.sendNotification({
              userId,
              title,
              message,
              category: "system",
              persistent: true
            });
            if (result) {
              success++;
            } else {
              failed++;
            }
          } catch (error2) {
            failed++;
            logger15.error("Erreur lors de l'envoi de notification syst\xE8me", {
              userId,
              error: error2 instanceof Error ? error2.message : "Erreur inconnue"
            });
          }
        }
        logger15.info("Notification syst\xE8me envoy\xE9e", {
          total: userIds.length,
          success,
          failed,
          title
        });
        return { success, failed };
      }
      async sendBroadcastNotification(title, message, excludeUserIds = []) {
        if (!this.io) {
          return false;
        }
        try {
          const notificationData = {
            id: `broadcast_${Date.now()}`,
            title,
            message,
            type: "system_alert" /* SYSTEM_ALERT */,
            category: "broadcast",
            createdAt: /* @__PURE__ */ new Date(),
            isRead: false
          };
          for (const [userId, socketIds] of this.connectedUsers.entries()) {
            if (!excludeUserIds.includes(userId)) {
              this.io.to(`user_${userId}`).emit("broadcast_notification", notificationData);
            }
          }
          logger15.info("Notification broadcast envoy\xE9e", {
            title,
            connectedUsers: this.connectedUsers.size,
            excludedUsers: excludeUserIds.length
          });
          return true;
        } catch (error2) {
          logger15.error("Erreur lors du broadcast", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async sendUnreadNotifications(userId, socketId) {
        try {
          const notifications = await Notification.findUnread(userId, 50);
          const unreadCount = await this.getUnreadCount(userId);
          if (this.io) {
            this.io.to(socketId).emit("unread_notifications", {
              notifications: notifications.map((n) => ({
                id: n._id.toString(),
                title: n.title,
                message: n.message,
                type: n.type,
                createdAt: n.createdAt,
                data: n.data,
                priority: n.priority
              })),
              count: unreadCount
            });
          }
        } catch (error2) {
          logger15.error("Erreur lors de l'envoi des notifications non lues", {
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
      registerUserConnection(userId, socketId) {
        if (!this.connectedUsers.has(userId)) {
          this.connectedUsers.set(userId, /* @__PURE__ */ new Set());
        }
        this.connectedUsers.get(userId).add(socketId);
        this.userSockets.set(socketId, userId);
        logger15.debug("Connexion utilisateur enregistr\xE9e", {
          userId,
          socketId,
          totalConnections: this.connectedUsers.get(userId).size
        });
      }
      unregisterUserConnection(socketId) {
        const userId = this.userSockets.get(socketId);
        if (userId) {
          const userConnections = this.connectedUsers.get(userId);
          if (userConnections) {
            userConnections.delete(socketId);
            if (userConnections.size === 0) {
              this.connectedUsers.delete(userId);
            }
          }
          this.userSockets.delete(socketId);
          logger15.debug("Connexion utilisateur supprim\xE9e", {
            userId,
            socketId,
            remainingConnections: userConnections?.size || 0
          });
        }
      }
      async markAsRead(notificationId, userId) {
        try {
          const notification = await Notification.findOne({ _id: notificationId, userId });
          if (!notification) {
            return false;
          }
          await notification.markAsRead();
          await this.recordDeliveryHistory(notificationId, userId, "read" /* READ */);
          return true;
        } catch (error2) {
          logger15.error("Erreur lors du marquage comme lu", {
            notificationId,
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async markAllAsRead(userId) {
        try {
          await Notification.markAllAsRead(userId);
          return true;
        } catch (error2) {
          logger15.error("Erreur lors du marquage de toutes les notifications", {
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async getNotifications(userId, options = {}) {
        const page = options.page || 1;
        const limit = options.limit || 20;
        const skip = (page - 1) * limit;
        const query2 = { userId };
        if (options.type) query2.type = options.type;
        if (options.isRead !== void 0) query2.isRead = options.isRead;
        const [notifications, total] = await Promise.all([
          Notification.find(query2).sort({ createdAt: -1 }).skip(skip).limit(limit).lean(),
          Notification.countDocuments(query2)
        ]);
        return {
          notifications: notifications.map((n) => ({
            id: n._id.toString(),
            title: n.title,
            message: n.message,
            type: n.type,
            data: n.data,
            priority: n.priority,
            isRead: n.isRead,
            createdAt: n.createdAt,
            updatedAt: n.updatedAt
          })),
          pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit)
          }
        };
      }
      async getUnreadCount(userId) {
        try {
          return await Notification.getUnreadCount(userId);
        } catch (error2) {
          logger15.error("Erreur lors du comptage des notifications non lues", {
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return 0;
        }
      }
      async deleteNotification(notificationId, userId) {
        try {
          const result = await Notification.deleteOne({ _id: notificationId, userId });
          return result.deletedCount > 0;
        } catch (error2) {
          logger15.error("Erreur lors de la suppression de notification", {
            notificationId,
            userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async cleanupExpiredNotifications() {
        try {
          const result = await Notification.cleanupExpired();
          logger15.info("Notifications expir\xE9es nettoy\xE9es", { count: result.deletedCount });
          return result.deletedCount;
        } catch (error2) {
          logger15.error("Erreur lors du nettoyage des notifications expir\xE9es", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return 0;
        }
      }
      async recordDeliveryHistory(notificationId, userId, status) {
        try {
          const history = new NotificationHistory({
            notificationId,
            userId,
            channel: "in_app" /* IN_APP */,
            status,
            attempts: 1,
            lastAttemptAt: /* @__PURE__ */ new Date(),
            deliveredAt: status === "delivered" /* DELIVERED */ ? /* @__PURE__ */ new Date() : void 0,
            readAt: status === "read" /* READ */ ? /* @__PURE__ */ new Date() : void 0,
            metadata: {
              realTime: true,
              socketConnections: this.connectedUsers.get(userId)?.size || 0
            }
          });
          await history.save();
        } catch (error2) {
          logger15.error("Erreur lors de l'enregistrement de l'historique", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            notificationId,
            userId
          });
        }
      }
      getConnectedUsers() {
        return Array.from(this.connectedUsers.entries()).map(([userId, connections]) => ({
          userId,
          connections: connections.size
        }));
      }
      isUserConnected(userId) {
        return this.connectedUsers.has(userId) && this.connectedUsers.get(userId).size > 0;
      }
      async getProviderStatus() {
        return {
          name: "In-App Notifications",
          type: "in_app" /* IN_APP */,
          isEnabled: this.io !== null,
          config: {
            socketIOEnabled: this.io !== null,
            connectedUsers: this.connectedUsers.size,
            totalConnections: Array.from(this.connectedUsers.values()).reduce((sum, connections) => sum + connections.size, 0)
          }
        };
      }
    };
  }
});

// src/notification/models/NotificationPreference.ts
import mongoose4, { Schema as Schema10 } from "mongoose";
var ChannelPreferencesSchema, NotificationPreferenceSchema, NotificationPreference;
var init_NotificationPreference = __esm({
  "src/notification/models/NotificationPreference.ts"() {
    ChannelPreferencesSchema = new Schema10({
      inApp: { type: Boolean, default: true },
      push: { type: Boolean, default: true },
      email: { type: Boolean, default: false },
      sms: { type: Boolean, default: false }
    }, { _id: false });
    NotificationPreferenceSchema = new Schema10({
      userId: { type: String, required: true, unique: true, index: true },
      preferences: {
        wallet: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: false, sms: false } },
        property: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: true, sms: false } },
        service: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: false, sms: false } },
        general: { type: ChannelPreferencesSchema, default: { inApp: true, push: false, email: false, sms: false } },
        security: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: true, sms: false } },
        reminder: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: false, sms: false } },
        marketplace: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: false, sms: false } },
        defi: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: true, sms: false } },
        governance: { type: ChannelPreferencesSchema, default: { inApp: true, push: true, email: false, sms: false } }
      },
      pushToken: { type: String },
      deviceInfo: {
        platform: { type: String, enum: ["ios", "android", "web"] },
        deviceId: { type: String },
        appVersion: { type: String }
      },
      quietHours: {
        enabled: { type: Boolean, default: false },
        startTime: { type: String, default: "22:00" },
        endTime: { type: String, default: "08:00" },
        timezone: { type: String, default: "UTC" }
      }
    }, {
      timestamps: true
    });
    NotificationPreferenceSchema.index({ userId: 1 });
    NotificationPreferenceSchema.index({ pushToken: 1 });
    NotificationPreference = mongoose4.models.NotificationPreference || mongoose4.model(
      "NotificationPreference",
      NotificationPreferenceSchema
    );
  }
});

// src/notification/services/PushNotificationService.ts
var logger16, FCMProvider, APNSProvider, PushNotificationService;
var init_PushNotificationService = __esm({
  "src/notification/services/PushNotificationService.ts"() {
    init_NotificationPreference();
    init_notificationTypes();
    init_logger();
    logger16 = createLogger2("PushNotificationService");
    FCMProvider = class {
      constructor() {
        __publicField(this, "fcm");
        try {
          const admin2 = __require("firebase-admin");
          if (!admin2.apps.length) {
            const serviceAccount = __require(process.env.FIREBASE_SERVICE_ACCOUNT_PATH || "./firebase-service-account.json");
            admin2.initializeApp({
              credential: admin2.credential.cert(serviceAccount),
              projectId: process.env.FIREBASE_PROJECT_ID
            });
          }
          this.fcm = admin2.messaging();
          logger16.info("Firebase Cloud Messaging initialis\xE9 avec succ\xE8s");
        } catch (error2) {
          logger16.warn("Firebase non configur\xE9, push notifications d\xE9sactiv\xE9es", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          this.fcm = null;
        }
      }
      async sendNotification(token, payload) {
        if (!this.fcm) {
          throw new Error("Firebase not configured");
        }
        try {
          const message = {
            token,
            notification: {
              title: payload.title,
              body: payload.body,
              ...payload.icon && { icon: payload.icon },
              ...payload.image && { image: payload.image }
            },
            data: payload.data ? this.stringifyData(payload.data) : {},
            android: {
              notification: {
                ...payload.sound && { sound: payload.sound },
                ...payload.clickAction && { clickAction: payload.clickAction },
                priority: "high"
              }
            },
            apns: {
              payload: {
                aps: {
                  ...payload.badge && { badge: payload.badge },
                  ...payload.sound && { sound: payload.sound },
                  "content-available": 1
                }
              }
            },
            webpush: {
              notification: {
                title: payload.title,
                body: payload.body,
                ...payload.icon && { icon: payload.icon },
                ...payload.image && { image: payload.image },
                requireInteraction: payload.title.includes("urgent"),
                actions: payload.clickAction ? [
                  {
                    action: "open",
                    title: "Ouvrir",
                    icon: "/icons/open.png"
                  }
                ] : void 0
              },
              fcmOptions: {
                link: payload.clickAction
              }
            }
          };
          const response = await this.fcm.send(message);
          logger16.info("Push notification envoy\xE9e avec succ\xE8s", {
            token: token.substring(0, 10) + "...",
            response
          });
          return true;
        } catch (error2) {
          logger16.error("Erreur envoi push FCM", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            code: error2.code
          });
          if (error2.code === "messaging/registration-token-not-registered" || error2.code === "messaging/invalid-registration-token") {
            await this.cleanupInvalidToken(token);
          }
          return false;
        }
      }
      stringifyData(data) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
          result[key] = typeof value === "string" ? value : JSON.stringify(value);
        }
        return result;
      }
      async cleanupInvalidToken(token) {
        try {
          await NotificationPreference.updateMany(
            { pushToken: token },
            { $unset: { pushToken: 1 } }
          );
          logger16.info("Token push invalide supprim\xE9", { token: token.substring(0, 10) + "..." });
        } catch (error2) {
          logger16.error("Erreur suppression token invalide", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
    };
    APNSProvider = class {
      async sendNotification(token, payload) {
        logger16.warn("APNS provider non impl\xE9ment\xE9", { token: token.substring(0, 10) + "..." });
        return false;
      }
    };
    PushNotificationService = class {
      constructor() {
        __publicField(this, "providers", /* @__PURE__ */ new Map());
        this.providers.set("fcm", new FCMProvider());
        this.providers.set("apns", new APNSProvider());
        logger16.info("PushNotificationService initialis\xE9");
      }
      /**
       * Envoyer une notification push à partir d'une notification existante
       */
      async sendNotification(notification) {
        try {
          const preferences = await NotificationPreference.findOne({
            userId: notification.userId,
            pushToken: { $exists: true, $ne: null }
          });
          if (!preferences?.pushToken) {
            throw new Error("No push token found for user");
          }
          const payload = this.buildPayload(notification);
          const platform = preferences.deviceInfo?.platform || "android";
          const provider = this.getProvider(platform);
          const success = await provider.sendNotification(preferences.pushToken, payload);
          if (!success) {
            throw new Error("Push notification failed");
          }
          logger16.info("Notification push envoy\xE9e", {
            userId: notification.userId,
            type: notification.type,
            platform
          });
        } catch (error2) {
          logger16.error("Erreur PushNotificationService", {
            userId: notification.userId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          throw error2;
        }
      }
      /**
       * Envoyer une notification push personnalisée
       */
      async sendCustomNotification(data) {
        let success = 0;
        let failed = 0;
        const tokens = Array.isArray(data.tokens) ? data.tokens : [data.tokens];
        for (const token of tokens) {
          try {
            const payload = {
              title: data.title,
              body: data.body,
              icon: data.icon,
              image: data.image,
              sound: data.sound,
              badge: data.badge,
              data: data.data,
              clickAction: data.clickAction
            };
            const provider = this.providers.get("fcm");
            const result = await provider.sendNotification(token, payload);
            if (result) {
              success++;
            } else {
              failed++;
            }
          } catch (error2) {
            failed++;
            logger16.error("Erreur envoi notification personnalis\xE9e", {
              token: token.substring(0, 10) + "...",
              error: error2 instanceof Error ? error2.message : "Erreur inconnue"
            });
          }
        }
        logger16.info("Envoi de notifications push personnalis\xE9es termin\xE9", {
          total: tokens.length,
          success,
          failed
        });
        return { success, failed };
      }
      /**
       * Envoyer des notifications push en masse
       */
      async sendBulkNotifications(notifications) {
        const batchSize = 100;
        for (let i = 0; i < notifications.length; i += batchSize) {
          const batch = notifications.slice(i, i + batchSize);
          const promises = batch.map(
            (notification) => this.sendNotification(notification).catch((error2) => {
              logger16.error("Erreur envoi notification en masse", {
                notificationId: notification._id,
                error: error2 instanceof Error ? error2.message : "Erreur inconnue"
              });
              return null;
            })
          );
          await Promise.allSettled(promises);
          if (i + batchSize < notifications.length) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        }
        logger16.info("Envoi en masse termin\xE9", { total: notifications.length });
      }
      /**
       * Tester un token push
       */
      async testPushToken(token, platform = "android") {
        try {
          const provider = this.getProvider(platform);
          const testPayload = {
            title: "Test de notification",
            body: "Votre token push fonctionne correctement !",
            data: { test: "true" }
          };
          const result = await provider.sendNotification(token, testPayload);
          logger16.info("Test du token push", {
            token: token.substring(0, 10) + "...",
            success: result
          });
          return result;
        } catch (error2) {
          logger16.error("Erreur test token push", {
            token: token.substring(0, 10) + "...",
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Construire le payload à partir d'une notification
       */
      buildPayload(notification) {
        const payload = {
          title: notification.title,
          body: notification.message,
          data: {
            notificationId: notification._id.toString(),
            type: notification.type,
            category: notification.category,
            priority: notification.priority,
            ...notification.metadata
          }
        };
        switch (notification.type) {
          case "wallet":
            payload.icon = "/icons/wallet.png";
            payload.sound = "default";
            break;
          case "property":
            payload.icon = "/icons/property.png";
            payload.sound = "default";
            break;
          case "service":
            payload.icon = "/icons/service.png";
            break;
          case "security":
            payload.icon = "/icons/security.png";
            payload.sound = "alert";
            break;
          default:
            payload.icon = "/icons/default.png";
        }
        switch (notification.priority) {
          case "urgent":
            payload.sound = "alert";
            payload.badge = 1;
            break;
          case "high":
            payload.sound = "default";
            payload.badge = 1;
            break;
          default:
            payload.sound = notification.type === "security" ? "default" : void 0;
        }
        if (notification.metadata?.actionUrl) {
          payload.clickAction = notification.metadata.actionUrl;
        }
        if (notification.metadata?.imageUrl) {
          payload.image = notification.metadata.imageUrl;
        }
        return payload;
      }
      /**
       * Obtenir le provider selon la plateforme
       */
      getProvider(platform) {
        switch (platform) {
          case "ios":
            return this.providers.get("apns") || this.providers.get("fcm");
          case "android":
          case "web":
          default:
            return this.providers.get("fcm");
        }
      }
      /**
       * Obtenir le statut du service
       */
      async getProviderStatus() {
        const fcmProvider = this.providers.get("fcm");
        const apnsProvider = this.providers.get("apns");
        return {
          name: "Push Notification Service",
          type: "push" /* PUSH */,
          isEnabled: fcmProvider?.fcm !== null,
          config: {
            fcmEnabled: fcmProvider?.fcm !== null,
            apnsEnabled: false,
            providers: ["FCM", "APNS (\xE0 impl\xE9menter)"]
          }
        };
      }
    };
  }
});

// src/notification/services/NotificationManager.ts
var logger17, NotificationManager;
var init_NotificationManager = __esm({
  "src/notification/services/NotificationManager.ts"() {
    init_EmailNotificationService();
    init_SmsNotificationService();
    init_InAppNotificationService();
    init_PushNotificationService();
    init_Notification();
    init_notificationTypes();
    init_logger();
    logger17 = createLogger2("NotificationManager");
    NotificationManager = class {
      constructor(io) {
        __publicField(this, "emailService");
        __publicField(this, "smsService");
        __publicField(this, "inAppService");
        __publicField(this, "pushService");
        // ✅ AJOUTÉ
        __publicField(this, "isProcessingQueue", false);
        __publicField(this, "queueProcessingInterval", null);
        this.emailService = new EmailNotificationService();
        this.smsService = new SmsNotificationService();
        this.inAppService = new InAppNotificationService(io);
        this.pushService = new PushNotificationService();
        this.startQueueProcessing();
        logger17.info("NotificationManager initialis\xE9 avec tous les services");
      }
      /**
       * Méthode principale pour envoyer des notifications multicanaux
       */
      async sendNotification(request) {
        const results = {};
        let overallSuccess = false;
        let notificationId;
        try {
          const userIds = Array.isArray(request.userId) ? request.userId : [request.userId];
          for (const userId of userIds) {
            if (request.channels.includes("in_app" /* IN_APP */)) {
              const notification = new Notification({
                userId,
                type: request.type,
                title: request.title,
                message: request.message,
                data: request.data,
                priority: request.priority || "normal" /* NORMAL */,
                isRead: false,
                scheduledAt: request.scheduledAt,
                expiresAt: request.expiresAt,
                metadata: {
                  ...request.metadata,
                  channel: request.channels,
                  source: request.metadata?.source || "api"
                }
              });
              const savedNotification = await notification.save();
              notificationId = savedNotification._id.toString();
            }
            for (const channel of request.channels) {
              try {
                let channelResult = false;
                switch (channel) {
                  case "email" /* EMAIL */:
                    if (request.data?.email) {
                      channelResult = await this.emailService.sendEmail(
                        request.data.email,
                        userId,
                        notificationId
                      );
                    }
                    break;
                  case "sms" /* SMS */:
                    if (request.data?.sms) {
                      channelResult = await this.smsService.sendSms(
                        request.data.sms,
                        userId,
                        notificationId
                      );
                    }
                    break;
                  case "in_app" /* IN_APP */:
                    if (request.data?.inApp) {
                      channelResult = await this.inAppService.sendNotification(
                        { ...request.data.inApp, userId },
                        notificationId
                      );
                    } else {
                      channelResult = await this.inAppService.sendNotification({
                        userId,
                        title: request.title,
                        message: request.message,
                        category: this.getNotificationCategory(request.type)
                      }, notificationId);
                    }
                    break;
                  case "push" /* PUSH */:
                    if (request.data?.push) {
                      channelResult = await this.sendPushNotification(request.data.push, userId, notificationId);
                    }
                    break;
                  case "webhook" /* WEBHOOK */:
                    if (request.data?.webhook) {
                      channelResult = await this.sendWebhook(request.data.webhook, userId, notificationId);
                    }
                    break;
                }
                results[channel] = channelResult;
                if (channelResult) {
                  overallSuccess = true;
                }
                logger17.debug("R\xE9sultat envoi canal", {
                  channel,
                  success: channelResult,
                  userId,
                  notificationId
                });
              } catch (error2) {
                logger17.error("Erreur envoi canal", {
                  channel,
                  error: error2 instanceof Error ? error2.message : "Erreur inconnue",
                  userId,
                  notificationId
                });
                results[channel] = false;
              }
            }
          }
          return {
            success: overallSuccess,
            results,
            notificationId
          };
        } catch (error2) {
          logger17.error("Erreur lors de l'envoi de notification", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            request: {
              type: request.type,
              channels: request.channels,
              userId: request.userId
            }
          });
          return {
            success: false,
            results,
            notificationId: void 0
          };
        }
      }
      /**
       * Envoyer une notification avec template prédéfini
       */
      async sendTemplateNotification(templateId, templateData, request) {
        const template = await this.getTemplate(templateId);
        if (!template) {
          throw new Error(`Template non trouv\xE9: ${templateId}`);
        }
        const title = this.replaceTemplateVariables(template.title, templateData);
        const message = this.replaceTemplateVariables(template.message, templateData);
        return this.sendNotification({
          ...request,
          title,
          message,
          type: template.type,
          priority: template.priority
        });
      }
      /**
       * Planifier une notification pour plus tard
       */
      async scheduleNotification(request, scheduledAt) {
        try {
          const notification = new Notification({
            userId: Array.isArray(request.userId) ? request.userId[0] : request.userId,
            type: request.type,
            title: request.title,
            message: request.message,
            data: request.data,
            priority: request.priority || "normal" /* NORMAL */,
            isRead: false,
            scheduledAt,
            expiresAt: request.expiresAt,
            metadata: {
              ...request.metadata,
              channel: request.channels,
              source: "scheduled"
            }
          });
          const savedNotification = await notification.save();
          logger17.info("Notification planifi\xE9e", {
            notificationId: savedNotification._id.toString(),
            scheduledAt,
            type: request.type,
            userId: request.userId
          });
          return savedNotification._id.toString();
        } catch (error2) {
          logger17.error("Erreur lors de la planification", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            scheduledAt
          });
          throw error2;
        }
      }
      /**
       * Traiter les notifications planifiées
       */
      async processScheduledNotifications() {
        try {
          const now = /* @__PURE__ */ new Date();
          const scheduledNotifications = await Notification.find({
            scheduledAt: { $lte: now },
            isRead: false,
            "metadata.processed": { $ne: true }
          }).limit(50);
          if (scheduledNotifications.length === 0) {
            return;
          }
          logger17.info("Traitement des notifications planifi\xE9es", {
            count: scheduledNotifications.length
          });
          for (const notification of scheduledNotifications) {
            try {
              const metadata = notification.metadata;
              const request = metadata?.scheduledRequest;
              if (request) {
                await this.sendNotification(request);
                notification.metadata = notification.metadata || {};
                notification.metadata.processed = true;
                notification.metadata.processedAt = /* @__PURE__ */ new Date();
                await notification.save();
              }
            } catch (error2) {
              logger17.error("Erreur traitement notification planifi\xE9e", {
                notificationId: notification._id.toString(),
                error: error2 instanceof Error ? error2.message : "Erreur inconnue"
              });
            }
          }
        } catch (error2) {
          logger17.error("Erreur traitement notifications planifi\xE9es", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
      /**
       * Démarrer le traitement automatique de la queue
       */
      startQueueProcessing() {
        if (this.queueProcessingInterval) {
          return;
        }
        this.queueProcessingInterval = setInterval(async () => {
          if (!this.isProcessingQueue) {
            this.isProcessingQueue = true;
            try {
              await this.processScheduledNotifications();
              await this.inAppService.cleanupExpiredNotifications();
            } catch (error2) {
              logger17.error("Erreur traitement queue", {
                error: error2 instanceof Error ? error2.message : "Erreur inconnue"
              });
            } finally {
              this.isProcessingQueue = false;
            }
          }
        }, 6e4);
        logger17.info("Traitement automatique de la queue d\xE9marr\xE9");
      }
      /**
       * Arrêter le traitement automatique
       */
      stopQueueProcessing() {
        if (this.queueProcessingInterval) {
          clearInterval(this.queueProcessingInterval);
          this.queueProcessingInterval = null;
          logger17.info("Traitement automatique de la queue arr\xEAt\xE9");
        }
      }
      /**
       * Obtenir les statistiques de notifications
       */
      async getNotificationStats(userId, startDate, endDate) {
        try {
          const query2 = {};
          if (userId) query2.userId = userId;
          if (startDate || endDate) {
            query2.createdAt = {};
            if (startDate) query2.createdAt.$gte = startDate;
            if (endDate) query2.createdAt.$lte = endDate;
          }
          const [notifications, history] = await Promise.all([
            Notification.find(query2),
            NotificationHistory.find(query2)
          ]);
          const stats = {
            total: notifications.length,
            sent: history.filter((h) => h.status === "sent" /* SENT */).length,
            delivered: history.filter((h) => h.status === "delivered" /* DELIVERED */).length,
            failed: history.filter((h) => h.status === "failed" /* FAILED */).length,
            read: history.filter((h) => h.status === "read" /* READ */).length,
            clicked: history.filter((h) => h.status === "clicked" /* CLICKED */).length,
            byChannel: {},
            byType: {},
            byPriority: {}
          };
          for (const channel of Object.values(NotificationChannel)) {
            const channelHistory = history.filter((h) => h.channel === channel);
            stats.byChannel[channel] = {
              sent: channelHistory.filter((h) => h.status === "sent" /* SENT */).length,
              delivered: channelHistory.filter((h) => h.status === "delivered" /* DELIVERED */).length,
              failed: channelHistory.filter((h) => h.status === "failed" /* FAILED */).length
            };
          }
          for (const type of Object.values(NotificationType)) {
            stats.byType[type] = notifications.filter((n) => n.type === type).length;
          }
          for (const priority of Object.values(NotificationPriority)) {
            stats.byPriority[priority] = notifications.filter((n) => n.priority === priority).length;
          }
          return stats;
        } catch (error2) {
          logger17.error("Erreur r\xE9cup\xE9ration statistiques", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          throw error2;
        }
      }
      /**
       * Obtenir le statut de tous les services
       */
      async getAllServicesStatus() {
        const services = await Promise.all([
          this.emailService.getProviderStatus(),
          this.smsService.getProviderStatus(),
          this.inAppService.getProviderStatus(),
          this.pushService.getProviderStatus()
          // ✅ AJOUTÉ
        ]);
        return services;
      }
      /**
       * Tester tous les services
       */
      async testAllServices() {
        const results = {};
        try {
          const [emailTest, smsTest] = await Promise.all([
            this.emailService.testConfiguration(),
            this.smsService.testConfiguration()
          ]);
          results["email" /* EMAIL */] = emailTest;
          results["sms" /* SMS */] = smsTest;
          results["in_app" /* IN_APP */] = true;
          logger17.info("Test de tous les services termin\xE9", results);
          return results;
        } catch (error2) {
          logger17.error("Erreur test des services", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          throw error2;
        }
      }
      // Méthodes privées utilitaires
      async sendPushNotification(pushData, userId, notificationId) {
        try {
          if (pushData.tokens && pushData.tokens.length > 0) {
            const result = await this.pushService.sendCustomNotification({
              tokens: pushData.tokens,
              title: pushData.title,
              body: pushData.body,
              icon: pushData.icon,
              image: pushData.image,
              sound: pushData.sound,
              badge: pushData.badge,
              data: pushData.data,
              clickAction: pushData.clickAction,
              category: pushData.category,
              tag: pushData.tag
            });
            logger17.info("Push notification envoy\xE9e", {
              userId,
              notificationId,
              success: result.success,
              failed: result.failed
            });
            return result.success > 0;
          }
          return false;
        } catch (error2) {
          logger17.error("Erreur envoi push notification", {
            userId,
            notificationId,
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      async sendWebhook(webhookData, userId, notificationId) {
        try {
          const fetch3 = (await Promise.resolve().then(() => (init_lib(), lib_exports))).default;
          const response = await fetch3(webhookData.url, {
            method: webhookData.method || "POST",
            headers: {
              "Content-Type": "application/json",
              ...webhookData.headers
            },
            body: JSON.stringify({
              ...webhookData.payload,
              userId,
              notificationId,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            })
          });
          return response.ok;
        } catch (error2) {
          logger17.error("Erreur envoi webhook", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            url: webhookData.url
          });
          return false;
        }
      }
      getNotificationCategory(type) {
        const categoryMap = {
          ["user_registration" /* USER_REGISTRATION */]: "account",
          ["user_verification" /* USER_VERIFICATION */]: "account",
          ["password_reset" /* PASSWORD_RESET */]: "security",
          ["password_changed" /* PASSWORD_CHANGED */]: "security",
          ["account_locked" /* ACCOUNT_LOCKED */]: "security",
          ["account_unlocked" /* ACCOUNT_UNLOCKED */]: "security",
          ["security_alert" /* SECURITY_ALERT */]: "security",
          ["property_approved" /* PROPERTY_APPROVED */]: "property",
          ["property_rejected" /* PROPERTY_REJECTED */]: "property",
          ["property_published" /* PROPERTY_PUBLISHED */]: "property",
          ["property_rented" /* PROPERTY_RENTED */]: "property",
          ["property_available" /* PROPERTY_AVAILABLE */]: "property",
          ["booking_request" /* BOOKING_REQUEST */]: "booking",
          ["booking_confirmed" /* BOOKING_CONFIRMED */]: "booking",
          ["booking_cancelled" /* BOOKING_CANCELLED */]: "booking",
          ["visit_scheduled" /* VISIT_SCHEDULED */]: "booking",
          ["visit_cancelled" /* VISIT_CANCELLED */]: "booking",
          ["visit_reminder" /* VISIT_REMINDER */]: "booking",
          ["payment_received" /* PAYMENT_RECEIVED */]: "financial",
          ["payment_failed" /* PAYMENT_FAILED */]: "financial",
          ["payment_refund" /* PAYMENT_REFUND */]: "financial",
          ["subscription_expired" /* SUBSCRIPTION_EXPIRED */]: "financial",
          ["invoice_generated" /* INVOICE_GENERATED */]: "financial",
          ["message_received" /* MESSAGE_RECEIVED */]: "communication",
          ["review_received" /* REVIEW_RECEIVED */]: "communication",
          ["support_ticket" /* SUPPORT_TICKET */]: "support",
          ["maintenance_notice" /* MAINTENANCE_NOTICE */]: "system",
          ["feature_update" /* FEATURE_UPDATE */]: "system",
          ["system_alert" /* SYSTEM_ALERT */]: "system",
          ["custom" /* CUSTOM */]: "general"
        };
        return categoryMap[type] || "general";
      }
      async getTemplate(templateId) {
        const templates = {
          welcome: {
            title: "Bienvenue sur EasyRent !",
            message: "Bienvenue {{firstName}}, votre compte a \xE9t\xE9 cr\xE9\xE9 avec succ\xE8s.",
            type: "user_registration" /* USER_REGISTRATION */,
            priority: "high" /* HIGH */
          },
          booking_confirmation: {
            title: "R\xE9servation confirm\xE9e",
            message: "Votre r\xE9servation pour {{propertyName}} a \xE9t\xE9 confirm\xE9e du {{checkIn}} au {{checkOut}}.",
            type: "booking_confirmed" /* BOOKING_CONFIRMED */,
            priority: "high" /* HIGH */
          },
          payment_success: {
            title: "Paiement confirm\xE9",
            message: "Votre paiement de {{amount}}\u20AC a \xE9t\xE9 trait\xE9 avec succ\xE8s.",
            type: "payment_received" /* PAYMENT_RECEIVED */,
            priority: "normal" /* NORMAL */
          }
        };
        return templates[templateId];
      }
      replaceTemplateVariables(template, data) {
        return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
          return data[key] || match;
        });
      }
      /**
       * Méthodes publiques pour l'accès aux services individuels
       */
      get email() {
        return this.emailService;
      }
      get sms() {
        return this.smsService;
      }
      get inApp() {
        return this.inAppService;
      }
      get push() {
        return this.pushService;
      }
    };
  }
});

// src/property/model/atoutShema.ts
import { Schema as Schema11 } from "mongoose";
var AtoutSchema, atoutShema_default;
var init_atoutShema = __esm({
  "src/property/model/atoutShema.ts"() {
    AtoutSchema = new Schema11(
      {
        id: { type: String, required: true },
        type: {
          type: String,
          enum: ["predefined", "custom_text", "custom_icon"],
          required: true
        },
        text: { type: String, required: true },
        icon: { type: String },
        lib: { type: String },
        category: { type: String, required: true },
        verified: { type: Boolean, default: false },
        priority: { type: Number, default: 0 },
        customIcon: { type: Boolean, default: false }
      },
      { _id: false }
    );
    atoutShema_default = AtoutSchema;
  }
});

// src/property/model/equipmentSchema.ts
import { Schema as Schema12 } from "mongoose";
var EquipmentSchema, equipmentSchema_default;
var init_equipmentSchema = __esm({
  "src/property/model/equipmentSchema.ts"() {
    EquipmentSchema = new Schema12(
      {
        id: { type: String, required: true },
        name: { type: String, required: true },
        icon: { type: String, required: true },
        lib: { type: String, required: true },
        category: { type: String, required: true }
      },
      { _id: false }
    );
    equipmentSchema_default = EquipmentSchema;
  }
});

// src/property/model/propertyModel.ts
import mongoose6, { model as model4, Schema as Schema13 } from "mongoose";
var propertySchema, Property, propertyModel_default;
var init_propertyModel = __esm({
  "src/property/model/propertyModel.ts"() {
    init_propertyType();
    init_atoutShema();
    init_equipmentSchema();
    propertySchema = new Schema13(
      {
        propertyId: {
          type: mongoose6.Schema.Types.ObjectId,
          default: () => new mongoose6.Types.ObjectId(),
          index: true
        },
        ownerId: {
          type: Schema13.Types.ObjectId,
          ref: "User",
          required: [true, "L'identifiant du propri\xE9taire est requis"],
          index: true
        },
        acquiredBy: {
          type: Schema13.Types.ObjectId,
          ref: "User",
          default: null
        },
        actionType: {
          type: String,
          enum: ["rent", "sell"]
        },
        propertyType: {
          type: String,
          enum: [
            "villa",
            "apartment",
            "home",
            "penthouse",
            "studio",
            "loft",
            "bureau",
            "chalet",
            "hotel",
            "terrain",
            "commercial"
          ],
          required: true
        },
        island: { type: Boolean, default: false },
        ishome: { type: Boolean, default: true },
        title: {
          type: String,
          maxlength: [50, "Le titre ne peut pas d\xE9passer 50 caract\xE8res"],
          required: [true, "Le titre est requis"],
          trim: true
        },
        description: {
          type: String,
          minlength: [80, "La description doit contenir au moins 80 caract\xE8res"],
          required: [true, "La description est requise"],
          trim: true
        },
        address: {
          type: String,
          minlength: [10, "L'adresse doit contenir au moins 10 caract\xE8res"],
          required: [true, "L'adresse est requise"],
          trim: true
        },
        generalHInfo: {
          rooms: { type: Number, min: 1, default: 1 },
          bedrooms: { type: Number, min: 0, required: true },
          bathrooms: { type: Number, min: 0, required: true },
          toilets: { type: Number, default: 0 },
          surface: { type: Number, min: 1, required: true },
          area: { type: String, required: true, trim: true },
          furnished: { type: Boolean, default: false },
          pets: { type: Boolean, default: false },
          smoking: { type: Boolean, default: false },
          maxOccupants: { type: Number, min: 1, default: 1 }
        },
        generalLandinfo: {
          surface: { type: Number, min: 1, required: true },
          constructible: { type: Boolean, default: true },
          cultivable: { type: Boolean, default: true },
          fence: { type: Boolean, default: false }
        },
        images: {
          type: [{
            publicId: { type: String, required: true },
            originalUrl: { type: String, required: true },
            variants: {
              thumbnail: { type: String, required: true },
              small: { type: String, required: true },
              medium: { type: String, required: true },
              large: { type: String, required: true },
              original: { type: String, required: true }
            },
            metadata: {
              width: { type: Number, required: true },
              height: { type: Number, required: true },
              format: { type: String, required: true },
              size: { type: Number, required: true },
              aspectRatio: { type: Number, required: true }
            },
            uploadedAt: { type: Date, default: Date.now },
            order: { type: Number, default: 0 }
          }],
          validate: {
            validator: (v) => v.length > 0,
            message: "Au moins une image est requise"
          },
          required: true
        },
        amenities: { type: [String], default: [] },
        availableFrom: { type: Date, required: true, default: Date.now, index: true },
        status: {
          type: String,
          enum: Object.values(PropertyStatus),
          default: "disponible" /* AVAILABLE */,
          index: true
        },
        isActive: { type: Boolean, default: true, index: true },
        equipments: { type: [equipmentSchema_default], default: [] },
        ownerCriteria: {
          monthlyRent: { type: Number, min: 0, required: true },
          isGarantRequired: { type: Boolean, default: false },
          depositAmount: { type: Number, min: 0, default: 0 },
          minimumDuration: { type: Number, default: 1 },
          solvability: {
            type: String,
            enum: ["instant", "date"],
            default: "instant"
          },
          guarantorRequired: { type: Boolean, default: false },
          guarantorLocation: {
            type: String,
            enum: ["same", "different"],
            default: "same"
          },
          acceptedSituations: { type: [String], default: [] },
          isdocumentRequired: { type: Boolean, default: false },
          requiredDocuments: {
            client: { type: [String], default: [] },
            guarantor: { type: [String], default: [] }
          }
        },
        iserviceAvalaible: { type: Boolean, default: false },
        services: {
          serviceId: {
            type: mongoose6.Types.ObjectId,
            ref: "Services",
            required: true,
            index: true
          }
        },
        atouts: { type: [atoutShema_default], default: [] }
      },
      {
        timestamps: true,
        toJSON: { virtuals: true },
        toObject: { virtuals: true }
      }
    );
    propertySchema.index({ "generalHInfo.area": 1 });
    propertySchema.index({ "ownerCriteria.monthlyRent": 1 });
    propertySchema.index({ "generalHInfo.bedrooms": 1 });
    propertySchema.index({ status: 1, isActive: 1 });
    propertySchema.index({ "ownerCriteria.monthlyRent": 1, "generalHInfo.area": 1 });
    propertySchema.index(
      { title: "text", description: "text", address: "text", "generalHInfo.area": "text" },
      {
        weights: { title: 10, "generalHInfo.area": 5, address: 3, description: 1 },
        name: "property_text_index"
      }
    );
    propertySchema.virtual("pricePerSquareMeter").get(function() {
      return this.generalHInfo.surface > 0 ? this.ownerCriteria.monthlyRent / this.generalHInfo.surface : 0;
    });
    propertySchema.methods.isAvailableAt = function(date) {
      return date >= this.availableFrom && this.status === "disponible" /* AVAILABLE */;
    };
    propertySchema.pre("save", function(next) {
      if (this.generalHInfo.bedrooms + this.generalHInfo.bathrooms > this.generalHInfo.rooms) {
        return next(
          new Error(
            "Le nombre total de chambres et salles de bain ne peut pas d\xE9passer le nombre de pi\xE8ces"
          )
        );
      }
      next();
    });
    Property = model4("Property", propertySchema);
    propertyModel_default = Property;
  }
});

// src/notification/services/ActivityNotificationService.ts
var logger18, ActivityNotificationService;
var init_ActivityNotificationService = __esm({
  "src/notification/services/ActivityNotificationService.ts"() {
    init_notificationTypes();
    init_logger();
    init_userModel();
    init_propertyModel();
    logger18 = createLogger2("ActivityNotificationService");
    ActivityNotificationService = class {
      constructor(notificationManager) {
        __publicField(this, "notificationManager");
        this.notificationManager = notificationManager;
      }
      /**
       * Notification pour demande de visite
       */
      async sendVisitRequestNotification(activity) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId).populate("ownerId"),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) {
            logger18.warn("Propri\xE9t\xE9 ou client non trouv\xE9 pour notification de visite");
            return false;
          }
          const owner = property2.ownerId;
          const ownerNotification = {
            userId: owner._id.toString(),
            type: "visit_scheduled" /* VISIT_SCHEDULED */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "high" /* HIGH */,
            title: "Nouvelle demande de visite",
            message: `${client.firstName} ${client.lastName} souhaite visiter votre propri\xE9t\xE9 "${property2.title}"`,
            data: {
              email: {
                to: owner.email,
                subject: "Nouvelle demande de visite - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  visitDate: activity.visitDate,
                  message: activity.message,
                  propertyUrl: `/properties/${property2._id}`,
                  activityUrl: `/activities/${activity._id}`
                }
              },
              inApp: {
                userId: owner._id.toString(),
                title: "Nouvelle demande de visite",
                message: `${client.firstName} ${client.lastName} souhaite visiter "${property2.title}"`,
                actionUrl: `/activities/${activity._id}`,
                actionLabel: "Voir la demande",
                category: "visit",
                icon: "calendar"
              }
            },
            metadata: {
              activityId: activity._id
            }
          };
          const result = await this.notificationManager.sendTemplateNotification(
            "visit_request",
            ownerNotification.data?.email?.templateData || {},
            ownerNotification
          );
          logger18.info("Notification de demande de visite envoy\xE9e", {
            propertyId: property2._id,
            ownerId: owner._id,
            clientId: client._id,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger18.error("Erreur envoi notification demande de visite", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id
          });
          return false;
        }
      }
      /**
       * Notification pour acceptation/refus de visite
       */
      async sendVisitResponseNotification(activity, isAccepted, reason) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) {
            logger18.warn("Propri\xE9t\xE9 ou client non trouv\xE9 pour notification de r\xE9ponse visite");
            return false;
          }
          const notificationType = isAccepted ? "visit_scheduled" /* VISIT_SCHEDULED */ : "visit_cancelled" /* VISIT_CANCELLED */;
          const title = isAccepted ? "Visite accept\xE9e !" : "Visite refus\xE9e";
          const message = isAccepted ? `Votre demande de visite pour "${property2.title}" a \xE9t\xE9 accept\xE9e` : `Votre demande de visite pour "${property2.title}" a \xE9t\xE9 refus\xE9e`;
          const clientNotification = {
            userId: client._id.toString(),
            type: notificationType,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */, "sms" /* SMS */],
            priority: "high" /* HIGH */,
            title,
            message,
            data: {
              email: {
                to: client.email,
                subject: `${title} - EasyRent`,
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  isAccepted,
                  reason,
                  visitDate: activity.visitDate,
                  propertyUrl: `/properties/${property2._id}`,
                  activityUrl: `/activities/${activity._id}`
                }
              },
              sms: client.phoneNumber ? {
                to: client.phoneNumber,
                message: `EasyRent: ${message}. ${isAccepted ? "D\xE9tails sur votre compte." : reason || ""}`
              } : void 0,
              inApp: {
                userId: client._id.toString(),
                title,
                message,
                actionUrl: `/activities/${activity._id}`,
                actionLabel: "Voir d\xE9tails",
                category: "visit",
                icon: isAccepted ? "check-circle" : "x-circle"
              }
            },
            metadata: {
              activityId: activity._id
            }
          };
          const templateId = isAccepted ? "visit_accepted" : "visit_rejected";
          const result = await this.notificationManager.sendTemplateNotification(
            templateId,
            clientNotification.data?.email?.templateData || {},
            clientNotification
          );
          logger18.info("Notification de r\xE9ponse visite envoy\xE9e", {
            propertyId: property2._id,
            clientId: client._id,
            isAccepted,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger18.error("Erreur envoi notification r\xE9ponse visite", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id,
            isAccepted
          });
          return false;
        }
      }
      /**
       * Notification pour demande de réservation
       */
      async sendReservationRequestNotification(activity) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId).populate("ownerId"),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) {
            logger18.warn("Propri\xE9t\xE9 ou client non trouv\xE9 pour notification de r\xE9servation");
            return false;
          }
          const owner = property2.ownerId;
          const ownerNotification = {
            userId: owner._id.toString(),
            type: "booking_request" /* BOOKING_REQUEST */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "high" /* HIGH */,
            title: "Nouvelle demande de r\xE9servation",
            message: `${client.firstName} ${client.lastName} souhaite r\xE9server votre propri\xE9t\xE9 "${property2.title}"`,
            data: {
              email: {
                to: owner.email,
                subject: "Nouvelle demande de r\xE9servation - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  reservationDate: activity.reservationDate,
                  documentsUploaded: activity.documentsUploaded,
                  amount: property2.ownerCriteria?.depositAmount || property2.monthlyRent,
                  propertyUrl: `/properties/${property2._id}`,
                  activityUrl: `/activities/${activity._id}`
                }
              },
              inApp: {
                userId: owner._id.toString(),
                title: "Nouvelle demande de r\xE9servation",
                message: `${client.firstName} ${client.lastName} souhaite r\xE9server "${property2.title}"`,
                actionUrl: `/activities/${activity._id}`,
                actionLabel: "Examiner la demande",
                category: "reservation",
                icon: "home"
              }
            },
            metadata: {
              activityId: activity._id
            }
          };
          const result = await this.notificationManager.sendTemplateNotification(
            "reservation_request",
            ownerNotification.data?.email?.templateData || {},
            ownerNotification
          );
          logger18.info("Notification de demande de r\xE9servation envoy\xE9e", {
            propertyId: property2._id,
            ownerId: owner._id,
            clientId: client._id,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger18.error("Erreur envoi notification demande de r\xE9servation", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id
          });
          return false;
        }
      }
      /**
       * Notification pour acceptation/refus de réservation
       */
      async sendReservationResponseNotification(activity, isAccepted, reason) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) {
            logger18.warn("Propri\xE9t\xE9 ou client non trouv\xE9 pour notification de r\xE9ponse r\xE9servation");
            return false;
          }
          const notificationType = isAccepted ? "booking_confirmed" /* BOOKING_CONFIRMED */ : "booking_cancelled" /* BOOKING_CANCELLED */;
          const title = isAccepted ? "R\xE9servation accept\xE9e !" : "R\xE9servation refus\xE9e";
          const message = isAccepted ? `Votre r\xE9servation pour "${property2.title}" a \xE9t\xE9 accept\xE9e. Vous pouvez proc\xE9der au paiement.` : `Votre r\xE9servation pour "${property2.title}" a \xE9t\xE9 refus\xE9e`;
          const clientNotification = {
            userId: client._id.toString(),
            type: notificationType,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */, "sms" /* SMS */],
            priority: "high" /* HIGH */,
            title,
            message,
            data: {
              email: {
                to: client.email,
                subject: `${title} - EasyRent`,
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  isAccepted,
                  reason,
                  reservationDate: activity.reservationDate,
                  amount: property2.ownerCriteria?.depositAmount || property2.monthlyRent,
                  propertyUrl: `/properties/${property2._id}`,
                  activityUrl: `/activities/${activity._id}`,
                  paymentUrl: isAccepted ? `/payment/${activity._id}` : void 0
                }
              },
              sms: client.phoneNumber ? {
                to: client.phoneNumber,
                message: `EasyRent: ${message}. ${isAccepted ? "Proc\xE9dez au paiement sur votre compte." : reason || ""}`
              } : void 0,
              inApp: {
                userId: client._id.toString(),
                title,
                message,
                actionUrl: isAccepted ? `/payment/${activity._id}` : `/activities/${activity._id}`,
                actionLabel: isAccepted ? "Proc\xE9der au paiement" : "Voir d\xE9tails",
                category: "reservation",
                icon: isAccepted ? "credit-card" : "x-circle"
              }
            }
          };
          const templateId = isAccepted ? "reservation_accepted" : "reservation_rejected";
          const result = await this.notificationManager.sendTemplateNotification(
            templateId,
            clientNotification.data?.email?.templateData || {},
            clientNotification
          );
          logger18.info("Notification de r\xE9ponse r\xE9servation envoy\xE9e", {
            propertyId: property2._id,
            clientId: client._id,
            isAccepted,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger18.error("Erreur envoi notification r\xE9ponse r\xE9servation", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id,
            isAccepted
          });
          return false;
        }
      }
      /**
       * Notification pour paiement effectué
       */
      async sendPaymentNotification(activity) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId).populate("ownerId"),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) {
            logger18.warn("Propri\xE9t\xE9 ou client non trouv\xE9 pour notification de paiement");
            return false;
          }
          const owner = property2.ownerId;
          const ownerNotification = {
            userId: owner._id.toString(),
            type: "payment_received" /* PAYMENT_RECEIVED */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "high" /* HIGH */,
            title: "Paiement re\xE7u",
            message: `Paiement de ${activity.amount}\u20AC re\xE7u pour "${property2.title}"`,
            data: {
              email: {
                to: owner.email,
                subject: "Paiement re\xE7u - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  amount: activity.amount,
                  paymentDate: activity.payementDate,
                  reference: activity._id,
                  propertyUrl: `/properties/${property2._id}`,
                  activityUrl: `/activities/${activity._id}`
                }
              },
              inApp: {
                userId: owner._id.toString(),
                title: "Paiement re\xE7u",
                message: `Paiement de ${activity.amount}\u20AC re\xE7u de ${client.firstName} ${client.lastName}`,
                actionUrl: `/activities/${activity._id}`,
                actionLabel: "Voir d\xE9tails",
                category: "payment",
                icon: "dollar-sign"
              }
            }
          };
          const clientNotification = {
            userId: client._id.toString(),
            type: "payment_received" /* PAYMENT_RECEIVED */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */, "sms" /* SMS */],
            priority: "high" /* HIGH */,
            title: "Paiement confirm\xE9",
            message: `Votre paiement de ${activity.amount}\u20AC a \xE9t\xE9 confirm\xE9 pour "${property2.title}"`,
            data: {
              email: {
                to: client.email,
                subject: "Paiement confirm\xE9 - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  amount: activity.amount,
                  paymentDate: activity.payementDate,
                  reference: activity._id,
                  propertyUrl: `/properties/${property2._id}`,
                  invoiceUrl: `/invoice/${activity._id}`
                }
              },
              sms: client.phoneNumber ? {
                to: client.phoneNumber,
                message: `EasyRent: Paiement de ${activity.amount}\u20AC confirm\xE9 pour ${property2.title}. R\xE9f: ${activity._id}`
              } : void 0,
              inApp: {
                userId: client._id.toString(),
                title: "Paiement confirm\xE9",
                message: `Votre paiement de ${activity.amount}\u20AC a \xE9t\xE9 confirm\xE9`,
                actionUrl: `/invoice/${activity._id}`,
                actionLabel: "T\xE9l\xE9charger facture",
                category: "payment",
                icon: "check-circle"
              }
            }
          };
          const [ownerResult, clientResult] = await Promise.all([
            this.notificationManager.sendTemplateNotification(
              "payment_received_owner",
              ownerNotification.data?.email?.templateData || {},
              ownerNotification
            ),
            this.notificationManager.sendTemplateNotification(
              "payment_confirmed_client",
              clientNotification.data?.email?.templateData || {},
              clientNotification
            )
          ]);
          logger18.info("Notifications de paiement envoy\xE9es", {
            propertyId: property2._id,
            ownerId: owner._id,
            clientId: client._id,
            amount: activity.amount,
            ownerSuccess: ownerResult.success,
            clientSuccess: clientResult.success
          });
          return ownerResult.success && clientResult.success;
        } catch (error2) {
          logger18.error("Erreur envoi notifications de paiement", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id
          });
          return false;
        }
      }
      /**
       * Notification de rappel de paiement
       */
      async sendPaymentReminderNotification(activity) {
        try {
          const [property2, client] = await Promise.all([
            propertyModel_default.findById(activity.propertyId),
            userModel_default.findById(activity.clientId)
          ]);
          if (!property2 || !client) return false;
          const daysLeft = Math.ceil((new Date(activity.reservationDate).getTime() - Date.now()) / (1e3 * 60 * 60 * 24));
          const clientNotification = {
            userId: client._id.toString(),
            type: "payment_failed" /* PAYMENT_FAILED */,
            channels: ["in_app" /* IN_APP */, "sms" /* SMS */, "email" /* EMAIL */],
            priority: "high" /* HIGH */,
            title: "Rappel de paiement",
            message: `N'oubliez pas de payer votre r\xE9servation pour "${property2.title}"`,
            data: {
              email: {
                to: client.email,
                subject: "Rappel de paiement - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  clientName: `${client.firstName} ${client.lastName}`,
                  amount: property2.ownerCriteria?.depositAmount || property2.monthlyRent,
                  daysLeft,
                  paymentUrl: `/payment/${activity._id}`
                }
              },
              sms: client.phoneNumber ? {
                to: client.phoneNumber,
                message: `EasyRent: Rappel - Paiement de ${property2.ownerCriteria?.depositAmount || property2.monthlyRent}\u20AC requis pour ${property2.title}. ${daysLeft} jour(s) restant(s).`
              } : void 0,
              inApp: {
                userId: client._id.toString(),
                title: "Rappel de paiement",
                message: `Paiement en attente pour "${property2.title}"`,
                actionUrl: `/payment/${activity._id}`,
                actionLabel: "Payer maintenant",
                category: "payment",
                icon: "clock"
              }
            }
          };
          const result = await this.notificationManager.sendTemplateNotification(
            "payment_reminder",
            clientNotification.data?.email?.templateData || {},
            clientNotification
          );
          return result.success;
        } catch (error2) {
          logger18.error("Erreur envoi rappel de paiement", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id
          });
          return false;
        }
      }
      /**
       * Planifier les notifications de rappel
       */
      async scheduleActivityReminders(activity) {
        try {
          if (activity.isReservationAccepted && !activity.isPayment) {
            const reminderDate = new Date(activity.reservationDate);
            reminderDate.setDate(reminderDate.getDate() - 1);
            if (reminderDate > /* @__PURE__ */ new Date()) {
              await this.notificationManager.scheduleNotification(
                {
                  userId: activity.clientId.toString(),
                  type: "payment_failed" /* PAYMENT_FAILED */,
                  channels: ["in_app" /* IN_APP */, "sms" /* SMS */],
                  title: "Rappel de paiement",
                  message: "N'oubliez pas de payer votre r\xE9servation",
                  metadata: {
                    activityId: activity._id.toString(),
                    reminderType: "payment"
                  }
                },
                reminderDate
              );
            }
          }
          if (activity.isVisitAccepted && activity.visitDate) {
            const visitReminderDate = new Date(activity.visitDate);
            visitReminderDate.setHours(visitReminderDate.getHours() - 2);
            if (visitReminderDate > /* @__PURE__ */ new Date()) {
              await this.notificationManager.scheduleNotification(
                {
                  userId: activity.clientId.toString(),
                  type: "visit_reminder" /* VISIT_REMINDER */,
                  channels: ["in_app" /* IN_APP */, "sms" /* SMS */],
                  title: "Rappel de visite",
                  message: "Votre visite commence dans 2 heures",
                  metadata: {
                    activityId: activity._id.toString(),
                    reminderType: "visit"
                  }
                },
                visitReminderDate
              );
            }
          }
        } catch (error2) {
          logger18.error("Erreur planification des rappels d'activit\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            activityId: activity._id
          });
        }
      }
      /**
       * Obtenir les followers d'un utilisateur (pour les propriétés)
       */
      async getUserFollowers(userId) {
        try {
          const users = await userModel_default.find({
            _id: { $ne: userId },
            isActive: true
          }).limit(100).select("_id");
          return users.map((user) => user._id.toString());
        } catch (error2) {
          logger18.error("Erreur r\xE9cup\xE9ration followers", { error: error2 });
          return [];
        }
      }
    };
  }
});

// src/notification/services/PropertyNotificationService.ts
var logger19, PropertyNotificationService;
var init_PropertyNotificationService = __esm({
  "src/notification/services/PropertyNotificationService.ts"() {
    init_notificationTypes();
    init_logger();
    init_userModel();
    logger19 = createLogger2("PropertyNotificationService");
    PropertyNotificationService = class {
      constructor(notificationManager) {
        __publicField(this, "notificationManager");
        this.notificationManager = notificationManager;
      }
      /**
       * Notification broadcast pour nouvelle propriété (comme Instagram)
       * Notifie tous les utilisateurs de l'application
       */
      async sendNewPropertyNotification(property2) {
        try {
          const owner = await userModel_default.findById(property2.ownerId);
          if (!owner) {
            logger19.warn("Propri\xE9taire non trouv\xE9 pour nouvelle propri\xE9t\xE9");
            return false;
          }
          const users = await userModel_default.find({
            _id: { $ne: property2.ownerId },
            isActive: true
            // Vous pouvez ajouter d'autres filtres ici (préférences de notification, etc.)
          }).select("_id email firstName lastName phoneNumber").limit(500);
          if (users.length === 0) {
            logger19.info("Aucun utilisateur \xE0 notifier pour la nouvelle propri\xE9t\xE9");
            return true;
          }
          const userIds = users.map((user) => user._id.toString());
          const broadcastNotification = {
            userId: userIds,
            type: "property_published" /* PROPERTY_PUBLISHED */,
            channels: ["in_app" /* IN_APP */],
            priority: "normal" /* NORMAL */,
            title: "Nouvelle propri\xE9t\xE9 disponible !",
            message: `${owner.firstName} ${owner.lastName} a publi\xE9 une nouvelle propri\xE9t\xE9 : "${property2.title}" \xE0 ${property2.area}`,
            data: {
              inApp: {
                userId: userIds,
                title: "Nouvelle propri\xE9t\xE9 disponible !",
                message: `Nouvelle propri\xE9t\xE9 \xE0 ${property2.area} - ${property2.monthlyRent}\u20AC/mois`,
                actionUrl: `/properties/${property2._id}`,
                actionLabel: "Voir la propri\xE9t\xE9",
                category: "property",
                icon: "home",
                image: property2.images?.[0]
              }
            },
            metadata: {
              propertyId: property2._id.toString(),
              ownerId: property2.ownerId.toString(),
              broadcast: true,
              source: "new_property"
            }
          };
          const result = await this.notificationManager.sendNotification(broadcastNotification);
          await this.sendNewPropertyEmailsToInterestedUsers(property2, owner, users);
          logger19.info("Notification broadcast nouvelle propri\xE9t\xE9 envoy\xE9e", {
            propertyId: property2._id,
            ownerId: property2.ownerId,
            usersNotified: userIds.length,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger19.error("Erreur envoi notification nouvelle propri\xE9t\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            propertyId: property2._id
          });
          return false;
        }
      }
      /**
       * Notification pour changement de statut de propriété
       */
      async sendPropertyStatusUpdateNotification(property2, oldStatus, newStatus) {
        try {
          const owner = await userModel_default.findById(property2.ownerId);
          if (!owner) return false;
          let notificationType;
          let title;
          let message;
          switch (newStatus) {
            case "disponible":
              notificationType = "property_available" /* PROPERTY_AVAILABLE */;
              title = "Propri\xE9t\xE9 disponible";
              message = `Votre propri\xE9t\xE9 "${property2.title}" est maintenant disponible`;
              break;
            case "lou\xE9":
            case "vendu":
              notificationType = "property_rented" /* PROPERTY_RENTED */;
              title = newStatus === "lou\xE9" ? "Propri\xE9t\xE9 lou\xE9e" : "Propri\xE9t\xE9 vendue";
              message = `F\xE9licitations ! Votre propri\xE9t\xE9 "${property2.title}" a \xE9t\xE9 ${newStatus === "lou\xE9" ? "lou\xE9e" : "vendue"}`;
              break;
            case "retir\xE9":
              notificationType = "property_rejected" /* PROPERTY_REJECTED */;
              title = "Propri\xE9t\xE9 retir\xE9e";
              message = `Votre propri\xE9t\xE9 "${property2.title}" a \xE9t\xE9 retir\xE9e du march\xE9`;
              break;
            default:
              notificationType = "property_approved" /* PROPERTY_APPROVED */;
              title = "Statut de propri\xE9t\xE9 mis \xE0 jour";
              message = `Le statut de votre propri\xE9t\xE9 "${property2.title}" a \xE9t\xE9 mis \xE0 jour`;
          }
          const ownerNotification = {
            userId: owner._id.toString(),
            type: notificationType,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "normal" /* NORMAL */,
            title,
            message,
            data: {
              email: {
                to: owner.email,
                subject: `${title} - EasyRent`,
                templateData: {
                  propertyName: property2.title,
                  ownerName: `${owner.firstName} ${owner.lastName}`,
                  oldStatus,
                  newStatus,
                  propertyUrl: `/properties/${property2._id}`,
                  dashboardUrl: "/dashboard"
                }
              },
              inApp: {
                userId: owner._id.toString(),
                title,
                message,
                actionUrl: `/properties/${property2._id}`,
                actionLabel: "Voir la propri\xE9t\xE9",
                category: "property",
                icon: "home"
              }
            }
          };
          const result = await this.notificationManager.sendTemplateNotification(
            "property_status_update",
            ownerNotification.data?.email?.templateData || {},
            ownerNotification
          );
          if (newStatus === "disponible") {
            await this.notifyInterestedUsersPropertyAvailable(property2);
          }
          logger19.info("Notification changement statut propri\xE9t\xE9 envoy\xE9e", {
            propertyId: property2._id,
            ownerId: property2.ownerId,
            oldStatus,
            newStatus,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger19.error("Erreur envoi notification changement statut", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            propertyId: property2._id
          });
          return false;
        }
      }
      /**
       * Notification pour propriété similaire disponible
       */
      async sendSimilarPropertyNotification(newProperty, interestedUsers) {
        try {
          if (interestedUsers.length === 0) return true;
          const owner = await userModel_default.findById(newProperty.ownerId);
          if (!owner) return false;
          const notification = {
            userId: interestedUsers,
            type: "property_available" /* PROPERTY_AVAILABLE */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "normal" /* NORMAL */,
            title: "Propri\xE9t\xE9 similaire disponible",
            message: `Une propri\xE9t\xE9 similaire \xE0 vos crit\xE8res est disponible \xE0 ${newProperty.area}`,
            data: {
              inApp: {
                userId: interestedUsers,
                title: "Propri\xE9t\xE9 similaire disponible",
                message: `${newProperty.bedrooms} chambres, ${newProperty.monthlyRent}\u20AC/mois \xE0 ${newProperty.area}`,
                actionUrl: `/properties/${newProperty._id}`,
                actionLabel: "Voir la propri\xE9t\xE9",
                category: "property",
                icon: "heart",
                image: newProperty.images?.[0]
              }
            }
          };
          const result = await this.notificationManager.sendNotification(notification);
          logger19.info("Notification propri\xE9t\xE9 similaire envoy\xE9e", {
            propertyId: newProperty._id,
            usersNotified: interestedUsers.length,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger19.error("Erreur envoi notification propri\xE9t\xE9 similaire", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Notification pour baisse de prix
       */
      async sendPriceDropNotification(property2, oldPrice, newPrice) {
        try {
          const interestedUsers = await this.getInterestedUsers(property2);
          if (interestedUsers.length === 0) return true;
          const percentageDecrease = Math.round((oldPrice - newPrice) / oldPrice * 100);
          const notification = {
            userId: interestedUsers,
            type: "property_available" /* PROPERTY_AVAILABLE */,
            channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
            priority: "high" /* HIGH */,
            title: "Baisse de prix !",
            message: `Le prix de "${property2.title}" a baiss\xE9 de ${percentageDecrease}% !`,
            data: {
              email: {
                to: "",
                // Will be set for each user
                subject: "Baisse de prix sur une propri\xE9t\xE9 qui vous int\xE9resse - EasyRent",
                templateData: {
                  propertyName: property2.title,
                  oldPrice,
                  newPrice,
                  percentageDecrease,
                  area: property2.area,
                  propertyUrl: `/properties/${property2._id}`
                }
              },
              inApp: {
                userId: interestedUsers,
                title: `Baisse de prix - ${percentageDecrease}% !`,
                message: `${property2.title} - Maintenant ${newPrice}\u20AC/mois (\xE9tait ${oldPrice}\u20AC)`,
                actionUrl: `/properties/${property2._id}`,
                actionLabel: "Voir l'offre",
                category: "property",
                icon: "trending-down"
              }
            }
          };
          const result = await this.notificationManager.sendTemplateNotification(
            "price_drop",
            notification.data?.email?.templateData || {},
            notification
          );
          logger19.info("Notification baisse de prix envoy\xE9e", {
            propertyId: property2._id,
            oldPrice,
            newPrice,
            percentageDecrease,
            usersNotified: interestedUsers.length,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger19.error("Erreur envoi notification baisse de prix", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            propertyId: property2._id
          });
          return false;
        }
      }
      /**
       * Notification pour nouvelles propriétés dans une zone
       */
      async sendNewPropertyInAreaNotification(property2) {
        try {
          const interestedUsers = await userModel_default.find({
            "searchPreferences.areas": property2.area,
            isActive: true,
            _id: { $ne: property2.ownerId }
          }).select("_id email firstName lastName");
          if (interestedUsers.length === 0) return true;
          const userIds = interestedUsers.map((user) => user._id.toString());
          const notification = {
            userId: userIds,
            type: "property_published" /* PROPERTY_PUBLISHED */,
            channels: ["in_app" /* IN_APP */],
            priority: "normal" /* NORMAL */,
            title: `Nouvelle propri\xE9t\xE9 \xE0 ${property2.area}`,
            message: `Une nouvelle propri\xE9t\xE9 correspond \xE0 vos crit\xE8res de recherche`,
            data: {
              inApp: {
                userId: userIds,
                title: `Nouvelle propri\xE9t\xE9 \xE0 ${property2.area}`,
                message: `${property2.bedrooms} chambres - ${property2.monthlyRent}\u20AC/mois`,
                actionUrl: `/properties/${property2._id}`,
                actionLabel: "D\xE9couvrir",
                category: "property",
                icon: "map-pin"
              }
            }
          };
          const result = await this.notificationManager.sendNotification(notification);
          logger19.info("Notification nouvelle propri\xE9t\xE9 dans zone envoy\xE9e", {
            propertyId: property2._id,
            area: property2.area,
            usersNotified: userIds.length,
            success: result.success
          });
          return result.success;
        } catch (error2) {
          logger19.error("Erreur envoi notification nouvelle propri\xE9t\xE9 zone", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
          return false;
        }
      }
      /**
       * Envoyer des emails aux utilisateurs intéressés pour nouvelle propriété
       */
      async sendNewPropertyEmailsToInterestedUsers(property2, owner, users) {
        try {
          const emailUsers = users.filter(
            (user) => user.notificationPreferences?.newProperties !== false && user.email
          );
          if (emailUsers.length === 0) return;
          const batchSize = 50;
          for (let i = 0; i < emailUsers.length; i += batchSize) {
            const batch = emailUsers.slice(i, i + batchSize);
            const emailPromises = batch.map(
              (user) => this.notificationManager.email.sendTemplateEmail(
                "new_property_alert",
                {
                  to: user.email,
                  subject: `Nouvelle propri\xE9t\xE9 \xE0 ${property2.area} - EasyRent`,
                  templateData: {
                    userName: `${user.firstName} ${user.lastName}`,
                    propertyName: property2.title,
                    ownerName: `${owner.firstName} ${owner.lastName}`,
                    area: property2.area,
                    price: property2.monthlyRent,
                    bedrooms: property2.bedrooms,
                    surface: property2.surface,
                    propertyUrl: `/properties/${property2._id}`,
                    unsubscribeUrl: `/unsubscribe/${user._id}`
                  }
                },
                user._id.toString()
              )
            );
            await Promise.all(emailPromises);
            if (i + batchSize < emailUsers.length) {
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          }
          logger19.info("Emails nouvelle propri\xE9t\xE9 envoy\xE9s", {
            propertyId: property2._id,
            emailsSent: emailUsers.length
          });
        } catch (error2) {
          logger19.error("Erreur envoi emails nouvelle propri\xE9t\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue"
          });
        }
      }
      /**
       * Notifier les utilisateurs intéressés qu'une propriété est disponible
       */
      async notifyInterestedUsersPropertyAvailable(property2) {
        try {
          const interestedUsers = await this.getInterestedUsers(property2);
          if (interestedUsers.length === 0) return;
          const notification = {
            userId: interestedUsers,
            type: "property_available" /* PROPERTY_AVAILABLE */,
            channels: ["in_app" /* IN_APP */],
            priority: "normal" /* NORMAL */,
            title: "Propri\xE9t\xE9 de nouveau disponible",
            message: `"${property2.title}" est de nouveau disponible !`,
            data: {
              inApp: {
                userId: interestedUsers,
                title: "Propri\xE9t\xE9 disponible",
                message: `"${property2.title}" \xE0 ${property2.area}`,
                actionUrl: `/properties/${property2._id}`,
                actionLabel: "Voir maintenant",
                category: "property",
                icon: "refresh-cw"
              }
            }
          };
          await this.notificationManager.sendNotification(notification);
        } catch (error2) {
          logger19.error("Erreur notification propri\xE9t\xE9 disponible", { error: error2 });
        }
      }
      /**
       * Récupérer les utilisateurs intéressés par une propriété
       */
      async getInterestedUsers(property2) {
        try {
          const users = await userModel_default.find({
            _id: { $ne: property2.ownerId },
            isActive: true,
            $or: [
              { "searchPreferences.areas": property2.area },
              {
                "searchPreferences.maxRent": { $gte: property2.monthlyRent },
                "searchPreferences.minRent": { $lte: property2.monthlyRent }
              },
              { "searchPreferences.minBedrooms": { $lte: property2.bedrooms } }
            ]
          }).select("_id").limit(100);
          return users.map((user) => user._id.toString());
        } catch (error2) {
          logger19.error("Erreur r\xE9cup\xE9ration utilisateurs int\xE9ress\xE9s", { error: error2 });
          return [];
        }
      }
      /**
       * Planifier des notifications de propriétés
       */
      async schedulePropertyReminders(property2) {
        try {
          const reminderDate = /* @__PURE__ */ new Date();
          reminderDate.setDate(reminderDate.getDate() + 7);
          await this.notificationManager.scheduleNotification(
            {
              userId: property2.ownerId.toString(),
              type: "system_alert" /* SYSTEM_ALERT */,
              channels: ["in_app" /* IN_APP */, "email" /* EMAIL */],
              title: "Boostez votre propri\xE9t\xE9",
              message: "Votre propri\xE9t\xE9 n'a pas eu d'activit\xE9 r\xE9cente. Voulez-vous la mettre en avant ?",
              data: {
                inApp: {
                  userId: property2.ownerId.toString(),
                  title: "Boostez votre propri\xE9t\xE9",
                  message: "Augmentez la visibilit\xE9 de votre annonce",
                  actionUrl: `/properties/${property2._id}/boost`,
                  actionLabel: "Booster",
                  category: "property"
                }
              },
              metadata: {
                propertyId: property2._id.toString(),
                reminderType: "boost"
              }
            },
            reminderDate
          );
        } catch (error2) {
          logger19.error("Erreur planification rappels propri\xE9t\xE9", { error: error2 });
        }
      }
    };
  }
});

// src/notification/services/ChatNotificationService.ts
var logger20, ChatNotificationService;
var init_ChatNotificationService = __esm({
  "src/notification/services/ChatNotificationService.ts"() {
    init_notificationTypes();
    init_logger();
    logger20 = createLogger2("ChatNotificationService");
    ChatNotificationService = class {
      constructor(notificationManager) {
        this.notificationManager = notificationManager;
      }
      /**
       * Notification pour nouveau message
       */
      async sendNewMessageNotification(message, conversation) {
        try {
          const participants = conversation.participants.filter(
            (p) => p._id?.toString() !== message.senderId?.toString()
          );
          if (participants.length === 0) {
            return true;
          }
          const senderName = await this.getSenderName(message.senderId);
          let messagePreview = "";
          if (typeof message.content === "string") {
            messagePreview = message.content.length > 100 ? message.content.substring(0, 100) + "..." : message.content;
          } else {
            messagePreview = this.getMessageTypeDescription(message.messageType);
          }
          const targetUserIds = participants.map((p) => p._id?.toString() || p.toString());
          const result = await this.notificationManager.sendNotification({
            userId: targetUserIds,
            type: "message_received" /* MESSAGE_RECEIVED */,
            channels: ["in_app" /* IN_APP */, "push" /* PUSH */],
            priority: this.getMessagePriority(message),
            title: `\u{1F4AC} ${senderName}`,
            message: messagePreview,
            data: {
              push: {
                tokens: [],
                title: `\u{1F4AC} ${senderName}`,
                body: messagePreview,
                data: {
                  type: "chat",
                  action: "new_message",
                  conversationId: conversation._id.toString(),
                  messageId: message._id?.toString(),
                  senderId: message.senderId?.toString(),
                  messageType: message.messageType
                }
              }
            }
          });
          return result.success;
        } catch (error2) {
          logger20.error("Erreur notification nouveau message", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            messageId: message._id,
            conversationId: conversation._id
          });
          return false;
        }
      }
      /**
       * Notification pour réaction à un message
       */
      async sendMessageReactionNotification(message, reactorId, reactionType, conversation) {
        try {
          if (message.senderId?.toString() === reactorId) {
            return true;
          }
          const reactorName = await this.getSenderName(reactorId);
          const result = await this.notificationManager.sendNotification({
            userId: [message.senderId?.toString()],
            type: "message_received" /* MESSAGE_RECEIVED */,
            channels: ["in_app" /* IN_APP */],
            priority: "normal" /* NORMAL */,
            title: "\u{1F44D} Nouvelle r\xE9action",
            message: `${reactorName} a r\xE9agi ${reactionType} \xE0 votre message`,
            data: {
              inApp: {
                userId: message.senderId?.toString(),
                title: "\u{1F44D} Nouvelle r\xE9action",
                message: `${reactorName} a r\xE9agi ${reactionType} \xE0 votre message`,
                category: "chat"
              }
            }
          });
          return result.success;
        } catch (error2) {
          logger20.error("Erreur notification r\xE9action message", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            messageId: message._id,
            reactorId
          });
          return false;
        }
      }
      /**
       * Notification pour mention dans un message
       */
      async sendMessageMentionNotification(message, mentionedUserIds, conversation) {
        try {
          if (mentionedUserIds.length === 0) {
            return true;
          }
          const senderName = await this.getSenderName(message.senderId);
          const messageText = typeof message.content === "string" ? message.content.substring(0, 100) : "Message avec mention";
          const result = await this.notificationManager.sendNotification({
            userId: mentionedUserIds,
            type: "message_received" /* MESSAGE_RECEIVED */,
            channels: ["in_app" /* IN_APP */, "push" /* PUSH */],
            priority: "high" /* HIGH */,
            title: `\u{1F514} ${senderName} vous a mentionn\xE9`,
            message: messageText,
            data: {
              inApp: {
                userId: mentionedUserIds,
                title: `\u{1F514} ${senderName} vous a mentionn\xE9`,
                message: messageText,
                category: "chat"
              }
            }
          });
          return result.success;
        } catch (error2) {
          logger20.error("Erreur notification mention message", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            messageId: message._id,
            mentionedUserIds
          });
          return false;
        }
      }
      /**
       * Notification pour nouvelle conversation créée
       */
      async sendConversationCreatedNotification(conversation, creatorId) {
        try {
          const participants = conversation.participants.filter(
            (p) => p._id?.toString() !== creatorId
          );
          if (participants.length === 0) {
            return true;
          }
          const creatorName = await this.getSenderName(creatorId);
          let title = "";
          let body3 = "";
          if (conversation.type === "direct") {
            title = `\u{1F4AC} ${creatorName}`;
            body3 = "A commenc\xE9 une conversation avec vous";
          } else if (conversation.type === "group") {
            title = "\u{1F465} Nouvelle conversation de groupe";
            body3 = `${creatorName} vous a ajout\xE9 \xE0 un groupe`;
          } else if (conversation.type === "property_discussion") {
            title = "\u{1F3E0} Discussion propri\xE9t\xE9";
            body3 = `${creatorName} souhaite discuter d'une propri\xE9t\xE9`;
          }
          const targetUserIds = participants.map((p) => p._id?.toString() || p.toString());
          const result = await this.notificationManager.sendNotification({
            userId: targetUserIds,
            type: "message_received" /* MESSAGE_RECEIVED */,
            channels: ["in_app" /* IN_APP */],
            priority: "normal" /* NORMAL */,
            title,
            message: body3,
            data: {
              inApp: {
                userId: targetUserIds,
                title,
                message: body3,
                category: "chat"
              }
            }
          });
          return result.success;
        } catch (error2) {
          logger20.error("Erreur notification nouvelle conversation", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            conversationId: conversation._id,
            creatorId
          });
          return false;
        }
      }
      /**
       * Notification pour message programmé livré
       */
      async sendScheduledMessageDeliveredNotification(message) {
        try {
          const result = await this.notificationManager.sendNotification({
            userId: [message.senderId?.toString()],
            type: "message_received" /* MESSAGE_RECEIVED */,
            channels: ["in_app" /* IN_APP */],
            priority: "low" /* LOW */,
            title: "\u23F0 Message programm\xE9 envoy\xE9",
            message: "Votre message programm\xE9 a \xE9t\xE9 livr\xE9",
            data: {
              inApp: {
                userId: message.senderId?.toString(),
                title: "\u23F0 Message programm\xE9 envoy\xE9",
                message: "Votre message programm\xE9 a \xE9t\xE9 livr\xE9",
                category: "chat"
              }
            }
          });
          return result.success;
        } catch (error2) {
          logger20.error("Erreur notification message programm\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            messageId: message._id
          });
          return false;
        }
      }
      // ==================== MÉTHODES UTILITAIRES ====================
      /**
       * Obtenir le nom de l'expéditeur
       */
      async getSenderName(senderId) {
        try {
          return "Utilisateur";
        } catch (error2) {
          logger20.error("Erreur r\xE9cup\xE9ration nom exp\xE9diteur", { senderId, error: error2 });
          return "Utilisateur";
        }
      }
      /**
       * Obtenir la description du type de message
       */
      getMessageTypeDescription(messageType) {
        const descriptions = {
          "text": "Message texte",
          "image": "\u{1F4F7} Photo partag\xE9e",
          "video": "\u{1F3A5} Vid\xE9o partag\xE9e",
          "audio": "\u{1F3B5} Audio partag\xE9",
          "document": "\u{1F4C4} Document partag\xE9",
          "location": "\u{1F4CD} Position partag\xE9e",
          "contact": "\u{1F464} Contact partag\xE9",
          "property": "\u{1F3E0} Propri\xE9t\xE9 partag\xE9e",
          "voice_note": "\u{1F3A4} Note vocale",
          "ar_preview": "\u{1F52E} Aper\xE7u AR",
          "virtual_tour": "\u{1F3E0} Visite virtuelle"
        };
        return descriptions[messageType] || "Message";
      }
      /**
       * Déterminer la priorité du message
       */
      getMessagePriority(message) {
        if (message.mentions && message.mentions.length > 0) {
          return "high" /* HIGH */;
        }
        if (message.replyTo) {
          return "normal" /* NORMAL */;
        }
        if (message.aiInsights?.priority === "urgent") {
          return "urgent" /* URGENT */;
        }
        if (message.aiInsights?.priority === "high") {
          return "high" /* HIGH */;
        }
        if (message.messageType === "property" || message.messageType === "location") {
          return "normal" /* NORMAL */;
        }
        if (["image", "video", "audio", "document"].includes(message.messageType)) {
          return "normal" /* NORMAL */;
        }
        return "normal" /* NORMAL */;
      }
      /**
       * Vérifier si l'utilisateur accepte ce type de notification
       */
      async shouldNotifyUser(userId, notificationType) {
        try {
          return true;
        } catch (error2) {
          logger20.error("Erreur v\xE9rification pr\xE9f\xE9rences utilisateur", { userId, notificationType, error: error2 });
          return true;
        }
      }
      /**
       * Formater le message pour différents types de notifications
       */
      formatMessageForNotification(message, maxLength = 100) {
        if (!message.content) {
          return this.getMessageTypeDescription(message.messageType);
        }
        if (typeof message.content === "string") {
          return message.content.length > maxLength ? message.content.substring(0, maxLength) + "..." : message.content;
        }
        return this.getMessageTypeDescription(message.messageType);
      }
      /**
       * Obtenir le statut du service
       */
      async getServiceStatus() {
        return {
          isHealthy: true,
          lastActivity: /* @__PURE__ */ new Date(),
          notificationsSent: 0
          // À implémenter avec des métriques réelles
        };
      }
    };
  }
});

// src/notification/services/IntegratedNotificationService.ts
var logger21, IntegratedNotificationService;
var init_IntegratedNotificationService = __esm({
  "src/notification/services/IntegratedNotificationService.ts"() {
    init_NotificationManager();
    init_ActivityNotificationService();
    init_PropertyNotificationService();
    init_ChatNotificationService();
    init_notificationTypes();
    init_logger();
    logger21 = createLogger2("IntegratedNotificationService");
    IntegratedNotificationService = class {
      constructor(io) {
        __publicField(this, "notificationManager");
        __publicField(this, "activityNotifications");
        __publicField(this, "propertyNotifications");
        __publicField(this, "chatNotifications");
        this.notificationManager = new NotificationManager(io);
        this.activityNotifications = new ActivityNotificationService(this.notificationManager);
        this.propertyNotifications = new PropertyNotificationService(this.notificationManager);
        this.chatNotifications = new ChatNotificationService(this.notificationManager);
        logger21.info("Service int\xE9gr\xE9 de notifications initialis\xE9");
      }
      // ==================== PROPERTY NOTIFICATIONS ====================
      /**
       * Nouvelle propriété créée - Broadcast à tous les utilisateurs (style Instagram)
       */
      async onNewPropertyCreated(property2) {
        try {
          logger21.info("Notification nouvelle propri\xE9t\xE9", { propertyId: property2._id });
          const broadcastResult = await this.propertyNotifications.sendNewPropertyNotification(property2);
          const areaResult = await this.propertyNotifications.sendNewPropertyInAreaNotification(property2);
          await this.propertyNotifications.schedulePropertyReminders(property2);
          return broadcastResult && areaResult;
        } catch (error2) {
          logger21.error("Erreur notification nouvelle propri\xE9t\xE9", {
            error: error2 instanceof Error ? error2.message : "Erreur inconnue",
            propertyId: property2._id
          });
          return false;
        }
      }
      /**
       * Statut de propriété modifié
       */
      async onPropertyStatusChanged(property2, oldStatus, newStatus) {
        try {
          logger21.info("Notification changement statut propri\xE9t\xE9", {
            propertyId: property2._id,
            oldStatus,
            newStatus
          });
          return await this.propertyNotifications.sendPropertyStatusUpdateNotification(
            property2,
            oldStatus,
            newStatus
          );
        } catch (error2) {
          logger21.error("Erreur notification changement statut", { error: error2 });
          return false;
        }
      }
      /**
       * Prix de propriété modifié
       */
      async onPropertyPriceChanged(property2, oldPrice, newPrice) {
        try {
          if (newPrice < oldPrice) {
            logger21.info("Notification baisse de prix", {
              propertyId: property2._id,
              oldPrice,
              newPrice
            });
            return await this.propertyNotifications.sendPriceDropNotification(
              property2,
              oldPrice,
              newPrice
            );
          }
          return true;
        } catch (error2) {
          logger21.error("Erreur notification changement prix", { error: error2 });
          return false;
        }
      }
      // ==================== ACTIVITY NOTIFICATIONS ====================
      /**
       * Demande de visite créée
       */
      async onVisitRequested(activity) {
        try {
          logger21.info("Notification demande de visite", { activityId: activity._id });
          const result = await this.activityNotifications.sendVisitRequestNotification(activity);
          await this.activityNotifications.scheduleActivityReminders(activity);
          return result;
        } catch (error2) {
          logger21.error("Erreur notification demande de visite", { error: error2 });
          return false;
        }
      }
      /**
       * Visite acceptée ou refusée
       */
      async onVisitResponseGiven(activity, isAccepted, reason) {
        try {
          logger21.info("Notification r\xE9ponse visite", {
            activityId: activity._id,
            isAccepted,
            reason
          });
          return await this.activityNotifications.sendVisitResponseNotification(
            activity,
            isAccepted,
            reason
          );
        } catch (error2) {
          logger21.error("Erreur notification r\xE9ponse visite", { error: error2 });
          return false;
        }
      }
      /**
       * Demande de réservation créée
       */
      async onReservationRequested(activity) {
        try {
          logger21.info("Notification demande de r\xE9servation", { activityId: activity._id });
          const result = await this.activityNotifications.sendReservationRequestNotification(activity);
          await this.activityNotifications.scheduleActivityReminders(activity);
          return result;
        } catch (error2) {
          logger21.error("Erreur notification demande de r\xE9servation", { error: error2 });
          return false;
        }
      }
      /**
       * Réservation acceptée ou refusée
       */
      async onReservationResponseGiven(activity, isAccepted, reason) {
        try {
          logger21.info("Notification r\xE9ponse r\xE9servation", {
            activityId: activity._id,
            isAccepted,
            reason
          });
          return await this.activityNotifications.sendReservationResponseNotification(
            activity,
            isAccepted,
            reason
          );
        } catch (error2) {
          logger21.error("Erreur notification r\xE9ponse r\xE9servation", { error: error2 });
          return false;
        }
      }
      /**
       * Paiement effectué
       */
      async onPaymentCompleted(activity) {
        try {
          logger21.info("Notification paiement effectu\xE9", { activityId: activity._id });
          return await this.activityNotifications.sendPaymentNotification(activity);
        } catch (error2) {
          logger21.error("Erreur notification paiement", { error: error2 });
          return false;
        }
      }
      /**
       * Rappel de paiement
       */
      async onPaymentReminder(activity) {
        try {
          logger21.info("Rappel de paiement", { activityId: activity._id });
          return await this.activityNotifications.sendPaymentReminderNotification(activity);
        } catch (error2) {
          logger21.error("Erreur rappel de paiement", { error: error2 });
          return false;
        }
      }
      // ==================== CHAT NOTIFICATIONS ====================
      /**
       * Nouveau message reçu
       */
      async onNewMessage(message, conversation) {
        try {
          logger21.info("Notification nouveau message", {
            messageId: message._id,
            conversationId: conversation._id
          });
          return await this.chatNotifications.sendNewMessageNotification(message, conversation);
        } catch (error2) {
          logger21.error("Erreur notification nouveau message", { error: error2 });
          return false;
        }
      }
      /**
       * Réaction à un message
       */
      async onMessageReaction(message, reactorId, reactionType, conversation) {
        try {
          logger21.info("Notification r\xE9action message", {
            messageId: message._id,
            reactorId,
            reactionType
          });
          return await this.chatNotifications.sendMessageReactionNotification(
            message,
            reactorId,
            reactionType,
            conversation
          );
        } catch (error2) {
          logger21.error("Erreur notification r\xE9action message", { error: error2 });
          return false;
        }
      }
      /**
       * Message mentionné
       */
      async onMessageMention(message, mentionedUserIds, conversation) {
        try {
          logger21.info("Notification mention message", {
            messageId: message._id,
            mentionedUserIds
          });
          return await this.chatNotifications.sendMessageMentionNotification(
            message,
            mentionedUserIds,
            conversation
          );
        } catch (error2) {
          logger21.error("Erreur notification mention message", { error: error2 });
          return false;
        }
      }
      /**
       * Nouvelle conversation créée
       */
      async onConversationCreated(conversation, creatorId) {
        try {
          logger21.info("Notification nouvelle conversation", {
            conversationId: conversation._id,
            creatorId
          });
          return await this.chatNotifications.sendConversationCreatedNotification(conversation, creatorId);
        } catch (error2) {
          logger21.error("Erreur notification nouvelle conversation", { error: error2 });
          return false;
        }
      }
      // ==================== SERVICE MARKETPLACE NOTIFICATIONS ====================
      /**
       * Nouveau service proposé
       */
      async onNewServiceOffered(service) {
        try {
          logger21.info("Notification nouveau service propos\xE9", { serviceId: service._id });
          const targetUsers = await this.getInterestedUsers("service", service);
          const result = await this.notificationManager.sendNotification({
            userId: targetUsers,
            type: "custom" /* CUSTOM */,
            channels: ["in_app" /* IN_APP */, "push" /* PUSH */],
            title: "\u{1F527} Nouveau service disponible",
            message: `${service.title} propos\xE9 dans votre r\xE9gion`,
            data: {
              inApp: {
                userId: targetUsers,
                title: "\u{1F527} Nouveau service disponible",
                message: `${service.title} propos\xE9 dans votre r\xE9gion`,
                category: "service",
                actionUrl: `/services/${service._id}`
              }
            },
            priority: "normal" /* NORMAL */,
            metadata: {
              source: "service_marketplace",
              tags: ["new_service", service.category]
            }
          });
          return result.success;
        } catch (error2) {
          logger21.error("Erreur notification nouveau service", { error: error2 });
          return false;
        }
      }
      /**
       * Demande de service reçue
       */
      async onServiceRequested(serviceRequest) {
        try {
          logger21.info("Notification demande de service", { requestId: serviceRequest._id });
          const result = await this.notificationManager.sendNotification({
            userId: serviceRequest.providerId,
            type: "custom" /* CUSTOM */,
            channels: ["in_app" /* IN_APP */, "push" /* PUSH */],
            title: "\u{1F4DE} Nouvelle demande de service",
            message: `Quelqu'un souhaite votre service: ${serviceRequest.serviceTitle}`,
            data: {
              inApp: {
                userId: serviceRequest.providerId,
                title: "\u{1F4DE} Nouvelle demande de service",
                message: `Quelqu'un souhaite votre service: ${serviceRequest.serviceTitle}`,
                category: "service",
                actionUrl: `/service-requests/${serviceRequest._id}`
              }
            },
            priority: "high" /* HIGH */,
            metadata: {
              source: "service_marketplace",
              tags: ["service_request"]
            }
          });
          return result.success;
        } catch (error2) {
          logger21.error("Erreur notification demande de service", { error: error2 });
          return false;
        }
      }
      /**
       * Service accepté/refusé
       */
      async onServiceResponseGiven(serviceRequest, isAccepted, response) {
        try {
          logger21.info("Notification r\xE9ponse service", {
            requestId: serviceRequest._id,
            isAccepted
          });
          const title = isAccepted ? "\u2705 Service accept\xE9" : "\u274C Service refus\xE9";
          const message = isAccepted ? `Votre demande pour ${serviceRequest.serviceTitle} a \xE9t\xE9 accept\xE9e` : `Votre demande pour ${serviceRequest.serviceTitle} a \xE9t\xE9 refus\xE9e`;
          const fullMessage = response ? `${message}: ${response}` : message;
          const result = await this.notificationManager.sendNotification({
            userId: serviceRequest.clientId,
            type: "custom" /* CUSTOM */,
            channels: ["in_app" /* IN_APP */, "push" /* PUSH */],
            title,
            message: fullMessage,
            data: {
              inApp: {
                userId: serviceRequest.clientId,
                title,
                message: fullMessage,
                category: "service",
                actionUrl: `/service-requests/${serviceRequest._id}`
              }
            },
            priority: "high" /* HIGH */,
            metadata: {
              source: "service_marketplace",
              tags: [isAccepted ? "service_accepted" : "service_refused"]
            }
          });
          return result.success;
        } catch (error2) {
          logger21.error("Erreur notification r\xE9ponse service", { error: error2 });
          return false;
        }
      }
      // ==================== UTILITY METHODS ====================
      /**
       * Obtenir les utilisateurs intéressés par un type de contenu
       */
      async getInterestedUsers(type, item) {
        return [];
      }
      /**
       * Envoyer notification custom
       */
      async sendCustomNotification(request) {
        return await this.notificationManager.sendNotification(request);
      }
      /**
       * Obtenir les statistiques de notifications
       */
      async getNotificationStats(userId, startDate, endDate) {
        return await this.notificationManager.getNotificationStats(userId, startDate, endDate);
      }
      /**
       * Marquer une notification comme lue
       */
      async markNotificationAsRead(notificationId, userId) {
        return await this.notificationManager.inApp.markAsRead(notificationId, userId);
      }
      /**
       * Marquer toutes les notifications comme lues
       */
      async markAllNotificationsAsRead(userId) {
        return await this.notificationManager.inApp.markAllAsRead(userId);
      }
      /**
       * Obtenir les notifications d'un utilisateur
       */
      async getUserNotifications(userId, options = {}) {
        return await this.notificationManager.inApp.getNotifications(userId, options);
      }
      /**
       * Obtenir le nombre de notifications non lues
       */
      async getUnreadCount(userId) {
        return await this.notificationManager.inApp.getUnreadCount(userId);
      }
      /**
       * Vérifier si un utilisateur est connecté
       */
      isUserConnected(userId) {
        return this.notificationManager.inApp.isUserConnected(userId);
      }
      /**
       * Obtenir les utilisateurs connectés
       */
      getConnectedUsers() {
        return this.notificationManager.inApp.getConnectedUsers();
      }
      /**
       * Envoyer notification broadcast à tous les utilisateurs connectés
       */
      async sendBroadcastNotification(title, message, excludeUserIds = []) {
        return await this.notificationManager.inApp.sendBroadcastNotification(
          title,
          message,
          excludeUserIds
        );
      }
      /**
       * Planifier une notification
       */
      async scheduleNotification(request, scheduledAt) {
        return await this.notificationManager.scheduleNotification(request, scheduledAt);
      }
      /**
       * Obtenir le statut de tous les services
       */
      async getServicesStatus() {
        return await this.notificationManager.getAllServicesStatus();
      }
      /**
       * Tester tous les services
       */
      async testAllServices() {
        return await this.notificationManager.testAllServices();
      }
      /**
       * Arrêter le service (cleanup)
       */
      stop() {
        this.notificationManager.stopQueueProcessing();
        logger21.info("Service int\xE9gr\xE9 de notifications arr\xEAt\xE9");
      }
      // ==================== GETTERS ====================
      /**
       * Accès au gestionnaire principal
       */
      get manager() {
        return this.notificationManager;
      }
      /**
       * Accès aux notifications d'activité
       */
      get activity() {
        return this.activityNotifications;
      }
      /**
       * Accès aux notifications de propriété
       */
      get property() {
        return this.propertyNotifications;
      }
      /**
       * Accès aux notifications de chat
       */
      get chat() {
        return this.chatNotifications;
      }
      /**
       * Accès aux services individuels
       */
      get email() {
        return this.notificationManager.email;
      }
      get sms() {
        return this.notificationManager.sms;
      }
      get inApp() {
        return this.notificationManager.inApp;
      }
    };
  }
});

// src/property/proprityServices/proprityServices.ts
import mongoose7 from "mongoose";
var logger22, PropertyServices, proprityServices_default;
var init_proprityServices = __esm({
  "src/property/proprityServices/proprityServices.ts"() {
    init_propertyType();
    init_IntegratedNotificationService();
    init_logger();
    init_propertyModel();
    logger22 = createLogger2("proprietyCreation");
    PropertyServices = class {
      constructor() {
        __publicField(this, "notificationService");
        this.notificationService = new IntegratedNotificationService();
      }
      async createProperty(propertyData, userId) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        logger22.info("tantative de  creation de  neew  proprity");
        try {
          if (!propertyData.ownerId && userId) {
            propertyData.ownerId = userId;
          }
          const property2 = new propertyModel_default(propertyData);
          await property2.save({ session });
          await mongoose7.model("User").findByIdAndUpdate(
            propertyData.ownerId,
            { $inc: { propertyCount: 1 } },
            { session }
          );
          await session.commitTransaction();
          session.endSession();
          logger22.info(`Propri\xE9t\xE9 cr\xE9\xE9e avec succ\xE8s: ${property2._id}`);
          await this.notificationService.onNewPropertyCreated(property2);
          return property2;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger22.error("Erreur lors de la cr\xE9ation de la propri\xE9t\xE9:", error2);
          throw error2;
        }
      }
      async deleteProperty(propertyId) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const property2 = await propertyModel_default.findById(propertyId);
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger22.warn("no property  found ");
            return null;
          }
          await propertyModel_default.findByIdAndUpdate(
            propertyId,
            {
              isActive: false,
              status: "retir\xE9" /* REMOVED */
            },
            { session }
          );
          await mongoose7.model("User").findByIdAndUpdate(
            property2.ownerId,
            { $inc: { activePropertyCount: -1 } },
            { session }
          );
          await session.commitTransaction();
          session.endSession();
          logger22.info(`Propri\xE9t\xE9 supprim\xE9e (logique): ${propertyId}`);
        } catch (error2) {
          logger22.warn("error  while deleting  the  property", error2);
        }
      }
      async getProperty(propertyQuery) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const {
            area,
            minRent,
            maxRent,
            minBedrooms,
            ownerId,
            status,
            isActive = true,
            availableFrom,
            page = 1,
            limit = 10,
            sortBy = "createdAt",
            sortOrder = "desc"
          } = propertyQuery;
          const filters = { isActive };
          if (area) filters.area = { $regex: new RegExp(area, "i") };
          if (minRent) filters.monthlyRent = { $gte: minRent };
          if (maxRent) filters.monthlyRent = { ...filters.monthlyRent, $lte: maxRent };
          if (minBedrooms) filters.bedrooms = { $gte: minBedrooms };
          if (ownerId) filters.ownerId = ownerId;
          if (status) filters.status = status;
          if (availableFrom) filters.availableFrom = { $lte: availableFrom };
          const sort = { [sortBy]: sortOrder === "asc" ? 1 : -1 };
          const total = await propertyModel_default.countDocuments(filters);
          const skip = (Number(page) - 1) * Number(limit);
          const properties = await propertyModel_default.find(filters).sort(sort).skip(skip).limit(Number(limit)).populate("ownerId", "name email phone").session(session);
          if (!properties) {
            await session.abortTransaction();
            session.endSession();
            logger22.warn("no property  found");
            return null;
          }
          logger22.info(`R\xE9cup\xE9ration de ${properties.length} propri\xE9t\xE9s`);
          await session.commitTransaction();
          session.endSession();
          return {
            properties,
            total,
            page: Number(page),
            limit: Number(limit),
            totalPages: Math.ceil(total / Number(limit))
          };
        } catch (error2) {
          logger22.warn("error  while getting  the  property", error2);
        }
      }
      async getPropertyByOwner(propertyQuery) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const { pagination, status, ownerId } = propertyQuery;
          const filter2 = { ownerId, active: true };
          if (status) filter2.status = status;
          const skip = (Number(pagination.page) - 1) * Number(pagination.limit);
          const total = await propertyModel_default.countDocuments(filter2);
          if (total === 0) {
            logger22.warn("nothing  has  not  bee,n   found");
            return;
          }
          const property2 = await propertyModel_default.find(filter2).sort({ createdAt: -1 }).skip(skip).limit(Number(pagination.limit)).lean();
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger22.info("the property   is  not  available");
          }
          session.commitTransaction();
          session.endSession();
          return property2;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("Error  fetching  property", error2);
        }
      }
      async finPropertyById(id) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const property2 = await propertyModel_default.findById(id).populate("ownerId", "name email phone").lean();
          if (!property2) {
            session.abortTransaction();
            session.endSession();
            logger22.warn("property has  not been  found");
            return null;
          }
          session.commitTransaction();
          session.endSession();
          return property2;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error  fetching  the  propety", error2);
        }
      }
      async getPropertyState() {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const [
            totalProperties,
            availableProperties,
            rentedProperties,
            averageRent,
            averageSize,
            propertiesByArea,
            propertiesByStatus
          ] = await Promise.all([
            // Nombre total de propriétés actives
            propertyModel_default.countDocuments({ isActive: true }),
            // Nombre de propriétés disponibles
            propertyModel_default.countDocuments({ isActive: true, status: "disponible" /* AVAILABLE */ }),
            // Nombre de propriétés louées
            propertyModel_default.countDocuments({ isActive: true, status: "lou\xE9" /* RENTED */ }),
            // Loyer moyen
            propertyModel_default.aggregate([
              { $match: { isActive: true } },
              { $group: { _id: null, average: { $avg: "$monthlyRent" } } }
            ]),
            // Taille moyenne
            propertyModel_default.aggregate([
              { $match: { isActive: true } },
              { $group: { _id: null, average: { $avg: "$surface" } } }
            ]),
            // Propriétés par zone/quartier
            propertyModel_default.aggregate([
              { $match: { isActive: true } },
              { $group: { _id: "$area", count: { $sum: 1 } } },
              { $sort: { count: -1 } }
            ]),
            // Propriétés par statut
            propertyModel_default.aggregate([
              { $match: { isActive: true } },
              { $group: { _id: "$status", count: { $sum: 1 } } }
            ])
          ]);
          logger22.info("Statistiques des propri\xE9t\xE9s r\xE9cup\xE9r\xE9es");
          session.commitTransaction();
          session.endSession();
          return {
            totalProperties,
            availableProperties,
            rentedProperties,
            averageRent: averageRent[0]?.average || 0,
            averageSize: averageSize[0]?.average || 0,
            propertiesByArea,
            propertiesByStatus
          };
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          throw error2;
        }
      }
      async getSImilarProperty(data) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const { propertyId, pagination } = data;
          const property2 = await propertyModel_default.findById(propertyId);
          if (!property2) {
            logger22.warn("no property  found");
            return null;
          }
          const similarProperty = await propertyModel_default.find({
            _id: { $ne: propertyId },
            isActive: true,
            status: "disponible" /* AVAILABLE */,
            area: property2.area,
            $or: [
              { bedrooms: property2.bedrooms },
              // Même nombre de chambres
              { monthlyRent: { $gte: property2.monthlyRent * 0.8, $lte: property2.monthlyRent * 1.2 } }
              // Prix similaire (±20%)
            ]
          }).limit(Number(pagination.limit)).lean();
          if (!similarProperty) {
            session.abortTransaction();
            session.endSession();
            logger22.warn("No similar  property  founded");
          }
          logger22.info("similar  property  founded");
          session.commitTransaction();
          session.endSession();
          return similarProperty;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error  while getting  the  similar  property", error2);
        }
      }
      async permanentDeleteProperty(id) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const property2 = await propertyModel_default.findById(id);
          if (!property2) {
            logger22.warn("no property  found");
            return null;
          }
          const deletProperty = await propertyModel_default.findByIdAndDelete(id, { session });
          if (!deletProperty) {
            logger22.warn("no property has  not  been  deleted");
            return null;
          }
          await mongoose7.model("User").findByIdAndUpdate(
            property2.ownerId,
            { $inc: { propertyCount: -1 } },
            { session }
          );
          await mongoose7.model("Property").deleteMany(property2.id, { session });
          await session.commitTransaction();
          session.endSession();
          logger22.info(`Property  has  been  removed  permanently: ${id}`);
          return null;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error  while deleting  the  property", error2);
        }
      }
      async restoreProperty(propertyId) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        try {
          const propert = await propertyModel_default.findById(propertyId);
          if (!propert) {
            session.abortTransaction();
            session.endSession();
            logger22.warn("no property  found");
            return null;
          }
          const restorProperty = await propertyModel_default.findByIdAndUpdate(
            propertyId,
            {
              isActive: true,
              status: "disponible" /* AVAILABLE */
            },
            { session }
          );
          if (!restorProperty) {
            session.abortTransaction();
            session.endSession();
            logger22.warn("no property found to  restore");
          }
          await mongoose7.model("User").findByIdAndUpdate(
            propert.ownerId,
            { $inc: { activePropertyCount: 1 } },
            { session }
          );
          session.commitTransaction();
          session.endSession();
          logger22.info("property restore");
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error  restoring  the  property", error2);
        }
      }
      async searchProperty(propertyData) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        const { q, pagination } = propertyData;
        const page = pagination?.page ?? 1;
        const limit = pagination?.limit ?? 10;
        try {
          if (!q || q.trim() === "") {
            session.abortTransaction(), session.endSession();
            logger22.warn("property query  has not been  provided");
            return null;
          }
          const total = await propertyModel_default.countDocuments({
            $text: { $search: propertyData.q },
            isActive: true,
            status: "disponible" /* AVAILABLE */
          });
          const skip = (page - 1) * limit;
          const property2 = await propertyModel_default.find(
            {
              $text: { $search: q },
              isActive: true,
              status: "disponible" /* AVAILABLE */
            },
            { score: { $meta: "textScore" } }
          ).sort({ score: { $meta: "textScore" } }).skip(skip).limit(limit).populate("ownerId", "name email phone").lean();
          const result = {
            property: property2,
            total,
            limit,
            page,
            totalPages: Math.ceil(total / limit)
          };
          session.commitTransaction();
          session.endSession();
          logger22.info("property found");
          return result;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error while  searching  property", error2);
        }
      }
      async updateProperty(updataData) {
        const session = await mongoose7.startSession();
        session.startTransaction();
        const { propertyId, data } = updataData;
        try {
          const property2 = await propertyModel_default.findById(propertyId);
          if (!property2) {
            session.abortTransaction();
            session.endSession();
            logger22.warn("no  property found");
            return null;
          }
          const updateProperty = await propertyModel_default.findOneAndUpdate(
            { _id: propertyId },
            { $set: data },
            {
              new: true,
              // Retourner le document mis à jour
              runValidators: true,
              // Exécuter les validateurs
              session
            }
          ).lean();
          session.commitTransaction();
          session.endSession();
          logger22.info("property  succesfuly  update");
          return updateProperty;
        } catch (error2) {
          session.abortTransaction();
          session.endSession();
          logger22.warn("error updating  property", error2);
        }
      }
    };
    proprityServices_default = PropertyServices;
  }
});

// src/wallet/models/Wallet.ts
import mongoose11, { Schema as Schema14 } from "mongoose";
var WalletSchema, Wallet;
var init_Wallet = __esm({
  "src/wallet/models/Wallet.ts"() {
    WalletSchema = new Schema14({
      userId: { type: String, required: true, unique: true },
      balance: { type: Number, default: 0, min: 0 },
      pendingBalance: { type: Number, default: 0, min: 0 },
      currency: { type: String, default: "EUR", enum: ["EUR", "USD", "GBP"] },
      cryptoBalances: [{
        currency: { type: String, required: true },
        amount: { type: Number, required: true, min: 0 },
        value: { type: Number, required: true, min: 0 }
      }]
    }, {
      timestamps: true
    });
    Wallet = mongoose11.model("Wallet", WalletSchema);
  }
});

// src/wallet/models/Transaction.ts
import mongoose12, { Schema as Schema15 } from "mongoose";
var TransactionSchema, Transaction;
var init_Transaction = __esm({
  "src/wallet/models/Transaction.ts"() {
    TransactionSchema = new Schema15({
      userId: { type: String, required: true },
      type: {
        type: String,
        required: true,
        enum: ["payment", "received", "crypto", "deposit", "withdrawal"]
      },
      amount: { type: Number, required: true, min: 0 },
      currency: { type: String, default: "EUR" },
      description: { type: String, required: true, maxlength: 255 },
      status: {
        type: String,
        default: "pending",
        enum: ["completed", "pending", "failed", "cancelled"]
      },
      paymentMethodId: { type: String },
      cryptoCurrency: { type: String },
      recipientId: { type: String },
      metadata: { type: Schema15.Types.Mixed }
    }, {
      timestamps: true
    });
    TransactionSchema.index({ userId: 1, createdAt: -1 });
    Transaction = mongoose12.model("Transaction", TransactionSchema);
  }
});

// src/wallet/services/walletService.ts
import mongoose13 from "mongoose";
var WalletService;
var init_walletService = __esm({
  "src/wallet/services/walletService.ts"() {
    init_Wallet();
    init_Transaction();
    WalletService = class {
      async createWallet(userId) {
        const wallet = new Wallet({
          userId,
          balance: 0,
          pendingBalance: 0,
          currency: "EUR",
          cryptoBalances: []
        });
        return await wallet.save();
      }
      async getWallet(userId) {
        return await Wallet.findOne({ userId });
      }
      async updateBalance(userId, amount, isPending = false) {
        const updateField = isPending ? "pendingBalance" : "balance";
        await Wallet.updateOne(
          { userId },
          { $inc: { [updateField]: amount } }
        );
      }
      async createTransaction(userId, data) {
        const transaction = new Transaction({
          userId,
          type: data.type,
          amount: data.amount,
          currency: data.currency || "EUR",
          description: data.description,
          status: "pending",
          paymentMethodId: data.paymentMethodId,
          cryptoCurrency: data.cryptoCurrency,
          recipientId: data.recipientId
        });
        return await transaction.save();
      }
      async getTransactions(userId, limit = 50) {
        return await Transaction.find({
          $or: [{ userId }, { recipientId: userId }]
        }).sort({ createdAt: -1 }).limit(limit);
      }
      async updateTransactionStatus(transactionId, status) {
        await Transaction.updateOne(
          { _id: transactionId },
          { $set: { status } }
        );
      }
      async processPayment(userId, data) {
        const session = await mongoose13.startSession();
        try {
          return await session.withTransaction(async () => {
            if (data.type === "payment") {
              const wallet = await this.getWallet(userId);
              if (!wallet || wallet.balance < data.amount) {
                throw new Error("Solde insuffisant");
              }
            }
            const transaction = await this.createTransaction(userId, data);
            if (data.type === "payment") {
              await this.updateBalance(userId, -data.amount);
            }
            if (data.type === "received") {
              await this.updateBalance(userId, data.amount);
            }
            await this.updateTransactionStatus(transaction._id.toString(), "completed");
            return await Transaction.findById(transaction._id);
          });
        } finally {
          await session.endSession();
        }
      }
      async transferMoney(userId, data) {
        const session = await mongoose13.startSession();
        try {
          return await session.withTransaction(async () => {
            const wallet = await this.getWallet(userId);
            if (!wallet || wallet.balance < data.amount) {
              throw new Error("Solde insuffisant");
            }
            const debitTransaction = await this.createTransaction(userId, {
              type: "payment",
              amount: data.amount,
              currency: data.currency,
              description: data.description,
              recipientId: data.recipientId,
              paymentMethodId: data.paymentMethodId
            });
            await this.createTransaction(data.recipientId, {
              type: "received",
              amount: data.amount,
              currency: data.currency,
              description: `Re\xE7u de ${userId}: ${data.description}`,
              recipientId: userId
            });
            await this.updateBalance(userId, -data.amount);
            await this.updateBalance(data.recipientId, data.amount);
            await this.updateTransactionStatus(debitTransaction._id.toString(), "completed");
            return debitTransaction;
          });
        } finally {
          await session.endSession();
        }
      }
      async getTransactionById(userId, transactionId) {
        return await Transaction.findOne({
          _id: transactionId,
          $or: [{ userId }, { recipientId: userId }]
        });
      }
    };
  }
});

// src/wallet/models/PaymentMethod.ts
import mongoose14, { Schema as Schema16 } from "mongoose";
var PaymentMethodSchema, PaymentMethod;
var init_PaymentMethod = __esm({
  "src/wallet/models/PaymentMethod.ts"() {
    PaymentMethodSchema = new Schema16({
      userId: { type: String, required: true },
      type: {
        type: String,
        required: true,
        enum: ["card", "bank", "paypal", "mobile_money", "crypto"]
      },
      name: { type: String, required: true, maxlength: 100 },
      details: {
        last4: { type: String },
        expiry: { type: String },
        iban: { type: String },
        email: { type: String },
        phoneNumber: { type: String },
        cryptoAddress: { type: String }
      },
      isDefault: { type: Boolean, default: false },
      isActive: { type: Boolean, default: true }
    }, {
      timestamps: true
    });
    PaymentMethodSchema.index({ userId: 1, isActive: 1 });
    PaymentMethod = mongoose14.model("PaymentMethod", PaymentMethodSchema);
  }
});

// src/wallet/services/paymentMethodService.ts
var PaymentMethodService;
var init_paymentMethodService = __esm({
  "src/wallet/services/paymentMethodService.ts"() {
    init_PaymentMethod();
    PaymentMethodService = class {
      async createPaymentMethod(userId, data) {
        if (data.isDefault) {
          await PaymentMethod.updateMany(
            { userId },
            { $set: { isDefault: false } }
          );
        }
        const paymentMethod = new PaymentMethod({
          userId,
          type: data.type,
          name: data.name,
          details: this.sanitizeDetails(data.details),
          isDefault: data.isDefault || false,
          isActive: true
        });
        return await paymentMethod.save();
      }
      async getPaymentMethods(userId) {
        return await PaymentMethod.find({ userId, isActive: true }).sort({ isDefault: -1, createdAt: -1 });
      }
      async deletePaymentMethod(userId, methodId) {
        await PaymentMethod.updateOne(
          { _id: methodId, userId },
          { $set: { isActive: false } }
        );
      }
      async setDefaultPaymentMethod(userId, methodId) {
        await PaymentMethod.updateMany(
          { userId },
          { $set: { isDefault: false } }
        );
        await PaymentMethod.updateOne(
          { _id: methodId, userId },
          { $set: { isDefault: true } }
        );
      }
      sanitizeDetails(details) {
        const sanitized = { ...details };
        if (sanitized.cardNumber) {
          sanitized.last4 = sanitized.cardNumber.slice(-4);
          delete sanitized.cardNumber;
          delete sanitized.cvv;
        }
        if (sanitized.iban) {
          sanitized.last4 = sanitized.iban.slice(-4);
        }
        return sanitized;
      }
    };
  }
});

// src/wallet/services/cryptoService.ts
import mongoose15 from "mongoose";
var CryptoService;
var init_cryptoService = __esm({
  "src/wallet/services/cryptoService.ts"() {
    init_Wallet();
    init_config();
    CryptoService = class {
      checkCryptoEnabled() {
        if (!config_default.features.crypto.enabled) {
          throw new Error("Crypto functionality is currently disabled");
        }
      }
      validateCurrency(currency) {
        if (!config_default.features.crypto.supportedCurrencies.includes(currency)) {
          throw new Error(`Currency ${currency} is not supported`);
        }
      }
      async getPrices(currencies = []) {
        this.checkCryptoEnabled();
        const supportedCurrencies = currencies.filter(
          (c) => config_default.features.crypto.supportedCurrencies.includes(c)
        );
        if (supportedCurrencies.length === 0) {
          return [];
        }
        const mockPrices = {
          "BTC": 45e3,
          "ETH": 3200,
          "LTC": 180,
          "BCH": 420,
          "XRP": 0.65,
          "ADA": 1.85
        };
        return supportedCurrencies.map((currency) => ({
          currency,
          priceEUR: mockPrices[currency] || 0,
          priceUSD: mockPrices[currency] * 1.1 || 0,
          change24h: Math.random() * 10 - 5,
          // Random change between -5% and +5%
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        }));
      }
      async updateCryptoBalance(userId, currency, amount, value) {
        const wallet = await Wallet.findOne({ userId });
        if (!wallet) return;
        const cryptoIndex = wallet.cryptoBalances.findIndex((c) => c.currency === currency);
        if (cryptoIndex >= 0) {
          wallet.cryptoBalances[cryptoIndex] = { currency, amount, value };
        } else {
          wallet.cryptoBalances.push({ currency, amount, value });
        }
        await wallet.save();
      }
      async getCryptoBalances(userId) {
        this.checkCryptoEnabled();
        const wallet = await Wallet.findOne({ userId });
        return wallet?.cryptoBalances || [];
      }
      async buyCrypto(userId, currency, amount, totalCost) {
        this.checkCryptoEnabled();
        this.validateCurrency(currency);
        if (totalCost < config_default.features.crypto.minimumBuyAmount) {
          throw new Error(`Minimum buy amount is ${config_default.features.crypto.minimumBuyAmount} EUR`);
        }
        if (totalCost > config_default.features.crypto.maximumBuyAmount) {
          throw new Error(`Maximum buy amount is ${config_default.features.crypto.maximumBuyAmount} EUR`);
        }
        const session = await mongoose15.startSession();
        try {
          await session.withTransaction(async () => {
            const wallet = await Wallet.findOne({ userId }).session(session);
            if (!wallet || wallet.balance < totalCost) {
              throw new Error("Solde insuffisant pour acheter cette crypto");
            }
            const feeAmount = totalCost * (config_default.features.crypto.transactionFeePercentage / 100);
            const finalCost = totalCost + feeAmount;
            if (wallet.balance < finalCost) {
              throw new Error(`Solde insuffisant (frais inclus: ${feeAmount} EUR)`);
            }
            await Wallet.updateOne(
              { userId },
              { $inc: { balance: -finalCost } }
            ).session(session);
            const existingCrypto = wallet.cryptoBalances?.find((c) => c.currency === currency);
            const newAmount = existingCrypto ? existingCrypto.amount + amount : amount;
            await this.updateCryptoBalance(userId, currency, newAmount, newAmount * (totalCost / amount));
          });
        } finally {
          await session.endSession();
        }
      }
      async sellCrypto(userId, currency, amount, totalValue) {
        this.checkCryptoEnabled();
        this.validateCurrency(currency);
        const session = await mongoose15.startSession();
        try {
          await session.withTransaction(async () => {
            const wallet = await Wallet.findOne({ userId }).session(session);
            const cryptoBalance = wallet?.cryptoBalances?.find((c) => c.currency === currency);
            if (!cryptoBalance || cryptoBalance.amount < amount) {
              throw new Error("Solde crypto insuffisant");
            }
            const feeAmount = totalValue * (config_default.features.crypto.transactionFeePercentage / 100);
            const finalValue = totalValue - feeAmount;
            await Wallet.updateOne(
              { userId },
              { $inc: { balance: finalValue } }
            ).session(session);
            const newAmount = cryptoBalance.amount - amount;
            await this.updateCryptoBalance(userId, currency, newAmount, newAmount * (cryptoBalance.value / cryptoBalance.amount));
          });
        } finally {
          await session.endSession();
        }
      }
    };
  }
});

// src/service-marketplace/models/Service.ts
import mongoose16, { Schema as Schema17 } from "mongoose";
var ServiceSchema, Service;
var init_Service = __esm({
  "src/service-marketplace/models/Service.ts"() {
    ServiceSchema = new Schema17({
      providerId: { type: String, required: true },
      title: { type: String, required: true, maxlength: 100 },
      description: { type: String, required: true, maxlength: 1e3 },
      category: {
        type: String,
        required: true,
        enum: ["maintenance", "cleaning", "security", "gardening", "insurance", "utilities", "wellness", "emergency", "eco", "tech", "collaborative"]
      },
      contractTypes: [{
        type: String,
        enum: ["short_term", "long_term", "seasonal", "on_demand", "emergency"]
      }],
      pricing: {
        basePrice: { type: Number, required: true, min: 0 },
        currency: { type: String, default: "EUR" },
        billingPeriod: {
          type: String,
          required: true,
          enum: ["hourly", "daily", "weekly", "monthly", "yearly", "one_time"]
        },
        discounts: {
          longTerm: { type: Number, min: 0, max: 100 },
          seasonal: { type: Number, min: 0, max: 100 },
          bulk: { type: Number, min: 0, max: 100 }
        }
      },
      requirements: {
        propertyTypes: [{
          type: String,
          enum: ["apartment", "house", "studio", "villa", "commercial"]
        }],
        minContractDuration: { type: Number },
        maxContractDuration: { type: Number },
        isMandatory: { type: Boolean, default: false },
        isOptional: { type: Boolean, default: true }
      },
      availability: {
        zones: [{ type: String, required: true }],
        schedule: {
          days: [{ type: String }],
          hours: { type: String }
        },
        isEmergency: { type: Boolean, default: false }
      },
      media: {
        photos: [{ type: String }],
        videos: [{ type: String }],
        documents: [{ type: String }]
      },
      tags: [{ type: String }],
      status: {
        type: String,
        default: "active",
        enum: ["active", "inactive", "pending", "suspended"]
      },
      rating: { type: Number, default: 0, min: 0, max: 5 },
      totalReviews: { type: Number, default: 0 }
    }, {
      timestamps: true
    });
    ServiceSchema.index({ category: 1, "availability.zones": 1, status: 1 });
    ServiceSchema.index({ providerId: 1 });
    ServiceSchema.index({ rating: -1, totalReviews: -1 });
    Service = mongoose16.model("Service", ServiceSchema);
  }
});

// src/service-marketplace/models/ServiceProvider.ts
import mongoose17, { Schema as Schema18 } from "mongoose";
var ServiceProviderSchema, ServiceProvider;
var init_ServiceProvider = __esm({
  "src/service-marketplace/models/ServiceProvider.ts"() {
    ServiceProviderSchema = new Schema18({
      userId: { type: String, required: true, unique: true },
      companyName: { type: String, maxlength: 100 },
      description: { type: String, required: true, maxlength: 500 },
      certifications: [{ type: String }],
      rating: { type: Number, default: 0, min: 0, max: 5 },
      totalReviews: { type: Number, default: 0 },
      isVerified: { type: Boolean, default: false },
      availableZones: [{ type: String, required: true }],
      contactInfo: {
        phone: { type: String },
        email: { type: String },
        website: { type: String }
      },
      businessInfo: {
        siret: { type: String },
        insurance: { type: String },
        license: { type: String }
      }
    }, {
      timestamps: true
    });
    ServiceProviderSchema.index({ userId: 1 });
    ServiceProviderSchema.index({ availableZones: 1, isVerified: 1 });
    ServiceProvider = mongoose17.model("ServiceProvider", ServiceProviderSchema);
  }
});

// src/service-marketplace/models/ServiceSubscription.ts
import mongoose18, { Schema as Schema19 } from "mongoose";
var ServiceSubscriptionSchema, ServiceSubscription;
var init_ServiceSubscription = __esm({
  "src/service-marketplace/models/ServiceSubscription.ts"() {
    ServiceSubscriptionSchema = new Schema19({
      userId: { type: String, required: true },
      propertyId: { type: String, required: true },
      serviceId: { type: String, required: true },
      contractType: {
        type: String,
        required: true,
        enum: ["short_term", "long_term", "seasonal", "on_demand", "emergency"]
      },
      status: {
        type: String,
        default: "active",
        enum: ["active", "paused", "cancelled", "completed"]
      },
      startDate: { type: Date, required: true },
      endDate: { type: Date },
      pricing: {
        amount: { type: Number, required: true, min: 0 },
        currency: { type: String, default: "EUR" },
        billingPeriod: { type: String, required: true }
      },
      autoRenewal: { type: Boolean, default: false },
      sharedWith: [{ type: String }],
      paymentHistory: [{
        date: { type: Date, default: Date.now },
        amount: { type: Number, required: true },
        status: { type: String, enum: ["paid", "pending", "failed"], default: "pending" }
      }]
    }, {
      timestamps: true
    });
    ServiceSubscriptionSchema.index({ userId: 1, status: 1 });
    ServiceSubscriptionSchema.index({ serviceId: 1 });
    ServiceSubscriptionSchema.index({ propertyId: 1 });
    ServiceSubscription = mongoose18.model("ServiceSubscription", ServiceSubscriptionSchema);
  }
});

// src/service-marketplace/services/ServiceMarketplaceService.ts
import mongoose19 from "mongoose";
var ServiceMarketplaceService;
var init_ServiceMarketplaceService = __esm({
  "src/service-marketplace/services/ServiceMarketplaceService.ts"() {
    init_Service();
    init_ServiceProvider();
    init_ServiceSubscription();
    ServiceMarketplaceService = class {
      async createServiceProvider(userId, data) {
        const provider = new ServiceProvider({
          userId,
          ...data
        });
        return await provider.save();
      }
      async createService(providerId, data, photos) {
        const service = new Service({
          providerId,
          ...data,
          media: {
            photos: photos || [],
            videos: [],
            documents: []
          }
        });
        return await service.save();
      }
      async getServices(filters) {
        const query2 = { status: "active" };
        if (filters.category) query2.category = filters.category;
        if (filters.location) query2["availability.zones"] = filters.location;
        if (filters.propertyType) query2["requirements.propertyTypes"] = filters.propertyType;
        if (filters.contractType) query2.contractTypes = filters.contractType;
        if (filters.priceRange) {
          query2["pricing.basePrice"] = {
            $gte: filters.priceRange[0],
            $lte: filters.priceRange[1]
          };
        }
        return await Service.find(query2).sort({ rating: -1, totalReviews: -1 }).limit(50);
      }
      async subscribeToService(userId, data) {
        const session = await mongoose19.startSession();
        try {
          return await session.withTransaction(async () => {
            const service = await Service.findById(data.serviceId).session(session);
            if (!service || service.status !== "active") {
              throw new Error("Service non disponible");
            }
            const subscription = new ServiceSubscription({
              userId,
              ...data,
              pricing: {
                amount: service.pricing.basePrice,
                currency: service.pricing.currency,
                billingPeriod: service.pricing.billingPeriod
              }
            });
            await subscription.save({ session });
            return subscription;
          });
        } finally {
          await session.endSession();
        }
      }
      async getUserSubscriptions(userId) {
        return await ServiceSubscription.find({ userId }).populate("serviceId").sort({ createdAt: -1 });
      }
      async pauseSubscription(userId, subscriptionId) {
        await ServiceSubscription.updateOne(
          { _id: subscriptionId, userId },
          { status: "paused" }
        );
      }
      async resumeSubscription(userId, subscriptionId) {
        await ServiceSubscription.updateOne(
          { _id: subscriptionId, userId },
          { status: "active" }
        );
      }
      async cancelSubscription(userId, subscriptionId) {
        await ServiceSubscription.updateOne(
          { _id: subscriptionId, userId },
          { status: "cancelled" }
        );
      }
      async shareService(userId, subscriptionId, shareWithUserIds) {
        const subscription = await ServiceSubscription.findOne({
          _id: subscriptionId,
          userId
        });
        if (!subscription) {
          throw new Error("Abonnement non trouv\xE9");
        }
        const totalUsers = shareWithUserIds.length + 1;
        const sharedPrice = subscription.pricing.amount / totalUsers;
        await ServiceSubscription.updateOne(
          { _id: subscriptionId },
          {
            sharedWith: shareWithUserIds,
            "pricing.amount": sharedPrice
          }
        );
      }
      async getProviderServices(providerId) {
        return await Service.find({ providerId }).sort({ createdAt: -1 });
      }
      async updateServiceStatus(providerId, serviceId, status) {
        await Service.updateOne(
          { _id: serviceId, providerId },
          { status }
        );
      }
      async getServiceStats(serviceId) {
        const subscriptions = await ServiceSubscription.aggregate([
          { $match: { serviceId } },
          {
            $group: {
              _id: "$status",
              count: { $sum: 1 },
              totalRevenue: { $sum: "$pricing.amount" }
            }
          }
        ]);
        return {
          subscriptions,
          totalActive: subscriptions.find((s) => s._id === "active")?.count || 0,
          monthlyRevenue: subscriptions.reduce((sum, s) => sum + (s.totalRevenue || 0), 0)
        };
      }
    };
  }
});

// src/service-marketplace/services/RecommendationEngine.ts
var RecommendationEngine;
var init_RecommendationEngine = __esm({
  "src/service-marketplace/services/RecommendationEngine.ts"() {
    init_Service();
    init_ServiceSubscription();
    RecommendationEngine = class {
      async getRecommendations(input) {
        const recommendations = [];
        const propertyBasedServices = await this.getPropertyBasedServices(input.propertyType, input.location.city);
        recommendations.push(...propertyBasedServices);
        const neighborhoodServices = await this.getNeighborhoodServices(input.location, input.servicesAlreadySubscribed);
        recommendations.push(...neighborhoodServices);
        const seasonalServices = await this.getSeasonalServices(input.seasonalContext);
        recommendations.push(...seasonalServices);
        const profileBasedServices = await this.getProfileBasedServices(input.userProfile);
        recommendations.push(...profileBasedServices);
        return this.sortAndFilterRecommendations(recommendations, input.userProfile.budget);
      }
      async getPropertyBasedServices(propertyType, location) {
        const recommendations = [];
        const propertyRules = {
          house: ["gardening", "security", "maintenance"],
          apartment: ["insurance", "cleaning", "utilities"],
          villa: ["gardening", "security", "wellness", "tech"],
          studio: ["cleaning", "utilities"],
          commercial: ["security", "maintenance", "cleaning"]
        };
        const suggestedCategories = propertyRules[propertyType] || [];
        for (const category of suggestedCategories) {
          const services = await Service.find({
            category,
            "availability.zones": location,
            status: "active",
            "requirements.propertyTypes": propertyType
          }).limit(3);
          services.forEach((service) => {
            recommendations.push({
              serviceId: service._id.toString(),
              score: this.calculatePropertyScore(category, propertyType),
              reason: `Recommand\xE9 pour les ${propertyType}s`,
              urgency: category === "security" ? "high" : "medium",
              category,
              estimatedPrice: service.pricing.basePrice
            });
          });
        }
        return recommendations;
      }
      async getNeighborhoodServices(location, excludeServices) {
        const recommendations = [];
        const popularServices = await ServiceSubscription.aggregate([
          {
            $lookup: {
              from: "services",
              localField: "serviceId",
              foreignField: "_id",
              as: "service"
            }
          },
          {
            $unwind: "$service"
          },
          {
            $match: {
              "service.availability.zones": location.city,
              serviceId: { $nin: excludeServices },
              status: "active"
            }
          },
          {
            $group: {
              _id: "$serviceId",
              count: { $sum: 1 },
              service: { $first: "$service" }
            }
          },
          {
            $sort: { count: -1 }
          },
          {
            $limit: 5
          }
        ]);
        popularServices.forEach((item) => {
          recommendations.push({
            serviceId: item._id,
            score: 70 + item.count * 5,
            reason: `${item.count} voisins utilisent ce service`,
            urgency: "low",
            category: item.service.category,
            estimatedPrice: item.service.pricing.basePrice
          });
        });
        return recommendations;
      }
      async getSeasonalServices(season) {
        const recommendations = [];
        if (!season) return recommendations;
        const seasonalCategories = {
          winter: ["maintenance", "utilities"],
          spring: ["gardening", "cleaning"],
          summer: ["gardening", "wellness"],
          autumn: ["maintenance", "cleaning"]
        };
        const categories = seasonalCategories[season] || [];
        for (const category of categories) {
          const services = await Service.find({
            category,
            status: "active",
            tags: { $in: ["seasonal", season] }
          }).limit(2);
          services.forEach((service) => {
            recommendations.push({
              serviceId: service._id.toString(),
              score: 60,
              reason: `Service saisonnier pour ${season}`,
              urgency: "low",
              category,
              estimatedPrice: service.pricing.basePrice
            });
          });
        }
        return recommendations;
      }
      async getProfileBasedServices(userProfile) {
        const recommendations = [];
        if (userProfile.preferences.includes("eco")) {
          const ecoServices = await Service.find({
            category: "eco",
            status: "active",
            "pricing.basePrice": { $lte: userProfile.budget }
          }).limit(3);
          ecoServices.forEach((service) => {
            recommendations.push({
              serviceId: service._id.toString(),
              score: 80,
              reason: "Correspond \xE0 vos pr\xE9f\xE9rences \xE9cologiques",
              urgency: "medium",
              category: "eco",
              estimatedPrice: service.pricing.basePrice
            });
          });
        }
        return recommendations;
      }
      calculatePropertyScore(category, propertyType) {
        const scores = {
          house: { gardening: 90, security: 85, maintenance: 80 },
          apartment: { insurance: 90, cleaning: 85, utilities: 80 },
          villa: { gardening: 95, security: 90, wellness: 85 }
        };
        return scores[propertyType]?.[category] || 50;
      }
      sortAndFilterRecommendations(recommendations, budget) {
        return recommendations.filter((rec) => rec.estimatedPrice <= budget).sort((a, b) => b.score - a.score).slice(0, 10);
      }
    };
  }
});

// node_modules/@graphql-tools/utils/esm/loaders.js
var init_loaders = __esm({
  "node_modules/@graphql-tools/utils/esm/loaders.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/helpers.js
import { parse } from "graphql";
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  let name;
  if ("alias" in a) {
    name = a.alias?.value;
  }
  if (name == null && "name" in a) {
    name = a.name?.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}
var asArray;
var init_helpers = __esm({
  "node_modules/@graphql-tools/utils/esm/helpers.js"() {
    asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
  }
});

// node_modules/cross-inspect/esm/index.js
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatError(value) {
  if (value.name = "GraphQLError") {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var MAX_RECURSIVE_DEPTH;
var init_esm = __esm({
  "node_modules/cross-inspect/esm/index.js"() {
    MAX_RECURSIVE_DEPTH = 3;
  }
});

// node_modules/@graphql-tools/utils/esm/errors.js
import { GraphQLError, versionInfo } from "graphql";
function isGraphQLErrorLike(error2) {
  return error2 != null && typeof error2 === "object" && Object.keys(error2).every((key) => possibleGraphQLErrorProperties.includes(key));
}
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties;
var init_errors = __esm({
  "node_modules/@graphql-tools/utils/esm/errors.js"() {
    possibleGraphQLErrorProperties = [
      "message",
      "locations",
      "path",
      "nodes",
      "source",
      "positions",
      "originalError",
      "name",
      "stack",
      "extensions"
    ];
  }
});

// node_modules/@whatwg-node/promise-helpers/esm/index.js
function isPromise(value) {
  return value?.then != null;
}
function isActualPromise(value) {
  const maybePromise = value;
  return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;
}
function fakePromise(value) {
  if (value && isActualPromise(value)) {
    return value;
  }
  if (isPromise(value)) {
    return {
      then: (resolve, reject) => fakePromise(value.then(resolve, reject)),
      catch: (reject) => fakePromise(value.then((res) => res, reject)),
      finally: (cb) => fakePromise(cb ? promiseLikeFinally(value, cb) : value),
      [Symbol.toStringTag]: "Promise"
    };
  }
  return {
    then(resolve) {
      if (resolve) {
        try {
          return fakePromise(resolve(value));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch() {
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          return fakePromise(cb()).then(() => value, () => value);
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    [Symbol.toStringTag]: "Promise",
    __fakePromiseValue: value,
    [kFakePromise]: "resolved"
  };
}
function fakeRejectPromise(error2) {
  return {
    then(_resolve, reject) {
      if (reject) {
        try {
          return fakePromise(reject(error2));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    catch(reject) {
      if (reject) {
        try {
          return fakePromise(reject(error2));
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    finally(cb) {
      if (cb) {
        try {
          cb();
        } catch (err) {
          return fakeRejectPromise(err);
        }
      }
      return this;
    },
    __fakeRejectError: error2,
    [Symbol.toStringTag]: "Promise",
    [kFakePromise]: "rejected"
  };
}
function promiseLikeFinally(value, onFinally) {
  if ("finally" in value) {
    return value.finally(onFinally);
  }
  return value.then((res) => {
    const finallyRes = onFinally();
    return isPromise(finallyRes) ? finallyRes.then(() => res) : res;
  }, (err) => {
    const finallyRes = onFinally();
    if (isPromise(finallyRes)) {
      return finallyRes.then(() => {
        throw err;
      });
    } else {
      throw err;
    }
  });
}
var kFakePromise;
var init_esm2 = __esm({
  "node_modules/@whatwg-node/promise-helpers/esm/index.js"() {
    kFakePromise = Symbol.for("@whatwg-node/promise-helpers/FakePromise");
  }
});

// node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var init_jsutils = __esm({
  "node_modules/@graphql-tools/utils/esm/jsutils.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/getArgumentValues.js
import { isNonNullType, Kind, print, valueFromAST } from "graphql";
function getArgumentValues(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== void 0) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" was not provided.`, {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (defaultValue !== void 0) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`, {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
var init_getArgumentValues = __esm({
  "node_modules/@graphql-tools/utils/esm/getArgumentValues.js"() {
    init_esm();
    init_errors();
    init_jsutils();
  }
});

// node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize2(fn) {
  const memoize2cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2) {
    let cache2 = memoize2cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize2cache.set(a1, cache2);
      const newValue = fn(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    const cachedValue = cache2.get(a2);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize5Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache32.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache4);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
var init_memoize = __esm({
  "node_modules/@graphql-tools/utils/esm/memoize.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/getDirectiveExtensions.js
import { valueFromAST as valueFromAST2, valueFromASTUntyped } from "graphql";
function getDirectiveExtensions(directableObj, schema, pathToDirectivesInExtensions = ["directives"]) {
  const directiveExtensions = {};
  if (directableObj.extensions) {
    let directivesInExtensions = directableObj.extensions;
    for (const pathSegment of pathToDirectivesInExtensions) {
      directivesInExtensions = directivesInExtensions?.[pathSegment];
    }
    if (directivesInExtensions != null) {
      for (const directiveNameProp in directivesInExtensions) {
        const directiveObjs = directivesInExtensions[directiveNameProp];
        const directiveName = directiveNameProp;
        if (Array.isArray(directiveObjs)) {
          for (const directiveObj of directiveObjs) {
            let existingDirectiveExtensions = directiveExtensions[directiveName];
            if (!existingDirectiveExtensions) {
              existingDirectiveExtensions = [];
              directiveExtensions[directiveName] = existingDirectiveExtensions;
            }
            existingDirectiveExtensions.push(directiveObj);
          }
        } else {
          let existingDirectiveExtensions = directiveExtensions[directiveName];
          if (!existingDirectiveExtensions) {
            existingDirectiveExtensions = [];
            directiveExtensions[directiveName] = existingDirectiveExtensions;
          }
          existingDirectiveExtensions.push(directiveObjs);
        }
      }
    }
  }
  const memoizedStringify = memoize1((obj) => JSON.stringify(obj));
  const astNodes = [];
  if (directableObj.astNode) {
    astNodes.push(directableObj.astNode);
  }
  if (directableObj.extensionASTNodes) {
    astNodes.push(...directableObj.extensionASTNodes);
  }
  for (const astNode of astNodes) {
    if (astNode.directives?.length) {
      for (const directive of astNode.directives) {
        const directiveName = directive.name.value;
        let existingDirectiveExtensions = directiveExtensions[directiveName];
        if (!existingDirectiveExtensions) {
          existingDirectiveExtensions = [];
          directiveExtensions[directiveName] = existingDirectiveExtensions;
        }
        const directiveInSchema = schema?.getDirective(directiveName);
        let value = {};
        if (directiveInSchema) {
          value = getArgumentValues(directiveInSchema, directive);
        }
        if (directive.arguments) {
          for (const argNode of directive.arguments) {
            const argName = argNode.name.value;
            if (value[argName] == null) {
              const argInDirective = directiveInSchema?.args.find((arg) => arg.name === argName);
              if (argInDirective) {
                value[argName] = valueFromAST2(argNode.value, argInDirective.type);
              }
            }
            if (value[argName] == null) {
              value[argName] = valueFromASTUntyped(argNode.value);
            }
          }
        }
        if (astNodes.length > 0 && existingDirectiveExtensions.length > 0) {
          const valStr = memoizedStringify(value);
          if (existingDirectiveExtensions.some((val) => memoizedStringify(val) === valStr)) {
            continue;
          }
        }
        existingDirectiveExtensions.push(value);
      }
    }
  }
  return directiveExtensions;
}
var init_getDirectiveExtensions = __esm({
  "node_modules/@graphql-tools/utils/esm/getDirectiveExtensions.js"() {
    init_getArgumentValues();
    init_memoize();
  }
});

// node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  const directiveExtensions = getDirectiveExtensions(node, void 0, pathToDirectivesInExtensions);
  return Object.entries(directiveExtensions).map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map((directiveArgs) => ({
    name: directiveName,
    args: directiveArgs
  }))).flat(Infinity).filter(Boolean);
}
var init_get_directives = __esm({
  "node_modules/@graphql-tools/utils/esm/get-directives.js"() {
    init_getDirectiveExtensions();
  }
});

// node_modules/@graphql-tools/utils/esm/get-fields-with-directives.js
import { valueFromASTUntyped as valueFromASTUntyped2 } from "graphql";
var init_get_fields_with_directives = __esm({
  "node_modules/@graphql-tools/utils/esm/get-fields-with-directives.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/get-arguments-with-directives.js
import { Kind as Kind2, valueFromASTUntyped as valueFromASTUntyped3 } from "graphql";
var init_get_arguments_with_directives = __esm({
  "node_modules/@graphql-tools/utils/esm/get-arguments-with-directives.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/get-implementing-types.js
var init_get_implementing_types = __esm({
  "node_modules/@graphql-tools/utils/esm/get-implementing-types.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/astFromType.js
import { isListType, isNonNullType as isNonNullType2, Kind as Kind3 } from "graphql";
function astFromType(type) {
  if (isNonNullType2(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === Kind3.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: Kind3.NON_NULL_TYPE,
      type: innerType
    };
  } else if (isListType(type)) {
    return {
      kind: Kind3.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: Kind3.NAMED_TYPE,
    name: {
      kind: Kind3.NAME,
      value: type.name
    }
  };
}
var init_astFromType = __esm({
  "node_modules/@graphql-tools/utils/esm/astFromType.js"() {
    init_esm();
  }
});

// node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
import { Kind as Kind4 } from "graphql";
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: Kind4.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: Kind4.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    if (value?.toJSON) {
      return astFromValueUntyped(value.toJSON());
    }
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: Kind4.OBJECT_FIELD,
          name: { kind: Kind4.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: Kind4.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: Kind4.BOOLEAN, value };
  }
  if (typeof value === "bigint") {
    return { kind: Kind4.INT, value: String(value) };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: Kind4.INT, value: stringNum } : { kind: Kind4.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: Kind4.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp;
var init_astFromValueUntyped = __esm({
  "node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js"() {
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/utils/esm/astFromValue.js
import { isEnumType, isInputObjectType, isLeafType, isListType as isListType2, isNonNullType as isNonNullType3, Kind as Kind5 } from "graphql";
function astFromValue(value, type) {
  if (isNonNullType3(type)) {
    const astValue = astFromValue(value, type.ofType);
    if (astValue?.kind === Kind5.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return { kind: Kind5.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType2(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: Kind5.LIST, values: valuesNodes };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind5.OBJECT_FIELD,
          name: { kind: Kind5.NAME, value: field.name },
          value: fieldValue
        });
      }
    }
    return { kind: Kind5.OBJECT, fields: fieldNodes };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (isEnumType(type)) {
      return { kind: Kind5.ENUM, value: serialized };
    }
    if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp2.test(serialized)) {
      return { kind: Kind5.INT, value: serialized };
    }
    return astFromValueUntyped(serialized);
  }
  console.assert(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp2;
var init_astFromValue = __esm({
  "node_modules/@graphql-tools/utils/esm/astFromValue.js"() {
    init_esm();
    init_astFromValueUntyped();
    init_jsutils();
    integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/utils/esm/descriptionFromObject.js
import { Kind as Kind6 } from "graphql";
function getDescriptionNode(obj) {
  if (obj.astNode?.description) {
    return {
      ...obj.astNode.description,
      block: true
    };
  }
  if (obj.description) {
    return {
      kind: Kind6.STRING,
      value: obj.description,
      block: true
    };
  }
}
var init_descriptionFromObject = __esm({
  "node_modules/@graphql-tools/utils/esm/descriptionFromObject.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/rootTypes.js
var getRootTypeNames, getRootTypes, getRootTypeMap;
var init_rootTypes = __esm({
  "node_modules/@graphql-tools/utils/esm/rootTypes.js"() {
    init_memoize();
    getRootTypeNames = memoize1(function getRootTypeNames2(schema) {
      const rootTypes = getRootTypes(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    getRootTypes = memoize1(function getRootTypes2(schema) {
      const rootTypeMap = getRootTypeMap(schema);
      return new Set(rootTypeMap.values());
    });
    getRootTypeMap = memoize1(function getRootTypeMap2(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
import { GraphQLDeprecatedDirective, isEnumType as isEnumType2, isInputObjectType as isInputObjectType2, isInterfaceType, isIntrospectionType, isObjectType, isScalarType, isSpecifiedDirective, isSpecifiedScalarType, isUnionType, Kind as Kind7, print as print2, specifiedDirectives } from "graphql";
function getDocumentNodeFromSchema(schema, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if (isSpecifiedDirective(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = isSpecifiedScalarType(type);
    const isIntrospection = isIntrospectionType(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if (isObjectType(type)) {
      definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
    } else if (isInterfaceType(type)) {
      definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
    } else if (isUnionType(type)) {
      definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
    } else if (isInputObjectType2(type)) {
      definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
    } else if (isEnumType2(type)) {
      definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
    } else if (isScalarType(type)) {
      definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: Kind7.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema, pathToDirectivesInExtensions) {
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: Kind7.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? Kind7.SCHEMA_DEFINITION : Kind7.SCHEMA_EXTENSION,
    operationTypes,
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
  const descriptionNode = getDescriptionNode(schema);
  if (descriptionNode) {
    schemaNode.description = descriptionNode;
  }
  return schemaNode;
}
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.DIRECTIVE_DEFINITION,
    description: getDescriptionNode(directive),
    name: {
      kind: Kind7.NAME,
      value: directive.name
    },
    arguments: directive.args?.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: directive.locations?.map((location) => ({
      kind: Kind7.NAME,
      value: location
    })) || []
  };
}
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  let directiveNodesBesidesNativeDirectives = [];
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  }
  let deprecatedDirectiveNode = null;
  let specifiedByDirectiveNode = null;
  let oneOfDirectiveNode = null;
  if (directives != null) {
    directiveNodesBesidesNativeDirectives = directives.filter((directive) => specifiedDirectives.every((specifiedDirective) => specifiedDirective.name !== directive.name.value));
    deprecatedDirectiveNode = directives.find((directive) => directive.name.value === "deprecated");
    specifiedByDirectiveNode = directives.find((directive) => directive.name.value === "specifiedBy");
    oneOfDirectiveNode = directives.find((directive) => directive.name.value === "oneOf");
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  if (entity.specifiedByUrl != null || entity.specifiedByURL != null && specifiedByDirectiveNode == null) {
    const specifiedByValue = entity.specifiedByUrl || entity.specifiedByURL;
    const specifiedByArgs = {
      url: specifiedByValue
    };
    specifiedByDirectiveNode = makeDirectiveNode("specifiedBy", specifiedByArgs);
  }
  if (entity.isOneOf && oneOfDirectiveNode == null) {
    oneOfDirectiveNode = makeDirectiveNode("oneOf");
  }
  if (deprecatedDirectiveNode != null) {
    directiveNodesBesidesNativeDirectives.push(deprecatedDirectiveNode);
  }
  if (specifiedByDirectiveNode != null) {
    directiveNodesBesidesNativeDirectives.push(specifiedByDirectiveNode);
  }
  if (oneOfDirectiveNode != null) {
    directiveNodesBesidesNativeDirectives.push(oneOfDirectiveNode);
  }
  return directiveNodesBesidesNativeDirectives;
}
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(arg),
    name: {
      kind: Kind7.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    defaultValue: arg.defaultValue !== void 0 ? astFromValue(arg.defaultValue, arg.type) ?? void 0 : void 0,
    directives: getDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
  const node = {
    kind: Kind7.INTERFACE_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.UNION_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.INPUT_OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.ENUM_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives = makeDirectiveNodes(schema, directivesInExtensions);
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: Kind7.SCALAR_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind7.NAME,
      value: type.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
}
function astFromField(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.FIELD_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: Kind7.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: Kind7.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions),
    defaultValue: astFromValue(field.defaultValue, field.type) ?? void 0
  };
}
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
  return {
    kind: Kind7.ENUM_VALUE_DEFINITION,
    description: getDescriptionNode(value),
    name: {
      kind: Kind7.NAME,
      value: value.name
    },
    directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  for (const argName in args) {
    const argValue = args[argName];
    let value;
    if (directive != null) {
      const arg = directive.args.find((arg2) => arg2.name === argName);
      if (arg) {
        value = astFromValue(argValue, arg.type);
      }
    }
    if (value == null) {
      value = astFromValueUntyped(argValue);
    }
    if (value != null) {
      directiveArguments.push({
        kind: Kind7.ARGUMENT,
        name: {
          kind: Kind7.NAME,
          value: argName
        },
        value
      });
    }
  }
  return {
    kind: Kind7.DIRECTIVE,
    name: {
      kind: Kind7.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema, directiveValues) {
  const directiveNodes = [];
  for (const { name, args } of directiveValues) {
    const directive = schema?.getDirective(name);
    directiveNodes.push(makeDirectiveNode(name, args, directive));
  }
  return directiveNodes;
}
var init_print_schema_with_directives = __esm({
  "node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js"() {
    init_astFromType();
    init_astFromValue();
    init_astFromValueUntyped();
    init_descriptionFromObject();
    init_get_directives();
    init_helpers();
    init_rootTypes();
  }
});

// node_modules/@graphql-tools/utils/esm/validate-documents.js
import { Kind as Kind8, specifiedRules, validate as validate3, versionInfo as versionInfo2 } from "graphql";
var init_validate_documents = __esm({
  "node_modules/@graphql-tools/utils/esm/validate-documents.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/parse-graphql-json.js
import { buildClientSchema } from "graphql";
var init_parse_graphql_json = __esm({
  "node_modules/@graphql-tools/utils/esm/parse-graphql-json.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/comments.js
import { TokenKind, visit } from "graphql";
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  const entityName = node.name?.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys = [entity];
  if (field) {
    keys.push(field);
    if (argument) {
      keys.push(argument);
    }
  }
  const path4 = keys.join(".");
  if (!commentsRegistry[path4]) {
    commentsRegistry[path4] = [];
  }
  commentsRegistry[path4].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join2(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
  return maybeArray?.some((str) => str.includes("\n")) ?? false;
}
function addDescription(cb) {
  return (node, _key, _parent, path4, ancestors) => {
    const keys = [];
    const parent = path4.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, parent?.name?.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path4, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join2(array, "\n"))}
}` : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/\\/g, "\\\\").replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
function printWithComments(ast) {
  return visit(ast, printDocASTReducerWithComments);
}
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "	")) {
    i++;
  }
  return i;
}
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
var MAX_LINE_LENGTH, commentsRegistry, printDocASTReducer, printDocASTReducerWithComments;
var init_comments = __esm({
  "node_modules/@graphql-tools/utils/esm/comments.js"() {
    MAX_LINE_LENGTH = 80;
    commentsRegistry = {};
    printDocASTReducer = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join2(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap("on ", typeCondition), join2(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2([
          "type",
          name,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type + wrap(" ", join2(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap("= ", defaultValue), join2(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2([
          "interface",
          name,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2([
          "extend type",
          name,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2([
          "extend interface",
          name,
          wrap("implements ", join2(interfaces, " & ")),
          join2(directives, " "),
          block(fields)
        ], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
      }
    };
    printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer[key].leave)
      }
    }), {});
  }
});

// node_modules/@graphql-tools/utils/esm/parse-graphql-sdl.js
import { Source as GraphQLSource, isTypeSystemDefinitionNode, Kind as Kind9, parse as parse2, print as print3, visit as visit2 } from "graphql";
var init_parse_graphql_sdl = __esm({
  "node_modules/@graphql-tools/utils/esm/parse-graphql-sdl.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/build-operation-for-field.js
import { getNamedType, isEnumType as isEnumType3, isInterfaceType as isInterfaceType2, isListType as isListType3, isNonNullType as isNonNullType4, isObjectType as isObjectType2, isScalarType as isScalarType2, isUnionType as isUnionType2, Kind as Kind10 } from "graphql";
var init_build_operation_for_field = __esm({
  "node_modules/@graphql-tools/utils/esm/build-operation-for-field.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/types.js
var DirectiveLocation;
var init_types = __esm({
  "node_modules/@graphql-tools/utils/esm/types.js"() {
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind;
var init_Interfaces = __esm({
  "node_modules/@graphql-tools/utils/esm/Interfaces.js"() {
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind || (MapperKind = {}));
  }
});

// node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
import { isObjectType as isObjectType3 } from "graphql";
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if (isObjectType3(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}
var init_getObjectTypeFromTypeMap = __esm({
  "node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/stub.js
import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLString, Kind as Kind11 } from "graphql";
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case GraphQLInt.name:
      return GraphQLInt;
    case GraphQLFloat.name:
      return GraphQLFloat;
    case GraphQLString.name:
      return GraphQLString;
    case GraphQLBoolean.name:
      return GraphQLBoolean;
    case GraphQLID.name:
      return GraphQLID;
    default:
      return type;
  }
}
var init_stub = __esm({
  "node_modules/@graphql-tools/utils/esm/stub.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/rewire.js
import { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType as GraphQLInputObjectType2, GraphQLInterfaceType as GraphQLInterfaceType2, GraphQLList as GraphQLList2, GraphQLNonNull as GraphQLNonNull2, GraphQLObjectType as GraphQLObjectType2, GraphQLScalarType, GraphQLUnionType, isEnumType as isEnumType4, isInputObjectType as isInputObjectType3, isInterfaceType as isInterfaceType3, isListType as isListType4, isNamedType, isNonNullType as isNonNullType5, isObjectType as isObjectType4, isScalarType as isScalarType3, isSpecifiedDirective as isSpecifiedDirective2, isSpecifiedScalarType as isSpecifiedScalarType2, isUnionType as isUnionType3 } from "graphql";
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if (isSpecifiedDirective2(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if (isObjectType4(type)) {
      const config3 = type.toConfig();
      const newConfig = {
        ...config3,
        fields: () => rewireFields(config3.fields),
        interfaces: () => rewireNamedTypes(config3.interfaces)
      };
      return new GraphQLObjectType2(newConfig);
    } else if (isInterfaceType3(type)) {
      const config3 = type.toConfig();
      const newConfig = {
        ...config3,
        fields: () => rewireFields(config3.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config3.interfaces);
      }
      return new GraphQLInterfaceType2(newConfig);
    } else if (isUnionType3(type)) {
      const config3 = type.toConfig();
      const newConfig = {
        ...config3,
        types: () => rewireNamedTypes(config3.types)
      };
      return new GraphQLUnionType(newConfig);
    } else if (isInputObjectType3(type)) {
      const config3 = type.toConfig();
      const newConfig = {
        ...config3,
        fields: () => rewireInputFields(config3.fields)
      };
      return new GraphQLInputObjectType2(newConfig);
    } else if (isEnumType4(type)) {
      const enumConfig = type.toConfig();
      return new GraphQLEnumType(enumConfig);
    } else if (isScalarType3(type)) {
      if (isSpecifiedScalarType2(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if (isListType4(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new GraphQLList2(rewiredType) : null;
    } else if (isNonNullType5(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new GraphQLNonNull2(rewiredType) : null;
    } else if (isNamedType(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}
var init_rewire = __esm({
  "node_modules/@graphql-tools/utils/esm/rewire.js"() {
    init_stub();
  }
});

// node_modules/@graphql-tools/utils/esm/transformInputValue.js
import { getNullableType, isInputObjectType as isInputObjectType4, isLeafType as isLeafType2, isListType as isListType5 } from "graphql";
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = getNullableType(type);
  if (isLeafType2(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if (isListType5(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if (isInputObjectType4(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.serialize(v);
    } catch {
      return v;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.parseValue(v);
    } catch {
      return v;
    }
  });
}
var init_transformInputValue = __esm({
  "node_modules/@graphql-tools/utils/esm/transformInputValue.js"() {
    init_helpers();
  }
});

// node_modules/@graphql-tools/utils/esm/mapSchema.js
import { GraphQLEnumType as GraphQLEnumType2, GraphQLInputObjectType as GraphQLInputObjectType3, GraphQLInterfaceType as GraphQLInterfaceType3, GraphQLList as GraphQLList3, GraphQLNonNull as GraphQLNonNull3, GraphQLObjectType as GraphQLObjectType3, GraphQLSchema, isEnumType as isEnumType5, isInputObjectType as isInputObjectType5, isInterfaceType as isInterfaceType4, isLeafType as isLeafType3, isListType as isListType6, isNamedType as isNamedType2, isNonNullType as isNonNullType6, isObjectType as isObjectType5, isScalarType as isScalarType4, isUnionType as isUnionType4, Kind as Kind12 } from "graphql";
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type) => isLeafType3(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type) => !isLeafType3(type)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new GraphQLSchema({
    ...schema.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config3 = type.toConfig();
      const originalEnumValueConfigMap = config3.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new GraphQLEnumType2({
        ...config3,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => isEnumType5(type));
}
function mapDefaultValues(originalTypeMap, schema, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
function getNewType(newTypeMap, type) {
  if (isListType6(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new GraphQLList3(newType) : null;
  } else if (isNonNullType6(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new GraphQLNonNull3(newType) : null;
  } else if (isNamedType2(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType5(originalType) && !isInterfaceType4(originalType) && !isInputObjectType5(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config3 = originalType.toConfig();
      const originalFieldConfigMap = config3.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if (isObjectType5(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType3({
          ...config3,
          fields: newFieldConfigMap
        }));
      } else if (isInterfaceType4(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType3({
          ...config3,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType3({
          ...config3,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType5(originalType) && !isInterfaceType4(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config3 = originalType.toConfig();
      const originalFieldConfigMap = config3.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if (isObjectType5(originalType)) {
        newTypeMap[typeName] = new GraphQLObjectType3({
          ...config3,
          fields: newFieldConfigMap
        });
      } else if (isInterfaceType4(originalType)) {
        newTypeMap[typeName] = new GraphQLInterfaceType3({
          ...config3,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new GraphQLInputObjectType3({
          ...config3,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema, typeName) {
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if (isObjectType5(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === schema.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === schema.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === schema.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if (isInputObjectType5(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if (isInterfaceType4(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if (isUnionType4(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if (isEnumType5(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if (isScalarType4(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema, typeName) {
  const type = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if (isObjectType5(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === schema.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === schema.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === schema.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if (isInterfaceType4(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if (isInputObjectType5(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper ?? null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type) {
  if (isObjectType5(type)) {
    const config3 = type.toConfig();
    if (config3.astNode != null) {
      const fields = [];
      for (const fieldName in config3.fields) {
        const fieldConfig = config3.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config3.astNode = {
        ...config3.astNode,
        kind: Kind12.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config3.extensionASTNodes != null) {
      config3.extensionASTNodes = config3.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind12.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLObjectType3(config3);
  } else if (isInterfaceType4(type)) {
    const config3 = type.toConfig();
    if (config3.astNode != null) {
      const fields = [];
      for (const fieldName in config3.fields) {
        const fieldConfig = config3.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config3.astNode = {
        ...config3.astNode,
        kind: Kind12.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config3.extensionASTNodes != null) {
      config3.extensionASTNodes = config3.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind12.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInterfaceType3(config3);
  } else if (isInputObjectType5(type)) {
    const config3 = type.toConfig();
    if (config3.astNode != null) {
      const fields = [];
      for (const fieldName in config3.fields) {
        const fieldConfig = config3.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config3.astNode = {
        ...config3.astNode,
        kind: Kind12.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config3.extensionASTNodes != null) {
      config3.extensionASTNodes = config3.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind12.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInputObjectType3(config3);
  } else if (isEnumType5(type)) {
    const config3 = type.toConfig();
    if (config3.astNode != null) {
      const values = [];
      for (const enumKey in config3.values) {
        const enumValueConfig = config3.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config3.astNode = {
        ...config3.astNode,
        values
      };
    }
    if (config3.extensionASTNodes != null) {
      config3.extensionASTNodes = config3.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new GraphQLEnumType2(config3);
  } else {
    return type;
  }
}
var init_mapSchema = __esm({
  "node_modules/@graphql-tools/utils/esm/mapSchema.js"() {
    init_getObjectTypeFromTypeMap();
    init_Interfaces();
    init_rewire();
    init_transformInputValue();
  }
});

// node_modules/@graphql-tools/utils/esm/filterSchema.js
import { GraphQLInputObjectType as GraphQLInputObjectType4, GraphQLInterfaceType as GraphQLInterfaceType4, GraphQLObjectType as GraphQLObjectType4 } from "graphql";
var init_filterSchema = __esm({
  "node_modules/@graphql-tools/utils/esm/filterSchema.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/heal.js
import { GraphQLList as GraphQLList4, GraphQLNonNull as GraphQLNonNull4, isInputObjectType as isInputObjectType6, isInterfaceType as isInterfaceType5, isLeafType as isLeafType4, isListType as isListType7, isNamedType as isNamedType3, isNonNullType as isNonNullType7, isObjectType as isObjectType6, isUnionType as isUnionType5 } from "graphql";
function healSchema(schema) {
  healTypes(schema.getTypeMap(), schema.getDirectives());
  return schema;
}
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if (isObjectType6(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if (isInterfaceType5(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if (isUnionType5(type)) {
      healUnderlyingTypes(type);
      return;
    } else if (isInputObjectType6(type)) {
      healInputFields(type);
      return;
    } else if (isLeafType4(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if (isListType7(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new GraphQLList4(healedType) : null;
    } else if (isNonNullType7(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new GraphQLNonNull4(healedType) : null;
    } else if (isNamedType3(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}
var init_heal = __esm({
  "node_modules/@graphql-tools/utils/esm/heal.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/getResolversFromSchema.js
import { GraphQLScalarType as GraphQLScalarType2, isEnumType as isEnumType6, isInterfaceType as isInterfaceType6, isObjectType as isObjectType7, isScalarType as isScalarType5, isSpecifiedScalarType as isSpecifiedScalarType3, isUnionType as isUnionType6 } from "graphql";
var init_getResolversFromSchema = __esm({
  "node_modules/@graphql-tools/utils/esm/getResolversFromSchema.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/forEachField.js
import { getNamedType as getNamedType2, isObjectType as isObjectType8 } from "graphql";
function forEachField(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!getNamedType2(type).name.startsWith("__") && isObjectType8(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn(field, typeName, fieldName);
      }
    }
  }
}
var init_forEachField = __esm({
  "node_modules/@graphql-tools/utils/esm/forEachField.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
import { getNamedType as getNamedType3, isInputObjectType as isInputObjectType7, isObjectType as isObjectType9 } from "graphql";
function forEachDefaultValue(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!getNamedType3(type).name.startsWith("__")) {
      if (isObjectType9(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn(arg.type, arg.defaultValue);
          }
        }
      } else if (isInputObjectType7(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn(field.type, field.defaultValue);
        }
      }
    }
  }
}
var init_forEachDefaultValue = __esm({
  "node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/addTypes.js
import { GraphQLSchema as GraphQLSchema2, isDirective, isNamedType as isNamedType4 } from "graphql";
var init_addTypes = __esm({
  "node_modules/@graphql-tools/utils/esm/addTypes.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/prune.js
import { getNamedType as getNamedType4, isEnumType as isEnumType7, isInputObjectType as isInputObjectType8, isInterfaceType as isInterfaceType7, isObjectType as isObjectType10, isScalarType as isScalarType6, isSpecifiedScalarType as isSpecifiedScalarType4, isUnionType as isUnionType7 } from "graphql";
var init_prune = __esm({
  "node_modules/@graphql-tools/utils/esm/prune.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/mergeDeep.js
function mergeDeep(sources, respectPrototype = false, respectArrays = false, respectArrayLength = false) {
  let expectedLength;
  let allArrays = true;
  const areArraysInTheSameLength = sources.every((source) => {
    if (Array.isArray(source)) {
      if (expectedLength === void 0) {
        expectedLength = source.length;
        return true;
      } else if (expectedLength === source.length) {
        return true;
      }
    } else {
      allArrays = false;
    }
    return false;
  });
  if (respectArrayLength && areArraysInTheSameLength) {
    return new Array(expectedLength).fill(null).map((_, index) => mergeDeep(sources.map((source) => source[index]), respectPrototype, respectArrays, respectArrayLength));
  }
  if (allArrays) {
    return sources.flat(1);
  }
  let output;
  let firstObjectSource;
  if (respectPrototype) {
    firstObjectSource = sources.find((source) => isObject(source));
    if (output == null) {
      output = {};
    }
    if (firstObjectSource) {
      Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(firstObjectSource)));
    }
  }
  for (const source of sources) {
    if (isObject(source)) {
      if (firstObjectSource) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (output == null) {
          output = {};
        }
        if (key in output) {
          output[key] = mergeDeep([output[key], source[key]], respectPrototype, respectArrays, respectArrayLength);
        } else {
          output[key] = source[key];
        }
      }
    } else if (Array.isArray(source)) {
      if (!Array.isArray(output)) {
        output = source;
      } else {
        output = mergeDeep([output, source], respectPrototype, respectArrays, respectArrayLength);
      }
    } else {
      output = source;
    }
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
var init_mergeDeep = __esm({
  "node_modules/@graphql-tools/utils/esm/mergeDeep.js"() {
    init_helpers();
  }
});

// node_modules/@graphql-tools/utils/esm/selectionSets.js
import { parse as parse3 } from "graphql";
var init_selectionSets = __esm({
  "node_modules/@graphql-tools/utils/esm/selectionSets.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/getResponseKeyFromInfo.js
var init_getResponseKeyFromInfo = __esm({
  "node_modules/@graphql-tools/utils/esm/getResponseKeyFromInfo.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/fields.js
import { GraphQLObjectType as GraphQLObjectType5 } from "graphql";
var init_fields = __esm({
  "node_modules/@graphql-tools/utils/esm/fields.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/renameType.js
import { GraphQLEnumType as GraphQLEnumType3, GraphQLInputObjectType as GraphQLInputObjectType5, GraphQLInterfaceType as GraphQLInterfaceType5, GraphQLObjectType as GraphQLObjectType6, GraphQLScalarType as GraphQLScalarType3, GraphQLUnionType as GraphQLUnionType2, isEnumType as isEnumType8, isInputObjectType as isInputObjectType9, isInterfaceType as isInterfaceType8, isObjectType as isObjectType11, isScalarType as isScalarType7, isUnionType as isUnionType8 } from "graphql";
var init_renameType = __esm({
  "node_modules/@graphql-tools/utils/esm/renameType.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/updateArgument.js
import { Kind as Kind13 } from "graphql";
var init_updateArgument = __esm({
  "node_modules/@graphql-tools/utils/esm/updateArgument.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/implementsAbstractType.js
import { doTypesOverlap, isCompositeType } from "graphql";
var init_implementsAbstractType = __esm({
  "node_modules/@graphql-tools/utils/esm/implementsAbstractType.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/observableToAsyncIterable.js
var init_observableToAsyncIterable = __esm({
  "node_modules/@graphql-tools/utils/esm/observableToAsyncIterable.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
var AccumulatorMap;
var init_AccumulatorMap = __esm({
  "node_modules/@graphql-tools/utils/esm/AccumulatorMap.js"() {
    AccumulatorMap = class extends Map {
      get [Symbol.toStringTag]() {
        return "AccumulatorMap";
      }
      add(key, item) {
        const group = this.get(key);
        if (group === void 0) {
          this.set(key, [item]);
        } else {
          group.push(item);
        }
      }
    };
  }
});

// node_modules/@graphql-tools/utils/esm/directives.js
import { DirectiveLocation as DirectiveLocation2, GraphQLBoolean as GraphQLBoolean2, GraphQLDirective as GraphQLDirective2, GraphQLInt as GraphQLInt2, GraphQLNonNull as GraphQLNonNull5, GraphQLString as GraphQLString2 } from "graphql";
var GraphQLDeferDirective, GraphQLStreamDirective;
var init_directives = __esm({
  "node_modules/@graphql-tools/utils/esm/directives.js"() {
    GraphQLDeferDirective = new GraphQLDirective2({
      name: "defer",
      description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
      locations: [DirectiveLocation2.FRAGMENT_SPREAD, DirectiveLocation2.INLINE_FRAGMENT],
      args: {
        if: {
          type: new GraphQLNonNull5(GraphQLBoolean2),
          description: "Deferred when true or undefined.",
          defaultValue: true
        },
        label: {
          type: GraphQLString2,
          description: "Unique name"
        }
      }
    });
    GraphQLStreamDirective = new GraphQLDirective2({
      name: "stream",
      description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
      locations: [DirectiveLocation2.FIELD],
      args: {
        if: {
          type: new GraphQLNonNull5(GraphQLBoolean2),
          description: "Stream when true or undefined.",
          defaultValue: true
        },
        label: {
          type: GraphQLString2,
          description: "Unique name"
        },
        initialCount: {
          defaultValue: 0,
          type: GraphQLInt2,
          description: "Number of items to return immediately"
        }
      }
    });
  }
});

// node_modules/@graphql-tools/utils/esm/collectFields.js
import { getDirectiveValues, GraphQLIncludeDirective, GraphQLSkipDirective, isAbstractType, Kind as Kind14, typeFromAST } from "graphql";
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind14.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey(selection), selection);
        break;
      }
      case Kind14.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind14.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : void 0
  };
}
var collectSubFields;
var init_collectFields = __esm({
  "node_modules/@graphql-tools/utils/esm/collectFields.js"() {
    init_AccumulatorMap();
    init_directives();
    init_memoize();
    collectSubFields = memoize5(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = new AccumulatorMap();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      const subPatches = [];
      const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
      };
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
      }
      return subFieldsAndPatches;
    });
  }
});

// node_modules/@graphql-tools/utils/esm/getOperationASTFromRequest.js
import { getOperationAST } from "graphql";
function getOperationASTFromDocument(documentNode, operationName) {
  const doc = getOperationAST(documentNode, operationName);
  if (!doc) {
    throw new Error(`Cannot infer operation ${operationName || ""}`);
  }
  return doc;
}
var getOperationASTFromRequest;
var init_getOperationASTFromRequest = __esm({
  "node_modules/@graphql-tools/utils/esm/getOperationASTFromRequest.js"() {
    init_memoize();
    getOperationASTFromRequest = memoize1(function getOperationASTFromRequest2(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// node_modules/@graphql-tools/utils/esm/visitResult.js
import { getNullableType as getNullableType2, isAbstractType as isAbstractType2, isListType as isListType8, isObjectType as isObjectType12, Kind as Kind15, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from "graphql";
var init_visitResult = __esm({
  "node_modules/@graphql-tools/utils/esm/visitResult.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/valueMatchesCriteria.js
var init_valueMatchesCriteria = __esm({
  "node_modules/@graphql-tools/utils/esm/valueMatchesCriteria.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
var init_isAsyncIterable = __esm({
  "node_modules/@graphql-tools/utils/esm/isAsyncIterable.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/isDocumentNode.js
import { Kind as Kind16 } from "graphql";
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === Kind16.DOCUMENT;
}
var init_isDocumentNode = __esm({
  "node_modules/@graphql-tools/utils/esm/isDocumentNode.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/executor.js
var init_executor = __esm({
  "node_modules/@graphql-tools/utils/esm/executor.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/withCancel.js
var proxyMethodFactory;
var init_withCancel = __esm({
  "node_modules/@graphql-tools/utils/esm/withCancel.js"() {
    init_memoize();
    proxyMethodFactory = memoize2(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
  }
});

// node_modules/@graphql-tools/utils/esm/fixSchemaAst.js
import { buildASTSchema } from "graphql";
var init_fixSchemaAst = __esm({
  "node_modules/@graphql-tools/utils/esm/fixSchemaAst.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/extractExtensionsFromSchema.js
var init_extractExtensionsFromSchema = __esm({
  "node_modules/@graphql-tools/utils/esm/extractExtensionsFromSchema.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/Path.js
var init_Path = __esm({
  "node_modules/@graphql-tools/utils/esm/Path.js"() {
  }
});

// node_modules/dset/merge/index.mjs
var init_merge = __esm({
  "node_modules/dset/merge/index.mjs"() {
  }
});

// node_modules/@graphql-tools/utils/esm/mergeIncrementalResult.js
var init_mergeIncrementalResult = __esm({
  "node_modules/@graphql-tools/utils/esm/mergeIncrementalResult.js"() {
    init_merge();
  }
});

// node_modules/@graphql-tools/utils/esm/debugTimer.js
var init_debugTimer = __esm({
  "node_modules/@graphql-tools/utils/esm/debugTimer.js"() {
  }
});

// node_modules/@graphql-tools/utils/esm/registerAbortSignalListener.js
function registerAbortSignalListener(signal, listener) {
  if (signal.aborted) {
    listener();
    return;
  }
  getListenersOfAbortSignal(signal).add(listener);
}
var getListenersOfAbortSignal, getAbortPromise;
var init_registerAbortSignalListener = __esm({
  "node_modules/@graphql-tools/utils/esm/registerAbortSignalListener.js"() {
    init_esm2();
    init_memoize();
    getListenersOfAbortSignal = memoize1(function getListenersOfAbortSignal2(signal) {
      const listeners = /* @__PURE__ */ new Set();
      signal.addEventListener("abort", (e) => {
        for (const listener of listeners) {
          listener(e);
        }
      }, { once: true });
      return listeners;
    });
    getAbortPromise = memoize1(function getAbortPromise2(signal) {
      if (signal.aborted) {
        return fakeRejectPromise(signal.reason);
      }
      return new Promise((_resolve, reject) => {
        if (signal.aborted) {
          reject(signal.reason);
          return;
        }
        registerAbortSignalListener(signal, () => {
          reject(signal.reason);
        });
      });
    });
  }
});

// node_modules/@graphql-tools/utils/esm/index.js
var init_esm3 = __esm({
  "node_modules/@graphql-tools/utils/esm/index.js"() {
    init_loaders();
    init_helpers();
    init_get_directives();
    init_get_fields_with_directives();
    init_get_arguments_with_directives();
    init_get_implementing_types();
    init_print_schema_with_directives();
    init_get_fields_with_directives();
    init_validate_documents();
    init_parse_graphql_json();
    init_parse_graphql_sdl();
    init_build_operation_for_field();
    init_types();
    init_filterSchema();
    init_heal();
    init_getResolversFromSchema();
    init_forEachField();
    init_forEachDefaultValue();
    init_mapSchema();
    init_addTypes();
    init_rewire();
    init_prune();
    init_mergeDeep();
    init_Interfaces();
    init_stub();
    init_selectionSets();
    init_getResponseKeyFromInfo();
    init_fields();
    init_renameType();
    init_transformInputValue();
    init_updateArgument();
    init_astFromType();
    init_implementsAbstractType();
    init_errors();
    init_observableToAsyncIterable();
    init_visitResult();
    init_getArgumentValues();
    init_valueMatchesCriteria();
    init_isAsyncIterable();
    init_isDocumentNode();
    init_astFromValueUntyped();
    init_executor();
    init_withCancel();
    init_rootTypes();
    init_comments();
    init_collectFields();
    init_memoize();
    init_fixSchemaAst();
    init_getOperationASTFromRequest();
    init_extractExtensionsFromSchema();
    init_Path();
    init_jsutils();
    init_directives();
    init_mergeIncrementalResult();
    init_debugTimer();
    init_getDirectiveExtensions();
    init_registerAbortSignalListener();
  }
});

// node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
import { getNamedType as getNamedType5, isScalarType as isScalarType8 } from "graphql";
function assertResolversPresent(schema, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !isScalarType8(getNamedType5(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
function expectResolver(validator2, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator2}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}
var init_assertResolversPresent = __esm({
  "node_modules/@graphql-tools/schema/esm/assertResolversPresent.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  mapSchema(schema, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}
var init_checkForResolveTypeResolver = __esm({
  "node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces(schema, resolvers2) {
  const extendedResolvers = {};
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers2[iFace.name]) {
          for (const fieldName in resolvers2[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers2[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers2[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}
var init_extendResolversFromInterfaces = __esm({
  "node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js"() {
  }
});

// node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
import { GraphQLEnumType as GraphQLEnumType4, GraphQLInterfaceType as GraphQLInterfaceType6, GraphQLObjectType as GraphQLObjectType7, GraphQLScalarType as GraphQLScalarType4, GraphQLUnionType as GraphQLUnionType3, isEnumType as isEnumType9, isInterfaceType as isInterfaceType9, isObjectType as isObjectType13, isScalarType as isScalarType9, isSpecifiedScalarType as isSpecifiedScalarType5, isUnionType as isUnionType9 } from "graphql";
function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers2 = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
  for (const typeName in resolvers2) {
    const resolverValue = resolvers2[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema.getType(typeName);
    if (type == null) {
      const msg = `"${typeName}" defined in resolvers, but not in schema`;
      if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "error") {
        if (requireResolversToMatchSchema === "warn") {
          console.warn(msg);
        }
        continue;
      }
      throw new Error(msg);
    } else if (isSpecifiedScalarType5(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType9(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (isUnionType9(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (isObjectType13(type) || isInterfaceType9(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              const msg = `${typeName}.${fieldName} defined in resolvers, but not in schema`;
              if (requireResolversToMatchSchema === "error") {
                throw new Error(msg);
              } else {
                console.error(msg);
              }
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
  }
  return schema;
}
function addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver) {
  const typeMap = schema.getTypeMap();
  for (const typeName in resolvers2) {
    const type = schema.getType(typeName);
    const resolverValue = resolvers2[typeName];
    if (isScalarType9(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: resolverValue?.astNode?.description ?? type.astNode.description,
            directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType9(type)) {
      const config3 = type.toConfig();
      const enumValueConfigMap = config3.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config3[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config3.astNode != null) {
          config3.astNode = {
            ...config3.astNode,
            description: resolverValue?.astNode?.description ?? config3.astNode.description,
            directives: (config3.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && config3.extensionASTNodes != null) {
          config3.extensionASTNodes = config3.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new GraphQLEnumType4(config3);
    } else if (isUnionType9(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if (isObjectType13(type) || isInterfaceType9(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema, serializeInputValue);
  healSchema(schema);
  forEachDefaultValue(schema, parseInputValue);
  if (defaultFieldResolver != null) {
    forEachField(schema, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver;
      }
    });
  }
  return schema;
}
function createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver) {
  schema = mapSchema(schema, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      const config3 = type.toConfig();
      const resolverValue = resolvers2[type.name];
      if (!isSpecifiedScalarType5(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config3[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config3.astNode != null) {
            config3.astNode = {
              ...config3.astNode,
              description: resolverValue?.astNode?.description ?? config3.astNode.description,
              directives: (config3.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config3.extensionASTNodes != null) {
            config3.extensionASTNodes = config3.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config3.extensions != null && resolverValue.extensions != null) {
            config3.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config3[fieldName] = resolverValue[fieldName];
          }
        }
        return new GraphQLScalarType4(config3);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      const config3 = type.toConfig();
      const enumValueConfigMap = config3.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config3[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config3.astNode != null) {
            config3.astNode = {
              ...config3.astNode,
              description: resolverValue?.astNode?.description ?? config3.astNode.description,
              directives: (config3.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config3.extensionASTNodes != null) {
            config3.extensionASTNodes = config3.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config3.extensions != null && resolverValue.extensions != null) {
            config3.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new GraphQLEnumType4(config3);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config3 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config3.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLUnionType3(config3);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config3 = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config3.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new GraphQLObjectType7(config3);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config3 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config3.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLInterfaceType6(config3);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers2[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver != null) {
    schema = mapSchema(schema, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
      })
    });
  }
  return schema;
}
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}
var init_addResolversToSchema = __esm({
  "node_modules/@graphql-tools/schema/esm/addResolversToSchema.js"() {
    init_esm3();
    init_checkForResolveTypeResolver();
    init_extendResolversFromInterfaces();
  }
});

// node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers2 = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers2.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers2, true);
  if (options?.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (["__proto__", "constructor", "prototype"].includes(typeName) || ["__proto__", "constructor", "prototype"].includes(fieldName)) {
        continue;
      }
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}
var init_merge_resolvers = __esm({
  "node_modules/@graphql-tools/merge/esm/merge-resolvers.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments(args1, args2, config3) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome), config3);
  if (config3 && config3.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function deduplicateArguments(args, config3) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!config3?.reverseArguments) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
}
var init_arguments = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
import { Kind as Kind17 } from "graphql";
function isRepeatableDirective(directive, directives, repeatableLinkImports) {
  return !!(directives?.[directive.name.value]?.repeatable ?? repeatableLinkImports?.has(directive.name.value));
}
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
function mergeArguments2(a1, a2) {
  const result = [];
  for (const argument of [...a2, ...a1]) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex === -1) {
      result.push(argument);
    } else {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value = {
          ...existingArg.value,
          values: deduplicateLists(source, target, (targetVal, source2) => {
            const value = targetVal.value;
            return !value || !source2.some((sourceVal) => sourceVal.value === value);
          })
        };
      } else {
        existingArg.value = argument.value;
      }
    }
  }
  return result;
}
function mergeDirectives(d1 = [], d2 = [], config3, directives) {
  const reverseOrder = config3 && config3.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = [];
  for (const directive of [...asNext, ...asFirst]) {
    if (isRepeatableDirective(directive, directives, config3?.repeatableLinkImports)) {
      const exactDuplicate = result.find((d) => matchDirectives(directive, d));
      if (!exactDuplicate) {
        result.push(directive);
      }
    } else {
      const firstAt = result.findIndex((d) => d.name.value === directive.name.value);
      if (firstAt === -1) {
        result.push(directive);
      } else {
        const mergedArguments = mergeArguments2(directive.arguments ?? [], result[firstAt].arguments ?? []);
        result[firstAt] = {
          ...result[firstAt],
          arguments: mergedArguments.length === 0 ? void 0 : mergedArguments
        };
      }
    }
  }
  return result;
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    return {
      ...node,
      arguments: deduplicateLists(existingNode.arguments || [], node.arguments || [], (arg, existingArgs) => !nameAlreadyExists(arg.name, existingArgs.map((a) => a.name))),
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}
var matchValues, matchArguments, matchDirectives;
var init_directives2 = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js"() {
    matchValues = (a, b) => {
      if (a.kind === b.kind) {
        switch (a.kind) {
          case Kind17.LIST:
            return a.values.length === b.values.length && a.values.every((aVal) => b.values.find((bVal) => matchValues(aVal, bVal)));
          case Kind17.VARIABLE:
          case Kind17.NULL:
            return true;
          case Kind17.OBJECT:
            return a.fields.length === b.fields.length && a.fields.every((aField) => b.fields.find((bField) => aField.name.value === bField.name.value && matchValues(aField.value, bField.value)));
          default:
            return a.value === b.value;
        }
      }
      return false;
    };
    matchArguments = (a, b) => a.name.value === b.name.value && a.value.kind === b.value.kind && matchValues(a.value, b.value);
    matchDirectives = (a, b) => {
      const matched = a.name.value === b.name.value && (a.arguments === b.arguments || a.arguments?.length === b.arguments?.length && a.arguments?.every((argA) => b.arguments?.find((argB) => matchArguments(argA, argB))));
      return !!matched;
    };
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues(first, second, config3, directives) {
  if (config3?.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config3 && config3.sort) {
    result.sort(compareNodes);
  }
  return result;
}
var init_enum_values = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js"() {
    init_esm3();
    init_directives2();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
import { Kind as Kind18 } from "graphql";
function mergeEnum(e1, e2, config3, directives) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: config3?.convertExtensions || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config3, directives),
      values: mergeEnumValues(e1.values, e2.values, config3)
    };
  }
  return config3?.convertExtensions ? {
    ...e1,
    kind: Kind18.ENUM_TYPE_DEFINITION
  } : e1;
}
var init_enum = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js"() {
    init_directives2();
    init_enum_values();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
import { Kind as Kind19, Source } from "graphql";
function isStringTypes(types) {
  return typeof types === "string";
}
function isSourceTypes(types) {
  return types instanceof Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === Kind19.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== Kind19.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === Kind19.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === Kind19.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
var CompareVal;
var init_utils = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js"() {
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal || (CompareVal = {}));
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
function fieldAlreadyExists(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
}
function mergeFields(type, f1, f2, config3, directives) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists(result, field);
      if (existing && !config3?.ignoreFieldConflicts) {
        const newField = config3?.onFieldTypeConflict && config3.onFieldTypeConflict(existing, field, type, config3?.throwOnConflict) || preventConflicts(type, existing, field, config3?.throwOnConflict);
        newField.arguments = mergeArguments(field["arguments"] || [], existing["arguments"] || [], config3);
        newField.directives = mergeDirectives(field.directives, existing.directives, config3, directives);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config3 && config3.sort) {
    result.sort(compareNodes);
  }
  if (config3 && config3.exclusions) {
    const exclusions = config3.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
function preventConflicts(type, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType) {
    const t1 = extractType(a.type);
    const t2 = extractType(b.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
    if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode(b.type) && !isNonNullTypeNode(a.type)) {
    a.type = b.type;
  }
  return a;
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}
var init_fields2 = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js"() {
    init_esm3();
    init_arguments();
    init_directives2();
    init_utils();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
import { Kind as Kind20 } from "graphql";
function mergeInputType(node, existingNode, config3, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config3?.convertExtensions || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config3),
        directives: mergeDirectives(node.directives, existingNode.directives, config3, directives)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return config3?.convertExtensions ? {
    ...node,
    kind: Kind20.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}
var init_input_type = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js"() {
    init_directives2();
    init_fields2();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
function alreadyExists(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config3 = {}) {
  const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config3 && config3.sort) {
    result.sort(compareNodes);
  }
  return result;
}
var init_merge_named_type_array = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
import { Kind as Kind21 } from "graphql";
function mergeInterface(node, existingNode, config3, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config3?.convertExtensions || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config3, directives),
        directives: mergeDirectives(node.directives, existingNode.directives, config3, directives),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config3) : void 0
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return config3?.convertExtensions ? {
    ...node,
    kind: Kind21.INTERFACE_TYPE_DEFINITION
  } : node;
}
var init_interface = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js"() {
    init_directives2();
    init_fields2();
    init_merge_named_type_array();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
import { Kind as Kind22 } from "graphql";
function mergeScalar(node, existingNode, config3, directives) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: config3?.convertExtensions || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config3, directives)
    };
  }
  return config3?.convertExtensions ? {
    ...node,
    kind: Kind22.SCALAR_TYPE_DEFINITION
  } : node;
}
var init_scalar = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js"() {
    init_directives2();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
import { Kind as Kind23 } from "graphql";
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config3, directives) {
  if (existingNode) {
    return {
      kind: node.kind === Kind23.SCHEMA_DEFINITION || existingNode.kind === Kind23.SCHEMA_DEFINITION ? Kind23.SCHEMA_DEFINITION : Kind23.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config3, directives),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return config3?.convertExtensions ? {
    ...node,
    kind: Kind23.SCHEMA_DEFINITION
  } : node;
}
var DEFAULT_OPERATION_TYPE_NAME_MAP;
var init_schema_def = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js"() {
    init_directives2();
    DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
import { Kind as Kind24 } from "graphql";
function mergeType(node, existingNode, config3, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config3?.convertExtensions || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config3, directives),
        directives: mergeDirectives(node.directives, existingNode.directives, config3, directives),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config3)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return config3?.convertExtensions ? {
    ...node,
    kind: Kind24.OBJECT_TYPE_DEFINITION
  } : node;
}
var init_type = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js"() {
    init_directives2();
    init_fields2();
    init_merge_named_type_array();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
import { Kind as Kind25 } from "graphql";
function mergeUnion(first, second, config3, directives) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
      directives: mergeDirectives(first.directives, second.directives, config3, directives),
      kind: config3?.convertExtensions || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? Kind25.UNION_TYPE_DEFINITION : Kind25.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config3)
    };
  }
  return config3?.convertExtensions ? {
    ...first,
    kind: Kind25.UNION_TYPE_DEFINITION
  } : first;
}
var init_union = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js"() {
    init_directives2();
    init_merge_named_type_array();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
import { Kind as Kind26 } from "graphql";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config3, directives = {}) {
  const mergedResultMap = directives;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = nodeDefinition.name?.value;
      if (config3?.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (config3?.exclusions?.includes(name + ".*") || config3?.exclusions?.includes(name)) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case Kind26.OBJECT_TYPE_DEFINITION:
          case Kind26.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.ENUM_TYPE_DEFINITION:
          case Kind26.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.UNION_TYPE_DEFINITION:
          case Kind26.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.SCALAR_TYPE_DEFINITION:
          case Kind26.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.INPUT_OBJECT_TYPE_DEFINITION:
          case Kind26.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.INTERFACE_TYPE_DEFINITION:
          case Kind26.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config3, directives);
            break;
          case Kind26.DIRECTIVE_DEFINITION:
            if (mergedResultMap[name]) {
              const isInheritedFromPrototype = name in {};
              if (isInheritedFromPrototype) {
                if (!isASTNode(mergedResultMap[name])) {
                  mergedResultMap[name] = void 0;
                }
              }
            }
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === Kind26.SCHEMA_DEFINITION || nodeDefinition.kind === Kind26.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config3);
    }
  }
  return mergedResultMap;
}
function isASTNode(node) {
  return node != null && typeof node === "object" && "kind" in node && typeof node.kind === "string";
}
var schemaDefSymbol;
var init_merge_nodes = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js"() {
    init_esm3();
    init_directives2();
    init_enum();
    init_input_type();
    init_interface();
    init_scalar();
    init_schema_def();
    init_type();
    init_union();
    schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
  }
});

// node_modules/@graphql-tools/merge/esm/links.js
import { Kind as Kind27 } from "graphql";
function namespace(link) {
  return link.as ?? link.url.name;
}
function defaultImport(link) {
  const name = namespace(link);
  return name && `@${name}`;
}
function resolveImportName(link, elementName) {
  if (link.url.name && elementName === `@${link.url.name}`) {
    return defaultImport(link).substring(1);
  }
  const imported = link.imports.find((i) => i.name === elementName);
  const resolvedName = imported?.as ?? imported?.name ?? namespaced(namespace(link), elementName);
  return resolvedName.startsWith("@") ? resolvedName.substring(1) : resolvedName;
}
function namespaced(namespace2, name) {
  if (namespace2?.length) {
    if (name.startsWith("@")) {
      return `@${namespace2}__${name.substring(1)}`;
    }
    return `${namespace2}__${name}`;
  }
  return name;
}
function extractLinks(typeDefs2) {
  let links = [];
  for (const definition of typeDefs2.definitions) {
    if (definition.kind === Kind27.SCHEMA_EXTENSION || definition.kind === Kind27.SCHEMA_DEFINITION) {
      const defLinks = definition.directives?.filter((directive) => directive.name.value === "link");
      const parsedLinks = defLinks?.map((l) => linkFromArgs(l.arguments ?? [])).filter((l) => l !== void 0) ?? [];
      links = links.concat(parsedLinks);
      const defCores = definition.directives?.filter(({ name }) => name.value === "core");
      const coreLinks = defCores?.map((c) => linkFromCoreArgs(c.arguments ?? [])).filter((l) => l !== void 0);
      if (coreLinks) {
        links = links.concat(...coreLinks);
      }
    }
  }
  return links;
}
function linkFromArgs(args) {
  let url2;
  let imports = [];
  let as;
  for (const arg of args) {
    switch (arg.name.value) {
      case "url": {
        if (arg.value.kind === Kind27.STRING) {
          url2 = parseFederationLinkUrl(arg.value.value);
        }
        break;
      }
      case "import": {
        imports = parseImportNode(arg.value);
        break;
      }
      case "as": {
        if (arg.value.kind === Kind27.STRING) {
          as = arg.value.value ?? void 0;
        }
        break;
      }
      default: {
      }
    }
  }
  if (url2 !== void 0) {
    return {
      url: url2,
      as,
      imports
    };
  }
}
function linkFromCoreArgs(args) {
  const feature = args.find(({ name, value }) => name.value === "feature" && value.kind === Kind27.STRING);
  if (feature) {
    const url2 = parseFederationLinkUrl(feature.value.value);
    return {
      url: url2,
      imports: []
    };
  }
}
function parseImportNode(node) {
  if (node.kind === Kind27.LIST) {
    const imports = node.values.map((v) => {
      let namedImport;
      if (v.kind === Kind27.STRING) {
        namedImport = { name: v.value };
      } else if (v.kind === Kind27.OBJECT) {
        let name = "";
        let as;
        for (const f of v.fields) {
          if (f.name.value === "name") {
            if (f.value.kind === Kind27.STRING) {
              name = f.value.value;
            }
          } else if (f.name.value === "as") {
            if (f.value.kind === Kind27.STRING) {
              as = f.value.value;
            }
          }
        }
        namedImport = { name, as };
      }
      return namedImport;
    });
    return imports.filter((i) => i !== void 0);
  }
  return [];
}
function parseFederationLinkUrl(urlSource) {
  const url2 = new URL(urlSource);
  const parts = url2.pathname.split("/").filter(Boolean);
  const versionOrName = parts[parts.length - 1];
  if (versionOrName) {
    if (VERSION_MATCH.test(versionOrName)) {
      const maybeName = parts[parts.length - 2];
      return {
        identity: url2.origin + (maybeName ? `/${parts.slice(0, parts.length - 1).join("/")}` : ""),
        name: maybeName ?? null,
        version: versionOrName
      };
    }
    return {
      identity: `${url2.origin}/${parts.join("/")}`,
      name: versionOrName,
      version: null
    };
  }
  return {
    identity: url2.origin,
    name: null,
    version: null
  };
}
var VERSION_MATCH;
var init_links = __esm({
  "node_modules/@graphql-tools/merge/esm/links.js"() {
    VERSION_MATCH = /v(\d{1,3})\.(\d{1,4})/i;
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
import { isDefinitionNode, isSchema, Kind as Kind28, parse as parse4 } from "graphql";
function mergeTypeDefs(typeSource, config3) {
  resetComments();
  const doc = {
    kind: Kind28.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config3
    })
  };
  let result;
  if (config3?.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set(), repeatableLinkImports = /* @__PURE__ */ new Set()) {
  const addRepeatable = (name) => {
    repeatableLinkImports.add(name);
  };
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);
    } else if (Array.isArray(typeSource)) {
      for (const type of typeSource) {
        visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);
      }
    } else if (isSchema(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = parse4(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);
    } else if (typeof typeSource === "object" && isDefinitionNode(typeSource)) {
      const links = extractLinks({
        definitions: [typeSource],
        kind: Kind28.DOCUMENT
      });
      const federationUrl = "https://specs.apollo.dev/federation";
      const linkUrl = "https://specs.apollo.dev/link";
      const federationLink = links.find((l) => l.url.identity === federationUrl);
      if (federationLink) {
        addRepeatable(resolveImportName(federationLink, "@composeDirective"));
        addRepeatable(resolveImportName(federationLink, "@key"));
      }
      const linkLink = links.find((l) => l.url.identity === linkUrl);
      if (linkLink) {
        addRepeatable(resolveImportName(linkLink, "@link"));
      }
      if (typeSource.kind === Kind28.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources, repeatableLinkImports);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes, repeatableLinkImports };
}
function mergeGraphQLTypes(typeSource, config3) {
  resetComments();
  const { allDirectives, allNodes, repeatableLinkImports } = visitTypeSources(typeSource, config3);
  const mergedDirectives = mergeGraphQLNodes(allDirectives, config3);
  config3.repeatableLinkImports = repeatableLinkImports;
  const mergedNodes = mergeGraphQLNodes(allNodes, config3, mergedDirectives);
  if (config3?.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: Kind28.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: Kind28.OPERATION_TYPE_DEFINITION,
            type: {
              kind: Kind28.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if (config3?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol]?.operationTypes?.length) {
    mergedNodes[schemaDefSymbol] = {
      kind: Kind28.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: Kind28.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: Kind28.NAMED_TYPE,
            name: {
              kind: Kind28.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config3?.sort) {
    const sortFn = typeof config3.sort === "function" ? config3.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => sortFn(a.name?.value, b.name?.value));
  }
  return mergedNodeDefinitions;
}
var init_merge_typedefs = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js"() {
    init_esm3();
    init_links();
    init_merge_nodes();
    init_schema_def();
    init_utils();
  }
});

// node_modules/@graphql-tools/merge/esm/typedefs-mergers/index.js
var init_typedefs_mergers = __esm({
  "node_modules/@graphql-tools/merge/esm/typedefs-mergers/index.js"() {
    init_arguments();
    init_directives2();
    init_enum_values();
    init_enum();
    init_fields2();
    init_input_type();
    init_interface();
    init_merge_named_type_array();
    init_merge_nodes();
    init_merge_typedefs();
    init_scalar();
    init_type();
    init_union();
    init_utils();
  }
});

// node_modules/@graphql-tools/merge/esm/extensions.js
function applyExtensionObject(obj, extensions) {
  if (!obj || !extensions || extensions === obj.extensions) {
    return;
  }
  if (!obj.extensions) {
    obj.extensions = extensions;
    return;
  }
  obj.extensions = mergeDeep([obj.extensions, extensions], false, true);
}
function applyExtensions(schema, extensions) {
  applyExtensionObject(schema, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type = schema.getType(typeName);
    if (type) {
      applyExtensionObject(type, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema;
}
var init_extensions = __esm({
  "node_modules/@graphql-tools/merge/esm/extensions.js"() {
    init_esm3();
  }
});

// node_modules/@graphql-tools/merge/esm/index.js
var init_esm4 = __esm({
  "node_modules/@graphql-tools/merge/esm/index.js"() {
    init_merge_resolvers();
    init_typedefs_mergers();
    init_extensions();
  }
});

// node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
import { buildASTSchema as buildASTSchema2, buildSchema, isSchema as isSchema2 } from "graphql";
function makeExecutableSchema({ typeDefs: typeDefs2, resolvers: resolvers2 = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, defaultFieldResolver, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs2) {
    throw new Error("Must provide typeDefs");
  }
  let schema;
  if (isSchema2(typeDefs2)) {
    schema = typeDefs2;
  } else if (otherOptions?.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema = buildSchema(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, otherOptions);
    schema = buildASTSchema2(mergedTypeDefs, otherOptions);
  }
  schema = addResolversToSchema({
    schema,
    resolvers: mergeResolvers(resolvers2),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace,
    defaultFieldResolver
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema, resolverValidationOptions);
  }
  if (schemaExtensions) {
    for (const schemaExtension of asArray(schemaExtensions)) {
      applyExtensions(schema, schemaExtension);
    }
  }
  return schema;
}
var init_makeExecutableSchema = __esm({
  "node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js"() {
    init_esm4();
    init_esm3();
    init_addResolversToSchema();
    init_assertResolversPresent();
  }
});

// node_modules/@graphql-tools/schema/esm/types.js
var init_types2 = __esm({
  "node_modules/@graphql-tools/schema/esm/types.js"() {
  }
});

// node_modules/@graphql-tools/schema/esm/merge-schemas.js
var init_merge_schemas = __esm({
  "node_modules/@graphql-tools/schema/esm/merge-schemas.js"() {
  }
});

// node_modules/@graphql-tools/schema/esm/index.js
var init_esm5 = __esm({
  "node_modules/@graphql-tools/schema/esm/index.js"() {
    init_makeExecutableSchema();
    init_types2();
    init_merge_schemas();
  }
});

// src/property/graphql/propertySchema.ts
import gql from "graphql-tag";
var propertyTypeDefs;
var init_propertySchema = __esm({
  "src/property/graphql/propertySchema.ts"() {
    propertyTypeDefs = gql`
  enum PropertyStatus {
    AVAILABLE
    RENTED
    MAINTENANCE
    UNAVAILABLE
  }

  enum PropertyActionType {
    rent
    sell
  }

  enum PropertyType {
    villa
    apartment
    home
    penthouse
    studio
    loft
    bureau
    chalet
    hotel
    terrain
    commercial
  }

  enum SolvabilityType {
    instant
    date
  }

  enum GuarantorLocation {
    same
    different
  }

  type GeneralHouseInfo {
    rooms: Int!
    bedrooms: Int!
    bathrooms: Int!
    toilets: Int
    surface: Float!
    area: String!
    furnished: Boolean!
    pets: Boolean!
    smoking: Boolean!
    maxOccupants: Int!
  }

  type GeneralLandInfo {
    surface: Float!
    constructible: Boolean!
    cultivable: Boolean!
    fence: Boolean!
  }

  type OwnerCriteria {
    monthlyRent: Float!
    isGarantRequired: Boolean!
    depositAmount: Float!
    minimumDuration: Int!
    solvability: SolvabilityType!
    guarantorRequired: Boolean!
    guarantorLocation: GuarantorLocation!
    acceptedSituations: [String!]!
    isdocumentRequired: Boolean!
    requiredDocuments: RequiredDocuments!
  }

  type RequiredDocuments {
    client: [String!]!
    guarantor: [String!]!
  }

  type Equipment {
    name: String!
    category: String!
    condition: String
  }

  type Atout {
    name: String!
    description: String
    icon: String
  }

  type Property {
    id: ID!
    propertyId: ID!
    ownerId: ID!
    acquiredBy: ID
    actionType: PropertyActionType!
    propertyType: PropertyType!
    island: Boolean!
    ishome: Boolean!
    title: String!
    description: String!
    address: String!
    generalHInfo: GeneralHouseInfo!
    generalLandinfo: GeneralLandInfo
    images: [String!]!
    amenities: [String!]!
    availableFrom: String!
    status: PropertyStatus!
    isActive: Boolean!
    equipments: [Equipment!]!
    ownerCriteria: OwnerCriteria!
    iserviceAvalaible: Boolean!
    services: PropertyService
    atouts: [Atout!]!
    createdAt: String!
    updatedAt: String!

    # Relations GraphQL
    owner: User
    activities: [Activity!]
    conversations: [Conversation!]
    recentActivities: [Activity!]
    similarProperties: [Property!]

    # Computed fields
    pricePerSquareMeter: Float
    isAvailable: Boolean
    occupancyRate: Float
    performanceScore: Float

    # Analytics
    financialStats: PropertyFinancialStats
    marketAnalysis: PropertyMarketAnalysis
    reviews: [PropertyReview!]
    recommendedServices: [ServiceRecommendation!]
  }

  type PropertyService {
    serviceId: ID!
  }

  type PropertyFinancialStats {
    totalRevenue: Float!
    totalExpenses: Float!
    netIncome: Float!
    transactionCount: Int!
    averageMonthlyRevenue: Float!
  }

  type PropertyMarketAnalysis {
    averageMarketPrice: Float!
    pricePosition: String!
    priceDifference: Float!
    pricePercentage: Int!
    competitorCount: Int!
    marketTrend: String!
  }

  type PropertyReview {
    id: ID!
    rating: Int!
    comment: String!
    reviewer: User!
    date: String!
  }

  type PropertyStats {
    totalProperties: Int!
    availableProperties: Int!
    rentedProperties: Int!
    averageRent: Float!
    averageSize: Float!
    propertiesByArea: [PropertyAreaStat!]!
    propertiesByStatus: [PropertyStatusStat!]!
  }

  type PropertyAreaStat {
    area: String!
    count: Int!
    averageRent: Float!
  }

  type PropertyStatusStat {
    status: PropertyStatus!
    count: Int!
  }

  type PropertyConnection {
    edges: [PropertyEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
  }

  type PropertyEdge {
    node: Property!
    cursor: String!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  input PropertyFilters {
    actionType: PropertyActionType
    propertyType: PropertyType
    status: PropertyStatus
    minPrice: Float
    maxPrice: Float
    minRooms: Int
    maxRooms: Int
    minBedrooms: Int
    maxBedrooms: Int
    minSurface: Float
    maxSurface: Float
    area: String
    furnished: Boolean
    pets: Boolean
    smoking: Boolean
    amenities: [String!]
    availableFrom: String
    tags: [String!]
  }

  input PaginationInput {
    first: Int
    after: String
    page: Int
    limit: Int
    sortBy: String
    sortOrder: String
  }

  input CreatePropertyInput {
    actionType: PropertyActionType!
    propertyType: PropertyType!
    island: Boolean = false
    ishome: Boolean = true
    title: String!
    description: String!
    address: String!
    generalHInfo: GeneralHouseInfoInput!
    generalLandinfo: GeneralLandInfoInput
    images: [String!]!
    amenities: [String!] = []
    availableFrom: String!
    equipments: [EquipmentInput!] = []
    ownerCriteria: OwnerCriteriaInput!
    iserviceAvalaible: Boolean = false
    services: PropertyServiceInput
    atouts: [AtoutInput!] = []
  }

  input GeneralHouseInfoInput {
    rooms: Int!
    bedrooms: Int!
    bathrooms: Int!
    toilets: Int = 0
    surface: Float!
    area: String!
    furnished: Boolean = false
    pets: Boolean = false
    smoking: Boolean = false
    maxOccupants: Int = 1
  }

  input GeneralLandInfoInput {
    surface: Float!
    constructible: Boolean = true
    cultivable: Boolean = true
    fence: Boolean = false
  }

  input OwnerCriteriaInput {
    monthlyRent: Float!
    isGarantRequired: Boolean = false
    depositAmount: Float = 0
    minimumDuration: Int = 1
    solvability: SolvabilityType = instant
    guarantorRequired: Boolean = false
    guarantorLocation: GuarantorLocation = same
    acceptedSituations: [String!] = []
    isdocumentRequired: Boolean = false
    requiredDocuments: RequiredDocumentsInput
  }

  input RequiredDocumentsInput {
    client: [String!] = []
    guarantor: [String!] = []
  }

  input EquipmentInput {
    name: String!
    category: String!
    condition: String
  }

  input AtoutInput {
    name: String!
    description: String
    icon: String
  }

  input PropertyServiceInput {
    serviceId: ID!
  }

  input UpdatePropertyInput {
    actionType: PropertyActionType
    propertyType: PropertyType
    island: Boolean
    ishome: Boolean
    title: String
    description: String
    address: String
    generalHInfo: GeneralHouseInfoInput
    generalLandinfo: GeneralLandInfoInput
    images: [String!]
    amenities: [String!]
    availableFrom: String
    equipments: [EquipmentInput!]
    ownerCriteria: OwnerCriteriaInput
    iserviceAvalaible: Boolean
    services: PropertyServiceInput
    atouts: [AtoutInput!]
    status: PropertyStatus
    isActive: Boolean
  }

  extend type Query {
    property(id: ID!): Property
    properties(filters: PropertyFilters, pagination: PaginationInput): PropertyConnection!
    searchProperties(query: String, filters: PropertyFilters, pagination: PaginationInput): PropertyConnection!
    similarProperties(propertyId: ID!, limit: Int = 5): [Property!]!
    propertyStats: PropertyStats!
    propertiesByOwner(ownerId: ID, pagination: PaginationInput, status: PropertyStatus): PropertyConnection!
  }

  extend type Mutation {
    createProperty(input: CreatePropertyInput!): Property!
    updateProperty(id: ID!, input: UpdatePropertyInput!): Property!
    deleteProperty(id: ID!): Boolean!
    restoreProperty(id: ID!): Property!
    updatePropertyStatus(id: ID!, status: PropertyStatus!): Property!
  }

  extend type Subscription {
    propertyUpdated(propertyId: ID!): Property!
    propertyStatusChanged(ownerId: ID!): Property!
    newPropertyInArea(area: String!): Property!
  }
`;
  }
});

// src/service-marketplace/graphql/serviceSchema.ts
import gql2 from "graphql-tag";
var serviceTypeDefs;
var init_serviceSchema = __esm({
  "src/service-marketplace/graphql/serviceSchema.ts"() {
    serviceTypeDefs = gql2`
  enum ServiceCategory {
    maintenance
    cleaning
    security
    gardening
    insurance
    utilities
    wellness
    emergency
    eco
    tech
    collaborative
  }

  enum ContractType {
    short_term
    long_term
    seasonal
    on_demand
    emergency
  }

  enum ServiceStatus {
    active
    inactive
    pending
    suspended
  }

  enum SubscriptionStatus {
    active
    paused
    cancelled
    completed
  }

  enum BillingPeriod {
    hourly
    daily
    weekly
    monthly
    yearly
    one_time
  }

  enum PaymentStatus {
    paid
    pending
    failed
  }

  type ServiceProvider {
    id: ID!
    userId: ID!
    companyName: String
    description: String!
    certifications: [String!]!
    rating: Float!
    totalReviews: Int!
    isVerified: Boolean!
    availableZones: [String!]!
    contactInfo: ContactInfo!
    businessInfo: BusinessInfo!
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
    services: [Service!]!
  }

  type ContactInfo {
    phone: String
    email: String
    website: String
  }

  type BusinessInfo {
    siret: String
    insurance: String
    license: String
  }

  type Service {
    id: ID!
    providerId: ID!
    title: String!
    description: String!
    category: ServiceCategory!
    contractTypes: [ContractType!]!
    pricing: ServicePricing!
    requirements: ServiceRequirements!
    availability: ServiceAvailability!
    media: ServiceMedia!
    tags: [String!]!
    status: ServiceStatus!
    rating: Float!
    totalReviews: Int!
    createdAt: String!
    updatedAt: String!

    # Relations
    provider: ServiceProvider
    subscriptions: [ServiceSubscription!]!
    reviews: [ServiceReview!]!

    # Computed fields
    isAvailableForProperty(propertyId: ID!): Boolean!
    estimatedPrice(propertyType: String!): Float!
  }

  type ServicePricing {
    basePrice: Float!
    currency: String!
    billingPeriod: BillingPeriod!
    discounts: ServiceDiscounts
  }

  type ServiceDiscounts {
    longTerm: Float
    seasonal: Float
    bulk: Float
  }

  type ServiceRequirements {
    propertyTypes: [String!]!
    minContractDuration: Int
    maxContractDuration: Int
    isMandatory: Boolean!
    isOptional: Boolean!
  }

  type ServiceAvailability {
    zones: [String!]!
    schedule: ServiceSchedule!
    isEmergency: Boolean!
  }

  type ServiceSchedule {
    days: [String!]!
    hours: String!
  }

  type ServiceMedia {
    photos: [String!]!
    videos: [String!]!
    documents: [String!]!
  }

  type ServiceSubscription {
    id: ID!
    userId: ID!
    propertyId: ID!
    serviceId: ID!
    contractType: ContractType!
    status: SubscriptionStatus!
    startDate: String!
    endDate: String
    pricing: SubscriptionPricing!
    autoRenewal: Boolean!
    sharedWith: [ID!]!
    paymentHistory: [PaymentRecord!]!
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
    property: Property
    service: Service
  }

  type SubscriptionPricing {
    amount: Float!
    currency: String!
    billingPeriod: String!
  }

  type PaymentRecord {
    date: String!
    amount: Float!
    status: PaymentStatus!
  }

  type ServiceReview {
    id: ID!
    userId: ID!
    serviceId: ID!
    subscriptionId: ID!
    rating: Int!
    comment: String!
    photos: [String!]!
    isVerified: Boolean!
    providerResponse: ProviderResponse
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
    service: Service
    subscription: ServiceSubscription
  }

  type ProviderResponse {
    comment: String!
    date: String!
  }

  type ServiceRecommendation {
    serviceId: ID!
    score: Float!
    reason: String!
    urgency: String!
    category: ServiceCategory!
    estimatedPrice: Float!
    neighborhoodData: NeighborhoodData

    # Relations
    service: Service
  }

  type NeighborhoodData {
    popularServices: [String!]!
    averageRating: Float!
    totalUsers: Int!
  }

  type ServiceConnection {
    edges: [ServiceEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
  }

  type ServiceEdge {
    node: Service!
    cursor: String!
  }

  type ServiceStats {
    totalServices: Int!
    activeServices: Int!
    totalProviders: Int!
    averageRating: Float!
    popularCategories: [CategoryStat!]!
    revenueByCategory: [CategoryRevenue!]!
  }

  type CategoryStat {
    category: ServiceCategory!
    count: Int!
    averageRating: Float!
  }

  type CategoryRevenue {
    category: ServiceCategory!
    revenue: Float!
    subscriptions: Int!
  }

  input ServiceFilters {
    category: ServiceCategory
    location: String
    propertyType: String
    contractType: ContractType
    priceRange: PriceRangeInput
    isEmergency: Boolean
    tags: [String!]
    rating: Float
  }

  input PriceRangeInput {
    min: Float!
    max: Float!
  }

  input CreateServiceProviderInput {
    companyName: String
    description: String!
    certifications: [String!] = []
    availableZones: [String!]!
    contactInfo: ContactInfoInput
    businessInfo: BusinessInfoInput
  }

  input ContactInfoInput {
    phone: String
    email: String
    website: String
  }

  input BusinessInfoInput {
    siret: String
    insurance: String
    license: String
  }

  input CreateServiceInput {
    title: String!
    description: String!
    category: ServiceCategory!
    contractTypes: [ContractType!]!
    pricing: ServicePricingInput!
    requirements: ServiceRequirementsInput!
    availability: ServiceAvailabilityInput!
    tags: [String!] = []
  }

  input ServicePricingInput {
    basePrice: Float!
    currency: String = "EUR"
    billingPeriod: BillingPeriod!
    discounts: ServiceDiscountsInput
  }

  input ServiceDiscountsInput {
    longTerm: Float
    seasonal: Float
    bulk: Float
  }

  input ServiceRequirementsInput {
    propertyTypes: [String!]!
    minContractDuration: Int
    maxContractDuration: Int
    isMandatory: Boolean = false
    isOptional: Boolean = true
  }

  input ServiceAvailabilityInput {
    zones: [String!]!
    schedule: ServiceScheduleInput!
    isEmergency: Boolean = false
  }

  input ServiceScheduleInput {
    days: [String!]!
    hours: String!
  }

  input SubscribeServiceInput {
    serviceId: ID!
    propertyId: ID!
    contractType: ContractType!
    startDate: String!
    endDate: String
    autoRenewal: Boolean = false
    sharedWith: [ID!] = []
  }

  input UpdateServiceInput {
    title: String
    description: String
    category: ServiceCategory
    contractTypes: [ContractType!]
    pricing: ServicePricingInput
    requirements: ServiceRequirementsInput
    availability: ServiceAvailabilityInput
    tags: [String!]
    status: ServiceStatus
  }

  input RecommendationInput {
    propertyType: String!
    location: LocationInput!
    userProfile: UserProfileInput!
    servicesAlreadySubscribed: [ID!]!
    seasonalContext: String
  }

  input LocationInput {
    city: String!
    district: String!
    coordinates: [Float!]
  }

  input UserProfileInput {
    userId: ID!
    preferences: [String!]!
    budget: Float!
    lifestyle: [String!]!
  }

  input CreateReviewInput {
    serviceId: ID!
    subscriptionId: ID!
    rating: Int!
    comment: String!
    photos: [String!] = []
  }

  extend type Query {
    service(id: ID!): Service
    services(filters: ServiceFilters, pagination: PaginationInput): ServiceConnection!
    serviceRecommendations(input: RecommendationInput!): [ServiceRecommendation!]!
    serviceProvider(id: ID!): ServiceProvider
    serviceProviders(filters: String, pagination: PaginationInput): [ServiceProvider!]!
    userSubscriptions(userId: ID!): [ServiceSubscription!]!
    serviceStats: ServiceStats!
    providerServices(providerId: ID!): [Service!]!
    serviceReviews(serviceId: ID!, pagination: PaginationInput): [ServiceReview!]!
  }

  extend type Mutation {
    createServiceProvider(input: CreateServiceProviderInput!): ServiceProvider!
    updateServiceProvider(id: ID!, input: CreateServiceProviderInput!): ServiceProvider!

    createService(input: CreateServiceInput!): Service!
    updateService(id: ID!, input: UpdateServiceInput!): Service!
    deleteService(id: ID!): Boolean!

    subscribeToService(input: SubscribeServiceInput!): ServiceSubscription!
    pauseSubscription(subscriptionId: ID!): ServiceSubscription!
    resumeSubscription(subscriptionId: ID!): ServiceSubscription!
    cancelSubscription(subscriptionId: ID!): ServiceSubscription!
    shareService(subscriptionId: ID!, shareWithUserIds: [ID!]!): ServiceSubscription!

    createServiceReview(input: CreateReviewInput!): ServiceReview!
    respondToReview(reviewId: ID!, response: String!): ServiceReview!
  }

  extend type Subscription {
    serviceUpdated(serviceId: ID!): Service!
    subscriptionStatusChanged(userId: ID!): ServiceSubscription!
    newServiceInCategory(category: ServiceCategory!): Service!
    newRecommendations(userId: ID!): [ServiceRecommendation!]!
  }
`;
  }
});

// src/wallet/graphql/walletSchema.ts
import gql3 from "graphql-tag";
var walletTypeDefs;
var init_walletSchema = __esm({
  "src/wallet/graphql/walletSchema.ts"() {
    walletTypeDefs = gql3`
  enum TransactionType {
    payment
    received
    crypto
    deposit
    withdrawal
  }

  enum TransactionStatus {
    completed
    pending
    failed
    cancelled
  }

  enum PaymentMethodType {
    card
    bank
    paypal
    mobile_money
    crypto
  }

  enum CryptoCurrency {
    BTC
    ETH
    LTC
    BCH
    XRP
    ADA
    DOT
  }

  enum NotificationType {
    wallet
    property
    service
    general
    security
    reminder
  }

  enum NotificationCategory {
    transaction
    payment
    transfer
    rent
    reservation
    maintenance
    message
    alert
  }

  enum NotificationPriority {
    low
    medium
    high
    urgent
  }

  enum DeliveryStatus {
    pending
    delivered
    failed
    not_sent
  }

  type Wallet {
    id: ID!
    userId: ID!
    balance: Float!
    pendingBalance: Float!
    currency: String!
    cryptoBalances: [CryptoBalance!]!
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
    transactions(type: TransactionType, limit: Int = 50): [Transaction!]!
    paymentMethods: [PaymentMethod!]!

    # Computed fields
    totalBalance: Float!
    formattedBalance: String!
    recentTransactions(limit: Int = 10): [Transaction!]!
  }

  type CryptoBalance {
    currency: CryptoCurrency!
    amount: Float!
    value: Float!
    formattedValue: String!
  }

  type Transaction {
    id: ID!
    userId: ID!
    type: TransactionType!
    amount: Float!
    currency: String!
    description: String!
    status: TransactionStatus!
    paymentMethodId: ID
    cryptoCurrency: CryptoCurrency
    recipientId: ID
    metadata: TransactionMetadata
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
    recipient: User
    paymentMethod: PaymentMethod
    relatedProperty: Property
    relatedService: Service

    # Computed fields
    formattedAmount: String!
    isIncoming: Boolean!
    statusColor: String!
  }

  type TransactionMetadata {
    propertyId: ID
    serviceId: ID
    subscriptionId: ID
    reservationId: ID
    contractId: ID
    fees: TransactionFees
    exchangeRate: Float
    originalAmount: Float
    originalCurrency: String
    reference: String
    notes: String
  }

  type TransactionFees {
    platform: Float
    payment: Float
    conversion: Float
    total: Float
  }

  type PaymentMethod {
    id: ID!
    userId: ID!
    type: PaymentMethodType!
    name: String!
    details: PaymentMethodDetails!
    isDefault: Boolean!
    isActive: Boolean!
    createdAt: String!

    # Relations
    user: User

    # Computed fields
    displayName: String!
    maskedDetails: String!
  }

  type PaymentMethodDetails {
    last4: String
    expiry: String
    iban: String
    email: String
    phoneNumber: String
    cryptoAddress: String
    brand: String
    country: String
  }

  # Types pour les notifications
  type Notification {
    id: ID!
    userId: ID!
    type: NotificationType!
    category: NotificationCategory!
    title: String!
    message: String!
    isRead: Boolean!
    priority: NotificationPriority!
    channels: NotificationChannels!
    metadata: NotificationMetadata
    scheduledFor: String
    sentAt: NotificationSentAt
    deliveryStatus: NotificationDeliveryStatus!
    createdAt: String!
    updatedAt: String!

    # Relations
    user: User
  }

  type NotificationChannels {
    inApp: Boolean!
    push: Boolean!
    email: Boolean!
    sms: Boolean!
  }

  type NotificationSentAt {
    inApp: String
    push: String
    email: String
    sms: String
  }

  type NotificationDeliveryStatus {
    inApp: DeliveryStatus!
    push: DeliveryStatus!
    email: DeliveryStatus!
    sms: DeliveryStatus!
  }

  type NotificationMetadata {
    transactionId: ID
    propertyId: ID
    serviceId: ID
    amount: Float
    currency: String
    actionUrl: String
    imageUrl: String
    data: JSON
  }

  type NotificationPreference {
    id: ID!
    userId: ID!
    preferences: UserNotificationPreferences!
    quietHours: QuietHours!
    pushToken: String
    deviceInfo: DeviceInfo
    createdAt: String!
    updatedAt: String!
  }

  type UserNotificationPreferences {
    wallet: ChannelPreferences!
    property: ChannelPreferences!
    service: ChannelPreferences!
    general: ChannelPreferences!
    security: ChannelPreferences!
    reminder: ChannelPreferences!
  }

  type ChannelPreferences {
    inApp: Boolean!
    push: Boolean!
    email: Boolean!
    sms: Boolean!
  }

  type QuietHours {
    enabled: Boolean!
    startTime: String!
    endTime: String!
    timezone: String!
  }

  type DeviceInfo {
    platform: String!
    deviceId: String!
    appVersion: String!
  }

  # Types pour les statistiques
  type WalletStats {
    totalTransactions: Int!
    totalVolume: Float!
    averageTransaction: Float!
    transactionsByType: [TransactionTypeStat!]!
    transactionsByStatus: [TransactionStatusStat!]!
    monthlyVolume: [MonthlyVolumeStat!]!
    topPaymentMethods: [PaymentMethodStat!]!
  }

  type TransactionTypeStat {
    type: TransactionType!
    count: Int!
    volume: Float!
    percentage: Float!
  }

  type TransactionStatusStat {
    status: TransactionStatus!
    count: Int!
    percentage: Float!
  }

  type MonthlyVolumeStat {
    month: String!
    volume: Float!
    transactions: Int!
  }

  type PaymentMethodStat {
    method: String!
    count: Int!
    volume: Float!
    percentage: Float!
  }

  type NotificationsConnection {
    edges: [NotificationEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
    unreadCount: Int!
  }

  type NotificationEdge {
    node: Notification!
    cursor: String!
  }

  type TransactionConnection {
    edges: [TransactionEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
  }

  type TransactionEdge {
    node: Transaction!
    cursor: String!
  }

  # Enhanced Wallet Types
  type EnhancedWallet {
    id: ID!
    userId: ID!
    fiatCurrencies: [FiatCurrency!]!
    cryptoCurrencies: [EnhancedCryptoBalance!]!
    paymentMethods: [PaymentMethod!]!
    transactions: [Transaction!]!
    createdAt: String!
    updatedAt: String!
  }

  type FiatCurrency {
    code: String!
    name: String!
    balance: Float!
    isDefault: Boolean!
    lastUpdated: String!
  }

  type EnhancedCryptoBalance {
    symbol: String!
    name: String!
    balance: Float!
    balanceUSD: Float!
    balanceEUR: Float!
    lastUpdated: String!
  }

  # Currency & Validation Types
  type CurrencyConversion {
    fromCurrency: String!
    toCurrency: String!
    amount: Float!
    convertedAmount: Float!
    rate: Float!
    timestamp: String!
  }

  type TransactionValidation {
    isValid: Boolean!
    riskLevel: String!
    warnings: [String!]!
    recommendations: [String!]!
  }

  # Mobile Money Types
  type MobileMoneyProvider {
    id: ID!
    name: String!
    code: String!
    countryCode: String!
    supportedOperations: [String!]!
    fees: ProviderFees!
  }

  type ProviderFees {
    deposit: Float!
    withdrawal: Float!
    transfer: Float!
  }

  type PhoneValidation {
    isValid: Boolean!
    formatted: String!
    country: String!
    carrier: String
  }

  type MobileMoneyFees {
    amount: Float!
    fee: Float!
    total: Float!
    currency: String!
  }

  type Country {
    code: String!
    name: String!
    currency: String!
    supportedProviders: [String!]!
  }

  type CountryInfo {
    code: String!
    name: String!
    currency: String!
    providers: [MobileMoneyProvider!]!
    regulations: CountryRegulations
  }

  type CountryRegulations {
    maxTransactionAmount: Float!
    dailyLimit: Float!
    monthlyLimit: Float!
    requiresKYC: Boolean!
  }

  type UnifiedPaymentResponse {
    success: Boolean!
    transactionId: String!
    status: TransactionStatus!
    message: String
    error: String
  }

  # Inputs
  input UnifiedPaymentInput {
    amount: Float!
    currency: String!
    paymentMethodId: ID!
    type: TransactionType
    description: String
    recipientId: ID
    cryptoData: CryptoDataInput
  }

  input CryptoDataInput {
    network: String!
    toAddress: String!
  }

  input PurchaseCryptoUnifiedInput {
    amount: Float!
    currency: String!
    cryptoCurrency: String!
    paymentMethod: ID!
  }

  # Inputs
  input CreateTransactionInput {
    type: TransactionType!
    amount: Float!
    currency: String = "EUR"
    description: String!
    paymentMethodId: ID
    cryptoCurrency: CryptoCurrency
    recipientId: ID
    metadata: TransactionMetadataInput
  }

  input TransactionMetadataInput {
    propertyId: ID
    serviceId: ID
    subscriptionId: ID
    reservationId: ID
    contractId: ID
    reference: String
    notes: String
  }

  input TransferMoneyInput {
    recipientId: ID!
    amount: Float!
    currency: String = "EUR"
    description: String!
    paymentMethodId: ID
  }

  input CreatePaymentMethodInput {
    type: PaymentMethodType!
    name: String!
    details: PaymentMethodDetailsInput!
    isDefault: Boolean = false
  }

  input PaymentMethodDetailsInput {
    last4: String
    expiry: String
    iban: String
    email: String
    phoneNumber: String
    cryptoAddress: String
    brand: String
    country: String
  }

  input BuyCryptoInput {
    currency: CryptoCurrency!
    amount: Float!
    paymentMethodId: ID!
  }

  input SellCryptoInput {
    currency: CryptoCurrency!
    amount: Float!
    paymentMethodId: ID
  }

  input CreateNotificationInput {
    type: NotificationType!
    category: NotificationCategory!
    title: String!
    message: String!
    priority: NotificationPriority = medium
    metadata: NotificationMetadataInput
    scheduledFor: String
    forceChannels: NotificationChannelsInput
  }

  input NotificationMetadataInput {
    transactionId: ID
    propertyId: ID
    serviceId: ID
    amount: Float
    currency: String
    actionUrl: String
    imageUrl: String
    data: JSON
  }

  input NotificationChannelsInput {
    inApp: Boolean
    push: Boolean
    email: Boolean
    sms: Boolean
  }

  input UpdateNotificationPreferencesInput {
    wallet: ChannelPreferencesInput
    property: ChannelPreferencesInput
    service: ChannelPreferencesInput
    general: ChannelPreferencesInput
    security: ChannelPreferencesInput
    reminder: ChannelPreferencesInput
    quietHours: QuietHoursInput
  }

  input ChannelPreferencesInput {
    inApp: Boolean
    push: Boolean
    email: Boolean
    sms: Boolean
  }

  input QuietHoursInput {
    enabled: Boolean
    startTime: String
    endTime: String
    timezone: String
  }

  input RegisterPushTokenInput {
    token: String!
    platform: String!
    deviceId: String!
    appVersion: String!
  }

  input NotificationFilters {
    type: NotificationType
    category: NotificationCategory
    isRead: Boolean
    priority: NotificationPriority
    dateFrom: String
    dateTo: String
  }

  input TransactionFilters {
    type: TransactionType
    status: TransactionStatus
    minAmount: Float
    maxAmount: Float
    currency: String
    dateFrom: String
    dateTo: String
    paymentMethodId: ID
  }

  extend type Query {
    # Wallet queries
    wallet: Wallet!
    enhancedWallet: EnhancedWallet
    transaction(id: ID!): Transaction
    transactions(filters: TransactionFilters, pagination: PaginationInput): TransactionConnection!
    paymentMethods: [PaymentMethod!]!
    walletStats(dateFrom: String, dateTo: String): WalletStats!

    # Notification queries
    notifications(filters: NotificationFilters, pagination: PaginationInput): NotificationsConnection!
    notificationPreferences: NotificationPreference!
    unreadNotificationsCount: Int!

    # Crypto queries
    cryptoPrices(currencies: [CryptoCurrency!]): [CryptoPrice!]!
    cryptoPortfolio: [CryptoBalance!]!
    cryptoConfig: CryptoConfig!

    # Currency & validation
    convertCurrency(fromCurrency: String!, toCurrency: String!, amount: Float!): CurrencyConversion
    validateTransaction(amount: Float!, currency: String!, paymentMethod: String!): TransactionValidation

    # Mobile Money queries
    getMobileMoneyProviders(countryCode: String): [MobileMoneyProvider!]!
    validatePhoneNumber(phoneNumber: String!, countryCode: String!): PhoneValidation
    calculateMobileMoneyFees(providerId: String!, amount: Float!, type: String!): MobileMoneyFees
    getSupportedCountries: [Country!]!
    getCountryInfo(countryCode: String!): CountryInfo
  }

  extend type Mutation {
    # Wallet mutations
    createTransaction(input: CreateTransactionInput!): Transaction!
    transferMoney(input: TransferMoneyInput!): Transaction!

    # Payment methods
    addPaymentMethod(input: CreatePaymentMethodInput!): PaymentMethod!
    updatePaymentMethod(id: ID!, input: CreatePaymentMethodInput!): PaymentMethod!
    deletePaymentMethod(id: ID!): Boolean!
    setDefaultPaymentMethod(id: ID!): PaymentMethod!

    # Crypto operations
    buyCrypto(input: BuyCryptoInput!): Transaction!
    sellCrypto(input: SellCryptoInput!): Transaction!

    # Unified payment operations
    processUnifiedPayment(request: UnifiedPaymentInput!): UnifiedPaymentResponse!
    purchaseCryptoUnified(input: PurchaseCryptoUnifiedInput!): UnifiedPaymentResponse!

    # Notification mutations
    createNotification(input: CreateNotificationInput!): Notification!
    markNotificationAsRead(id: ID!): Notification!
    markAllNotificationsAsRead: Int!
    deleteNotification(id: ID!): Boolean!
    updateNotificationPreferences(input: UpdateNotificationPreferencesInput!): NotificationPreference!
    registerPushToken(input: RegisterPushTokenInput!): Boolean!

    # Test mutations
    testPushNotification: Boolean!
  }

  extend type Subscription {
    # Wallet subscriptions
    walletUpdated: Wallet!
    transactionCreated: Transaction!
    transactionStatusChanged(transactionId: ID!): Transaction!

    # Notification subscriptions
    notificationReceived: Notification!
    notificationStatusChanged: Notification!

    # Real-time balance updates
    balanceUpdated: Wallet!
  }

  type CryptoPrice {
    currency: CryptoCurrency!
    priceEUR: Float!
    priceUSD: Float!
    change24h: Float!
    lastUpdated: String!
  }

  type CryptoConfig {
    enabled: Boolean!
    supportedCurrencies: [String!]!
    minimumBuyAmount: Float!
    maximumBuyAmount: Float!
    transactionFeePercentage: Float!
  }

  scalar JSON
`;
  }
});

// src/chat/graphql/chatSchema.ts
import gql4 from "graphql-tag";
var chatTypeDefs;
var init_chatSchema = __esm({
  "src/chat/graphql/chatSchema.ts"() {
    chatTypeDefs = gql4`
  # ==================== TYPES ====================

  type User {
    id: ID!
    firstName: String!
    lastName: String!
    profilePicture: String
    email: String!
    presenceStatus: PresenceStatus
    lastActive: String
    isOnline: Boolean
  }

  type Property {
    id: ID!
    title: String!
    address: String
    images: [String!]
    price: Float
    location: Location
  }

  type Location {
    type: String!
    coordinates: [Float!]!
    address: String
  }

  type Conversation {
    id: ID!
    participants: [User!]!
    type: ConversationType!
    propertyId: Property
    lastMessage: Message
    unreadCount(userId: ID!): Int
    messages(limit: Int = 50, offset: Int = 0, filters: MessageFilters): [Message!]
    createdAt: String!
    updatedAt: String!
    property: Property
    stats: ConversationStats
    onlineParticipants: [User!]
    isArchivedFor(userId: ID!): Boolean
    settings: ConversationSettings
  }

  type ConversationSettings {
    encryption: Boolean
    disappearingMessages: DisappearingMessagesSettings
    smartReply: Boolean
    translation: Boolean
    voiceTranscription: Boolean
    readReceipts: Boolean
    typingIndicators: Boolean
  }

  type DisappearingMessagesSettings {
    enabled: Boolean
    duration: Int
  }

  type ConversationStats {
    conversationId: ID!
    participantsCount: Int!
    messageCount: Int!
    totalReactions: Int!
    lastActivity: String!
  }

  type Message {
    id: ID!
    conversationId: ID!
    sender: User!
    content: String
    messageType: MessageType!
    mediaData: MediaData
    mentions: [User!]
    replyTo: Message
    reactions: [Reaction!]
    aiInsights: AIInsight
    status: MessageStatus!
    createdAt: String!
    updatedAt: String!
    isEdited: Boolean
    editHistory: [MessageEdit!]
    readStatus(userId: ID!): String
    sentimentAnalysis: SentimentAnalysis
    property: Property
    isDeleted: Boolean
    deletedAt: String
    deletedBy: ID
  }

  type MediaData {
    filename: String!
    originalName: String!
    size: Int!
    mimetype: String!
    uploadedAt: String!
    dimensions: MediaDimensions
    variants: [MediaVariant!]
  }

  type MediaDimensions {
    width: Int!
    height: Int!
  }

  type MediaVariant {
    size: String!
    path: String!
  }

  type MessageStatus {
    sent: String
    delivered: [DeliveryStatus!]
    read: [ReadStatus!]
  }

  type DeliveryStatus {
    userId: ID!
    deliveredAt: String!
  }

  type ReadStatus {
    userId: ID!
    readAt: String!
  }

  type Reaction {
    userId: ID!
    emoji: String!
    timestamp: String!
  }

  type AIInsight {
    sentiment: SentimentAnalysis
    intentDetection: String
    autoSuggestions: [String!]
    priority: MessagePriority!
    confidence: Float!
    language: String!
    topics: [String!]
    entities: [String!]
  }

  type SentimentAnalysis {
    score: Float!
    label: SentimentLabel!
  }

  type MessageEdit {
    content: String!
    editedAt: String!
    reason: String
  }

  # ==================== INPUTS ====================

  input ConversationInput {
    participantId: ID
    type: ConversationType = DIRECT
    propertyId: ID
  }

  input SendMessageInput {
    conversationId: ID!
    content: String!
    messageType: MessageType = TEXT
    replyToId: ID
    mentions: [ID!] = []
    scheduleFor: String
    priority: MessagePriority = NORMAL
  }

  input MessageFilters {
    messageType: MessageType
    senderId: ID
    dateRange: DateRangeInput
  }

  input DateRangeInput {
    start: String
    end: String
  }

  input ReactionInput {
    messageId: ID!
    conversationId: ID!
    reactionType: String!
  }

  input DeleteMessageInput {
    messageId: ID!
    conversationId: ID!
    deleteType: DeleteType = SOFT
    deleteFor: DeleteScope = ME
  }

  input PaginationInput {
    first: Int
    after: String
  }

  input ConversationSearchFilters {
    type: ConversationType
  }

  # ==================== ENUMS ====================

  enum ConversationType {
    DIRECT
    GROUP
    PROPERTY_DISCUSSION
  }

  enum MessageType {
    TEXT
    IMAGE
    VIDEO
    AUDIO
    DOCUMENT
    LOCATION
    CONTACT
    PROPERTY
    VOICE_NOTE
    AR_PREVIEW
    VIRTUAL_TOUR
  }

  enum MessagePriority {
    LOW
    NORMAL
    HIGH
    URGENT
  }

  enum SentimentLabel {
    POSITIVE
    NEGATIVE
    NEUTRAL
  }

  enum PresenceStatus {
    ONLINE
    OFFLINE
    AWAY
    BUSY
  }

  enum DeleteType {
    SOFT
    HARD
  }

  enum DeleteScope {
    ME
    EVERYONE
  }

  # ==================== CONNECTION TYPES ====================

  type ConversationConnection {
    edges: [ConversationEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
  }

  type ConversationEdge {
    node: Conversation!
    cursor: String!
  }

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  # ==================== QUERIES ====================

  type Query {
    # Récupérer une conversation spécifique
    conversation(id: ID!): Conversation

    # Lister toutes les conversations de l'utilisateur
    conversations(pagination: PaginationInput): ConversationConnection!

    # Rechercher dans les conversations
    searchConversations(
      query: String!
      filters: ConversationSearchFilters
    ): [Conversation!]!

    # Statistiques d'une conversation
    conversationAnalytics(conversationId: ID!): ConversationStats

    # Rechercher dans les messages
    searchMessages(
      query: String!
      conversationId: ID
      messageType: MessageType
      dateRange: DateRangeInput
      limit: Int = 20
    ): [Message!]!

    # Obtenir les messages d'une conversation
    getMessages(
      conversationId: ID!
      limit: Int = 50
      offset: Int = 0
      filters: MessageFilters
    ): [Message!]!
  }

  # ==================== MUTATIONS ====================

  type Mutation {
    # Envoyer un message
    sendMessage(input: SendMessageInput!): Message!

    # Créer ou récupérer une conversation
    createOrGetConversation(input: ConversationInput!): Conversation!

    # Réagir à un message
    reactToMessage(input: ReactionInput!): Message!

    # Marquer les messages comme lus
    markMessagesAsRead(conversationId: ID!, messageIds: [ID!]): Boolean!

    # Supprimer un message
    deleteMessage(input: DeleteMessageInput!): Boolean!

    # Restaurer un message supprimé
    restoreMessage(messageId: ID!): Boolean!

    # Archiver une conversation
    archiveConversation(conversationId: ID!): Conversation!

    # Désarchiver une conversation
    unarchiveConversation(conversationId: ID!): Conversation!

    # Mettre à jour le statut de frappe
    updateTypingStatus(conversationId: ID!, isTyping: Boolean!): Boolean!

    # Épingler/Désépingler un message
    togglePinMessage(messageId: ID!): Boolean!

    # Éditer un message
    editMessage(messageId: ID!, newContent: String!, reason: String): Message!

    # Transférer un message
    forwardMessage(messageId: ID!, targetConversationIds: [ID!]!): Boolean!
  }

  # ==================== SUBSCRIPTIONS ====================

  type Subscription {
    # Nouveau message dans une conversation
    messageAdded(conversationId: ID!): Message!

    # Réaction ajoutée à un message
    messageReaction(conversationId: ID!): MessageReactionEvent!

    # Message supprimé
    messageDeleted(conversationId: ID!): MessageDeletedEvent!

    # Message restauré
    messageRestored(conversationId: ID!): MessageRestoredEvent!

    # Conversation mise à jour
    conversationUpdated(userId: ID!): Conversation!

    # Statut de frappe
    typingStatus(conversationId: ID!): TypingStatusEvent!

    # Utilisateur en ligne/hors ligne
    presenceStatus(userId: ID!): PresenceStatusEvent!

    # Messages marqués comme lus
    messagesMarkedAsRead(conversationId: ID!): MessagesReadEvent!
  }

  # ==================== SUBSCRIPTION EVENT TYPES ====================

  type MessageReactionEvent {
    messageId: ID!
    userId: ID!
    reactionType: String!
    reactions: [Reaction!]!
    timestamp: String!
  }

  type MessageDeletedEvent {
    messageId: ID!
    deleteFor: DeleteScope!
    deletedBy: ID!
    timestamp: String!
  }

  type MessageRestoredEvent {
    messageId: ID!
    restoredBy: ID!
    timestamp: String!
  }

  type TypingStatusEvent {
    userId: ID!
    isTyping: Boolean!
    typingUsers: [ID!]!
    timestamp: String!
  }

  type PresenceStatusEvent {
    userId: ID!
    status: PresenceStatus!
    lastSeen: String
    timestamp: String!
  }

  type MessagesReadEvent {
    userId: ID!
    messageIds: [ID!]!
    timestamp: String!
  }
`;
  }
});

// src/activity/graphql/activitySchema.ts
import gql5 from "graphql-tag";
var activityTypeDefs;
var init_activitySchema = __esm({
  "src/activity/graphql/activitySchema.ts"() {
    activityTypeDefs = gql5`
  type Activity {
    id: ID!
    propertyId: ID!
    property: Property
    clientId: ID!
    client: User
    message: String!
    isVisited: Boolean
    visitDate: String
    isVisiteAcccepted: Boolean
    isReservation: Boolean
    reservationDate: String
    isReservationAccepted: Boolean
    isPayment: Boolean
    paymentDate: String
    uploadedFiles: [String!]
    conversation: Conversation
    messages: [Message!]
    relatedTransactions: [Transaction!]
    status: ActivityStatus!
    type: ActivityType!
    duration: Int
    nextStep: String
    priorityScore: Int
    isCancelled: Boolean
    cancelReason: String
    cancelDate: String
    createdAt: String!
    updatedAt: String!
  }

  enum ActivityStatus {
    DRAFT
    PENDING
    ACCEPTED
    COMPLETED
    CANCELLED
  }

  enum ActivityType {
    INQUIRY
    VISIT
    RESERVATION
  }

  type ActivityEdge {
    node: Activity!
    cursor: String!
  }

  type ActivityConnection {
    edges: [ActivityEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
  }

  type ActivityStats {
    totalActivities: Int!
    visitRequests: Int!
    reservationRequests: Int!
    acceptedVisits: Int!
    acceptedReservations: Int!
    completedPayments: Int!
    acceptanceRate: Float!
    conversionRate: Float!
    averageResponseTime: Float!
  }

  input ActivityFilters {
    status: ActivityStatus
    type: ActivityType
    dateRange: DateRangeInput
  }

  input DateRangeInput {
    start: String
    end: String
  }

  input PaginationInput {
    first: Int
    after: String
    page: Int
    limit: Int
  }

  input TimeRangeInput {
    start: String
    end: String
  }

  input CreateActivityInput {
    propertyId: ID!
    message: String!
    isVisited: Boolean
    visitDate: String
    isReservation: Boolean
    reservationDate: String
    uploadedFiles: [String!]
  }

  extend type Query {
    activities(
      propertyId: ID
      userId: ID
      pagination: PaginationInput
      filters: ActivityFilters
    ): ActivityConnection!
    
    activity(id: ID!): Activity
    
    activityStats(
      propertyId: ID
      userId: ID
      timeRange: TimeRangeInput
    ): ActivityStats!
    
    ownerActivities(
      pagination: PaginationInput
      filters: ActivityFilters
    ): ActivityConnection!
  }

  extend type Mutation {
    createActivity(input: CreateActivityInput!): Activity!
    updateActivityStatus(id: ID!, status: ActivityStatus!, reason: String): Activity!
    processPayment(activityId: ID!, amount: Float!): Activity!
    cancelActivity(id: ID!, reason: String): Activity!
  }

  extend type Subscription {
    activityUpdated(propertyId: ID, userId: ID): Activity!
  }
`;
  }
});

// src/users/graphql/userSchema.ts
import gql6 from "graphql-tag";
var userTypeDefs;
var init_userSchema = __esm({
  "src/users/graphql/userSchema.ts"() {
    userTypeDefs = gql6`
  extend type User {
    username: String
    phoneNumber: String
    dateOfBirth: String
    address: Address
    agentDetails: AgentDetails
    preferences: UserPreferences
    loginHistory: [LoginHistory!]
    securityDetails: SecurityDetails
    notifications: [Notification!]
    properties: [Property!]
    activities: [Activity!]
    conversations: [Conversation!]
    wallet: Wallet
  }

  type Address {
    street: String
    city: String
    state: String
    postalCode: String
    country: String
  }

  type AgentDetails {
    agencyName: String
    licenseNumber: String
    yearsOfExperience: Int
    specializations: [String!]
  }

  type UserPreferences {
    language: String
    currency: String
    notifications: NotificationPreferences
  }

  type NotificationPreferences {
    email: Boolean
    sms: Boolean
    push: Boolean
  }

  type LoginHistory {
    timestamp: String!
    ipAddress: String
    userAgent: String
    location: String
  }

  type SecurityDetails {
    twoFactorEnabled: Boolean
    lastPasswordChange: String
    securityQuestions: [String!]
  }

  extend type Query {
    me: User
    user(id: ID!): User
    users(limit: Int, offset: Int): [User!]!
  }

  extend type Mutation {
    updateProfile(input: UpdateProfileInput!): User!
    updatePreferences(input: UpdatePreferencesInput!): User!
  }

  input UpdateProfileInput {
    firstName: String
    lastName: String
    phoneNumber: String
    dateOfBirth: String
    address: AddressInput
  }

  input AddressInput {
    street: String
    city: String
    state: String
    postalCode: String
    country: String
  }

  input UpdatePreferencesInput {
    language: String
    currency: String
    notifications: NotificationPreferencesInput
  }

  input NotificationPreferencesInput {
    email: Boolean
    sms: Boolean
    push: Boolean
  }
`;
  }
});

// src/crypto/graphql/cryptoSchema.ts
import gql7 from "graphql-tag";
var cryptoTypeDefs;
var init_cryptoSchema = __esm({
  "src/crypto/graphql/cryptoSchema.ts"() {
    cryptoTypeDefs = gql7`
  # ========== CRYPTO PAYMENTS ==========

  type CryptoPayment {
    id: ID!
    paymentId: String!
    userId: String!
    propertyId: String!
    paymentType: PaymentType!
    cryptocurrency: Cryptocurrency!
    network: BlockchainNetwork!
    amount: Float!
    amountFiat: Float!
    fiatCurrency: String!
    exchangeRate: Float!
    transactionHash: String!
    fromAddress: String!
    toAddress: String!
    blockHeight: Int
    confirmations: Int!
    gasUsed: Float
    gasPrice: Float
    status: PaymentStatus!
    confirmationsRequired: Int!
    smartContractAddress: String
    smartContractFunction: String
    contractInteractionData: JSON
    escrow: EscrowInfo
    recurring: RecurringInfo
    metadata: PaymentMetadata!
    createdAt: String!
    updatedAt: String!
  }

  type EscrowInfo {
    isEscrow: Boolean!
    escrowAddress: String
    releaseConditions: [String!]
    releaseDate: String
    isReleased: Boolean!
    releasedAt: String
    releasedTo: String
  }

  type RecurringInfo {
    isRecurring: Boolean!
    frequency: RecurringFrequency
    nextPaymentDate: String
    endDate: String
    totalPayments: Int
    completedPayments: Int!
  }

  type PaymentMetadata {
    propertyAddress: String!
    landlordId: String!
    leaseId: String
    paymentDescription: String!
    invoiceNumber: String
  }

  # ========== PROPERTY TOKENS ==========

  type PropertyToken {
    id: ID!
    tokenId: String!
    propertyId: String!
    propertyDetails: PropertyDetails!
    tokenomics: PropertyTokenomics!
    blockchain: BlockchainDetails!
    ownership: OwnershipInfo!
    revenueSharing: RevenueSharing!
    trading: TradingInfo!
    governance: GovernanceInfo!
    compliance: ComplianceInfo!
    legal: LegalInfo!
    status: TokenStatus!
    valueMetrics: ValueMetrics!
    createdAt: String!
    updatedAt: String!
  }

  type PropertyDetails {
    address: String!
    propertyType: PropertyType!
    totalValue: Float!
    currency: String!
    lastValuation: String!
  }

  type PropertyTokenomics {
    tokenSymbol: String!
    tokenName: String!
    totalSupply: Float!
    circulatingSupply: Float!
    tokenPrice: Float!
    priceHistory: [PriceHistoryPoint!]!
    minimumInvestment: Float!
  }

  type PriceHistoryPoint {
    date: String!
    price: Float!
    volume: Float!
    marketCap: Float!
  }

  type BlockchainDetails {
    network: BlockchainNetwork!
    contractAddress: String
    tokenStandard: TokenStandard!
    deploymentCost: Float!
    gasOptimization: Boolean!
  }

  type OwnershipInfo {
    totalOwners: Int!
    ownershipDistribution: [OwnershipDistribution!]!
  }

  type OwnershipDistribution {
    ownerId: String!
    tokensOwned: Float!
    ownershipPercentage: Float!
    acquisitionDate: String!
    averagePurchasePrice: Float!
    investmentAmount: Float!
    kycStatus: KYCStatus!
    accreditedInvestor: Boolean!
  }

  type RevenueSharing {
    enabled: Boolean!
    distributionFrequency: DistributionFrequency!
    nextDistribution: String!
    totalRevenueDistributed: Float!
    distributionHistory: [RevenueDistribution!]!
    reservePercentage: Float!
    managementFee: Float!
    expectedAnnualReturn: Float!
  }

  type RevenueDistribution {
    period: String!
    totalRevenue: Float!
    distributableAmount: Float!
    managementFee: Float!
    reserveAmount: Float!
    distributionDate: String!
    distributions: [IndividualDistribution!]!
  }

  type IndividualDistribution {
    ownerId: String!
    amount: Float!
    tokensOwned: Float!
    ownershipPercentage: Float!
    distributionDate: String!
    period: String!
    transactionHash: String!
  }

  type TradingInfo {
    isTradeEnabled: Boolean!
    dexListings: [DexListing!]!
    tradingVolume24h: Float!
    totalTradingVolume: Float!
    priceDiscovery: PriceDiscoveryMethod!
    liquidityPool: LiquidityPoolInfo!
    orderBook: OrderBook!
  }

  type DexListing {
    exchange: String!
    pair: String!
    liquidity: Float!
    volume24h: Float!
    apr: Float!
  }

  type LiquidityPoolInfo {
    totalLiquidity: Float!
    providers: [LiquidityProvider!]!
    rewardRate: Float!
  }

  type LiquidityProvider {
    providerId: String!
    liquidityProvided: Float!
    rewardsEarned: Float!
    joinDate: String!
  }

  type OrderBook {
    buyOrders: [TradingOrder!]!
    sellOrders: [TradingOrder!]!
    lastTrade: LastTrade
  }

  type TradingOrder {
    orderId: String!
    listingId: String
    sellerId: String
    buyerId: String
    tokensAmount: Float!
    pricePerToken: Float!
    totalValue: Float!
    orderType: OrderType!
    status: OrderStatus!
    createdAt: String!
    expiresAt: String
    minimumBid: Float
    reservePrice: Float
    bids: [Bid!]!
    views: Int!
    favorites: Int!
  }

  type Bid {
    bidId: String!
    bidderId: String!
    amount: Float!
    currency: String!
    walletAddress: String!
    timestamp: String!
    status: BidStatus!
    escrowTxHash: String!
  }

  type LastTrade {
    price: Float!
    quantity: Float!
    timestamp: String!
    buyer: String!
    seller: String!
  }

  type GovernanceInfo {
    enabled: Boolean!
    votingRights: VotingRights!
    quorum: Float!
    proposals: [Proposal!]!
    votingHistory: [Vote!]!
  }

  type Proposal {
    proposalId: String!
    title: String!
    description: String!
    proposalType: ProposalType!
    proposer: String!
    createdAt: String!
    votingStart: String!
    votingEnd: String!
    status: ProposalStatus!
    votes: VoteTally!
    voters: [Voter!]!
    quorumReached: Boolean!
    executed: Boolean!
  }

  type VoteTally {
    for: Float!
    against: Float!
    abstain: Float!
  }

  type Voter {
    userId: String!
    vote: VoteChoice!
    votingPower: Float!
    timestamp: String!
  }

  type Vote {
    proposalId: String!
    vote: VoteChoice!
    votingPower: Float!
    timestamp: String!
  }

  type ComplianceInfo {
    isCompliant: Boolean!
    jurisdiction: String!
    regulations: [String!]!
    auditTrail: [AuditEntry!]!
    kycRequirement: Boolean!
    accreditedInvestorOnly: Boolean!
  }

  type AuditEntry {
    action: String!
    performedBy: String!
    timestamp: String!
    details: String!
  }

  type LegalInfo {
    propertyDeed: String!
    operatingAgreement: String!
    prospectus: String!
    legalDocuments: [LegalDocument!]!
    custodian: String!
    propertyManager: String!
  }

  type LegalDocument {
    type: String!
    url: String!
    hash: String!
  }

  type ValueMetrics {
    currentValuation: Float!
    occupancyRate: Float!
    netOperatingIncome: Float!
    capRate: Float!
    appreciationRate: Float!
    totalReturn: Float!
    cashFlow: CashFlow!
  }

  type CashFlow {
    monthly: Float!
    quarterly: Float!
    annual: Float!
  }

  # ========== UTILITY TOKENS ==========

  type UtilityToken {
    id: ID!
    tokenId: String!
    name: String!
    symbol: String!
    contractAddress: String
    blockchain: BlockchainNetwork!
    decimals: Int!
    totalSupply: Float!
    circulatingSupply: Float!
    tokenomics: UtilityTokenomics!
    utilities: TokenUtilities!
    userBalances: [UserBalance!]!
    transactions: [TokenTransaction!]!
    platform: PlatformIntegration!
    economics: TokenEconomics!
    liquidity: LiquidityInfo!
    status: TokenStatus!
    launchDate: String!
    createdAt: String!
    updatedAt: String!
  }

  type UtilityTokenomics {
    initialPrice: Float!
    currentPrice: Float!
    priceHistory: [PriceHistoryPoint!]!
    distribution: TokenDistribution!
    vestingSchedules: [VestingSchedule!]!
  }

  type TokenDistribution {
    ecosystem: Float!
    team: Float!
    investors: Float!
    platform: Float!
    users: Float!
  }

  type VestingSchedule {
    category: VestingCategory!
    totalTokens: Float!
    releasedTokens: Float!
    vestingPeriod: Int!
    cliffPeriod: Int!
    nextRelease: String!
    releaseAmount: Float!
  }

  type TokenUtilities {
    feeDiscounts: FeeDiscounts!
    priorityAccess: PriorityAccess!
    staking: StakingUtility!
    governance: GovernanceUtility!
    cashback: CashbackUtility!
  }

  type FeeDiscounts {
    enabled: Boolean!
    tiers: [DiscountTier!]!
  }

  type DiscountTier {
    minTokens: Float!
    discountPercentage: Float!
    description: String!
  }

  type PriorityAccess {
    enabled: Boolean!
    minTokensRequired: Float!
    benefits: [String!]!
  }

  type StakingUtility {
    enabled: Boolean!
    apy: Float!
    minStakeAmount: Float!
    lockupPeriods: [LockupPeriod!]!
  }

  type LockupPeriod {
    duration: Int!
    multiplier: Float!
  }

  type GovernanceUtility {
    enabled: Boolean!
    minTokensForProposal: Float!
    votingPower: VotingPowerType!
    proposalDuration: Int!
    proposals: [Proposal!]
  }

  type CashbackUtility {
    enabled: Boolean!
    rate: Float!
    maxCashbackPerTransaction: Float!
    applicableServices: [String!]!
  }

  type UserBalance {
    userId: String!
    balance: Float!
    stakedBalance: Float!
    lockedBalance: Float!
    lastUpdate: String!
    stakingInfo: [StakingPosition!]!
  }

  type StakingPosition {
    amount: Float!
    startDate: String!
    lockupPeriod: Int!
    rewardsAccrued: Float!
    rewardsClaimed: Float!
    lastClaimDate: String!
  }

  type TokenTransaction {
    transactionId: String!
    type: TransactionType!
    from: String!
    to: String!
    amount: Float!
    fee: Float
    reason: String!
    metadata: JSON
    transactionHash: String!
    blockNumber: Int!
    timestamp: String!
  }

  type PlatformIntegration {
    acceptedServices: [AcceptedService!]!
    usage: UsageMetrics!
  }

  type AcceptedService {
    serviceType: ServiceType!
    discountRate: Float!
    acceptanceRate: Float!
  }

  type UsageMetrics {
    totalTransactions: Int!
    totalVolume: Float!
    activeUsers: Int!
    averageHoldingTime: Float!
    utilityUsage: UtilityUsage!
  }

  type UtilityUsage {
    staking: Float!
    feePayments: Float!
    governance: Float!
    cashback: Float!
  }

  type TokenEconomics {
    burnMechanisms: BurnMechanisms!
    revenueStreams: RevenueStreams!
    buyback: BuybackProgram!
  }

  type BurnMechanisms {
    transactionBurn: TransactionBurn!
    periodicBurn: PeriodicBurn!
  }

  type TransactionBurn {
    enabled: Boolean!
    burnRate: Float!
  }

  type PeriodicBurn {
    enabled: Boolean!
    frequency: BurnFrequency!
    burnAmount: Float!
    nextBurn: String!
  }

  type RevenueStreams {
    platformFees: Float!
    premiumSubscriptions: Float!
    transactionFees: Float!
    stakingFees: Float!
  }

  type BuybackProgram {
    enabled: Boolean!
    frequency: BuybackFrequency!
    percentage: Float!
    lastBuyback: String!
    nextBuyback: String!
    totalBoughtBack: Float!
  }

  type LiquidityInfo {
    dexListings: [DexListing!]!
    liquidityMining: LiquidityMining!
  }

  type LiquidityMining {
    enabled: Boolean!
    pools: [LiquidityMiningPool!]!
  }

  type LiquidityMiningPool {
    pair: String!
    rewardRate: Float!
    totalLiquidity: Float!
    participants: Int!
  }

  # ========== SMART CONTRACTS ==========

  type SmartContract {
    id: ID!
    contractId: String!
    contractType: ContractType!
    propertyId: String!
    blockchain: BlockchainNetwork!
    contractAddress: String
    abi: [JSON!]!
    bytecode: String
    parties: [ContractParty!]!
    terms: ContractTerms!
    paymentSchedule: PaymentSchedule
    functions: [ContractFunction!]!
    executionHistory: [ExecutionRecord!]!
    milestones: [Milestone!]!
    oracles: OracleIntegration
    security: SecurityInfo!
    status: ContractStatus!
    deployedAt: String
    terminatedAt: String
    createdAt: String!
    updatedAt: String!
  }

  type ContractParty {
    role: PartyRole!
    userId: String!
    walletAddress: String!
    signature: String
    signedAt: String
  }

  type ContractTerms {
    monthlyRent: Float
    currency: String!
    leaseDuration: Int
    securityDeposit: Float
    salePrice: Float
    escrowAmount: Float
    releaseConditions: [String!]!
    startDate: String!
    endDate: String
    automaticRenewal: Boolean
    penaltyClause: [PenaltyClause!]!
  }

  type PenaltyClause {
    description: String!
    amount: Float!
    currency: String!
  }

  type PaymentSchedule {
    frequency: PaymentFrequency!
    amount: Float!
    currency: String!
    nextPaymentDate: String!
    totalPayments: Int!
    completedPayments: Int!
    autoExecute: Boolean!
  }

  type ContractFunction {
    name: String!
    description: String!
    parameters: [FunctionParameter!]!
    access: FunctionAccess!
  }

  type FunctionParameter {
    name: String!
    type: String!
    description: String!
  }

  type ExecutionRecord {
    functionName: String!
    executedBy: String!
    executedAt: String!
    transactionHash: String!
    gasUsed: Int!
    success: Boolean!
    parameters: JSON
    result: JSON
    error: String
  }

  type Milestone {
    id: String!
    description: String!
    condition: String!
    status: MilestoneStatus!
    completedAt: String
    evidence: [Evidence!]!
  }

  type Evidence {
    type: EvidenceType!
    data: String!
    uploadedBy: String!
    uploadedAt: String!
  }

  type OracleIntegration {
    priceOracle: PriceOracle
    propertyOracle: PropertyOracle
  }

  type PriceOracle {
    provider: String!
    endpoint: String!
    frequency: Int!
    lastUpdate: String!
    currentPrice: Float!
  }

  type PropertyOracle {
    provider: String!
    endpoint: String!
    lastValuation: String!
    currentValuation: Float!
  }

  type SecurityInfo {
    isAudited: Boolean!
    auditReport: String
    vulnerabilities: [Vulnerability!]!
    pausedFunctions: [String!]!
  }

  type Vulnerability {
    severity: VulnerabilitySeverity!
    description: String!
    status: VulnerabilityStatus!
    reportedAt: String!
  }

  # ========== DEFI ==========

  # Dynamic Pricing
  type DynamicPricing {
    id: ID!
    propertyId: String!
    baseRent: Float!
    currentYieldRate: Float!
    adjustedRent: Float!
    pricingTier: PricingTier!
    discountPercentage: Float!
    lastUpdate: String!
    smoothingFactor: Float!
    historicalYields: [YieldHistory!]!
    isActive: Boolean!
  }

  type YieldHistory {
    date: String!
    yieldRate: Float!
    discountApplied: Float!
  }

  # Multi-Asset Staking
  type MultiAssetStaking {
    id: ID!
    propertyId: String!
    ownerId: String!
    totalStakedAmount: Float!
    assets: [StakingAsset!]!
    rebalanceThreshold: Float!
    autoRebalanceEnabled: Boolean!
    insuranceProvider: String!
    insuranceCoverage: Float!
    totalYield: Float!
    monthlyYield: Float!
    riskScore: Float!
    lastRebalanceDate: String!
    performanceHistory: [PerformanceHistory!]!
    diversificationScore: Float!
    isActive: Boolean!
  }

  type StakingAsset {
    assetType: AssetType!
    protocol: String!
    amount: Float!
    expectedYield: Float!
    currentYield: Float!
    riskLevel: RiskLevel!
    insuranceCovered: Boolean!
    lastRebalance: String!
  }

  type PerformanceHistory {
    date: String!
    totalYield: Float!
    assetPerformance: [AssetPerformance!]!
  }

  type AssetPerformance {
    assetType: String!
    yield: Float!
    allocation: Float!
  }

  # Fractional Ownership
  type FractionalOwnership {
    id: ID!
    propertyId: String!
    totalShares: Int!
    sharePrice: Float!
    availableShares: Int!
    totalValue: Float!
    shareholders: [Shareholder!]!
    daoGovernance: DAOGovernance!
    revenueSharing: PropertyRevenueSharing!
    transitionPath: TransitionPath!
    liquidityPool: PropertyLiquidityPool!
    totalShareholderValue: Float!
    isActive: Boolean!
  }

  type Shareholder {
    userId: String!
    shares: [FractionalShare!]!
    totalOwnership: Float!
    isActive: Boolean!
    joinDate: String!
  }

  type FractionalShare {
    tokenId: String!
    sharePercentage: Float!
    purchasePrice: Float!
    currentValue: Float!
    purchaseDate: String!
    isTransferrable: Boolean!
    votingRights: Boolean!
  }

  type DAOGovernance {
    isEnabled: Boolean!
    votingThreshold: Float!
    proposalCount: Int!
    activeProposals: [DAOProposal!]!
  }

  type DAOProposal {
    proposalId: String!
    title: String!
    description: String!
    votes: [DAOVote!]!
    status: ProposalStatus!
    createdAt: String!
    expiresAt: String!
  }

  type DAOVote {
    userId: String!
    vote: VoteChoice!
    votingPower: Float!
  }

  type PropertyRevenueSharing {
    enabled: Boolean!
    distributionSchedule: DistributionSchedule!
    lastDistribution: String
    totalDistributed: Float!
    distributions: [PropertyRevenueDistribution!]!
  }

  type PropertyRevenueDistribution {
    month: Int!
    year: Int!
    totalRevenue: Float!
    distributionPerShare: Float!
    distributed: Boolean!
    distributionDate: String
  }

  type TransitionPath {
    enabled: Boolean!
    tenantUserId: String
    accumulatedShares: Float!
    monthlyAccumulation: Float!
    targetOwnership: Float!
  }

  type PropertyLiquidityPool {
    available: Boolean!
    poolSize: Float!
    tradingEnabled: Boolean!
    lastTradePrice: Float!
    priceHistory: [PropertyPriceHistory!]!
  }

  type PropertyPriceHistory {
    date: String!
    price: Float!
    volume: Float!
  }

  # Loyalty Mining
  type LoyaltyMining {
    id: ID!
    userId: String!
    propertyId: String
    totalPoints: Int!
    currentTier: LoyaltyTier!
    tierMultiplier: Float!
    contractStartDate: String!
    contractDuration: Int!
    loyaltyActions: [LoyaltyAction!]!
    referrals: [ReferralBonus!]!
    referralCode: String!
    tokens: LoyaltyTokens!
    achievements: [Achievement!]!
    monthlyBonus: MonthlyBonus!
    loyaltyScore: Float!
    isActive: Boolean!
  }

  type LoyaltyAction {
    actionType: ActionType!
    points: Int!
    multiplier: Float!
    date: String!
    verified: Boolean!
    referenceId: String
  }

  type ReferralBonus {
    referredUserId: String!
    referralCode: String!
    bonusAmount: Float!
    conversionDate: String!
    isActive: Boolean!
  }

  type LoyaltyTokens {
    total: Float!
    available: Float!
    locked: Float!
    vestingSchedule: [VestingEntry!]!
  }

  type VestingEntry {
    amount: Float!
    releaseDate: String!
    released: Boolean!
  }

  type Achievement {
    achievementId: String!
    name: String!
    description: String!
    pointsReward: Int!
    unlockedDate: String!
  }

  type MonthlyBonus {
    consecutiveMonths: Int!
    lastPaymentDate: String
    bonusMultiplier: Float!
  }

  # AI Risk Assessment
  type AIRiskAssessment {
    id: ID!
    userId: String!
    propertyId: String
    onChainData: OnChainData!
    riskFactors: RiskFactors!
    overallRiskScore: Float!
    riskCategory: RiskCategory!
    predictionModel: PredictionModel!
    dynamicAdjustments: DynamicAdjustments!
    monitoringAlerts: [MonitoringAlert!]!
    confidenceScore: Float!
    lastAssessment: String!
    nextReview: String!
    isActive: Boolean!
  }

  type OnChainData {
    walletAddress: String!
    totalTransactions: Int!
    averageTransactionValue: Float!
    defiProtocolsUsed: [String!]!
    stakingHistory: [StakingHistoryEntry!]!
    liquidityProviding: [LiquidityEntry!]!
    creditScore: Float!
    riskLevel: RiskLevel!
  }

  type StakingHistoryEntry {
    protocol: String!
    amount: Float!
    duration: Int!
    returns: Float!
  }

  type LiquidityEntry {
    pool: String!
    amount: Float!
    duration: Int!
    impermanentLoss: Float!
  }

  type RiskFactors {
    paymentHistory: PaymentHistoryRisk!
    financialStability: FinancialStabilityRisk!
    behaviouralMetrics: BehaviouralMetricsRisk!
    externalFactors: ExternalFactorsRisk!
  }

  type PaymentHistoryRisk {
    totalPayments: Int!
    latePayments: Int!
    averageDelayDays: Float!
    consistency: Float!
  }

  type FinancialStabilityRisk {
    incomeVolatility: Float!
    debtToIncomeRatio: Float!
    cryptoAssetVolatility: Float!
    diversificationScore: Float!
  }

  type BehaviouralMetricsRisk {
    platformEngagement: Float!
    communityParticipation: Float!
    maintenanceReporting: Float!
    disputeHistory: Float!
  }

  type ExternalFactorsRisk {
    marketConditions: Float!
    regionEconomicHealth: Float!
    propertyMarketTrend: Float!
    seasonalFactors: Float!
  }

  type PredictionModel {
    algorithm: Algorithm!
    accuracy: Float!
    lastTraining: String!
    features: [String!]!
    predictions: [RiskPrediction!]!
  }

  type RiskPrediction {
    predictionType: PredictionType!
    probability: Float!
    confidence: Float!
    timeframe: Int!
    createdAt: String!
  }

  type DynamicAdjustments {
    conditionsAdjustment: Float!
    depositMultiplier: Float!
    interestRateAdjustment: Float!
    insurancePremium: Float!
  }

  type MonitoringAlert {
    alertType: AlertType!
    severity: AlertSeverity!
    message: String!
    actionRequired: Boolean!
    createdAt: String!
    resolved: Boolean!
  }

  # Insurance DAO
  type InsuranceDAO {
    id: ID!
    poolId: String!
    pools: [InsurancePool!]!
    totalPoolValue: Float!
    governance: InsuranceGovernance!
    claims: [InsuranceClaim!]!
    riskAssessment: InsuranceRiskAssessment!
    feeStructure: InsuranceFeeStructure!
    statistics: InsuranceStatistics!
    coverageRatio: Float!
    isActive: Boolean!
  }

  type InsurancePool {
    poolType: PoolType!
    totalFunds: Float!
    availableFunds: Float!
    lockedFunds: Float!
    contributors: [InsuranceContributor!]!
    coverageLimit: Float!
    minimumStake: Float!
    riskMultiplier: Float!
  }

  type InsuranceContributor {
    userId: String!
    contribution: Float!
    contributionDate: String!
    votingPower: Float!
    isActive: Boolean!
  }

  type InsuranceGovernance {
    votingThreshold: Float!
    votingPeriod: Int!
    quorumRequired: Float!
    proposals: [InsuranceProposal!]!
  }

  type InsuranceProposal {
    proposalId: String!
    proposalType: InsuranceProposalType!
    title: String!
    description: String!
    parameters: JSON
    votes: [InsuranceVote!]!
    status: ProposalStatus!
    createdAt: String!
    expiresAt: String!
    executedAt: String
  }

  type InsuranceVote {
    voterId: String!
    vote: VoteChoice!
    votingPower: Float!
    timestamp: String!
  }

  type InsuranceClaim {
    claimId: String!
    claimType: ClaimType!
    amount: Float!
    description: String!
    evidence: [String!]!
    status: ClaimStatus!
    claimantId: String!
    propertyId: String
    createdAt: String!
    resolvedAt: String
    votes: [ClaimVote!]!
  }

  type ClaimVote {
    voterId: String!
    vote: ClaimVoteChoice!
    votingPower: Float!
    reason: String
    timestamp: String!
  }

  type InsuranceRiskAssessment {
    protocolRisks: [ProtocolRisk!]!
    propertyRisks: [PropertyRisk!]!
  }

  type ProtocolRisk {
    protocol: String!
    riskLevel: Float!
    coverageMultiplier: Float!
    lastAssessment: String!
  }

  type PropertyRisk {
    propertyId: String!
    riskLevel: Float!
    premiumMultiplier: Float!
    coverageAmount: Float!
  }

  type InsuranceFeeStructure {
    claimFee: Float!
    administrationFee: Float!
    reinsuranceFee: Float!
    treasuryFee: Float!
  }

  type InsuranceStatistics {
    totalClaims: Int!
    approvedClaims: Int!
    totalPaidOut: Float!
    successRate: Float!
    averageClaimAmount: Float!
    averageProcessingTime: Float!
  }

  type YieldFarmingPool {
    poolId: String!
    name: String!
    tokenA: String!
    tokenB: String!
    totalLiquidity: Float!
    apy: Float!
    totalStaked: Float!
    rewardToken: String!
    rewardRate: Float!
    participants: Int!
    lockupPeriod: Int!
    multiplier: Float!
    isActive: Boolean!
    createdAt: String!
  }

  type LendingPool {
    poolId: String!
    asset: String!
    totalSupply: Float!
    totalBorrow: Float!
    supplyRate: Float!
    borrowRate: Float!
    collateralFactor: Float!
    liquidationThreshold: Float!
    utilizationRate: Float!
    isActive: Boolean!
  }

  type DeFiPosition {
    positionId: String!
    userId: String!
    poolId: String!
    type: PositionType!
    amount: Float!
    asset: String
    collateralTokenId: String
    collateralAmount: Float
    interestRate: Float!
    createdAt: String!
    lastUpdate: String!
    interestAccrued: Float!
    isActive: Boolean!
    healthFactor: Float
  }

  type UserDeFiSummary {
    totalValue: Float!
    totalRewards: Float!
    positionsCount: Int!
    yieldFarming: Int!
    lending: Int!
    positions: [DeFiPosition!]!
  }

  # ========== MARKETPLACE ==========

  type MarketplaceListing {
    listingId: String!
    token: TokenInfo!
    sellerId: String!
    quantity: Float!
    pricePerToken: Float!
    currency: String!
    listingType: ListingType!
    highestBid: Float
    bidCount: Int!
    views: Int!
    favorites: Int!
    createdAt: String!
    expiresAt: String!
  }

  type TokenInfo {
    tokenId: String!
    name: String!
    symbol: String
    type: String!
    propertyType: PropertyType
    location: String
  }

  type TradingHistory {
    type: TradeType!
    tokenId: String!
    tokenName: String!
    quantity: Float!
    pricePerToken: Float!
    totalAmount: Float!
    currency: String!
    status: String!
    createdAt: String!
    listingId: String
    bidId: String
  }

  # ========== PRICE DATA ==========

  type PriceData {
    symbol: String!
    price: Float!
    change24h: Float!
    volume24h: Float!
    marketCap: Float
    lastUpdate: String!
    source: String!
  }

  type ExchangeRate {
    from: String!
    to: String!
    rate: Float!
    timestamp: String!
    source: String!
  }

  type MarketIndicators {
    cryptoMarket: CryptoMarketData!
    realEstateMarket: RealEstateMarketData!
    defiMetrics: DeFiMetrics!
  }

  type CryptoMarketData {
    totalMarketCap: Float!
    fearGreedIndex: Int!
    dominance: Float!
  }

  type RealEstateMarketData {
    averageCapRate: Float!
    priceAppreciation: Float!
    rentalYield: Float!
  }

  type DeFiMetrics {
    totalValueLocked: Float!
    averageApy: Float!
    liquidityIndex: Float!
  }

  type HistoricalDataPoint {
    timestamp: String!
    price: Float!
    volume: Float!
  }

  # ========== ENUMS ==========

  enum PaymentType {
    rent
    purchase
    deposit
    security_deposit
    service_fee
  }

  enum Cryptocurrency {
    BTC
    ETH
    USDT
    USDC
    MATIC
    BNB
  }

  enum BlockchainNetwork {
    bitcoin
    ethereum
    polygon
    bsc
    avalanche
  }

  enum PaymentStatus {
    pending
    confirming
    confirmed
    failed
    refunded
  }

  enum RecurringFrequency {
    weekly
    monthly
    quarterly
  }

  enum PropertyType {
    residential
    commercial
    industrial
    land
  }

  enum TokenStandard {
    ERC_20
    ERC_721
    ERC_1155
  }

  enum TokenStatus {
    development
    tokenized
    deployed
    active
    paused
    completed
  }

  enum KYCStatus {
    pending
    verified
    rejected
  }

  enum DistributionFrequency {
    weekly
    monthly
    quarterly
    annually
  }

  enum PriceDiscoveryMethod {
    oracle_based
    amm_based
    order_book
    hybrid
  }

  enum OrderType {
    market
    limit
    fixed_price
    auction
    dutch_auction
  }

  enum OrderStatus {
    open
    filled
    cancelled
    expired
    sold
  }

  enum BidStatus {
    active
    accepted
    rejected
    cancelled
  }

  enum VotingRights {
    proportional
    equal
    weighted
  }

  enum ProposalType {
    parameter_change
    feature_request
    treasury_allocation
    partnership
  }

  enum ProposalStatus {
    active
    passed
    rejected
    executed
    expired
  }

  enum VoteChoice {
    for
    against
    abstain
  }

  enum VestingCategory {
    team
    investors
    ecosystem
  }

  enum VotingPowerType {
    linear
    quadratic
    weighted
  }

  enum TransactionType {
    mint
    burn
    transfer
    stake
    unstake
    reward
    purchase
    redemption
  }

  enum ServiceType {
    rental
    purchase
    marketplace
    premium_features
  }

  enum BurnFrequency {
    weekly
    monthly
    quarterly
  }

  enum BuybackFrequency {
    weekly
    monthly
    quarterly
  }

  enum ContractType {
    lease
    sale
    escrow
    revenue_sharing
    utility_token
  }

  enum PartyRole {
    landlord
    tenant
    buyer
    seller
    investor
    platform
  }

  enum PaymentFrequency {
    weekly
    monthly
    quarterly
  }

  enum FunctionAccess {
    public
    owner_only
    parties_only
  }

  enum ContractStatus {
    draft
    deployed
    active
    paused
    completed
    terminated
  }

  enum MilestoneStatus {
    pending
    met
    failed
  }

  enum EvidenceType {
    file
    transaction
    signature
  }

  enum VulnerabilitySeverity {
    low
    medium
    high
    critical
  }

  enum VulnerabilityStatus {
    open
    resolved
  }

  enum PositionType {
    supply
    borrow
    stake
    liquidity
  }

  enum ListingType {
    fixed_price
    auction
    dutch_auction
  }

  enum TradeType {
    buy
    sell
  }

  # New DeFi Enums
  enum PricingTier {
    low
    medium
    high
  }

  enum AssetType {
    ETH
    DeFi
    RWA
  }

  enum RiskLevel {
    very_low
    low
    medium
    high
    very_high
  }

  enum DistributionSchedule {
    monthly
    quarterly
    annual
  }

  enum LoyaltyTier {
    bronze
    silver
    gold
    platinum
    diamond
  }

  enum ActionType {
    payment_ontime
    contract_renewal
    referral
    review
    maintenance_report
  }

  enum RiskCategory {
    premium
    standard
    cautious
    high_risk
  }

  enum Algorithm {
    random_forest
    neural_network
    gradient_boosting
    ensemble
  }

  enum PredictionType {
    payment_default
    early_termination
    property_damage
    renewal_likelihood
  }

  enum AlertType {
    risk_increase
    unusual_activity
    payment_prediction
    market_volatility
  }

  enum AlertSeverity {
    low
    medium
    high
    critical
  }

  enum PoolType {
    defi_protection
    property_coverage
    general_fund
  }

  enum InsuranceProposalType {
    coverage_adjustment
    pool_rebalancing
    fee_structure
    policy_update
  }

  enum ClaimType {
    defi_loss
    property_damage
    payment_default
    smart_contract_bug
  }

  enum ClaimStatus {
    pending
    investigating
    voting
    approved
    rejected
    paid
  }

  enum ClaimVoteChoice {
    approve
    reject
  }

  # ========== INPUTS ==========

  input CreateCryptoPaymentInput {
    userId: String!
    propertyId: String!
    paymentType: PaymentType!
    cryptocurrency: Cryptocurrency!
    network: BlockchainNetwork!
    amountFiat: Float!
    fiatCurrency: String!
    fromAddress: String!
    toAddress: String!
    metadata: PaymentMetadataInput!
    recurring: RecurringInfoInput
    escrow: EscrowInfoInput
  }

  input PaymentMetadataInput {
    propertyAddress: String!
    landlordId: String!
    leaseId: String
    paymentDescription: String!
    invoiceNumber: String
  }

  input RecurringInfoInput {
    frequency: RecurringFrequency!
    endDate: String
    totalPayments: Int!
  }

  input EscrowInfoInput {
    releaseConditions: [String!]!
    releaseDate: String
  }

  input TokenizePropertyInput {
    propertyId: String!
    propertyAddress: String!
    propertyValue: Float!
    currency: String!
    totalTokens: Float!
    tokenSymbol: String!
    tokenName: String!
    blockchain: BlockchainNetwork!
    ownerId: String!
    minimumInvestment: Float!
    expectedAnnualReturn: Float!
    propertyType: PropertyType!
    legalDocuments: [LegalDocumentInput!]!
  }

  input LegalDocumentInput {
    type: String!
    url: String!
    hash: String!
  }

  input BuyTokensInput {
    propertyTokenId: String!
    buyerId: String!
    tokensAmount: Float!
    paymentMethod: String!
    walletAddress: String
  }

  input CreateUtilityTokenInput {
    name: String!
    symbol: String!
    totalSupply: Float!
    initialPrice: Float!
    blockchain: BlockchainNetwork!
    distribution: TokenDistributionInput!
  }

  input TokenDistributionInput {
    ecosystem: Float!
    team: Float!
    investors: Float!
    platform: Float!
    users: Float!
  }

  input StakeTokensInput {
    userId: String!
    tokenId: String!
    amount: Float!
    lockupPeriod: Int!
  }

  input CreateProposalInput {
    proposerId: String!
    tokenId: String!
    title: String!
    description: String!
    proposalType: ProposalType!
    votingPeriod: Int
  }

  input ListTokenInput {
    sellerId: String!
    tokenType: String!
    tokenId: String!
    quantity: Float!
    pricePerToken: Float!
    currency: String!
    listingType: ListingType!
    duration: Int
    minimumBid: Float
    reservePrice: Float
  }

  input PlaceBidInput {
    bidderId: String!
    listingId: String!
    bidAmount: Float!
    currency: String!
    walletAddress: String!
  }

  input YieldFarmingStakeInput {
    userId: String!
    poolId: String!
    amount: Float!
    lockupPeriod: Int
  }

  input LendingActionInput {
    userId: String!
    poolId: String!
    amount: Float!
    action: String!
    collateralTokenId: String
    collateralAmount: Float
  }

  input CryptoFiltersInput {
    paymentType: PaymentType
    cryptocurrency: Cryptocurrency
    status: PaymentStatus
    startDate: String
    endDate: String
    limit: Int
    offset: Int
  }

  input PropertyTokenFiltersInput {
    propertyType: PropertyType
    blockchain: BlockchainNetwork
    status: TokenStatus
    minPrice: Float
    maxPrice: Float
    limit: Int
  }

  input MarketplaceFiltersInput {
    tokenType: String
    priceRange: PriceRangeInput
    location: String
    propertyType: PropertyType
    sortBy: String
    limit: Int
  }

  input PriceRangeInput {
    min: Float!
    max: Float!
  }

  # New DeFi Inputs
  input SetupDynamicPricingInput {
    propertyId: String!
    baseRent: Float!
    initialYieldRate: Float
  }

  input UpdateRentPricingInput {
    propertyId: String!
    newYieldRate: Float!
  }

  input ProcessRentPaymentInput {
    tenantId: String!
    propertyId: String!
    paymentAmount: Float!
  }

  input SetupMultiAssetStakingInput {
    propertyId: String!
    ownerId: String!
    totalAmount: Float!
  }

  input TokenizePropertyInput2 {
    propertyId: String!
    totalValue: Float!
    totalShares: Int
  }

  input PurchasePropertySharesInput {
    propertyId: String!
    buyerId: String!
    sharesToBuy: Int!
  }

  input EnableTenantTransitionInput {
    propertyId: String!
    tenantId: String!
    monthlyAccumulation: Float
  }

  input InitializeLoyaltyInput {
    userId: String!
    propertyId: String!
    contractDuration: Int!
  }

  input UpdateLoyaltyInput {
    userId: String!
    propertyId: String!
    actionType: ActionType!
    referenceId: String
  }

  input ProcessReferralInput {
    referralCode: String!
    newUserId: String!
  }

  input CreateRiskAssessmentInput {
    userId: String!
    propertyId: String!
    walletAddress: String!
  }

  input SubmitInsuranceClaimInput {
    claimantId: String!
    claimType: ClaimType!
    amount: Float!
    description: String!
    evidence: [String!]!
    propertyId: String
  }

  input VoteOnInsuranceClaimInput {
    claimId: String!
    voterId: String!
    vote: ClaimVoteChoice!
    reason: String
  }

  # ========== QUERIES ==========

  type Query {
    # Crypto Payments
    getCryptoPayment(paymentId: String!): CryptoPayment
    getUserCryptoPayments(userId: String!, filters: CryptoFiltersInput): CryptoPaymentList!
    getPropertyCryptoPayments(propertyId: String!): [CryptoPayment!]!

    # Property Tokens
    getPropertyToken(tokenId: String!): PropertyToken
    getPropertyTokens(filters: PropertyTokenFiltersInput): [PropertyToken!]!
    getUserPropertyTokens(userId: String!): [UserPropertyToken!]!

    # Utility Tokens
    getUtilityToken(tokenId: String!): UtilityToken
    getUserUtilityTokens(userId: String!): [UserUtilityToken!]!
    getUtilityTokenProposals(tokenId: String!): [Proposal!]!

    # Smart Contracts
    getSmartContract(contractId: String!): SmartContract
    getPropertyContracts(propertyId: String!): [SmartContract!]!
    getUserContracts(userId: String!): [SmartContract!]!

    # Marketplace
    getMarketplaceListings(filters: MarketplaceFiltersInput): [MarketplaceListing!]!
    getUserTradingHistory(userId: String!): [TradingHistory!]!
    getMarketplaceListing(listingId: String!): MarketplaceListing

    # DeFi
    getYieldFarmingPools: [YieldFarmingPool!]!
    getLendingPools: [LendingPool!]!
    getUserDeFiPositions(userId: String!): UserDeFiSummary!

    # Price Data
    getCryptoPrices(symbols: [String!]!): [PriceData!]!
    getExchangeRate(from: String!, to: String!): ExchangeRate!
    getMarketIndicators: MarketIndicators!
    getHistoricalData(symbol: String!, period: String!): [HistoricalDataPoint!]!
    getPropertyValuation(propertyId: String!, location: String!): Float!

    # Analytics
    getCryptoAnalytics(userId: String!): CryptoAnalytics!

    # New DeFi Queries
    getDynamicPricing(propertyId: String!): DynamicPricing
    getMultiAssetStaking(propertyId: String!): MultiAssetStaking
    getFractionalOwnership(propertyId: String!): FractionalOwnership
    getLoyaltyMining(userId: String!, propertyId: String): LoyaltyMining
    getAIRiskAssessment(userId: String!, propertyId: String): AIRiskAssessment
    getInsuranceDAO: InsuranceDAO
    getInsuranceClaims(userId: String): [InsuranceClaim!]!
    getUserLoyaltyPrograms(userId: String!): [LoyaltyMining!]!
    getPropertyStakingPerformance(propertyId: String!): [PerformanceHistory!]!
    getUserRiskAssessments(userId: String!): [AIRiskAssessment!]!
    getInsuranceStatistics: InsuranceStatistics!
  }

  # ========== MUTATIONS ==========

  type Mutation {
    # Crypto Payments
    createCryptoPayment(input: CreateCryptoPaymentInput!): CryptoPayment!
    processCryptoPayment(paymentId: String!, transactionHash: String!): CryptoPayment!
    confirmCryptoPayment(paymentId: String!, confirmations: Int!, blockHeight: Int): CryptoPayment!
    refundCryptoPayment(paymentId: String!, reason: String!): CryptoPayment!
    releaseEscrow(paymentId: String!, releasedBy: String!): CryptoPayment!

    # Property Tokens
    tokenizeProperty(input: TokenizePropertyInput!): PropertyToken!
    buyPropertyTokens(input: BuyTokensInput!): TokenPurchaseResult!
    sellPropertyTokens(input: SellTokensInput!): TokenSaleResult!
    distributeRevenue(propertyTokenId: String!, totalRevenue: Float!, period: String!): Boolean!

    # Utility Tokens
    createUtilityToken(input: CreateUtilityTokenInput!): UtilityToken!
    mintUtilityTokens(tokenId: String!, recipient: String!, amount: Float!, reason: String!): Boolean!
    stakeUtilityTokens(input: StakeTokensInput!): Boolean!
    claimStakingRewards(userId: String!, tokenId: String!): Float!

    # Governance
    createGovernanceProposal(input: CreateProposalInput!): String!
    voteOnProposal(userId: String!, tokenId: String!, proposalId: String!, vote: VoteChoice!): Boolean!

    # Marketplace
    listTokensForSale(input: ListTokenInput!): String!
    placeBid(input: PlaceBidInput!): Boolean!
    acceptBid(sellerId: String!, listingId: String!, bidId: String!): Boolean!
    cancelListing(sellerId: String!, listingId: String!): Boolean!

    # DeFi
    stakeInYieldFarm(input: YieldFarmingStakeInput!): Boolean!
    claimYieldFarmingRewards(userId: String!, poolId: String!): Float!
    supplyToLendingPool(input: LendingActionInput!): Boolean!
    borrowFromLendingPool(input: LendingActionInput!): Boolean!
    repayLoan(userId: String!, positionId: String!, amount: Float!): Boolean!
    liquidatePosition(liquidatorId: String!, positionId: String!): Boolean!

    # Price Alerts
    subscribeToPriceAlerts(userId: String!, alerts: [PriceAlertInput!]!): Boolean!

    # New DeFi Mutations
    setupDynamicPricing(input: SetupDynamicPricingInput!): DynamicPricing!
    updateRentPricing(input: UpdateRentPricingInput!): DynamicPricing!
    processRentPayment(input: ProcessRentPaymentInput!): RentPaymentResult!
    setupMultiAssetStaking(input: SetupMultiAssetStakingInput!): MultiAssetStaking!
    rebalancePortfolio(propertyId: String!): Boolean!
    tokenizePropertyAdvanced(input: TokenizePropertyInput2!): PropertyTokenizationResult!
    purchasePropertyShares(input: PurchasePropertySharesInput!): Boolean!
    enableTenantTransition(input: EnableTenantTransitionInput!): Boolean!
    initializeLoyalty(input: InitializeLoyaltyInput!): LoyaltyMining!
    updateLoyalty(input: UpdateLoyaltyInput!): LoyaltyUpdateResult!
    processReferral(input: ProcessReferralInput!): ReferralResult!
    createRiskAssessment(input: CreateRiskAssessmentInput!): AIRiskAssessment!
    updateRiskAssessment(userId: String!, propertyId: String!): AIRiskAssessment!
    submitInsuranceClaim(input: SubmitInsuranceClaimInput!): String!
    voteOnInsuranceClaim(input: VoteOnInsuranceClaimInput!): Boolean!
  }

  # ========== RESPONSE TYPES ==========

  type CryptoPaymentList {
    payments: [CryptoPayment!]!
    total: Int!
    hasMore: Boolean!
  }

  type UserPropertyToken {
    propertyToken: PropertyToken!
    tokensOwned: Float!
    ownershipPercentage: Float!
    investmentAmount: Float!
    currentValue: Float!
    unrealizedGains: Float!
  }

  type UserUtilityToken {
    token: UtilityTokenInfo!
    balance: Float!
    stakedBalance: Float!
    pendingRewards: Float!
    totalValue: Float!
  }

  type UtilityTokenInfo {
    tokenId: String!
    name: String!
    symbol: String!
    currentPrice: Float!
  }

  type TokenPurchaseResult {
    success: Boolean!
    transactionHash: String!
    tokensOwned: Float!
    totalCost: Float!
    newOwnershipPercentage: Float!
  }

  type TokenSaleResult {
    success: Boolean!
    orderId: String!
    orderType: OrderType!
    status: String!
  }

  type CryptoAnalytics {
    totalPortfolioValue: Float!
    totalPayments: Int!
    totalRevenue: Float!
    activeTokens: Int!
    stakingRewards: Float!
    portfolioBreakdown: [PortfolioItem!]!
  }

  type PortfolioItem {
    type: String!
    name: String!
    value: Float!
    percentage: Float!
  }

  input SellTokensInput {
    propertyTokenId: String!
    sellerId: String!
    tokensAmount: Float!
    pricePerToken: Float
    orderType: OrderType!
  }

  input PriceAlertInput {
    symbol: String!
    targetPrice: Float!
    condition: String!
    frequency: String!
  }

  # New DeFi Response Types
  type RentPaymentResult {
    success: Boolean!
    originalRent: Float!
    adjustedRent: Float!
    discountApplied: Float!
    yieldGenerated: Float!
    loyaltyPointsEarned: Int!
    tokensAwarded: Float!
    nextPaymentDue: String!
  }

  type PropertyTokenizationResult {
    success: Boolean!
    totalShares: Int!
    sharePrice: Float!
    availableShares: Int!
    daoEnabled: Boolean!
    revenueSharing: Boolean!
  }

  type LoyaltyUpdateResult {
    pointsEarned: Int!
    tokensAwarded: Float!
  }

  type ReferralResult {
    success: Boolean!
    bonusPoints: Int!
  }

  # ========== SUBSCRIPTIONS ==========

  type Subscription {
    cryptoPaymentUpdates(userId: String!): CryptoPayment!
    priceUpdates(symbols: [String!]!): PriceData!
    tokenTransfers(tokenId: String!): TokenTransaction!
    governanceUpdates(tokenId: String!): Proposal!
    marketplaceUpdates: MarketplaceListing!
    deFiPositionUpdates(userId: String!): DeFiPosition!
  }

  # ========== CUSTOM SCALARS ==========

  scalar JSON
`;
  }
});

// src/graphql/types/index.ts
import gql8 from "graphql-tag";
var baseTypeDefs, typeDefs;
var init_types3 = __esm({
  "src/graphql/types/index.ts"() {
    init_propertySchema();
    init_serviceSchema();
    init_walletSchema();
    init_chatSchema();
    init_activitySchema();
    init_userSchema();
    init_cryptoSchema();
    baseTypeDefs = gql8`
  scalar Date
  scalar DateTime
  scalar JSON
  scalar Upload

  type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
  }

  type Query {
    _empty: String
  }

  type Mutation {
    _empty: String
  }

  type Subscription {
    _empty: String
  }
`;
    typeDefs = [
      baseTypeDefs,
      propertyTypeDefs,
      serviceTypeDefs,
      walletTypeDefs,
      chatTypeDefs,
      activityTypeDefs,
      userTypeDefs,
      cryptoTypeDefs
    ];
  }
});

// src/activity/model/activitySchema.ts
import mongoose21, { Schema as Schema20 } from "mongoose";
var UploadedFileSchema, ActivitySchema, Activity, activitySchema_default;
var init_activitySchema2 = __esm({
  "src/activity/model/activitySchema.ts"() {
    UploadedFileSchema = new Schema20({
      fileName: { type: String, required: true },
      fileUrl: { type: String, required: true },
      uploadedAt: { type: Date, default: Date.now }
    });
    ActivitySchema = new Schema20(
      {
        propertyId: {
          type: mongoose21.Schema.Types.ObjectId,
          default: () => new mongoose21.Types.ObjectId(),
          ref: "Property",
          required: true
        },
        clientId: {
          type: mongoose21.Schema.Types.ObjectId,
          default: () => new mongoose21.Types.ObjectId(),
          ref: "User",
          required: true
        },
        isVisited: { type: Boolean, default: false },
        visitDate: { type: Date },
        isVisitAccepted: { type: Boolean, default: true },
        isReservation: { type: Boolean, default: false },
        message: { type: String, default: "", required: true },
        reservationDate: { type: Date, default: Date.now },
        isReservationAccepted: { type: Boolean, default: false },
        booking: { type: Boolean, default: false },
        documentsUploaded: { type: Boolean, default: false },
        isBookingAccepted: { type: Boolean, default: false },
        uploadedFiles: { type: [UploadedFileSchema], default: [] },
        isPayment: { type: Boolean, default: false },
        amount: { type: Number, default: 0 },
        paymentDate: { type: Date, default: Date.now },
        refusDate: { type: Date, default: Date.now },
        reason: { type: String, default: "" }
      },
      { timestamps: true }
    );
    Activity = mongoose21.model("Activity", ActivitySchema);
    activitySchema_default = Activity;
  }
});

// src/chat/model/conversationModel.ts
import mongoose22 from "mongoose";
var ConversationSchema, Conversation, conversationModel_default;
var init_conversationModel = __esm({
  "src/chat/model/conversationModel.ts"() {
    ConversationSchema = new mongoose22.Schema({
      participants: [{
        type: mongoose22.Schema.Types.ObjectId,
        ref: "User",
        required: true
      }],
      type: {
        type: String,
        enum: ["direct", "group", "property_discussion"],
        default: "direct"
      },
      admins: [{ type: mongoose22.Schema.Types.ObjectId, ref: "User" }],
      // Métadonnées de groupe
      groupInfo: {
        name: String,
        description: String,
        avatar: String,
        admins: [{ type: mongoose22.Schema.Types.ObjectId, ref: "User" }],
        settings: {
          allowMemberAdd: { type: Boolean, default: true },
          allowMemberEdit: { type: Boolean, default: false },
          muteAll: { type: Boolean, default: false }
        }
      },
      // Propriété associée
      propertyId: { type: mongoose22.Schema.Types.ObjectId, ref: "Property" },
      // Paramètres de conversation
      settings: {
        encryption: { type: Boolean, default: true },
        disappearingMessages: {
          enabled: { type: Boolean, default: false },
          duration: { type: Number, default: 864e5 }
          // 24h en ms
        },
        smartReply: { type: Boolean, default: true },
        translation: { type: Boolean, default: false },
        voiceTranscription: { type: Boolean, default: true }
      },
      // Archivage et épinglage
      isArchivedBy: [{
        userId: { type: mongoose22.Schema.Types.ObjectId, ref: "User" },
        archivedAt: { type: Date, default: Date.now }
      }],
      isPinned: [{
        userId: { type: mongoose22.Schema.Types.ObjectId, ref: "User" },
        pinnedAt: { type: Date, default: Date.now }
      }],
      // Statut de frappe
      typingUsers: [{
        userId: { type: mongoose22.Schema.Types.ObjectId, ref: "User" },
        lastTyping: { type: Date, default: Date.now }
      }],
      // Messages épinglés
      pinnedMessages: [{ type: mongoose22.Schema.Types.ObjectId, ref: "Message" }],
      // Innovations uniques
      aiModerator: {
        enabled: { type: Boolean, default: true },
        autoResponseSuggestions: { type: Boolean, default: true },
        priceNegotiationAssist: { type: Boolean, default: true },
        appointmentScheduling: { type: Boolean, default: true }
      },
      // Statistiques avancées
      analytics: {
        messageCount: { type: Number, default: 0 },
        averageResponseTime: { type: Number, default: 0 },
        mostActiveHours: [Number],
        engagement: {
          reactionsCount: { type: Number, default: 0 },
          mediaSharedCount: { type: Number, default: 0 }
        }
      }
    }, {
      timestamps: true
    });
    Conversation = mongoose22.model("Conversation", ConversationSchema);
    conversationModel_default = Conversation;
  }
});

// src/property/graphql/propertyResolvers.ts
var propertyResolvers;
var init_propertyResolvers = __esm({
  "src/property/graphql/propertyResolvers.ts"() {
    init_propertyModel();
    init_userModel();
    init_activitySchema2();
    init_Service();
    init_RecommendationEngine();
    init_proprityServices();
    init_conversationModel();
    init_Transaction();
    propertyResolvers = {
      Query: {
        property: async (_, { id }, { user }) => {
          try {
            const propertyService = new proprityServices_default();
            const property2 = await propertyService.finPropertyById(id);
            if (!property2) throw new Error("Property not found");
            return property2;
          } catch (error2) {
            throw new Error(`Error fetching property: ${error2.message}`);
          }
        },
        properties: async (_, { filters, pagination }) => {
          try {
            const propertyService = new proprityServices_default();
            const result = await propertyService.getProperty({
              ...filters,
              ...pagination
            });
            if (!result || !result.properties) {
              return {
                edges: [],
                pageInfo: { hasNextPage: false, hasPreviousPage: false },
                totalCount: 0
              };
            }
            const edges = result.properties.map((property2, index) => ({
              node: property2,
              cursor: Buffer.from(((pagination?.page || 1) * (pagination?.limit || 10) + index).toString()).toString("base64")
            }));
            return {
              edges,
              pageInfo: {
                hasNextPage: result.page < result.totalPages,
                hasPreviousPage: result.page > 1,
                startCursor: edges[0]?.cursor,
                endCursor: edges[edges.length - 1]?.cursor
              },
              totalCount: result.total
            };
          } catch (error2) {
            throw new Error(`Error fetching properties: ${error2.message}`);
          }
        },
        searchProperties: async (_, { query: query2, filters, pagination }) => {
          try {
            const propertyService = new proprityServices_default();
            if (query2) {
              const result = await propertyService.searchProperty({
                q: query2,
                pagination
              });
              if (!result || !result.properties) {
                return {
                  edges: [],
                  pageInfo: { hasNextPage: false, hasPreviousPage: false },
                  totalCount: 0
                };
              }
              const edges = result.properties.map((property2, index) => ({
                node: property2,
                cursor: Buffer.from(((pagination?.page || 1) * (pagination?.limit || 10) + index).toString()).toString("base64")
              }));
              return {
                edges,
                pageInfo: {
                  hasNextPage: result.page < result.totalPages,
                  hasPreviousPage: result.page > 1,
                  startCursor: edges[0]?.cursor,
                  endCursor: edges[edges.length - 1]?.cursor
                },
                totalCount: result.total
              };
            }
            return await propertyService.getProperty({
              ...filters,
              ...pagination
            });
          } catch (error2) {
            throw new Error(`Error searching properties: ${error2.message}`);
          }
        },
        similarProperties: async (_, { propertyId, limit }) => {
          try {
            const propertyService = new proprityServices_default();
            const result = await propertyService.getSImilarProperty({
              propertyId,
              pagination: { limit: limit || 5 }
            });
            return Array.isArray(result) ? result : result?.properties || [];
          } catch (error2) {
            throw new Error(`Error fetching similar properties: ${error2.message}`);
          }
        },
        propertyStats: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const propertyService = new proprityServices_default();
            const stats = await propertyService.getPropertyState();
            if (!stats) throw new Error("Statistics not available");
            return stats;
          } catch (error2) {
            throw new Error(`Error fetching property stats: ${error2.message}`);
          }
        },
        propertiesByOwner: async (_, { ownerId, pagination, status }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const propertyService = new proprityServices_default();
            const result = await propertyService.getPropertyByOwner({
              ownerId: ownerId || user.userId,
              pagination,
              status
            });
            if (!result || !result.properties) {
              return {
                edges: [],
                pageInfo: { hasNextPage: false, hasPreviousPage: false },
                totalCount: 0
              };
            }
            const edges = result.properties.map((property2, index) => ({
              node: property2,
              cursor: Buffer.from(((pagination?.page || 1) * (pagination?.limit || 10) + index).toString()).toString("base64")
            }));
            return {
              edges,
              pageInfo: {
                hasNextPage: result.page < result.totalPages,
                hasPreviousPage: result.page > 1,
                startCursor: edges[0]?.cursor,
                endCursor: edges[edges.length - 1]?.cursor
              },
              totalCount: result.total
            };
          } catch (error2) {
            throw new Error(`Error fetching properties by owner: ${error2.message}`);
          }
        }
      },
      Mutation: {
        createProperty: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const propertyService = new proprityServices_default();
            const property2 = await propertyService.createProperty(
              input,
              user.userId
            );
            if (!property2) throw new Error("Failed to create property");
            return property2;
          } catch (error2) {
            throw new Error(`Error creating property: ${error2.message}`);
          }
        },
        updateProperty: async (_, { id, input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const property2 = await propertyModel_default.findOne({ _id: id, ownerId: user.userId });
            if (!property2) throw new Error("Property not found or unauthorized");
            const propertyService = new proprityServices_default();
            const updatedProperty = await propertyService.updateProperty({
              propertyId: id,
              data: input
            });
            if (!updatedProperty) throw new Error("Failed to update property");
            return updatedProperty;
          } catch (error2) {
            throw new Error(`Error updating property: ${error2.message}`);
          }
        },
        deleteProperty: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const property2 = await propertyModel_default.findById(id);
            if (!property2 || property2.ownerId.toString() !== user.userId) {
              throw new Error("Property not found or unauthorized");
            }
            const propertyService = new proprityServices_default();
            const result = await propertyService.deleteProperty(id);
            return !!result;
          } catch (error2) {
            throw new Error(`Error deleting property: ${error2.message}`);
          }
        },
        restoreProperty: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const property2 = await propertyModel_default.findById(id);
            if (!property2 || property2.ownerId.toString() !== user.userId) {
              throw new Error("Property not found or unauthorized");
            }
            const propertyService = new proprityServices_default();
            const result = await propertyService.restoreProperty(id);
            if (!result) throw new Error("Failed to restore property");
            return await propertyModel_default.findById(id);
          } catch (error2) {
            throw new Error(`Error restoring property: ${error2.message}`);
          }
        },
        updatePropertyStatus: async (_, { id, status }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const property2 = await propertyModel_default.findOne({ _id: id, ownerId: user.userId });
            if (!property2) throw new Error("Property not found or unauthorized");
            property2.status = status;
            await property2.save();
            return property2;
          } catch (error2) {
            throw new Error(`Error updating property status: ${error2.message}`);
          }
        }
      },
      Property: {
        owner: async (property2) => {
          return await userModel_default.findById(property2.ownerId);
        },
        activities: async (property2) => {
          return await activitySchema_default.find({ propertyId: property2._id }).sort({ createdAt: -1 });
        },
        services: async (property2) => {
          return await Service.find({
            "availability.zones": property2.generalHInfo.area,
            "requirements.propertyTypes": property2.propertyType,
            status: "active"
          });
        },
        conversations: async (property2) => {
          return await conversationModel_default.find({ propertyId: property2._id }).populate("participants", "firstName lastName profilePicture").sort({ updatedAt: -1 }).limit(10);
        },
        recentActivities: async (property2) => {
          return await activitySchema_default.find({ propertyId: property2._id }).populate("clientId", "firstName lastName profilePicture email").sort({ createdAt: -1 }).limit(20);
        },
        financialStats: async (property2) => {
          const transactions = await Transaction.find({
            "metadata.propertyId": property2._id.toString()
          });
          const totalRevenue = transactions.filter((t) => t.type === "received").reduce((sum, t) => sum + t.amount, 0);
          const totalExpenses = transactions.filter((t) => t.type === "payment").reduce((sum, t) => sum + t.amount, 0);
          return {
            totalRevenue,
            totalExpenses,
            netIncome: totalRevenue - totalExpenses,
            transactionCount: transactions.length,
            averageMonthlyRevenue: totalRevenue / 12
          };
        },
        similarProperties: async (property2) => {
          const propertyService = new proprityServices_default();
          return await propertyService.getSImilarProperty({
            propertyId: property2._id.toString(),
            pagination: { limit: 5 }
          });
        },
        occupancyRate: async (property2) => {
          const totalDays = 365;
          const rentedDays = await activitySchema_default.countDocuments({
            propertyId: property2._id,
            isReservationAccepted: true,
            createdAt: { $gte: new Date(Date.now() - 365 * 24 * 60 * 60 * 1e3) }
          }) * 30;
          return Math.min(100, rentedDays / totalDays * 100);
        },
        performanceScore: async (property2) => {
          const activities = await activitySchema_default.find({ propertyId: property2._id });
          const totalActivities = activities.length;
          const acceptedActivities = activities.filter(
            (a) => a.isReservationAccepted || a.isVisitAccepted
          ).length;
          if (totalActivities === 0) return 0;
          const acceptanceRate = acceptedActivities / totalActivities * 100;
          const priceCompetitiveness = 75;
          const responseTime = 85;
          return Math.round((acceptanceRate + priceCompetitiveness + responseTime) / 3);
        },
        reviews: async (property2) => {
          const activities = await activitySchema_default.find({
            propertyId: property2._id,
            isReservationAccepted: true
          }).populate("clientId", "firstName lastName");
          return activities.slice(0, 10).map((activity) => ({
            id: activity._id,
            rating: Math.floor(Math.random() * 2) + 4,
            comment: `Excellent s\xE9jour dans cette propri\xE9t\xE9. ${activity.message}`,
            reviewer: activity.clientId,
            date: activity.createdAt
          }));
        },
        marketAnalysis: async (property2) => {
          const similarProperties = await propertyModel_default.find({
            "generalHInfo.area": property2.generalHInfo.area,
            propertyType: property2.propertyType,
            isActive: true,
            _id: { $ne: property2._id }
          });
          const averagePrice = similarProperties.reduce(
            (sum, p) => sum + p.ownerCriteria.monthlyRent,
            0
          ) / similarProperties.length;
          const pricePosition = property2.ownerCriteria.monthlyRent > averagePrice ? "above" : "below";
          const priceDifference = Math.abs(property2.ownerCriteria.monthlyRent - averagePrice);
          const pricePercentage = priceDifference / averagePrice * 100;
          return {
            averageMarketPrice: averagePrice,
            pricePosition,
            priceDifference,
            pricePercentage: Math.round(pricePercentage),
            competitorCount: similarProperties.length,
            marketTrend: "stable"
          };
        },
        pricePerSquareMeter: (property2) => {
          return property2.generalHInfo.surface > 0 ? property2.ownerCriteria.monthlyRent / property2.generalHInfo.surface : 0;
        },
        isAvailable: (property2) => {
          return property2.status === "AVAILABLE" && property2.isActive;
        },
        recommendedServices: async (property2) => {
          const recommendationEngine = new RecommendationEngine();
          const recommendations = await recommendationEngine.getRecommendations({
            propertyType: property2.propertyType,
            location: {
              city: property2.generalHInfo.area,
              district: property2.generalHInfo.area
            },
            userProfile: {
              userId: property2.ownerId.toString(),
              preferences: ["maintenance", "security"],
              budget: property2.ownerCriteria.monthlyRent * 0.1,
              lifestyle: ["property_owner"]
            },
            servicesAlreadySubscribed: []
          });
          return recommendations;
        }
      },
      PropertyStats: {
        totalProperties: (stats) => stats.totalProperties || 0,
        availableProperties: (stats) => stats.availableProperties || 0,
        rentedProperties: (stats) => stats.rentedProperties || 0,
        averageRent: (stats) => stats.averageRent || 0,
        averageSize: (stats) => stats.averageSize || 0,
        propertiesByArea: (stats) => stats.propertiesByArea || [],
        propertiesByStatus: (stats) => stats.propertiesByStatus || []
      },
      PropertyFinancialStats: {
        totalRevenue: (stats) => stats.totalRevenue || 0,
        totalExpenses: (stats) => stats.totalExpenses || 0,
        netIncome: (stats) => stats.netIncome || 0,
        transactionCount: (stats) => stats.transactionCount || 0,
        averageMonthlyRevenue: (stats) => stats.averageMonthlyRevenue || 0
      },
      PropertyMarketAnalysis: {
        averageMarketPrice: (analysis) => analysis.averageMarketPrice || 0,
        pricePosition: (analysis) => analysis.pricePosition || "unknown",
        priceDifference: (analysis) => analysis.priceDifference || 0,
        pricePercentage: (analysis) => analysis.pricePercentage || 0,
        competitorCount: (analysis) => analysis.competitorCount || 0,
        marketTrend: (analysis) => analysis.marketTrend || "stable"
      }
    };
  }
});

// src/service-marketplace/models/ServiceReview.ts
import mongoose23, { Schema as Schema21 } from "mongoose";
var ServiceReviewSchema, ServiceReview;
var init_ServiceReview = __esm({
  "src/service-marketplace/models/ServiceReview.ts"() {
    ServiceReviewSchema = new Schema21({
      userId: { type: String, required: true },
      serviceId: { type: String, required: true },
      subscriptionId: { type: String, required: true },
      rating: { type: Number, required: true, min: 1, max: 5 },
      comment: { type: String, required: true, maxlength: 1e3 },
      photos: [{ type: String }],
      isVerified: { type: Boolean, default: false },
      providerResponse: {
        comment: { type: String, maxlength: 500 },
        date: { type: Date }
      }
    }, {
      timestamps: true
    });
    ServiceReviewSchema.index({ serviceId: 1, rating: -1 });
    ServiceReviewSchema.index({ userId: 1 });
    ServiceReview = mongoose23.model("ServiceReview", ServiceReviewSchema);
  }
});

// src/service-marketplace/graphql/serviceResolvers.ts
var serviceResolvers;
var init_serviceResolvers = __esm({
  "src/service-marketplace/graphql/serviceResolvers.ts"() {
    init_Service();
    init_ServiceProvider();
    init_ServiceSubscription();
    init_ServiceReview();
    init_ServiceMarketplaceService();
    init_RecommendationEngine();
    init_userModel();
    init_propertyModel();
    serviceResolvers = {
      Query: {
        service: async (_, { id }) => {
          try {
            const service = await Service.findById(id);
            if (!service) throw new Error("Service not found");
            return service;
          } catch (error2) {
            throw new Error(`Error fetching service: ${error2.message}`);
          }
        },
        services: async (_, { filters, pagination }) => {
          try {
            const marketplaceService = new ServiceMarketplaceService();
            const services = await marketplaceService.getServices(filters || {});
            const limit = pagination?.first || 20;
            const skip = pagination?.after ? parseInt(Buffer.from(pagination.after, "base64").toString()) : 0;
            const paginatedServices = services.slice(skip, skip + limit);
            const hasNextPage = services.length > skip + limit;
            const edges = paginatedServices.map((service, index) => ({
              node: service,
              cursor: Buffer.from((skip + index).toString()).toString("base64")
            }));
            return {
              edges,
              pageInfo: {
                hasNextPage,
                hasPreviousPage: skip > 0,
                startCursor: edges[0]?.cursor,
                endCursor: edges[edges.length - 1]?.cursor
              },
              totalCount: services.length
            };
          } catch (error2) {
            throw new Error(`Error fetching services: ${error2.message}`);
          }
        },
        serviceRecommendations: async (_, { input }) => {
          try {
            const recommendationEngine = new RecommendationEngine();
            const recommendations = await recommendationEngine.getRecommendations(input);
            return recommendations || [];
          } catch (error2) {
            throw new Error(`Error fetching service recommendations: ${error2.message}`);
          }
        },
        serviceProvider: async (_, { id }) => {
          try {
            const provider = await ServiceProvider.findById(id);
            if (!provider) throw new Error("Service provider not found");
            return provider;
          } catch (error2) {
            throw new Error(`Error fetching service provider: ${error2.message}`);
          }
        },
        serviceProviders: async (_, { filters, pagination }) => {
          try {
            const query2 = filters ? { $text: { $search: filters } } : {};
            const limit = pagination?.limit || 20;
            const skip = ((pagination?.page || 1) - 1) * limit;
            return await ServiceProvider.find(query2).skip(skip).limit(limit).sort({ rating: -1, totalReviews: -1 });
          } catch (error2) {
            throw new Error(`Error fetching service providers: ${error2.message}`);
          }
        },
        userSubscriptions: async (_, { userId }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            if (userId !== user.userId && user.role !== "admin") {
              throw new Error("Unauthorized access");
            }
            const marketplaceService = new ServiceMarketplaceService();
            return await marketplaceService.getUserSubscriptions(userId);
          } catch (error2) {
            throw new Error(`Error fetching user subscriptions: ${error2.message}`);
          }
        },
        serviceStats: async (_, __, { user }) => {
          try {
            if (!user || user.role !== "admin") {
              throw new Error("Admin access required");
            }
            const totalServices = await Service.countDocuments();
            const activeServices = await Service.countDocuments({ status: "active" });
            const totalProviders = await ServiceProvider.countDocuments();
            const services = await Service.find();
            const averageRating = services.reduce((sum, s) => sum + s.rating, 0) / services.length || 0;
            const popularCategories = await Service.aggregate([
              { $group: { _id: "$category", count: { $sum: 1 }, averageRating: { $avg: "$rating" } } },
              { $sort: { count: -1 } },
              { $limit: 10 }
            ]);
            return {
              totalServices,
              activeServices,
              totalProviders,
              averageRating,
              popularCategories: popularCategories.map((cat) => ({
                category: cat._id,
                count: cat.count,
                averageRating: cat.averageRating
              })),
              revenueByCategory: []
              // À implémenter avec les données de paiement
            };
          } catch (error2) {
            throw new Error(`Error fetching service stats: ${error2.message}`);
          }
        },
        providerServices: async (_, { providerId }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            if (providerId !== user.userId && user.role !== "admin") {
              throw new Error("Unauthorized access");
            }
            const marketplaceService = new ServiceMarketplaceService();
            return await marketplaceService.getProviderServices(providerId);
          } catch (error2) {
            throw new Error(`Error fetching provider services: ${error2.message}`);
          }
        },
        serviceReviews: async (_, { serviceId, pagination }) => {
          try {
            const limit = pagination?.limit || 20;
            const skip = ((pagination?.page || 1) - 1) * limit;
            return await ServiceReview.find({ serviceId }).populate("userId", "firstName lastName profilePicture").sort({ createdAt: -1 }).skip(skip).limit(limit);
          } catch (error2) {
            throw new Error(`Error fetching service reviews: ${error2.message}`);
          }
        }
      },
      Mutation: {
        createServiceProvider: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            const provider = await marketplaceService.createServiceProvider(user.userId, input);
            if (!provider) throw new Error("Failed to create service provider");
            return provider;
          } catch (error2) {
            throw new Error(`Error creating service provider: ${error2.message}`);
          }
        },
        updateServiceProvider: async (_, { id, input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const provider = await ServiceProvider.findOne({ _id: id, userId: user.userId });
            if (!provider) throw new Error("Service provider not found or unauthorized");
            Object.assign(provider, input);
            await provider.save();
            return provider;
          } catch (error2) {
            throw new Error(`Error updating service provider: ${error2.message}`);
          }
        },
        createService: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            const service = await marketplaceService.createService(user.userId, input);
            if (!service) throw new Error("Failed to create service");
            return service;
          } catch (error2) {
            throw new Error(`Error creating service: ${error2.message}`);
          }
        },
        updateService: async (_, { id, input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const service = await Service.findOne({ _id: id, providerId: user.userId });
            if (!service) throw new Error("Service not found or unauthorized");
            Object.assign(service, input);
            await service.save();
            return service;
          } catch (error2) {
            throw new Error(`Error updating service: ${error2.message}`);
          }
        },
        deleteService: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const service = await Service.findOne({ _id: id, providerId: user.userId });
            if (!service) throw new Error("Service not found or unauthorized");
            await Service.findByIdAndDelete(id);
            return true;
          } catch (error2) {
            throw new Error(`Error deleting service: ${error2.message}`);
          }
        },
        subscribeToService: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            const subscription = await marketplaceService.subscribeToService(user.userId, input);
            if (!subscription) throw new Error("Failed to create subscription");
            return subscription;
          } catch (error2) {
            throw new Error(`Error subscribing to service: ${error2.message}`);
          }
        },
        pauseSubscription: async (_, { subscriptionId }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            await marketplaceService.pauseSubscription(user.userId, subscriptionId);
            return await ServiceSubscription.findById(subscriptionId);
          } catch (error2) {
            throw new Error(`Error pausing subscription: ${error2.message}`);
          }
        },
        resumeSubscription: async (_, { subscriptionId }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            await marketplaceService.resumeSubscription(user.userId, subscriptionId);
            return await ServiceSubscription.findById(subscriptionId);
          } catch (error2) {
            throw new Error(`Error resuming subscription: ${error2.message}`);
          }
        },
        cancelSubscription: async (_, { subscriptionId }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            await marketplaceService.cancelSubscription(user.userId, subscriptionId);
            return await ServiceSubscription.findById(subscriptionId);
          } catch (error2) {
            throw new Error(`Error cancelling subscription: ${error2.message}`);
          }
        },
        shareService: async (_, { subscriptionId, shareWithUserIds }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const marketplaceService = new ServiceMarketplaceService();
            await marketplaceService.shareService(user.userId, subscriptionId, shareWithUserIds);
            return await ServiceSubscription.findById(subscriptionId);
          } catch (error2) {
            throw new Error(`Error sharing service: ${error2.message}`);
          }
        },
        createServiceReview: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const subscription = await ServiceSubscription.findOne({
              _id: input.subscriptionId,
              userId: user.userId
            });
            if (!subscription) throw new Error("Subscription not found or unauthorized");
            const review = new ServiceReview({
              ...input,
              userId: user.userId
            });
            await review.save();
            const service = await Service.findById(input.serviceId);
            if (service) {
              const reviews = await ServiceReview.find({ serviceId: input.serviceId });
              const averageRating = reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length;
              service.rating = averageRating;
              service.totalReviews = reviews.length;
              await service.save();
            }
            return review;
          } catch (error2) {
            throw new Error(`Error creating service review: ${error2.message}`);
          }
        },
        respondToReview: async (_, { reviewId, response }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const review = await ServiceReview.findById(reviewId).populate("serviceId");
            if (!review) throw new Error("Review not found");
            const service = await Service.findById(review.serviceId);
            if (!service || service.providerId !== user.userId) {
              throw new Error("Unauthorized to respond to this review");
            }
            review.providerResponse = {
              comment: response,
              date: /* @__PURE__ */ new Date()
            };
            await review.save();
            return review;
          } catch (error2) {
            throw new Error(`Error responding to review: ${error2.message}`);
          }
        }
      },
      Service: {
        provider: async (service) => {
          return await ServiceProvider.findOne({ userId: service.providerId });
        },
        subscriptions: async (service) => {
          return await ServiceSubscription.find({ serviceId: service._id });
        },
        reviews: async (service) => {
          return await ServiceReview.find({ serviceId: service._id }).sort({ createdAt: -1 });
        },
        isAvailableForProperty: async (service, { propertyId }) => {
          const property2 = await propertyModel_default.findById(propertyId);
          if (!property2) return false;
          return service.requirements.propertyTypes.includes(property2.propertyType) && service.availability.zones.includes(property2.generalHInfo.area);
        },
        estimatedPrice: async (service, { propertyType }) => {
          let basePrice = service.pricing.basePrice;
          const propertyMultipliers = {
            "villa": 1.5,
            "penthouse": 1.8,
            "apartment": 1,
            "studio": 0.8,
            "commercial": 2
          };
          return basePrice * (propertyMultipliers[propertyType] || 1);
        }
      },
      ServiceProvider: {
        user: async (provider) => {
          return await userModel_default.findById(provider.userId);
        },
        services: async (provider) => {
          return await Service.find({ providerId: provider.userId });
        }
      },
      ServiceSubscription: {
        user: async (subscription) => {
          return await userModel_default.findById(subscription.userId);
        },
        property: async (subscription) => {
          return await propertyModel_default.findById(subscription.propertyId);
        },
        service: async (subscription) => {
          return await Service.findById(subscription.serviceId);
        },
        paymentHistory: async (subscription) => {
          return subscription.paymentHistory || [];
        }
      },
      ServiceRecommendation: {
        service: async (recommendation) => {
          return await Service.findById(recommendation.serviceId);
        },
        neighborhoodData: async (recommendation) => {
          const service = await Service.findById(recommendation.serviceId);
          if (!service) return null;
          const subscriptions = await ServiceSubscription.find({
            serviceId: recommendation.serviceId,
            status: "active"
          });
          const reviews = await ServiceReview.find({
            serviceId: recommendation.serviceId
          });
          const averageRating = reviews.length > 0 ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length : 0;
          return {
            popularServices: [service.category],
            averageRating,
            totalUsers: subscriptions.length
          };
        }
      }
    };
  }
});

// src/users/graphql/userResolvers.ts
var userResolvers;
var init_userResolvers = __esm({
  "src/users/graphql/userResolvers.ts"() {
    init_userModel();
    init_propertyModel();
    init_activitySchema2();
    init_Wallet();
    init_ServiceSubscription();
    init_ServiceProvider();
    userResolvers = {
      Query: {
        user: async (_, { id }) => {
          return await userModel_default.findById(id);
        },
        me: async (_, __, { user }) => {
          if (!user) throw new Error("Authentication required");
          return await userModel_default.findById(user.userId);
        }
      },
      User: {
        fullName: (user) => {
          return `${user.firstName} ${user.lastName}`.trim();
        },
        properties: async (user) => {
          return await propertyModel_default.find({ ownerId: user._id, isActive: true });
        },
        activities: async (user) => {
          return await activitySchema_default.find({ clientId: user._id }).sort({ createdAt: -1 });
        },
        wallet: async (user) => {
          return await Wallet.findOne({ userId: user._id.toString() });
        },
        conversations: async (user) => {
          return [];
        },
        serviceSubscriptions: async (user) => {
          return await ServiceSubscription.find({ userId: user._id.toString() });
        },
        serviceProvider: async (user) => {
          return await ServiceProvider.findOne({ userId: user._id.toString() });
        }
      }
    };
  }
});

// src/wallet/models/EnhancedWallet.ts
import mongoose24, { Schema as Schema22 } from "mongoose";
var CryptoCurrencySchema, FiatCurrencySchema, MobileMoneyAccountSchema, PaymentMethodSchema2, WalletTransactionSchema, EnhancedWalletSchema, EnhancedWallet;
var init_EnhancedWallet = __esm({
  "src/wallet/models/EnhancedWallet.ts"() {
    CryptoCurrencySchema = new Schema22({
      symbol: { type: String, required: true },
      name: { type: String, required: true },
      network: { type: String, required: true },
      balance: { type: Number, default: 0, min: 0 },
      lockedBalance: { type: Number, default: 0, min: 0 },
      walletAddress: { type: String, required: true },
      privateKey: { type: String },
      // Chiffré
      isActive: { type: Boolean, default: true },
      lastSyncAt: { type: Date, default: Date.now },
      metadata: {
        contractAddress: { type: String },
        decimals: { type: Number, default: 18 },
        logoUrl: { type: String },
        marketCap: { type: Number },
        currentPrice: { type: Number, default: 0 },
        priceChange24h: { type: Number, default: 0 },
        lastPriceUpdate: { type: Date, default: Date.now }
      }
    }, { _id: false });
    FiatCurrencySchema = new Schema22({
      symbol: { type: String, required: true },
      name: { type: String, required: true },
      balance: { type: Number, default: 0, min: 0 },
      lockedBalance: { type: Number, default: 0, min: 0 },
      isBaseCurrency: { type: Boolean, default: false },
      exchangeRate: { type: Number, default: 1 },
      lastExchangeUpdate: { type: Date, default: Date.now }
    }, { _id: false });
    MobileMoneyAccountSchema = new Schema22({
      id: { type: String, required: true },
      providerId: { type: String, required: true },
      providerName: { type: String, required: true },
      phoneNumber: { type: String, required: true },
      accountName: { type: String, required: true },
      countryCode: { type: String, required: true, maxlength: 2 },
      currency: { type: String, required: true, maxlength: 3 },
      isVerified: { type: Boolean, default: false },
      isDefault: { type: Boolean, default: false },
      balance: { type: Number, min: 0 },
      lastSyncAt: { type: Date },
      limits: {
        dailyLimit: { type: Number, required: true },
        monthlyLimit: { type: Number, required: true },
        currentDailyUsage: { type: Number, default: 0 },
        currentMonthlyUsage: { type: Number, default: 0 }
      },
      fees: {
        deposit: { type: Number, required: true },
        withdrawal: { type: Number, required: true },
        transfer: { type: Number, required: true }
      },
      metadata: {
        lastTransactionAt: { type: Date },
        totalTransactions: { type: Number, default: 0 },
        totalVolume: { type: Number, default: 0 },
        averageTransactionAmount: { type: Number, default: 0 }
      },
      createdAt: { type: Date, default: Date.now },
      updatedAt: { type: Date, default: Date.now }
    }, { _id: false });
    PaymentMethodSchema2 = new Schema22({
      id: { type: String, required: true },
      type: {
        type: String,
        required: true,
        enum: ["bank_card", "bank_transfer", "crypto_wallet", "paypal", "apple_pay", "google_pay", "stripe", "internal"]
      },
      name: { type: String, required: true },
      isDefault: { type: Boolean, default: false },
      isActive: { type: Boolean, default: true },
      cardDetails: {
        last4: { type: String },
        brand: { type: String },
        expiryMonth: { type: Number },
        expiryYear: { type: Number },
        holderName: { type: String }
      },
      bankDetails: {
        iban: { type: String },
        bankName: { type: String },
        accountHolderName: { type: String }
      },
      cryptoDetails: {
        walletAddress: { type: String },
        network: { type: String },
        currency: { type: String }
      },
      externalDetails: {
        providerId: { type: String },
        providerData: { type: Schema22.Types.Mixed }
      },
      lastUsedAt: { type: Date }
    }, {
      _id: false,
      timestamps: true
    });
    WalletTransactionSchema = new Schema22({
      id: { type: String, required: true, unique: true },
      type: {
        type: String,
        required: true,
        enum: ["deposit", "withdrawal", "payment", "received", "transfer", "exchange", "fee", "refund", "stake", "unstake"]
      },
      subType: {
        type: String,
        enum: ["rent", "purchase", "deposit_security", "service_fee", "commission", "bonus", "cashback"]
      },
      amount: { type: Number, required: true },
      currency: { type: String, required: true },
      feeAmount: { type: Number },
      feeCurrency: { type: String },
      cryptoAmount: { type: Number },
      cryptoCurrency: { type: String },
      exchangeRate: { type: Number },
      exchangeRateSource: { type: String },
      fromUserId: { type: String },
      toUserId: { type: String },
      fromAddress: { type: String },
      toAddress: { type: String },
      paymentMethodId: { type: String },
      externalTransactionId: { type: String },
      status: {
        type: String,
        default: "pending",
        enum: ["pending", "processing", "completed", "failed", "cancelled", "refunded"]
      },
      confirmations: { type: Number, default: 0 },
      requiredConfirmations: { type: Number },
      txHash: { type: String },
      blockHeight: { type: Number },
      gasUsed: { type: Number },
      gasPrice: { type: Number },
      propertyId: { type: String },
      reservationId: { type: String },
      contractId: { type: String },
      description: { type: String, required: true },
      internalNotes: { type: String },
      scheduledFor: { type: Date },
      completedAt: { type: Date },
      confirmedAt: { type: Date },
      ipAddress: { type: String },
      userAgent: { type: String },
      deviceFingerprint: { type: String }
    }, {
      _id: false,
      timestamps: true
    });
    EnhancedWalletSchema = new Schema22({
      userId: { type: String, required: true, unique: true, index: true },
      fiatCurrencies: [FiatCurrencySchema],
      cryptoCurrencies: [CryptoCurrencySchema],
      paymentMethods: [PaymentMethodSchema2],
      mobileMoneyAccounts: [MobileMoneyAccountSchema],
      transactions: [WalletTransactionSchema],
      settings: {
        baseCurrency: { type: String, default: "EUR" },
        autoConvert: { type: Boolean, default: false },
        notificationsEnabled: { type: Boolean, default: true },
        twoFactorEnabled: { type: Boolean, default: false },
        maxDailyLimit: { type: Number, default: 1e4 },
        maxTransactionLimit: { type: Number, default: 5e3 },
        allowedCountries: [{ type: String }],
        kycLevel: {
          type: String,
          default: "none",
          enum: ["none", "basic", "intermediate", "advanced"]
        },
        isBlocked: { type: Boolean, default: false },
        blockedReason: { type: String },
        blockedAt: { type: Date }
      },
      stats: {
        totalBalance: { type: Number, default: 0 },
        totalCryptoValue: { type: Number, default: 0 },
        totalFiatValue: { type: Number, default: 0 },
        totalGains: { type: Number, default: 0 },
        totalLosses: { type: Number, default: 0 },
        portfolioPerformance: { type: Number, default: 0 },
        transactionCount: {
          total: { type: Number, default: 0 },
          thisMonth: { type: Number, default: 0 },
          thisWeek: { type: Number, default: 0 },
          thisYear: { type: Number, default: 0 }
        },
        transactionVolume: {
          total: { type: Number, default: 0 },
          thisMonth: { type: Number, default: 0 },
          thisWeek: { type: Number, default: 0 },
          thisYear: { type: Number, default: 0 }
        },
        currencyDistribution: [{
          currency: { type: String },
          percentage: { type: Number },
          value: { type: Number }
        }],
        lastCalculatedAt: { type: Date, default: Date.now }
      },
      security: {
        lastPasswordChange: { type: Date, default: Date.now },
        lastSecurityCheck: { type: Date, default: Date.now },
        failedLoginAttempts: { type: Number, default: 0 },
        lastFailedLogin: { type: Date },
        securityScore: { type: Number, default: 50 },
        riskLevel: {
          type: String,
          default: "low",
          enum: ["low", "medium", "high"]
        },
        fraudAlerts: [{
          alertId: { type: String, required: true },
          type: { type: String, required: true },
          description: { type: String, required: true },
          severity: {
            type: String,
            required: true,
            enum: ["low", "medium", "high", "critical"]
          },
          resolved: { type: Boolean, default: false },
          resolvedAt: { type: Date }
        }]
      },
      compliance: {
        kycStatus: {
          type: String,
          default: "pending",
          enum: ["pending", "approved", "rejected", "expired"]
        },
        kycDocuments: [{ type: String }],
        amlChecks: [{
          checkId: { type: String, required: true },
          provider: { type: String, required: true },
          status: {
            type: String,
            required: true,
            enum: ["passed", "failed", "pending"]
          },
          score: { type: Number, required: true },
          details: { type: Schema22.Types.Mixed },
          checkedAt: { type: Date, default: Date.now }
        }],
        sanctionCheck: {
          isClean: { type: Boolean, default: true },
          lastChecked: { type: Date, default: Date.now },
          provider: { type: String, default: "internal" }
        }
      },
      lastActivityAt: { type: Date, default: Date.now }
    }, {
      timestamps: true,
      toJSON: { virtuals: true },
      toObject: { virtuals: true }
    });
    EnhancedWalletSchema.index({ userId: 1 });
    EnhancedWalletSchema.index({ "transactions.status": 1 });
    EnhancedWalletSchema.index({ "transactions.type": 1 });
    EnhancedWalletSchema.index({ "transactions.createdAt": -1 });
    EnhancedWalletSchema.index({ "cryptoCurrencies.symbol": 1 });
    EnhancedWalletSchema.index({ "fiatCurrencies.symbol": 1 });
    EnhancedWalletSchema.index({ lastActivityAt: -1 });
    EnhancedWalletSchema.virtual("totalPortfolioValue").get(function() {
      return this.stats.totalCryptoValue + this.stats.totalFiatValue;
    });
    EnhancedWalletSchema.methods.getTotalBalance = function(currency = "EUR") {
      let total = 0;
      this.fiatCurrencies.forEach((fiat) => {
        if (fiat.symbol === currency) {
          total += fiat.balance;
        } else {
          total += fiat.balance * fiat.exchangeRate;
        }
      });
      this.cryptoCurrencies.forEach((crypto7) => {
        total += crypto7.balance * crypto7.metadata.currentPrice;
      });
      return total;
    };
    EnhancedWalletSchema.methods.addTransaction = function(transaction) {
      const newTransaction = {
        ...transaction,
        id: transaction.id || `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      this.transactions.push(newTransaction);
      this.lastActivityAt = /* @__PURE__ */ new Date();
      return this.save();
    };
    EnhancedWalletSchema.methods.updateStats = async function() {
      const now = /* @__PURE__ */ new Date();
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay()));
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      this.stats.totalFiatValue = this.fiatCurrencies.reduce((sum, fiat) => sum + fiat.balance, 0);
      this.stats.totalCryptoValue = this.cryptoCurrencies.reduce((sum, crypto7) => sum + crypto7.balance * crypto7.metadata.currentPrice, 0);
      this.stats.totalBalance = this.stats.totalFiatValue + this.stats.totalCryptoValue;
      this.stats.transactionCount.total = this.transactions.length;
      this.stats.transactionCount.thisMonth = this.transactions.filter(
        (tx) => tx.createdAt >= startOfMonth
      ).length;
      this.stats.transactionCount.thisWeek = this.transactions.filter(
        (tx) => tx.createdAt >= startOfWeek
      ).length;
      this.stats.transactionCount.thisYear = this.transactions.filter(
        (tx) => tx.createdAt >= startOfYear
      ).length;
      this.stats.lastCalculatedAt = /* @__PURE__ */ new Date();
      return this.save();
    };
    EnhancedWallet = mongoose24.model("EnhancedWallet", EnhancedWalletSchema);
  }
});

// src/crypto/models/CryptoPayment.ts
import mongoose25, { Schema as Schema23 } from "mongoose";
var CryptoPaymentSchema, CryptoPayment;
var init_CryptoPayment = __esm({
  "src/crypto/models/CryptoPayment.ts"() {
    CryptoPaymentSchema = new Schema23({
      paymentId: { type: String, required: true, unique: true },
      userId: { type: String, required: true, index: true },
      propertyId: { type: String, required: true, index: true },
      paymentType: {
        type: String,
        required: true,
        enum: ["rent", "purchase", "deposit", "security_deposit", "service_fee"]
      },
      cryptocurrency: {
        type: String,
        required: true,
        enum: ["BTC", "ETH", "USDT", "USDC", "MATIC", "BNB"]
      },
      network: {
        type: String,
        required: true,
        enum: ["bitcoin", "ethereum", "polygon", "bsc"]
      },
      amount: { type: Number, required: true, min: 0 },
      amountFiat: { type: Number, required: true, min: 0 },
      fiatCurrency: { type: String, required: true, default: "USD" },
      exchangeRate: { type: Number, required: true, min: 0 },
      transactionHash: { type: String, required: true, unique: true },
      fromAddress: { type: String, required: true },
      toAddress: { type: String, required: true },
      blockHeight: { type: Number },
      confirmations: { type: Number, default: 0, min: 0 },
      gasUsed: { type: Number, min: 0 },
      gasPrice: { type: Number, min: 0 },
      status: {
        type: String,
        default: "pending",
        enum: ["pending", "confirming", "confirmed", "failed", "refunded"]
      },
      confirmationsRequired: { type: Number, default: 6, min: 1 },
      smartContractAddress: { type: String },
      smartContractFunction: { type: String },
      contractInteractionData: { type: Schema23.Types.Mixed },
      escrow: {
        isEscrow: { type: Boolean, default: false },
        escrowAddress: { type: String },
        releaseConditions: [{ type: String }],
        releaseDate: { type: Date },
        isReleased: { type: Boolean, default: false },
        releasedAt: { type: Date },
        releasedTo: { type: String }
      },
      recurring: {
        isRecurring: { type: Boolean, default: false },
        frequency: { type: String, enum: ["weekly", "monthly", "quarterly"] },
        nextPaymentDate: { type: Date },
        endDate: { type: Date },
        totalPayments: { type: Number, min: 1 },
        completedPayments: { type: Number, default: 0, min: 0 }
      },
      metadata: {
        propertyAddress: { type: String, required: true },
        landlordId: { type: String, required: true },
        leaseId: { type: String },
        paymentDescription: { type: String, required: true },
        invoiceNumber: { type: String }
      }
    }, {
      timestamps: true
    });
    CryptoPaymentSchema.index({ transactionHash: 1 });
    CryptoPaymentSchema.index({ userId: 1, status: 1 });
    CryptoPaymentSchema.index({ propertyId: 1, paymentType: 1 });
    CryptoPaymentSchema.index({ status: 1, createdAt: -1 });
    CryptoPaymentSchema.index({ "recurring.nextPaymentDate": 1 });
    CryptoPayment = mongoose25.model("CryptoPayment", CryptoPaymentSchema);
  }
});

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
var init_bind = __esm({
  "node_modules/axios/lib/helpers/bind.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/utils.js
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toString, getPrototypeOf, iterator, toStringTag, kindOf, kindOfTest, typeOfTest, isArray, isUndefined, isArrayBuffer, isString, isFunction, isNumber, isObject2, isBoolean, isPlainObject, isEmptyObject, isDate, isFile, isBlob2, isFileList, isStream, isFormData, isURLSearchParams2, isReadableStream, isRequest2, isResponse, isHeaders, trim, _global, isContextDefined, extend, stripBOM, inherits, toFlatObject, endsWith, toArray, isTypedArray, forEachEntry, matchAll, isHTMLForm, toCamelCase, hasOwnProperty2, isRegExp, reduceDescriptors, freezeMethods, toObjectSet, noop, toFiniteNumber, toJSONObject, isAsyncFn, isThenable, _setImmediate, asap, isIterable, utils_default;
var init_utils2 = __esm({
  "node_modules/axios/lib/utils.js"() {
    "use strict";
    init_bind();
    ({ toString } = Object.prototype);
    ({ getPrototypeOf } = Object);
    ({ iterator, toStringTag } = Symbol);
    kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    typeOfTest = (type) => (thing) => typeof thing === type;
    ({ isArray } = Array);
    isUndefined = typeOfTest("undefined");
    isArrayBuffer = kindOfTest("ArrayBuffer");
    isString = typeOfTest("string");
    isFunction = typeOfTest("function");
    isNumber = typeOfTest("number");
    isObject2 = (thing) => thing !== null && typeof thing === "object";
    isBoolean = (thing) => thing === true || thing === false;
    isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype3 = getPrototypeOf(val);
      return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
    };
    isEmptyObject = (val) => {
      if (!isObject2(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    isDate = kindOfTest("Date");
    isFile = kindOfTest("File");
    isBlob2 = kindOfTest("Blob");
    isFileList = kindOfTest("FileList");
    isStream = (val) => isObject2(val) && isFunction(val.pipe);
    isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    isURLSearchParams2 = kindOfTest("URLSearchParams");
    [isReadableStream, isRequest2, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    isContextDefined = (context) => !isUndefined(context) && context !== _global;
    extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    isHTMLForm = kindOfTest("HTMLFormElement");
    toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    hasOwnProperty2 = (({ hasOwnProperty: hasOwnProperty3 }) => (obj, prop) => hasOwnProperty3.call(obj, prop))(Object.prototype);
    isRegExp = kindOfTest("RegExp");
    reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    toObjectSet = (arrayOrString, delimiter2) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
      return obj;
    };
    noop = () => {
    };
    toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit3 = (source, i) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit3(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit3(obj, 0);
    };
    isAsyncFn = kindOfTest("AsyncFunction");
    isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    utils_default = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject: isObject2,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest: isRequest2,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty2,
      hasOwnProp: hasOwnProperty2,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config3, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config3 && (this.config = config3);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
var prototype, descriptors, AxiosError_default;
var init_AxiosError = __esm({
  "node_modules/axios/lib/core/AxiosError.js"() {
    "use strict";
    init_utils2();
    utils_default.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils_default.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    prototype = AxiosError.prototype;
    descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = (error2, code, config3, request, response, customProps) => {
      const axiosError = Object.create(prototype);
      utils_default.toFlatObject(error2, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error2 && error2.message ? error2.message : "Error";
      const errCode = code == null && error2 ? error2.code : code;
      AxiosError.call(axiosError, msg, errCode, config3, request, response);
      if (error2 && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error2, configurable: true });
      }
      axiosError.name = error2 && error2.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_default = AxiosError;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
    var Stream2 = __require("stream").Stream;
    var util3 = __require("util");
    module.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream2);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream2.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
    var util3 = __require("util");
    var Stream2 = __require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream2);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream2.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/form-data/node_modules/mime-db/db.json
var require_db2 = __commonJS({
  "node_modules/form-data/node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/form-data/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/form-data/node_modules/mime-db/index.js"(exports, module) {
    module.exports = require_db2();
  }
});

// node_modules/form-data/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/form-data/node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = __require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path4) {
      if (!path4 || typeof path4 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path4).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module) {
    module.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module) {
    var defer = require_defer();
    module.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module) {
    module.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module) {
    var async = require_async();
    var abort = require_abort();
    module.exports = iterate;
    function iterate(list, iterator2, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator2, key, list[key], function(error2, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error2) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error2, state.results);
      });
    }
    function runJob(iterator2, key, item, callback) {
      var aborter;
      if (iterator2.length == 2) {
        aborter = iterator2(item, async(callback));
      } else {
        aborter = iterator2(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module) {
    module.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module) {
    var abort = require_abort();
    var async = require_async();
    module.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = parallel;
    function parallel(list, iterator2, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, function(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module.exports = serialOrdered;
    module.exports.ascending = ascending;
    module.exports.descending = descending;
    function serialOrdered(list, iterator2, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator2, state, function iteratorHandler(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator2, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module) {
    var serialOrdered = require_serialOrdered();
    module.exports = serial;
    function serial(list, iterator2, callback) {
      return serialOrdered(list, iterator2, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module) {
    module.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign2(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind2 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind2.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind2 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind2, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind2 = require_function_bind();
    module.exports = bind2.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor2 = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign2 = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor2,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign2,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind2.call($call, Array.prototype.concat);
    var $spliceApply = bind2.call($apply, Array.prototype.splice);
    var $replace = bind2.call($call, String.prototype.replace);
    var $strSlice = bind2.call($call, String.prototype.slice);
    var $exec = bind2.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
    module.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag2, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag2] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module) {
    "use strict";
    module.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util3 = __require("util");
    var path4 = __require("path");
    var http4 = __require("http");
    var https3 = __require("https");
    var parseUrl = __require("url").parse;
    var fs2 = __require("fs");
    var Stream2 = __require("stream").Stream;
    var crypto7 = __require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util3.inherits(FormData3, CombinedStream);
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream2)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs2.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path4.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path4.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path4.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto7.randomBytes(12).toString("hex");
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults2 = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https3.request(options);
      } else {
        request = http4.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error2, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error2, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData3, "FormData");
    module.exports = FormData3;
  }
});

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data, FormData_default;
var init_FormData = __esm({
  "node_modules/axios/lib/platform/node/classes/FormData.js"() {
    import_form_data = __toESM(require_form_data(), 1);
    FormData_default = import_form_data.default;
  }
});

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path4, key, dots) {
  if (!path4) return key;
  return path4.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path4) {
    let arr = value;
    if (value && !path4 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path4, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path4) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path4.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path4,
        exposedHelpers
      );
      if (result === true) {
        build(el, path4 ? path4.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var predicates, toFormData_default;
var init_toFormData = __esm({
  "node_modules/axios/lib/helpers/toFormData.js"() {
    "use strict";
    init_utils2();
    init_AxiosError();
    init_FormData();
    predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    toFormData_default = toFormData;
  }
});

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2, AxiosURLSearchParams_default;
var init_AxiosURLSearchParams = __esm({
  "node_modules/axios/lib/helpers/AxiosURLSearchParams.js"() {
    "use strict";
    init_toFormData();
    prototype2 = AxiosURLSearchParams.prototype;
    prototype2.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype2.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode2);
      } : encode2;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    AxiosURLSearchParams_default = AxiosURLSearchParams;
  }
});

// node_modules/axios/lib/helpers/buildURL.js
function encode3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode3;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
var init_buildURL = __esm({
  "node_modules/axios/lib/helpers/buildURL.js"() {
    "use strict";
    init_utils2();
    init_AxiosURLSearchParams();
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager, InterceptorManager_default;
var init_InterceptorManager = __esm({
  "node_modules/axios/lib/core/InterceptorManager.js"() {
    "use strict";
    init_utils2();
    InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils_default.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    InterceptorManager_default = InterceptorManager;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var transitional_default;
var init_transitional = __esm({
  "node_modules/axios/lib/defaults/transitional.js"() {
    "use strict";
    transitional_default = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default;
var init_URLSearchParams = __esm({
  "node_modules/axios/lib/platform/node/classes/URLSearchParams.js"() {
    "use strict";
    URLSearchParams_default = url.URLSearchParams;
  }
});

// node_modules/axios/lib/platform/node/index.js
import crypto4 from "crypto";
var ALPHA, DIGIT, ALPHABET, generateString, node_default;
var init_node = __esm({
  "node_modules/axios/lib/platform/node/index.js"() {
    init_URLSearchParams();
    init_FormData();
    ALPHA = "abcdefghijklmnopqrstuvwxyz";
    DIGIT = "0123456789";
    ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto4.randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    node_default = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams_default,
        FormData: FormData_default,
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
  }
});

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv, _navigator, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, origin;
var init_utils3 = __esm({
  "node_modules/axios/lib/platform/common/utils.js"() {
    hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    _navigator = typeof navigator === "object" && navigator || void 0;
    hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    origin = hasBrowserEnv && window.location.href || "http://localhost";
  }
});

// node_modules/axios/lib/platform/index.js
var platform_default;
var init_platform = __esm({
  "node_modules/axios/lib/platform/index.js"() {
    init_node();
    init_utils3();
    platform_default = {
      ...utils_exports,
      ...node_default
    };
  }
});

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path4, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
var init_toURLEncodedForm = __esm({
  "node_modules/axios/lib/helpers/toURLEncodedForm.js"() {
    "use strict";
    init_utils2();
    init_toFormData();
    init_platform();
  }
});

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path4, value, target, index) {
    let name = path4[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path4.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path4, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default;
var init_formDataToJSON = __esm({
  "node_modules/axios/lib/helpers/formDataToJSON.js"() {
    "use strict";
    init_utils2();
    formDataToJSON_default = formDataToJSON;
  }
});

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults, defaults_default;
var init_defaults = __esm({
  "node_modules/axios/lib/defaults/index.js"() {
    "use strict";
    init_utils2();
    init_AxiosError();
    init_transitional();
    init_toFormData();
    init_toURLEncodedForm();
    init_platform();
    init_formDataToJSON();
    defaults = {
      transitional: transitional_default,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils_default.isObject(data);
        if (isObjectPayload && utils_default.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils_default.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
        }
        if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
          return data;
        }
        if (utils_default.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils_default.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData_default(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional2 = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
          return data;
        }
        if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform_default.classes.FormData,
        Blob: platform_default.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    defaults_default = defaults;
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf, parseHeaders_default;
var init_parseHeaders = __esm({
  "node_modules/axios/lib/helpers/parseHeaders.js"() {
    "use strict";
    init_utils2();
    ignoreDuplicateOf = utils_default.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    parseHeaders_default = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/core/AxiosHeaders.js
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var $internals, isValidHeaderName, AxiosHeaders, AxiosHeaders_default;
var init_AxiosHeaders = __esm({
  "node_modules/axios/lib/core/AxiosHeaders.js"() {
    "use strict";
    init_utils2();
    init_parseHeaders();
    $internals = Symbol("internals");
    isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils_default.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders_default(header), valueOrRewrite);
        } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils_default.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils_default.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils_default.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils_default.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils_default.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils_default.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils_default.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils_default.forEach(this, (value, header) => {
          const key = utils_default.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils_default.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype3 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype3, _header);
            accessors[lHeader] = true;
          }
        }
        utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils_default.freezeMethods(AxiosHeaders);
    AxiosHeaders_default = AxiosHeaders;
  }
});

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config3 = this || defaults_default;
  const context = response || config3;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config3, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
var init_transformData = __esm({
  "node_modules/axios/lib/core/transformData.js"() {
    "use strict";
    init_utils2();
    init_defaults();
    init_AxiosHeaders();
  }
});

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
var init_isCancel = __esm({
  "node_modules/axios/lib/cancel/isCancel.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config3, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config3, request);
  this.name = "CanceledError";
}
var CanceledError_default;
var init_CanceledError = __esm({
  "node_modules/axios/lib/cancel/CanceledError.js"() {
    "use strict";
    init_AxiosError();
    init_utils2();
    utils_default.inherits(CanceledError, AxiosError_default, {
      __CANCEL__: true
    });
    CanceledError_default = CanceledError;
  }
});

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
var init_settle = __esm({
  "node_modules/axios/lib/core/settle.js"() {
    "use strict";
    init_AxiosError();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
var init_isAbsoluteURL = __esm({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
var init_combineURLs = __esm({
  "node_modules/axios/lib/helpers/combineURLs.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var init_buildFullPath = __esm({
  "node_modules/axios/lib/core/buildFullPath.js"() {
    "use strict";
    init_isAbsoluteURL();
    init_combineURLs();
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = __require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module) {
    var debug;
    module.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module) {
    var url2 = __require("url");
    var URL3 = url2.URL;
    var http4 = __require("http");
    var https3 = __require("https");
    var Writable = __require("stream").Writable;
    var assert = __require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction3(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL3(""));
    } catch (error2) {
      useNativeURL = error2.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop2;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error2) {
      destroyRequest(this._currentRequest, error2);
      destroy.call(this, error2);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction3(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction3(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property2) {
      Object.defineProperty(RedirectableRequest.prototype, property2, {
        get: function() {
          return this._currentRequest[property2];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction3(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap2(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction3(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop2() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL3(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base2) {
      return useNativeURL ? new URL3(relative, base2) : parseUrl(url2.resolve(base2, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key of preservedUrlFields) {
        spread3[key] = urlObject[key];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction3(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error2) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.destroy(error2);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction3(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL3 && value instanceof URL3;
    }
    module.exports = wrap2({ http: http4, https: https3 });
    module.exports.wrap = wrap2;
  }
});

// node_modules/axios/lib/env/data.js
var VERSION;
var init_data = __esm({
  "node_modules/axios/lib/env/data.js"() {
    VERSION = "1.12.2";
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
var init_parseProtocol = __esm({
  "node_modules/axios/lib/helpers/parseProtocol.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/fromDataURI.js
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body3 = match[3];
    const buffer = Buffer.from(decodeURIComponent(body3), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}
var DATA_URL_PATTERN;
var init_fromDataURI = __esm({
  "node_modules/axios/lib/helpers/fromDataURI.js"() {
    "use strict";
    init_AxiosError();
    init_parseProtocol();
    init_platform();
    DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  }
});

// node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";
var kInternals, AxiosTransformStream, AxiosTransformStream_default;
var init_AxiosTransformStream = __esm({
  "node_modules/axios/lib/helpers/AxiosTransformStream.js"() {
    "use strict";
    init_utils2();
    kInternals = Symbol("internals");
    AxiosTransformStream = class extends stream.Transform {
      constructor(options) {
        options = utils_default.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils_default.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    AxiosTransformStream_default = AxiosTransformStream;
  }
});

// node_modules/axios/lib/helpers/readBlob.js
var asyncIterator, readBlob, readBlob_default;
var init_readBlob = __esm({
  "node_modules/axios/lib/helpers/readBlob.js"() {
    ({ asyncIterator } = Symbol);
    readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    readBlob_default = readBlob;
  }
});

// node_modules/axios/lib/helpers/formDataToStream.js
import util from "util";
import { Readable as Readable2 } from "stream";
var BOUNDARY_ALPHABET, textEncoder, CRLF, CRLF_BYTES, CRLF_BYTES_COUNT, FormDataPart, formDataToStream, formDataToStream_default;
var init_formDataToStream = __esm({
  "node_modules/axios/lib/helpers/formDataToStream.js"() {
    init_utils2();
    init_readBlob();
    init_platform();
    BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
    textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util.TextEncoder();
    CRLF = "\r\n";
    CRLF_BYTES = textEncoder.encode(CRLF);
    CRLF_BYTES_COUNT = 2;
    FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils_default.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils_default.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob_default(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils_default.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils_default.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return Readable2.from(async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      }());
    };
    formDataToStream_default = formDataToStream;
  }
});

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";
var ZlibHeaderTransformStream, ZlibHeaderTransformStream_default;
var init_ZlibHeaderTransformStream = __esm({
  "node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js"() {
    "use strict";
    ZlibHeaderTransformStream = class extends stream2.Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;
  }
});

// node_modules/axios/lib/helpers/callbackify.js
var callbackify, callbackify_default;
var init_callbackify = __esm({
  "node_modules/axios/lib/helpers/callbackify.js"() {
    init_utils2();
    callbackify = (fn, reducer) => {
      return utils_default.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    callbackify_default = callbackify;
  }
});

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default;
var init_speedometer = __esm({
  "node_modules/axios/lib/helpers/speedometer.js"() {
    "use strict";
    speedometer_default = speedometer;
  }
});

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default;
var init_throttle = __esm({
  "node_modules/axios/lib/helpers/throttle.js"() {
    throttle_default = throttle;
  }
});

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer, progressEventDecorator, asyncDecorator;
var init_progressEventReducer = __esm({
  "node_modules/axios/lib/helpers/progressEventReducer.js"() {
    init_speedometer();
    init_throttle();
    init_utils2();
    progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer_default(50, 250);
      return throttle_default((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));
  }
});

// node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string") return 0;
  if (!url2.startsWith("data:")) return 0;
  const comma = url2.indexOf(",");
  if (comma < 0) return 0;
  const meta = url2.slice(5, comma);
  const body3 = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body3.length;
    const len = body3.length;
    for (let i = 0; i < len; i++) {
      if (body3.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body3.charCodeAt(i + 1);
        const b = body3.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body3.charCodeAt(j - 2) === 37 && // '%'
    body3.charCodeAt(j - 1) === 51 && // '3'
    (body3.charCodeAt(j) === 68 || body3.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body3.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body3.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body3, "utf8");
}
var init_estimateDataURLDecodedBytes = __esm({
  "node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js"() {
  }
});

// node_modules/axios/lib/adapters/http.js
import http2 from "http";
import https2 from "https";
import util2 from "util";
import zlib2 from "zlib";
import stream3 from "stream";
import { EventEmitter } from "events";
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var import_proxy_from_env, import_follow_redirects, zlibOptions, brotliOptions, isBrotliSupported, httpFollow, httpsFollow, isHttps, supportedProtocols, flushOnFinish, isHttpAdapterSupported, wrapAsync, resolveFamily, buildAddressEntry, http_default;
var init_http = __esm({
  "node_modules/axios/lib/adapters/http.js"() {
    "use strict";
    init_utils2();
    init_settle();
    init_buildFullPath();
    init_buildURL();
    import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
    import_follow_redirects = __toESM(require_follow_redirects(), 1);
    init_data();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_platform();
    init_fromDataURI();
    init_AxiosHeaders();
    init_AxiosTransformStream();
    init_formDataToStream();
    init_readBlob();
    init_ZlibHeaderTransformStream();
    init_callbackify();
    init_progressEventReducer();
    init_estimateDataURLDecodedBytes();
    zlibOptions = {
      flush: zlib2.constants.Z_SYNC_FLUSH,
      finishFlush: zlib2.constants.Z_SYNC_FLUSH
    };
    brotliOptions = {
      flush: zlib2.constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib2.constants.BROTLI_OPERATION_FLUSH
    };
    isBrotliSupported = utils_default.isFunction(zlib2.createBrotliDecompress);
    ({ http: httpFollow, https: httpsFollow } = import_follow_redirects.default);
    isHttps = /https:?/;
    supportedProtocols = platform_default.protocols.map((protocol) => {
      return protocol + ":";
    });
    flushOnFinish = (stream4, [throttled, flush]) => {
      stream4.on("end", flush).on("error", flush);
      return throttled;
    };
    isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
    wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    resolveFamily = ({ address, family }) => {
      if (!utils_default.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
    http_default = isHttpAdapterSupported && function httpAdapter(config3) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family } = config3;
        const { responseType, responseEncoding } = config3;
        const method = config3.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        if (lookup) {
          const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const emitter = new EventEmitter();
        const onFinished = () => {
          if (config3.cancelToken) {
            config3.cancelToken.unsubscribe(abort);
          }
          if (config3.signal) {
            config3.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        };
        onDone((value, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
        });
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config3, req) : reason);
        }
        emitter.once("abort", reject);
        if (config3.cancelToken || config3.signal) {
          config3.cancelToken && config3.cancelToken.subscribe(abort);
          if (config3.signal) {
            config3.signal.aborted ? abort() : config3.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config3.maxContentLength > -1) {
            const dataUrl = String(config3.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config3.maxContentLength) {
              return reject(new AxiosError_default(
                "maxContentLength size of " + config3.maxContentLength + " exceeded",
                AxiosError_default.ERR_BAD_RESPONSE,
                config3
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config: config3
            });
          }
          try {
            convertedData = fromDataURI(config3.url, responseType === "blob", {
              Blob: config3.env && config3.env.Blob
            });
          } catch (err) {
            throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config3);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils_default.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream3.Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders_default(),
            config: config3
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError_default(
            "Unsupported protocol " + protocol,
            AxiosError_default.ERR_BAD_REQUEST,
            config3
          ));
        }
        const headers = AxiosHeaders_default.from(config3.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config3;
        const maxRate = config3.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils_default.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream_default(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util2.promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream3.Readable.from(readBlob_default(data));
        } else if (data && !utils_default.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils_default.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils_default.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError_default(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError_default.ERR_BAD_REQUEST,
              config3
            ));
          }
          headers.setContentLength(data.length, false);
          if (config3.maxBodyLength > -1 && data.length > config3.maxBodyLength) {
            return reject(new AxiosError_default(
              "Request body larger than maxBodyLength limit",
              AxiosError_default.ERR_BAD_REQUEST,
              config3
            ));
          }
        }
        const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
        if (utils_default.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils_default.isStream(data)) {
            data = stream3.Readable.from(data, { objectMode: false });
          }
          data = stream3.pipeline([data, new AxiosTransformStream_default({
            maxRate: utils_default.toFiniteNumber(maxUploadRate)
          })], utils_default.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config3.auth) {
          const username = config3.auth.username || "";
          const password = config3.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path4;
        try {
          path4 = buildURL(
            parsed.pathname + parsed.search,
            config3.params,
            config3.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config3;
          customErr.url = config3.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path: path4,
          method,
          headers: headers.toJSON(),
          agents: { http: config3.httpAgent, https: config3.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        !utils_default.isUndefined(lookup) && (options.lookup = lookup);
        if (config3.socketPath) {
          options.socketPath = config3.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config3.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config3.httpsAgent : config3.httpAgent;
        if (config3.transport) {
          transport = config3.transport;
        } else if (config3.maxRedirects === 0) {
          transport = isHttpsRequest ? https2 : http2;
        } else {
          if (config3.maxRedirects) {
            options.maxRedirects = config3.maxRedirects;
          }
          if (config3.beforeRedirect) {
            options.beforeRedirects.config = config3.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config3.maxBodyLength > -1) {
          options.maxBodyLength = config3.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config3.insecureHTTPParser) {
          options.insecureHTTPParser = config3.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = +res.headers["content-length"];
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream_default({
              maxRate: utils_default.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config3.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib2.createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream_default());
                streams.push(zlib2.createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib2.createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
          const offListeners = stream3.finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders_default(res.headers),
            config: config3,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config3.maxContentLength > -1 && totalResponseBytes > config3.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError_default(
                  "maxContentLength size of " + config3.maxContentLength + " exceeded",
                  AxiosError_default.ERR_BAD_RESPONSE,
                  config3,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError_default(
                "stream has been aborted",
                AxiosError_default.ERR_BAD_RESPONSE,
                config3,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError_default.from(err, null, config3, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils_default.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError_default.from(err, null, config3, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError_default.from(err, null, config3, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config3.timeout) {
          const timeout = parseInt(config3.timeout, 10);
          if (Number.isNaN(timeout)) {
            reject(new AxiosError_default(
              "error trying to parse `config.timeout` to int",
              AxiosError_default.ERR_BAD_OPTION_VALUE,
              config3,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = config3.transitional || transitional_default;
            if (config3.timeoutErrorMessage) {
              timeoutErrorMessage = config3.timeoutErrorMessage;
            }
            reject(new AxiosError_default(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
              config3,
              req
            ));
            abort();
          });
        }
        if (utils_default.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError_default("Request stream has been aborted", config3, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default;
var init_isURLSameOrigin = __esm({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"() {
    init_platform();
    isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform_default.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform_default.origin),
      platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
    ) : () => true;
  }
});

// node_modules/axios/lib/helpers/cookies.js
var cookies_default;
var init_cookies = __esm({
  "node_modules/axios/lib/helpers/cookies.js"() {
    init_utils2();
    init_platform();
    cookies_default = platform_default.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path4, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils_default.isString(path4) && cookie.push("path=" + path4);
          utils_default.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
  }
});

// node_modules/axios/lib/core/mergeConfig.js
function mergeConfig(config1, config22) {
  config22 = config22 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config22) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config22 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config22[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
var headersToObject;
var init_mergeConfig = __esm({
  "node_modules/axios/lib/core/mergeConfig.js"() {
    "use strict";
    init_utils2();
    init_AxiosHeaders();
    headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
  }
});

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default;
var init_resolveConfig = __esm({
  "node_modules/axios/lib/helpers/resolveConfig.js"() {
    init_platform();
    init_utils2();
    init_isURLSameOrigin();
    init_cookies();
    init_buildFullPath();
    init_mergeConfig();
    init_AxiosHeaders();
    init_buildURL();
    resolveConfig_default = (config3) => {
      const newConfig = mergeConfig({}, config3);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders_default.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config3.params, config3.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils_default.isFormData(data)) {
        if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils_default.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform_default.hasStandardBrowserEnv) {
        withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported, xhr_default;
var init_xhr = __esm({
  "node_modules/axios/lib/adapters/xhr.js"() {
    init_utils2();
    init_settle();
    init_transitional();
    init_AxiosError();
    init_CanceledError();
    init_parseProtocol();
    init_platform();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    xhr_default = isXHRAdapterSupported && function(config3) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig_default(config3);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders_default.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config3,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config3, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config3, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional2 = _config.transitional || transitional_default;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError_default(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
            config3,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils_default.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError_default(null, config3, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config3));
          return;
        }
        request.send(requestData || null);
      });
    };
  }
});

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals, composeSignals_default;
var init_composeSignals = __esm({
  "node_modules/axios/lib/helpers/composeSignals.js"() {
    init_CanceledError();
    init_AxiosError();
    init_utils2();
    composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils_default.asap(unsubscribe);
        return signal;
      }
    };
    composeSignals_default = composeSignals;
  }
});

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk, readBytes, readStream, trackStream;
var init_trackStream = __esm({
  "node_modules/axios/lib/helpers/trackStream.js"() {
    streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    readStream = async function* (stream4) {
      if (stream4[Symbol.asyncIterator]) {
        yield* stream4;
        return;
      }
      const reader = stream4.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    trackStream = (stream4, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream4, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
  }
});

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE, isFunction2, globalFetchAPI, ReadableStream2, TextEncoder2, test, factory, seedCache, getFetch, adapter;
var init_fetch = __esm({
  "node_modules/axios/lib/adapters/fetch.js"() {
    init_platform();
    init_utils2();
    init_AxiosError();
    init_composeSignals();
    init_trackStream();
    init_AxiosHeaders();
    init_progressEventReducer();
    init_resolveConfig();
    init_settle();
    DEFAULT_CHUNK_SIZE = 64 * 1024;
    ({ isFunction: isFunction2 } = utils_default);
    globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
      Request: Request2,
      Response: Response2
    }))(utils_default.global);
    ({
      ReadableStream: ReadableStream2,
      TextEncoder: TextEncoder2
    } = utils_default.global);
    test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    factory = (env2) => {
      env2 = utils_default.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env2);
      const { fetch: envFetch, Request: Request2, Response: Response2 } = env2;
      const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction2(Request2);
      const isResponseSupported = isFunction2(Response2);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
      const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request2(platform_default.origin, {
          body: new ReadableStream2(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response2("").body));
      const resolvers2 = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers2[type] && (resolvers2[type] = (res, config3) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config3);
          });
        });
      })();
      const getBodyLength = async (body3) => {
        if (body3 == null) {
          return 0;
        }
        if (utils_default.isBlob(body3)) {
          return body3.size;
        }
        if (utils_default.isSpecCompliantForm(body3)) {
          const _request = new Request2(platform_default.origin, {
            method: "POST",
            body: body3
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils_default.isArrayBufferView(body3) || utils_default.isArrayBuffer(body3)) {
          return body3.byteLength;
        }
        if (utils_default.isURLSearchParams(body3)) {
          body3 = body3 + "";
        }
        if (utils_default.isString(body3)) {
          return (await encodeText(body3)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body3) => {
        const length = utils_default.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body3) : length;
      };
      return async (config3) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig_default(config3);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request2(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils_default.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request2(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response2(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers2[utils_default.findKey(resolvers2, responseType) || "text"](response, config3);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders_default.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config3,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config3, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError_default.from(err, err && err.code, config3, request);
        }
      };
    };
    seedCache = /* @__PURE__ */ new Map();
    getFetch = (config3) => {
      let env2 = config3 ? config3.env : {};
      const { fetch: fetch3, Request: Request2, Response: Response2 } = env2;
      const seeds = [
        Request2,
        Response2,
        fetch3
      ];
      let len = seeds.length, i = len, seed, target, map2 = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map2.get(seed);
        target === void 0 && map2.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env2));
        map2 = target;
      }
      return target;
    };
    adapter = getFetch();
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters, renderReason, isResolvedHandle, adapters_default;
var init_adapters = __esm({
  "node_modules/axios/lib/adapters/adapters.js"() {
    init_utils2();
    init_http();
    init_xhr();
    init_fetch();
    init_AxiosError();
    knownAdapters = {
      http: http_default,
      xhr: xhr_default,
      fetch: {
        get: getFetch
      }
    };
    utils_default.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    renderReason = (reason) => `- ${reason}`;
    isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
    adapters_default = {
      getAdapter: (adapters, config3) => {
        adapters = utils_default.isArray(adapters) ? adapters : [adapters];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter2;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters[i];
          let id;
          adapter2 = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter2 === void 0) {
              throw new AxiosError_default(`Unknown adapter '${id}'`);
            }
          }
          if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config3)))) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter2;
        }
        if (!adapter2) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError_default(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter2;
      },
      adapters: knownAdapters
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config3) {
  if (config3.cancelToken) {
    config3.cancelToken.throwIfRequested();
  }
  if (config3.signal && config3.signal.aborted) {
    throw new CanceledError_default(null, config3);
  }
}
function dispatchRequest(config3) {
  throwIfCancellationRequested(config3);
  config3.headers = AxiosHeaders_default.from(config3.headers);
  config3.data = transformData.call(
    config3,
    config3.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config3.method) !== -1) {
    config3.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config3.adapter || defaults_default.adapter, config3);
  return adapter2(config3).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config3);
    response.data = transformData.call(
      config3,
      config3.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config3);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config3,
          config3.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var init_dispatchRequest = __esm({
  "node_modules/axios/lib/core/dispatchRequest.js"() {
    "use strict";
    init_transformData();
    init_isCancel();
    init_defaults();
    init_CanceledError();
    init_AxiosHeaders();
    init_adapters();
  }
});

// node_modules/axios/lib/helpers/validator.js
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validators, deprecatedWarnings, validator_default;
var init_validator = __esm({
  "node_modules/axios/lib/helpers/validator.js"() {
    "use strict";
    init_data();
    init_AxiosError();
    validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    deprecatedWarnings = {};
    validators.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError_default(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError_default.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    validator_default = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var validators2, Axios, Axios_default;
var init_Axios = __esm({
  "node_modules/axios/lib/core/Axios.js"() {
    "use strict";
    init_utils2();
    init_buildURL();
    init_InterceptorManager();
    init_dispatchRequest();
    init_mergeConfig();
    init_buildFullPath();
    init_validator();
    init_AxiosHeaders();
    validators2 = validator_default.validators;
    Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager_default(),
          response: new InterceptorManager_default()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config3) {
        try {
          return await this._request(configOrUrl, config3);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config3) {
        if (typeof configOrUrl === "string") {
          config3 = config3 || {};
          config3.url = configOrUrl;
        } else {
          config3 = configOrUrl || {};
        }
        config3 = mergeConfig(this.defaults, config3);
        const { transitional: transitional2, paramsSerializer, headers } = config3;
        if (transitional2 !== void 0) {
          validator_default.assertOptions(transitional2, {
            silentJSONParsing: validators2.transitional(validators2.boolean),
            forcedJSONParsing: validators2.transitional(validators2.boolean),
            clarifyTimeoutError: validators2.transitional(validators2.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils_default.isFunction(paramsSerializer)) {
            config3.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator_default.assertOptions(paramsSerializer, {
              encode: validators2.function,
              serialize: validators2.function
            }, true);
          }
        }
        if (config3.allowAbsoluteUrls !== void 0) {
        } else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config3.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config3.allowAbsoluteUrls = true;
        }
        validator_default.assertOptions(config3, {
          baseUrl: validators2.spelling("baseURL"),
          withXsrfToken: validators2.spelling("withXSRFToken")
        }, true);
        config3.method = (config3.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils_default.merge(
          headers.common,
          headers[config3.method]
        );
        headers && utils_default.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config3.headers = AxiosHeaders_default.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config3);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config3;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error2) {
            onRejected.call(this, error2);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error2) {
          return Promise.reject(error2);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config3) {
        config3 = mergeConfig(this.defaults, config3);
        const fullPath = buildFullPath(config3.baseURL, config3.url, config3.allowAbsoluteUrls);
        return buildURL(fullPath, config3.params, config3.paramsSerializer);
      }
    };
    utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config3) {
        return this.request(mergeConfig(config3 || {}, {
          method,
          url: url2,
          data: (config3 || {}).data
        }));
      };
    });
    utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config3) {
          return this.request(mergeConfig(config3 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    Axios_default = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken, CancelToken_default;
var init_CancelToken = __esm({
  "node_modules/axios/lib/cancel/CancelToken.js"() {
    "use strict";
    init_CanceledError();
    CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config3, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError_default(message, config3, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    CancelToken_default = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
var init_spread = __esm({
  "node_modules/axios/lib/helpers/spread.js"() {
    "use strict";
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var init_isAxiosError = __esm({
  "node_modules/axios/lib/helpers/isAxiosError.js"() {
    "use strict";
    init_utils2();
  }
});

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode, HttpStatusCode_default;
var init_HttpStatusCode = __esm({
  "node_modules/axios/lib/helpers/HttpStatusCode.js"() {
    HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    HttpStatusCode_default = HttpStatusCode;
  }
});

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios, axios_default;
var init_axios = __esm({
  "node_modules/axios/lib/axios.js"() {
    "use strict";
    init_utils2();
    init_bind();
    init_Axios();
    init_mergeConfig();
    init_defaults();
    init_formDataToJSON();
    init_CanceledError();
    init_CancelToken();
    init_isCancel();
    init_data();
    init_toFormData();
    init_AxiosError();
    init_spread();
    init_isAxiosError();
    init_AxiosHeaders();
    init_adapters();
    init_HttpStatusCode();
    axios = createInstance(defaults_default);
    axios.Axios = Axios_default;
    axios.CanceledError = CanceledError_default;
    axios.CancelToken = CancelToken_default;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData_default;
    axios.AxiosError = AxiosError_default;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders_default;
    axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters_default.getAdapter;
    axios.HttpStatusCode = HttpStatusCode_default;
    axios.default = axios;
    axios_default = axios;
  }
});

// node_modules/axios/index.js
var Axios2, AxiosError2, CanceledError2, isCancel2, CancelToken2, VERSION2, all2, Cancel, isAxiosError2, spread2, toFormData2, AxiosHeaders2, HttpStatusCode2, formToJSON, getAdapter, mergeConfig2;
var init_axios2 = __esm({
  "node_modules/axios/index.js"() {
    init_axios();
    ({
      Axios: Axios2,
      AxiosError: AxiosError2,
      CanceledError: CanceledError2,
      isCancel: isCancel2,
      CancelToken: CancelToken2,
      VERSION: VERSION2,
      all: all2,
      Cancel,
      isAxiosError: isAxiosError2,
      spread: spread2,
      toFormData: toFormData2,
      AxiosHeaders: AxiosHeaders2,
      HttpStatusCode: HttpStatusCode2,
      formToJSON,
      getAdapter,
      mergeConfig: mergeConfig2
    } = axios_default);
  }
});

// src/crypto/config/CryptoConfig.ts
var CryptoConfig;
var init_CryptoConfig = __esm({
  "src/crypto/config/CryptoConfig.ts"() {
    CryptoConfig = class {
      constructor() {
        __publicField(this, "supportedCurrencies");
        __publicField(this, "networks");
        __publicField(this, "apiUrl");
        __publicField(this, "apiKey");
        this.supportedCurrencies = process.env.CRYPTO_SUPPORTED_CURRENCIES?.split(",") || [
          "BTC",
          "ETH",
          "LTC",
          "BCH",
          "XRP",
          "ADA",
          "USDT",
          "USDC"
        ];
        this.networks = {
          BTC: "bitcoin",
          ETH: "ethereum",
          LTC: "litecoin",
          BCH: "bitcoin-cash",
          XRP: "ripple",
          ADA: "cardano",
          USDT: "ethereum",
          USDC: "ethereum"
        };
        this.apiUrl = process.env.CRYPTO_API_URL || "https://api.coingecko.com/api/v3";
        this.apiKey = process.env.CRYPTO_API_KEY;
      }
      isSupportedCurrency(currency) {
        return this.supportedCurrencies.includes(currency.toUpperCase());
      }
      getNetwork(currency) {
        return this.networks[currency.toUpperCase()];
      }
    };
  }
});

// src/wallet/services/PriceService.ts
var PriceService;
var init_PriceService = __esm({
  "src/wallet/services/PriceService.ts"() {
    init_axios2();
    init_CryptoConfig();
    PriceService = class {
      // 5 minutes
      constructor() {
        __publicField(this, "cryptoConfig");
        __publicField(this, "cache", /* @__PURE__ */ new Map());
        __publicField(this, "cacheTimeout", 5 * 60 * 1e3);
        this.cryptoConfig = new CryptoConfig();
      }
      async convertCurrency(fromCurrency, toCurrency, amount) {
        try {
          const cacheKey = `${fromCurrency}-${toCurrency}`;
          const cached = this.cache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            const rate = cached.data.rate;
            return {
              fromCurrency,
              toCurrency,
              fromAmount: amount,
              toAmount: amount * rate,
              rate,
              timestamp: /* @__PURE__ */ new Date(),
              provider: "cache"
            };
          }
          if (this.isCryptoCurrency(fromCurrency) || this.isCryptoCurrency(toCurrency)) {
            return await this.convertCryptoCurrency(fromCurrency, toCurrency, amount);
          }
          return await this.convertFiatCurrency(fromCurrency, toCurrency, amount);
        } catch (error2) {
          console.error("Currency conversion error:", error2);
          throw new Error(`Failed to convert ${fromCurrency} to ${toCurrency}`);
        }
      }
      async getCryptoPrices(symbols) {
        try {
          const symbolsStr = symbols.map((s) => s.toLowerCase()).join(",");
          const response = await axios_default.get(
            `${process.env.CRYPTO_API_URL}/simple/price`,
            {
              params: {
                ids: symbolsStr,
                vs_currencies: "eur,usd",
                include_24hr_change: true,
                include_market_cap: true,
                include_24hr_vol: true
              },
              headers: process.env.CRYPTO_API_KEY ? {
                "X-CG-Demo-API-Key": process.env.CRYPTO_API_KEY
              } : {}
            }
          );
          return Object.entries(response.data).map(([id, data]) => ({
            symbol: id.toUpperCase(),
            name: id,
            price: data.eur || data.usd || 0,
            change24h: data.eur_24h_change || data.usd_24h_change || 0,
            marketCap: data.eur_market_cap || data.usd_market_cap || 0,
            volume24h: data.eur_24h_vol || data.usd_24h_vol || 0,
            lastUpdated: /* @__PURE__ */ new Date()
          }));
        } catch (error2) {
          console.error("Error fetching crypto prices:", error2);
          throw new Error("Failed to fetch cryptocurrency prices");
        }
      }
      async getCryptoPrice(symbol, vsCurrency = "EUR") {
        try {
          const cacheKey = `${symbol}-${vsCurrency}`;
          const cached = this.cache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data.price;
          }
          const response = await axios_default.get(
            `${process.env.CRYPTO_API_URL}/simple/price`,
            {
              params: {
                ids: symbol.toLowerCase(),
                vs_currencies: vsCurrency.toLowerCase()
              },
              headers: process.env.CRYPTO_API_KEY ? {
                "X-CG-Demo-API-Key": process.env.CRYPTO_API_KEY
              } : {}
            }
          );
          const price = response.data[symbol.toLowerCase()]?.[vsCurrency.toLowerCase()];
          if (!price) {
            throw new Error(`Price not found for ${symbol}/${vsCurrency}`);
          }
          this.cache.set(cacheKey, {
            data: { price },
            timestamp: Date.now()
          });
          return price;
        } catch (error2) {
          console.error(`Error fetching price for ${symbol}:`, error2);
          throw new Error(`Failed to fetch price for ${symbol}`);
        }
      }
      async convertCryptoCurrency(fromCurrency, toCurrency, amount) {
        if (this.isCryptoCurrency(fromCurrency) && this.isCryptoCurrency(toCurrency)) {
          const fromPriceEur = await this.getCryptoPrice(fromCurrency, "EUR");
          const toPriceEur = await this.getCryptoPrice(toCurrency, "EUR");
          const rate = fromPriceEur / toPriceEur;
          return {
            fromCurrency,
            toCurrency,
            fromAmount: amount,
            toAmount: amount * rate,
            rate,
            timestamp: /* @__PURE__ */ new Date(),
            provider: "coingecko"
          };
        }
        if (this.isCryptoCurrency(fromCurrency) && !this.isCryptoCurrency(toCurrency)) {
          const rate = await this.getCryptoPrice(fromCurrency, toCurrency);
          return {
            fromCurrency,
            toCurrency,
            fromAmount: amount,
            toAmount: amount * rate,
            rate,
            timestamp: /* @__PURE__ */ new Date(),
            provider: "coingecko"
          };
        }
        if (!this.isCryptoCurrency(fromCurrency) && this.isCryptoCurrency(toCurrency)) {
          const rate = await this.getCryptoPrice(toCurrency, fromCurrency);
          const conversionRate = 1 / rate;
          return {
            fromCurrency,
            toCurrency,
            fromAmount: amount,
            toAmount: amount * conversionRate,
            rate: conversionRate,
            timestamp: /* @__PURE__ */ new Date(),
            provider: "coingecko"
          };
        }
        throw new Error("Invalid currency conversion");
      }
      async convertFiatCurrency(fromCurrency, toCurrency, amount) {
        const exchangeRates = {
          "EUR": 1,
          "USD": 1.1,
          "GBP": 0.85,
          "CHF": 0.95,
          "CAD": 1.45
        };
        const fromRate = exchangeRates[fromCurrency.toUpperCase()] || 1;
        const toRate = exchangeRates[toCurrency.toUpperCase()] || 1;
        const rate = toRate / fromRate;
        return {
          fromCurrency,
          toCurrency,
          fromAmount: amount,
          toAmount: amount * rate,
          rate,
          timestamp: /* @__PURE__ */ new Date(),
          provider: "internal"
        };
      }
      isCryptoCurrency(currency) {
        const supportedCryptos = process.env.CRYPTO_SUPPORTED_CURRENCIES?.split(",") || [
          "BTC",
          "ETH",
          "LTC",
          "BCH",
          "XRP",
          "ADA"
        ];
        return supportedCryptos.includes(currency.toUpperCase());
      }
      async getExchangeRates(baseCurrency = "EUR") {
        try {
          const cacheKey = `rates-${baseCurrency}`;
          const cached = this.cache.get(cacheKey);
          if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
          }
          const fiatRates = {
            "EUR": baseCurrency === "EUR" ? 1 : 0.91,
            "USD": baseCurrency === "USD" ? 1 : 1.1,
            "GBP": baseCurrency === "GBP" ? 1 : 0.85,
            "CHF": baseCurrency === "CHF" ? 1 : 0.95
          };
          const supportedCryptos = process.env.CRYPTO_SUPPORTED_CURRENCIES?.split(",") || [
            "BTC",
            "ETH",
            "LTC",
            "BCH",
            "XRP",
            "ADA"
          ];
          const cryptoRates = {};
          for (const crypto7 of supportedCryptos) {
            try {
              cryptoRates[crypto7] = await this.getCryptoPrice(crypto7, baseCurrency);
            } catch (error2) {
              console.warn(`Failed to fetch rate for ${crypto7}:`, error2);
              cryptoRates[crypto7] = 0;
            }
          }
          const allRates = { ...fiatRates, ...cryptoRates };
          this.cache.set(cacheKey, {
            data: allRates,
            timestamp: Date.now()
          });
          return allRates;
        } catch (error2) {
          console.error("Error fetching exchange rates:", error2);
          throw new Error("Failed to fetch exchange rates");
        }
      }
      calculateTransactionFee(amount, currency, paymentMethod) {
        const baseFee = parseFloat(process.env.CRYPTO_TRANSACTION_FEE || "1.5");
        const feeMultipliers = {
          "crypto": 1,
          "bank_transfer": 0.5,
          "credit_card": 1.5,
          "paypal": 2,
          "stripe": 1.2
        };
        const multiplier = feeMultipliers[paymentMethod] || 1;
        const feePercent = baseFee * multiplier;
        return amount * feePercent / 100;
      }
      clearCache() {
        this.cache.clear();
      }
    };
  }
});

// src/wallet/services/SecurityService.ts
import crypto5 from "crypto";
var SecurityService;
var init_SecurityService = __esm({
  "src/wallet/services/SecurityService.ts"() {
    SecurityService = class {
      constructor() {
        __publicField(this, "suspiciousPatterns", [
          {
            pattern: "rapid_multiple_transactions",
            description: "Multiple transactions in short time frame",
            riskLevel: "medium",
            action: "review"
          },
          {
            pattern: "unusual_amount",
            description: "Transaction amount significantly higher than user average",
            riskLevel: "high",
            action: "review"
          },
          {
            pattern: "new_device_large_amount",
            description: "Large transaction from new device",
            riskLevel: "high",
            action: "block"
          },
          {
            pattern: "multiple_failed_attempts",
            description: "Multiple failed transaction attempts",
            riskLevel: "high",
            action: "block"
          },
          {
            pattern: "crypto_rapid_conversion",
            description: "Rapid cryptocurrency conversions",
            riskLevel: "medium",
            action: "monitor"
          }
        ]);
      }
      async validateTransaction(userId, amount, currency, paymentMethod, userTransactionHistory, userInfo) {
        const checks = [];
        const recommendations = [];
        let riskLevel = "low";
        let blockTransaction = false;
        const amountCheck = this.checkTransactionLimits(amount, currency, userInfo);
        if (!amountCheck.passed) {
          checks.push(...amountCheck.reasons);
          recommendations.push(...amountCheck.recommendations);
          if (amountCheck.riskLevel === "high") {
            riskLevel = "high";
            blockTransaction = true;
          }
        }
        const frequencyCheck = this.checkTransactionFrequency(userTransactionHistory);
        if (!frequencyCheck.passed) {
          checks.push(...frequencyCheck.reasons);
          recommendations.push(...frequencyCheck.recommendations);
          if (frequencyCheck.riskLevel === "high") {
            riskLevel = "high";
          }
        }
        const patternCheck = this.checkSuspiciousPatterns(
          userId,
          amount,
          currency,
          userTransactionHistory
        );
        if (!patternCheck.passed) {
          checks.push(...patternCheck.reasons);
          recommendations.push(...patternCheck.recommendations);
          if (patternCheck.riskLevel === "high") {
            riskLevel = "high";
            blockTransaction = true;
          }
        }
        const paymentMethodCheck = this.checkPaymentMethodSecurity(paymentMethod, amount);
        if (!paymentMethodCheck.passed) {
          checks.push(...paymentMethodCheck.reasons);
          recommendations.push(...paymentMethodCheck.recommendations);
        }
        const overallPassed = checks.length === 0;
        return {
          passed: overallPassed && !blockTransaction,
          riskLevel,
          reasons: checks,
          recommendations,
          blockTransaction
        };
      }
      checkTransactionLimits(amount, currency, userInfo) {
        const reasons = [];
        const recommendations = [];
        let riskLevel = "low";
        const minAmount = parseFloat(process.env.CRYPTO_MIN_BUY_AMOUNT || "10");
        const maxAmount = parseFloat(process.env.CRYPTO_MAX_BUY_AMOUNT || "10000");
        if (amount < minAmount) {
          reasons.push(`Transaction amount ${amount} ${currency} is below minimum limit ${minAmount}`);
          recommendations.push(`Minimum transaction amount is ${minAmount} ${currency}`);
          riskLevel = "medium";
        }
        if (amount > maxAmount) {
          reasons.push(`Transaction amount ${amount} ${currency} exceeds maximum limit ${maxAmount}`);
          recommendations.push(`Consider breaking large transactions into smaller amounts`);
          riskLevel = "high";
        }
        if (userInfo?.verificationLevel === "unverified" && amount > 1e3) {
          reasons.push("Large transaction attempted by unverified user");
          recommendations.push("Complete account verification to increase limits");
          riskLevel = "high";
        }
        return {
          passed: reasons.length === 0,
          riskLevel,
          reasons,
          recommendations,
          blockTransaction: riskLevel === "high"
        };
      }
      checkTransactionFrequency(userTransactionHistory) {
        const reasons = [];
        const recommendations = [];
        let riskLevel = "low";
        const now = /* @__PURE__ */ new Date();
        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
        const recentTransactions = userTransactionHistory.filter(
          (tx) => new Date(tx.createdAt) > oneHourAgo
        );
        const dailyTransactions = userTransactionHistory.filter(
          (tx) => new Date(tx.createdAt) > oneDayAgo
        );
        if (recentTransactions.length > 5) {
          reasons.push("Unusual number of transactions in the last hour");
          recommendations.push("Wait before making additional transactions");
          riskLevel = "high";
        }
        if (dailyTransactions.length > 20) {
          reasons.push("High transaction volume in the last 24 hours");
          recommendations.push("Consider spreading transactions over multiple days");
          riskLevel = "medium";
        }
        return {
          passed: reasons.length === 0,
          riskLevel,
          reasons,
          recommendations,
          blockTransaction: false
        };
      }
      checkSuspiciousPatterns(userId, amount, currency, userTransactionHistory) {
        const reasons = [];
        const recommendations = [];
        let riskLevel = "low";
        const amounts = userTransactionHistory.filter((tx) => tx.currency === currency).map((tx) => tx.amount);
        if (amounts.length > 0) {
          const avgAmount = amounts.reduce((sum, amt) => sum + amt, 0) / amounts.length;
          const maxAmount = Math.max(...amounts);
          if (amount > avgAmount * 5 && amount > maxAmount * 2) {
            reasons.push("Transaction amount significantly higher than user average");
            recommendations.push("Verify this transaction amount is correct");
            riskLevel = "high";
          }
        }
        const recentCryptoTxs = userTransactionHistory.filter(
          (tx) => new Date(tx.createdAt) > new Date(Date.now() - 30 * 60 * 1e3) && // last 30 minutes
          (tx.type === "deposit" || tx.type === "withdrawal")
        );
        if (recentCryptoTxs.length > 3) {
          reasons.push("Rapid cryptocurrency conversion activity detected");
          recommendations.push("Allow time between cryptocurrency transactions");
          riskLevel = "medium";
        }
        return {
          passed: reasons.length === 0,
          riskLevel,
          reasons,
          recommendations,
          blockTransaction: riskLevel === "high"
        };
      }
      checkPaymentMethodSecurity(paymentMethod, amount) {
        const reasons = [];
        const recommendations = [];
        let riskLevel = "low";
        switch (paymentMethod.toLowerCase()) {
          case "crypto":
            if (amount > 5e3) {
              recommendations.push("Consider using multiple smaller transactions for large crypto amounts");
            }
            break;
          case "credit_card":
            if (amount > 2e3) {
              reasons.push("Large credit card transaction may require additional verification");
              recommendations.push("Consider using bank transfer for large amounts");
              riskLevel = "medium";
            }
            break;
          case "bank_transfer":
            break;
          default:
            reasons.push(`Payment method ${paymentMethod} requires additional security review`);
            riskLevel = "medium";
        }
        return {
          passed: reasons.length === 0,
          riskLevel,
          reasons,
          recommendations,
          blockTransaction: false
        };
      }
      calculateTransactionRisk(userId, amount, currency, paymentMethod, userTransactionHistory, userInfo) {
        let riskScore = 0;
        const factors = [];
        const avgAmount = this.calculateAverageTransactionAmount(userTransactionHistory, currency);
        if (amount > avgAmount * 3) {
          riskScore += 25;
          factors.push("Amount significantly above user average");
        }
        const recentTxCount = this.getRecentTransactionCount(userTransactionHistory, 60);
        if (recentTxCount > 3) {
          riskScore += 20;
          factors.push("High transaction frequency");
        }
        if (userTransactionHistory.length < 5) {
          riskScore += 15;
          factors.push("Limited transaction history");
        }
        const paymentMethodRisk = this.getPaymentMethodRisk(paymentMethod);
        riskScore += paymentMethodRisk.score;
        if (paymentMethodRisk.factor) {
          factors.push(paymentMethodRisk.factor);
        }
        const hour = (/* @__PURE__ */ new Date()).getHours();
        if (hour < 6 || hour > 23) {
          riskScore += 10;
          factors.push("Transaction during unusual hours");
        }
        if (this.isCryptoCurrency(currency)) {
          riskScore += 5;
          factors.push("Cryptocurrency transaction");
        }
        const level2 = this.getRiskLevel(riskScore);
        return {
          score: Math.min(riskScore, 100),
          level: level2,
          factors,
          shouldBlock: riskScore >= 80,
          shouldReview: riskScore >= 60
        };
      }
      calculateAverageTransactionAmount(transactions, currency) {
        const relevantTxs = transactions.filter((tx) => tx.currency === currency);
        if (relevantTxs.length === 0) return 0;
        const total = relevantTxs.reduce((sum, tx) => sum + tx.amount, 0);
        return total / relevantTxs.length;
      }
      getRecentTransactionCount(transactions, minutesAgo) {
        const cutoff = new Date(Date.now() - minutesAgo * 60 * 1e3);
        return transactions.filter((tx) => new Date(tx.createdAt) > cutoff).length;
      }
      getPaymentMethodRisk(paymentMethod) {
        switch (paymentMethod.toLowerCase()) {
          case "crypto":
            return { score: 10, factor: "Cryptocurrency payment method" };
          case "credit_card":
            return { score: 15, factor: "Credit card payment" };
          case "paypal":
            return { score: 12, factor: "PayPal payment" };
          case "bank_transfer":
            return { score: 5 };
          case "stripe":
            return { score: 8 };
          default:
            return { score: 20, factor: "Unknown payment method" };
        }
      }
      getRiskLevel(score) {
        if (score >= 60) return "high";
        if (score >= 30) return "medium";
        return "low";
      }
      isCryptoCurrency(currency) {
        const supportedCryptos = process.env.CRYPTO_SUPPORTED_CURRENCIES?.split(",") || [
          "BTC",
          "ETH",
          "LTC",
          "BCH",
          "XRP",
          "ADA"
        ];
        return supportedCryptos.includes(currency.toUpperCase());
      }
      encryptSensitiveData(data) {
        const key = crypto5.scryptSync(process.env.ENCRYPTION_KEY || "default-key", "salt", 32);
        const iv = crypto5.randomBytes(16);
        const cipher = crypto5.createCipheriv("aes-256-cbc", key, iv);
        let encrypted = cipher.update(data, "utf8", "hex");
        encrypted += cipher.final("hex");
        return `${iv.toString("hex")}:${encrypted}`;
      }
      decryptSensitiveData(encryptedData) {
        const key = crypto5.scryptSync(process.env.ENCRYPTION_KEY || "default-key", "salt", 32);
        const [ivHex, encrypted] = encryptedData.split(":");
        const iv = Buffer.from(ivHex, "hex");
        const decipher = crypto5.createDecipheriv("aes-256-cbc", key, iv);
        let decrypted = decipher.update(encrypted, "hex", "utf8");
        decrypted += decipher.final("utf8");
        return decrypted;
      }
      generateTransactionHash(userId, amount, currency, timestamp) {
        const data = `${userId}-${amount}-${currency}-${timestamp.getTime()}`;
        return crypto5.createHash("sha256").update(data).digest("hex");
      }
      validateTransactionHash(userId, amount, currency, timestamp, hash) {
        const expectedHash = this.generateTransactionHash(userId, amount, currency, timestamp);
        return expectedHash === hash;
      }
    };
  }
});

// src/wallet/config/mobileMoneyProviders.ts
var MOBILE_MONEY_PROVIDERS, PHONE_VALIDATION_RULES, SUPPORTED_COUNTRIES;
var init_mobileMoneyProviders = __esm({
  "src/wallet/config/mobileMoneyProviders.ts"() {
    MOBILE_MONEY_PROVIDERS = [
      // Afrique de l'Ouest - Zone UEMOA (XOF)
      // Côte d'Ivoire
      {
        id: "orange_money_ci",
        name: "Orange Money",
        shortCode: "OM",
        country: "C\xF4te d'Ivoire",
        countryCode: "CI",
        currency: "XOF",
        logo: "https://cdn.orange.com/logos/orange-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.5,
          withdrawal: 2,
          transfer: 1,
          minimum: 50,
          maximum: 5e3
        },
        limits: {
          minTransaction: 100,
          maxTransaction: 1e6,
          dailyLimit: 2e6,
          monthlyLimit: 1e7
        },
        apiEndpoint: "https://api.orange.ci/mobile-money/v1",
        webhookSecret: "orange_ci_webhook_secret"
      },
      {
        id: "mtn_money_ci",
        name: "MTN Mobile Money",
        shortCode: "MOMO",
        country: "C\xF4te d'Ivoire",
        countryCode: "CI",
        currency: "XOF",
        logo: "https://cdn.mtn.com/logos/mtn-momo-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.2,
          withdrawal: 1.8,
          transfer: 0.8,
          minimum: 25,
          maximum: 4e3
        },
        limits: {
          minTransaction: 50,
          maxTransaction: 15e5,
          dailyLimit: 3e6,
          monthlyLimit: 15e6
        },
        apiEndpoint: "https://api.mtn.ci/momo/v1",
        webhookSecret: "mtn_ci_webhook_secret"
      },
      {
        id: "wave_ci",
        name: "Wave",
        shortCode: "WAVE",
        country: "C\xF4te d'Ivoire",
        countryCode: "CI",
        currency: "XOF",
        logo: "https://cdn.wave.com/logos/wave-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0.5,
          withdrawal: 1,
          transfer: 0.3,
          minimum: 10,
          maximum: 2e3
        },
        limits: {
          minTransaction: 25,
          maxTransaction: 2e6,
          dailyLimit: 5e6,
          monthlyLimit: 2e7
        },
        apiEndpoint: "https://api.wave.com/v1",
        webhookSecret: "wave_ci_webhook_secret"
      },
      // Sénégal
      {
        id: "orange_money_sn",
        name: "Orange Money",
        shortCode: "OM",
        country: "S\xE9n\xE9gal",
        countryCode: "SN",
        currency: "XOF",
        logo: "https://cdn.orange.com/logos/orange-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.5,
          withdrawal: 2,
          transfer: 1,
          minimum: 50,
          maximum: 5e3
        },
        limits: {
          minTransaction: 100,
          maxTransaction: 1e6,
          dailyLimit: 2e6,
          monthlyLimit: 1e7
        },
        apiEndpoint: "https://api.orange.sn/mobile-money/v1",
        webhookSecret: "orange_sn_webhook_secret"
      },
      {
        id: "wave_sn",
        name: "Wave",
        shortCode: "WAVE",
        country: "S\xE9n\xE9gal",
        countryCode: "SN",
        currency: "XOF",
        logo: "https://cdn.wave.com/logos/wave-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0,
          // Wave gratuit au Sénégal
          withdrawal: 0.5,
          transfer: 0,
          minimum: 0,
          maximum: 1e3
        },
        limits: {
          minTransaction: 25,
          maxTransaction: 2e6,
          dailyLimit: 5e6,
          monthlyLimit: 2e7
        },
        apiEndpoint: "https://api.wave.com/v1",
        webhookSecret: "wave_sn_webhook_secret"
      },
      // Togo
      {
        id: "tmoney_tg",
        name: "T-Money",
        shortCode: "TMONEY",
        country: "Togo",
        countryCode: "TG",
        currency: "XOF",
        logo: "https://cdn.togocom.tg/logos/tmoney-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1,
          withdrawal: 1.5,
          transfer: 0.75,
          minimum: 25,
          maximum: 3e3
        },
        limits: {
          minTransaction: 50,
          maxTransaction: 1e6,
          dailyLimit: 25e5,
          monthlyLimit: 12e6
        },
        apiEndpoint: "https://api.togocom.tg/tmoney/v1",
        webhookSecret: "tmoney_tg_webhook_secret"
      },
      {
        id: "flooz_tg",
        name: "Flooz",
        shortCode: "FLOOZ",
        country: "Togo",
        countryCode: "TG",
        currency: "XOF",
        logo: "https://cdn.moov.tg/logos/flooz-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0.8,
          withdrawal: 1.2,
          transfer: 0.5,
          minimum: 20,
          maximum: 2500
        },
        limits: {
          minTransaction: 25,
          maxTransaction: 15e5,
          dailyLimit: 3e6,
          monthlyLimit: 15e6
        },
        apiEndpoint: "https://api.moov.tg/flooz/v1",
        webhookSecret: "flooz_tg_webhook_secret"
      },
      // Mali
      {
        id: "orange_money_ml",
        name: "Orange Money",
        shortCode: "OM",
        country: "Mali",
        countryCode: "ML",
        currency: "XOF",
        logo: "https://cdn.orange.com/logos/orange-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.5,
          withdrawal: 2,
          transfer: 1,
          minimum: 50,
          maximum: 5e3
        },
        limits: {
          minTransaction: 100,
          maxTransaction: 1e6,
          dailyLimit: 2e6,
          monthlyLimit: 1e7
        },
        apiEndpoint: "https://api.orange.ml/mobile-money/v1",
        webhookSecret: "orange_ml_webhook_secret"
      },
      // Burkina Faso
      {
        id: "orange_money_bf",
        name: "Orange Money",
        shortCode: "OM",
        country: "Burkina Faso",
        countryCode: "BF",
        currency: "XOF",
        logo: "https://cdn.orange.com/logos/orange-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.5,
          withdrawal: 2,
          transfer: 1,
          minimum: 50,
          maximum: 5e3
        },
        limits: {
          minTransaction: 100,
          maxTransaction: 1e6,
          dailyLimit: 2e6,
          monthlyLimit: 1e7
        },
        apiEndpoint: "https://api.orange.bf/mobile-money/v1",
        webhookSecret: "orange_bf_webhook_secret"
      },
      // Afrique de l'Est
      // Kenya
      {
        id: "mpesa_ke",
        name: "M-Pesa",
        shortCode: "MPESA",
        country: "Kenya",
        countryCode: "KE",
        currency: "KES",
        logo: "https://cdn.safaricom.co.ke/logos/mpesa-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0,
          withdrawal: 1.5,
          transfer: 0.5,
          minimum: 10,
          maximum: 300
        },
        limits: {
          minTransaction: 10,
          maxTransaction: 3e5,
          dailyLimit: 3e5,
          monthlyLimit: 3e6
        },
        apiEndpoint: "https://api.safaricom.co.ke/mpesa/v1",
        webhookSecret: "mpesa_ke_webhook_secret"
      },
      {
        id: "airtel_money_ke",
        name: "Airtel Money",
        shortCode: "AIRTEL",
        country: "Kenya",
        countryCode: "KE",
        currency: "KES",
        logo: "https://cdn.airtel.co.ke/logos/airtel-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0,
          withdrawal: 1.2,
          transfer: 0.3,
          minimum: 5,
          maximum: 250
        },
        limits: {
          minTransaction: 10,
          maxTransaction: 25e4,
          dailyLimit: 25e4,
          monthlyLimit: 25e5
        },
        apiEndpoint: "https://api.airtel.co.ke/money/v1",
        webhookSecret: "airtel_ke_webhook_secret"
      },
      // Ghana
      {
        id: "mtn_momo_gh",
        name: "MTN Mobile Money",
        shortCode: "MOMO",
        country: "Ghana",
        countryCode: "GH",
        currency: "GHS",
        logo: "https://cdn.mtn.com/logos/mtn-momo-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0.75,
          withdrawal: 1.5,
          transfer: 0.5,
          minimum: 0.5,
          maximum: 100
        },
        limits: {
          minTransaction: 1,
          maxTransaction: 5e3,
          dailyLimit: 1e4,
          monthlyLimit: 5e4
        },
        apiEndpoint: "https://api.mtn.com.gh/momo/v1",
        webhookSecret: "mtn_gh_webhook_secret"
      },
      {
        id: "vodafone_cash_gh",
        name: "Vodafone Cash",
        shortCode: "VCASH",
        country: "Ghana",
        countryCode: "GH",
        currency: "GHS",
        logo: "https://cdn.vodafone.com.gh/logos/vodafone-cash-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 0.75,
          withdrawal: 1.5,
          transfer: 0.5,
          minimum: 0.5,
          maximum: 100
        },
        limits: {
          minTransaction: 1,
          maxTransaction: 5e3,
          dailyLimit: 1e4,
          monthlyLimit: 5e4
        },
        apiEndpoint: "https://api.vodafone.com.gh/cash/v1",
        webhookSecret: "vodafone_gh_webhook_secret"
      },
      // Afrique Centrale
      // Cameroun
      {
        id: "orange_money_cm",
        name: "Orange Money",
        shortCode: "OM",
        country: "Cameroun",
        countryCode: "CM",
        currency: "XAF",
        logo: "https://cdn.orange.com/logos/orange-money-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.5,
          withdrawal: 2,
          transfer: 1,
          minimum: 100,
          maximum: 1e4
        },
        limits: {
          minTransaction: 200,
          maxTransaction: 2e6,
          dailyLimit: 4e6,
          monthlyLimit: 2e7
        },
        apiEndpoint: "https://api.orange.cm/mobile-money/v1",
        webhookSecret: "orange_cm_webhook_secret"
      },
      {
        id: "mtn_momo_cm",
        name: "MTN Mobile Money",
        shortCode: "MOMO",
        country: "Cameroun",
        countryCode: "CM",
        currency: "XAF",
        logo: "https://cdn.mtn.com/logos/mtn-momo-logo.png",
        isActive: true,
        supportedOperations: ["deposit", "withdrawal", "transfer"],
        fees: {
          deposit: 1.2,
          withdrawal: 1.8,
          transfer: 0.8,
          minimum: 50,
          maximum: 8e3
        },
        limits: {
          minTransaction: 100,
          maxTransaction: 3e6,
          dailyLimit: 6e6,
          monthlyLimit: 3e7
        },
        apiEndpoint: "https://api.mtn.cm/momo/v1",
        webhookSecret: "mtn_cm_webhook_secret"
      }
    ];
    PHONE_VALIDATION_RULES = {
      "CI": {
        length: [8, 10],
        prefixes: {
          "orange_money_ci": ["07", "08", "09"],
          "mtn_money_ci": ["05", "06"],
          "wave_ci": ["01", "02", "03", "04", "05", "06", "07", "08", "09"]
        }
      },
      "SN": {
        length: [9],
        prefixes: {
          "orange_money_sn": ["77", "78"],
          "wave_sn": ["70", "75", "76", "77", "78"]
        }
      },
      "TG": {
        length: [8],
        prefixes: {
          "tmoney_tg": ["90", "91", "92", "93"],
          "flooz_tg": ["96", "97", "98", "99"]
        }
      },
      "ML": {
        length: [8],
        prefixes: {
          "orange_money_ml": ["65", "66", "67", "68", "69"]
        }
      },
      "BF": {
        length: [8],
        prefixes: {
          "orange_money_bf": ["65", "66", "67", "68", "69"]
        }
      },
      "KE": {
        length: [9, 10],
        prefixes: {
          "mpesa_ke": ["07", "01"],
          "airtel_money_ke": ["07", "10", "73", "78"]
        }
      },
      "GH": {
        length: [9, 10],
        prefixes: {
          "mtn_momo_gh": ["024", "054", "055", "059"],
          "vodafone_cash_gh": ["020", "050"]
        }
      },
      "CM": {
        length: [9],
        prefixes: {
          "orange_money_cm": ["69", "65", "66", "67"],
          "mtn_momo_cm": ["67", "65", "68"]
        }
      }
    };
    SUPPORTED_COUNTRIES = {
      "CI": { name: "C\xF4te d'Ivoire", currency: "XOF", flag: "\u{1F1E8}\u{1F1EE}" },
      "SN": { name: "S\xE9n\xE9gal", currency: "XOF", flag: "\u{1F1F8}\u{1F1F3}" },
      "TG": { name: "Togo", currency: "XOF", flag: "\u{1F1F9}\u{1F1EC}" },
      "ML": { name: "Mali", currency: "XOF", flag: "\u{1F1F2}\u{1F1F1}" },
      "BF": { name: "Burkina Faso", currency: "XOF", flag: "\u{1F1E7}\u{1F1EB}" },
      "KE": { name: "Kenya", currency: "KES", flag: "\u{1F1F0}\u{1F1EA}" },
      "GH": { name: "Ghana", currency: "GHS", flag: "\u{1F1EC}\u{1F1ED}" },
      "CM": { name: "Cameroun", currency: "XAF", flag: "\u{1F1E8}\u{1F1F2}" }
    };
  }
});

// src/wallet/services/MobileMoneyService.ts
var MobileMoneyService;
var init_MobileMoneyService = __esm({
  "src/wallet/services/MobileMoneyService.ts"() {
    init_mobileMoneyProviders();
    MobileMoneyService = class {
      constructor() {
        __publicField(this, "providers", /* @__PURE__ */ new Map());
        this.initializeProviders();
      }
      initializeProviders() {
        MOBILE_MONEY_PROVIDERS.forEach((provider) => {
          this.providers.set(provider.id, provider);
        });
      }
      /**
       * Récupère tous les providers disponibles
       */
      getAllProviders() {
        return Array.from(this.providers.values());
      }
      /**
       * Récupère les providers par pays
       */
      getProvidersByCountry(countryCode) {
        return Array.from(this.providers.values()).filter((provider) => provider.countryCode === countryCode && provider.isActive);
      }
      /**
       * Récupère les informations d'un pays supporté
       */
      getCountryInfo(countryCode) {
        return SUPPORTED_COUNTRIES[countryCode];
      }
      /**
       * Récupère tous les pays supportés
       */
      getSupportedCountries() {
        return SUPPORTED_COUNTRIES;
      }
      /**
       * Récupère un provider par ID
       */
      getProvider(providerId) {
        return this.providers.get(providerId);
      }
      /**
       * Valide un numéro de téléphone pour un provider donné
       */
      validatePhoneNumber(phoneNumber, countryCode) {
        const cleanNumber = phoneNumber.replace(/\D/g, "");
        const rule = PHONE_VALIDATION_RULES[countryCode];
        if (!rule) {
          return {
            isValid: false,
            error: `Country code ${countryCode} not supported`
          };
        }
        if (!rule.length.includes(cleanNumber.length)) {
          return {
            isValid: false,
            error: `Invalid phone number length for ${countryCode}`
          };
        }
        let suggestedProvider;
        for (const [providerId, prefixes] of Object.entries(rule.prefixes)) {
          if (prefixes.some((prefix) => cleanNumber.startsWith(prefix))) {
            suggestedProvider = providerId;
            break;
          }
        }
        return {
          isValid: true,
          formattedNumber: cleanNumber,
          suggestedProvider
        };
      }
      /**
       * Calcule les frais pour une transaction
       */
      calculateFees(providerId, type, amount) {
        const provider = this.getProvider(providerId);
        if (!provider) {
          throw new Error(`Provider ${providerId} not found`);
        }
        const feePercentage = provider.fees[type] || 0;
        let feeAmount = amount * feePercentage / 100;
        feeAmount = Math.max(feeAmount, provider.fees.minimum);
        feeAmount = Math.min(feeAmount, provider.fees.maximum);
        return {
          feeAmount,
          feePercentage,
          totalAmount: amount + feeAmount
        };
      }
      /**
       * Valide les limites de transaction
       */
      validateTransactionLimits(providerId, amount, userDailyVolume = 0, userMonthlyVolume = 0) {
        const provider = this.getProvider(providerId);
        if (!provider) {
          return {
            isValid: false,
            error: `Provider ${providerId} not found`,
            limits: null
          };
        }
        const { limits } = provider;
        if (amount < limits.minTransaction) {
          return {
            isValid: false,
            error: `Amount below minimum limit of ${limits.minTransaction} ${provider.currency}`,
            limits
          };
        }
        if (amount > limits.maxTransaction) {
          return {
            isValid: false,
            error: `Amount exceeds maximum limit of ${limits.maxTransaction} ${provider.currency}`,
            limits
          };
        }
        if (userDailyVolume + amount > limits.dailyLimit) {
          return {
            isValid: false,
            error: `Daily limit exceeded. Remaining: ${limits.dailyLimit - userDailyVolume} ${provider.currency}`,
            limits
          };
        }
        if (userMonthlyVolume + amount > limits.monthlyLimit) {
          return {
            isValid: false,
            error: `Monthly limit exceeded. Remaining: ${limits.monthlyLimit - userMonthlyVolume} ${provider.currency}`,
            limits
          };
        }
        return {
          isValid: true,
          limits
        };
      }
      /**
       * Traite une transaction mobile money
       */
      async processTransaction(request) {
        try {
          const provider = this.getProvider(request.providerId);
          if (!provider) {
            throw new Error(`Provider ${request.providerId} not found`);
          }
          const fees = this.calculateFees(request.providerId, request.type, request.amount);
          const reference = this.generateReference(request.providerId, request.type);
          const providerResponse = await this.callProviderAPI(provider, request, reference);
          return {
            success: providerResponse.success,
            transactionId: providerResponse.transactionId,
            reference,
            status: providerResponse.status,
            amount: request.amount,
            currency: request.currency || provider.currency,
            fees: fees.feeAmount,
            estimatedCompletion: providerResponse.estimatedCompletion,
            confirmationRequired: providerResponse.confirmationRequired,
            confirmationCode: providerResponse.confirmationCode,
            error: providerResponse.error,
            providerResponse
          };
        } catch (error2) {
          console.error("Error processing mobile money transaction:", error2);
          return {
            success: false,
            reference: this.generateReference(request.providerId, request.type),
            status: "failed",
            amount: request.amount,
            currency: request.currency || "XOF",
            fees: 0,
            confirmationRequired: false,
            error: error2 instanceof Error ? error2.message : "Unknown error occurred"
          };
        }
      }
      /**
       * Appel API simulé vers le provider
       */
      async callProviderAPI(provider, request, reference) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        const scenarios = [
          { success: true, status: "completed", confirmationRequired: false, probability: 0.7 },
          { success: true, status: "pending", confirmationRequired: true, probability: 0.2 },
          { success: false, status: "failed", confirmationRequired: false, probability: 0.1 }
        ];
        const random = Math.random();
        let cumulative = 0;
        let selectedScenario = scenarios[0];
        for (const scenario of scenarios) {
          cumulative += scenario.probability;
          if (random <= cumulative) {
            selectedScenario = scenario;
            break;
          }
        }
        if (selectedScenario.success) {
          return {
            success: true,
            transactionId: `${provider.shortCode}_${Date.now()}`,
            status: selectedScenario.status,
            confirmationRequired: selectedScenario.confirmationRequired,
            confirmationCode: selectedScenario.confirmationRequired ? Math.random().toString(36).substring(2, 8).toUpperCase() : void 0,
            estimatedCompletion: selectedScenario.status === "pending" ? new Date(Date.now() + 5 * 60 * 1e3) : void 0
            // 5 minutes
          };
        } else {
          return {
            success: false,
            status: "failed",
            error: "Transaction declined by provider",
            confirmationRequired: false
          };
        }
      }
      /**
       * Génère une référence unique pour la transaction
       */
      generateReference(providerId, type) {
        const provider = this.getProvider(providerId);
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        return `${provider?.shortCode || "MM"}_${type.toUpperCase()}_${timestamp}_${random}`;
      }
      /**
       * Vérifie le statut d'une transaction
       */
      async checkTransactionStatus(providerId, reference) {
        try {
          const provider = this.getProvider(providerId);
          if (!provider) {
            throw new Error(`Provider ${providerId} not found`);
          }
          await new Promise((resolve) => setTimeout(resolve, 500));
          return {
            status: "completed",
            details: {
              reference,
              completedAt: /* @__PURE__ */ new Date(),
              confirmationCode: Math.random().toString(36).substring(2, 8).toUpperCase()
            }
          };
        } catch (error2) {
          return {
            status: "failed",
            error: error2 instanceof Error ? error2.message : "Unknown error"
          };
        }
      }
      /**
       * Récupère le solde d'un compte mobile money (si supporté par l'API)
       */
      async getAccountBalance(providerId, accountId) {
        try {
          const provider = this.getProvider(providerId);
          if (!provider) {
            throw new Error(`Provider ${providerId} not found`);
          }
          await new Promise((resolve) => setTimeout(resolve, 800));
          const balance = Math.floor(Math.random() * 1e5) + 1e3;
          return {
            balance,
            currency: provider.currency,
            lastUpdated: /* @__PURE__ */ new Date()
          };
        } catch (error2) {
          return {
            error: error2 instanceof Error ? error2.message : "Unknown error"
          };
        }
      }
    };
  }
});

// src/wallet/services/UnifiedPaymentService.ts
var _UnifiedPaymentService, UnifiedPaymentService;
var init_UnifiedPaymentService = __esm({
  "src/wallet/services/UnifiedPaymentService.ts"() {
    init_EnhancedWallet();
    init_CryptoPayment();
    init_PriceService();
    init_SecurityService();
    init_MobileMoneyService();
    init_notificationServices();
    _UnifiedPaymentService = class _UnifiedPaymentService {
      constructor() {
        __publicField(this, "priceService");
        __publicField(this, "securityService");
        __publicField(this, "mobileMoneyService");
        __publicField(this, "notificationService");
        this.priceService = new PriceService();
        this.securityService = new SecurityService();
        this.mobileMoneyService = new MobileMoneyService();
        this.notificationService = new NotificationService();
      }
      static getInstance() {
        if (!_UnifiedPaymentService.instance) {
          _UnifiedPaymentService.instance = new _UnifiedPaymentService();
        }
        return _UnifiedPaymentService.instance;
      }
      /**
       * Point d'entrée unique pour tous les paiements
       * Tous les paiements passent par le wallet, même les externes
       */
      async processPayment(request) {
        try {
          let wallet = await EnhancedWallet.findOne({ userId: request.userId });
          if (!wallet) {
            wallet = await this.createWallet(request.userId);
          }
          const paymentMethod = request.paymentMethodId ? wallet.paymentMethods.find((pm) => pm.id === request.paymentMethodId) : wallet.paymentMethods.find((pm) => pm.isDefault);
          if (!paymentMethod) {
            throw new Error("No valid payment method found");
          }
          const fees = await this.calculateFees(request, paymentMethod.type);
          await this.checkLimits(wallet, request.amount, request.currency);
          const transactionId = await this.createWalletTransaction(wallet, request, fees);
          let paymentResult;
          switch (paymentMethod.type) {
            case "internal":
              paymentResult = await this.processInternalPayment(wallet, request, transactionId);
              break;
            case "crypto_wallet":
              paymentResult = await this.processCryptoPayment(wallet, request, transactionId);
              break;
            case "bank_card":
            case "stripe":
              paymentResult = await this.processStripePayment(wallet, request, transactionId);
              break;
            case "mobile_money":
              paymentResult = await this.processMobileMoneyPayment(wallet, request, transactionId);
              break;
            case "paypal":
              paymentResult = await this.processPayPalPayment(wallet, request, transactionId);
              break;
            case "bank_transfer":
              paymentResult = await this.processBankTransfer(wallet, request, transactionId);
              break;
            default:
              throw new Error(`Unsupported payment method: ${paymentMethod.type}`);
          }
          await this.updateTransactionStatus(wallet, transactionId, paymentResult.status);
          await this.sendPaymentNotification(wallet, request, paymentResult);
          return {
            ...paymentResult,
            transactionId,
            fees
          };
        } catch (error2) {
          console.error("Payment processing error:", error2);
          return {
            success: false,
            status: "failed",
            error: error2 instanceof Error ? error2.message : "Unknown payment error"
          };
        }
      }
      /**
       * Paiement interne (solde du wallet)
       */
      async processInternalPayment(wallet, request, transactionId) {
        const currency = wallet.fiatCurrencies.find((c) => c.symbol === request.currency);
        if (!currency) {
          throw new Error(`Currency ${request.currency} not available in wallet`);
        }
        if (currency.balance < request.amount) {
          throw new Error("Insufficient balance");
        }
        currency.balance -= request.amount;
        currency.lockedBalance += request.amount;
        await wallet.save();
        setTimeout(async () => {
          await this.completeInternalPayment(wallet, transactionId, request.amount, request.currency);
        }, 2e3);
        return {
          success: true,
          status: "processing",
          estimatedConfirmationTime: 2e3
        };
      }
      /**
       * Paiement crypto
       */
      async processCryptoPayment(wallet, request, transactionId) {
        if (!request.cryptoData) {
          throw new Error("Crypto data required for crypto payment");
        }
        const crypto7 = wallet.cryptoCurrencies.find((c) => c.symbol === request.currency);
        if (!crypto7) {
          throw new Error(`Cryptocurrency ${request.currency} not available in wallet`);
        }
        const cryptoAmount = request.amount / crypto7.metadata.currentPrice;
        if (crypto7.balance < cryptoAmount) {
          throw new Error("Insufficient crypto balance");
        }
        const cryptoPayment = new CryptoPayment({
          paymentId: transactionId,
          userId: request.userId,
          propertyId: request.propertyId,
          paymentType: request.type,
          cryptocurrency: request.currency,
          network: request.cryptoData.network,
          amount: cryptoAmount,
          amountFiat: request.amount,
          fiatCurrency: "EUR",
          exchangeRate: crypto7.metadata.currentPrice,
          fromAddress: crypto7.walletAddress,
          toAddress: request.cryptoData.toAddress,
          status: "pending",
          confirmationsRequired: request.cryptoData.network === "bitcoin" ? 6 : 12,
          metadata: {
            propertyAddress: "Property Address",
            // À récupérer depuis propertyId
            landlordId: "landlord_id",
            // À récupérer
            paymentDescription: request.description
          }
        });
        await cryptoPayment.save();
        crypto7.balance -= cryptoAmount;
        crypto7.lockedBalance += cryptoAmount;
        await wallet.save();
        const qrCodeData = this.generateCryptoQRCode(request.cryptoData.toAddress, cryptoAmount, request.currency);
        return {
          success: true,
          status: "pending",
          estimatedConfirmationTime: request.cryptoData.network === "bitcoin" ? 36e5 : 3e5,
          // 1h BTC, 5min ETH
          qrCodeData
        };
      }
      /**
       * Paiement Stripe
       */
      async processStripePayment(wallet, request, transactionId) {
        const stripePaymentIntent = {
          id: `pi_${Date.now()}`,
          client_secret: `pi_${Date.now()}_secret_${Math.random().toString(36).substr(2, 9)}`,
          status: "requires_payment_method"
        };
        const transaction = wallet.transactions.find((t) => t.id === transactionId);
        if (transaction) {
          transaction.externalTransactionId = stripePaymentIntent.id;
          transaction.status = "processing";
        }
        await wallet.save();
        return {
          success: true,
          status: "processing",
          externalPaymentUrl: `https://js.stripe.com/v3/#${stripePaymentIntent.client_secret}`,
          estimatedConfirmationTime: 3e4
          // 30 secondes
        };
      }
      /**
       * Paiement PayPal
       */
      async processPayPalPayment(wallet, request, transactionId) {
        const paypalOrderId = `PAY-${Date.now()}`;
        const transaction = wallet.transactions.find((t) => t.id === transactionId);
        if (transaction) {
          transaction.externalTransactionId = paypalOrderId;
          transaction.status = "processing";
        }
        await wallet.save();
        return {
          success: true,
          status: "processing",
          externalPaymentUrl: `https://www.paypal.com/checkoutnow?token=${paypalOrderId}`,
          estimatedConfirmationTime: 6e4
          // 1 minute
        };
      }
      /**
       * Virement bancaire
       */
      async processBankTransfer(wallet, request, transactionId) {
        const transaction = wallet.transactions.find((t) => t.id === transactionId);
        if (transaction) {
          transaction.status = "pending";
        }
        await wallet.save();
        return {
          success: true,
          status: "pending",
          estimatedConfirmationTime: 864e5
          // 24 heures
        };
      }
      /**
       * Transfert entre utilisateurs
       */
      async processTransfer(request) {
        try {
          const [fromWallet, toWallet] = await Promise.all([
            EnhancedWallet.findOne({ userId: request.fromUserId }),
            EnhancedWallet.findOne({ userId: request.toUserId })
          ]);
          if (!fromWallet || !toWallet) {
            throw new Error("Wallet not found");
          }
          const fromCurrency = fromWallet.fiatCurrencies.find((c) => c.symbol === request.currency);
          if (!fromCurrency || fromCurrency.balance < request.amount) {
            throw new Error("Insufficient balance");
          }
          fromCurrency.balance -= request.amount;
          let toCurrency = toWallet.fiatCurrencies.find((c) => c.symbol === request.currency);
          if (!toCurrency) {
            toCurrency = {
              symbol: request.currency,
              name: request.currency,
              balance: 0,
              lockedBalance: 0,
              isBaseCurrency: false,
              exchangeRate: 1,
              lastExchangeUpdate: /* @__PURE__ */ new Date()
            };
            toWallet.fiatCurrencies.push(toCurrency);
          }
          toCurrency.balance += request.amount - (request.fee || 0);
          const transferId = `transfer_${Date.now()}`;
          fromWallet.addTransaction({
            id: `${transferId}_out`,
            type: "transfer",
            amount: -request.amount,
            currency: request.currency,
            toUserId: request.toUserId,
            description: `Transfer to user ${request.toUserId}: ${request.description}`,
            status: "completed"
          });
          toWallet.addTransaction({
            id: `${transferId}_in`,
            type: "received",
            amount: request.amount - (request.fee || 0),
            currency: request.currency,
            fromUserId: request.fromUserId,
            description: `Transfer from user ${request.fromUserId}: ${request.description}`,
            status: "completed"
          });
          await Promise.all([fromWallet.save(), toWallet.save()]);
          return {
            success: true,
            transactionId: transferId,
            status: "completed"
          };
        } catch (error2) {
          return {
            success: false,
            status: "failed",
            error: error2 instanceof Error ? error2.message : "Transfer failed"
          };
        }
      }
      /**
       * Échange de devises
       */
      async processExchange(request) {
        try {
          const wallet = await EnhancedWallet.findOne({ userId: request.userId });
          if (!wallet) {
            throw new Error("Wallet not found");
          }
          const rates = await this.priceService.getExchangeRates();
          const exchangeRate = rates[request.toCurrency] / rates[request.fromCurrency] || 1;
          const toAmount = request.amount * exchangeRate * (1 - (request.slippage || 0.01));
          const fromCurrency = wallet.fiatCurrencies.find((c) => c.symbol === request.fromCurrency) || wallet.cryptoCurrencies.find((c) => c.symbol === request.fromCurrency);
          if (!fromCurrency || fromCurrency.balance < request.amount) {
            throw new Error("Insufficient balance for exchange");
          }
          fromCurrency.balance -= request.amount;
          let toCurrency = wallet.fiatCurrencies.find((c) => c.symbol === request.toCurrency) || wallet.cryptoCurrencies.find((c) => c.symbol === request.toCurrency);
          if (!toCurrency) {
            if (["BTC", "ETH", "USDT", "USDC"].includes(request.toCurrency)) {
              const newCrypto = {
                symbol: request.toCurrency,
                name: request.toCurrency,
                network: request.toCurrency === "BTC" ? "bitcoin" : "ethereum",
                balance: 0,
                lockedBalance: 0,
                walletAddress: this.generateWalletAddress(request.toCurrency),
                isActive: true,
                lastSyncAt: /* @__PURE__ */ new Date(),
                metadata: {
                  decimals: 18,
                  currentPrice: exchangeRate,
                  priceChange24h: 0,
                  lastPriceUpdate: /* @__PURE__ */ new Date()
                }
              };
              wallet.cryptoCurrencies.push(newCrypto);
              toCurrency = newCrypto;
            } else {
              const newFiat = {
                symbol: request.toCurrency,
                name: request.toCurrency,
                balance: 0,
                lockedBalance: 0,
                isBaseCurrency: false,
                exchangeRate: 1 / exchangeRate,
                lastExchangeUpdate: /* @__PURE__ */ new Date()
              };
              wallet.fiatCurrencies.push(newFiat);
              toCurrency = newFiat;
            }
          }
          toCurrency.balance += toAmount;
          const exchangeId = `exchange_${Date.now()}`;
          wallet.addTransaction({
            id: exchangeId,
            type: "exchange",
            amount: request.amount,
            currency: request.fromCurrency,
            cryptoAmount: toAmount,
            cryptoCurrency: request.toCurrency,
            exchangeRate,
            description: `Exchange ${request.amount} ${request.fromCurrency} to ${toAmount} ${request.toCurrency}`,
            status: "completed"
          });
          await wallet.save();
          return {
            success: true,
            transactionId: exchangeId,
            status: "completed"
          };
        } catch (error2) {
          return {
            success: false,
            status: "failed",
            error: error2 instanceof Error ? error2.message : "Exchange failed"
          };
        }
      }
      // Méthodes utilitaires privées
      async createWallet(userId) {
        const wallet = new EnhancedWallet({
          userId,
          fiatCurrencies: [{
            symbol: "EUR",
            name: "Euro",
            balance: 0,
            lockedBalance: 0,
            isBaseCurrency: true,
            exchangeRate: 1,
            lastExchangeUpdate: /* @__PURE__ */ new Date()
          }],
          cryptoCurrencies: [],
          paymentMethods: [{
            id: "internal_default",
            type: "internal",
            name: "Solde du wallet",
            isDefault: true,
            isActive: true,
            createdAt: /* @__PURE__ */ new Date()
          }],
          transactions: []
        });
        return await wallet.save();
      }
      async calculateFees(request, paymentType) {
        const baseFee = request.amount * 0.01;
        const fees = {
          network: 0,
          service: baseFee,
          exchange: 0
        };
        switch (paymentType) {
          case "crypto_wallet":
            fees.network = 1e-4;
            break;
          case "stripe":
          case "bank_card":
            fees.service = request.amount * 0.029 + 0.3;
            break;
          case "paypal":
            fees.service = request.amount * 0.034 + 0.35;
            break;
          case "internal":
            fees.service = 0;
            break;
        }
        return {
          amount: fees.network + fees.service + fees.exchange,
          currency: request.currency,
          breakdown: fees
        };
      }
      async checkLimits(wallet, amount, currency) {
        if (amount > wallet.settings.maxTransactionLimit) {
          throw new Error(`Transaction amount exceeds limit of ${wallet.settings.maxTransactionLimit}`);
        }
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const todayTransactions = wallet.transactions.filter(
          (tx) => tx.createdAt >= today && tx.status === "completed"
        );
        const todayVolume = todayTransactions.reduce((sum, tx) => sum + Math.abs(tx.amount), 0);
        if (todayVolume + amount > wallet.settings.maxDailyLimit) {
          throw new Error(`Daily limit exceeded. Current: ${todayVolume}, Limit: ${wallet.settings.maxDailyLimit}`);
        }
      }
      async createWalletTransaction(wallet, request, fees) {
        const transactionId = `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const transaction = {
          id: transactionId,
          type: "payment",
          subType: request.type,
          amount: request.amount,
          currency: request.currency,
          feeAmount: fees.amount,
          feeCurrency: request.currency,
          description: request.description,
          propertyId: request.propertyId,
          reservationId: request.reservationId,
          paymentMethodId: request.paymentMethodId,
          status: "pending",
          scheduledFor: request.scheduledFor
        };
        await wallet.addTransaction(transaction);
        return transactionId;
      }
      async updateTransactionStatus(wallet, transactionId, status) {
        const transaction = wallet.transactions.find((t) => t.id === transactionId);
        if (transaction) {
          transaction.status = status;
          if (status === "completed") {
            transaction.completedAt = /* @__PURE__ */ new Date();
          }
          await wallet.save();
        }
      }
      async completeInternalPayment(wallet, transactionId, amount, currency) {
        const currencyObj = wallet.fiatCurrencies.find((c) => c.symbol === currency);
        if (currencyObj) {
          currencyObj.lockedBalance -= amount;
        }
        await this.updateTransactionStatus(wallet, transactionId, "completed");
      }
      async processMobileMoneyPayment(wallet, request, transactionId) {
        try {
          if (!request.mobileMoneyData) {
            throw new Error("Mobile money data is required");
          }
          const { phoneNumber, providerId, countryCode, accountName } = request.mobileMoneyData;
          const validation = this.mobileMoneyService.validatePhoneNumber(phoneNumber, countryCode);
          if (!validation.isValid) {
            throw new Error(`Invalid phone number: ${validation.error}`);
          }
          const provider = this.mobileMoneyService.getProvider(providerId);
          if (!provider) {
            throw new Error(`Mobile money provider ${providerId} not found`);
          }
          const userDailyVolume = await this.getUserDailyVolume(wallet.userId, providerId);
          const userMonthlyVolume = await this.getUserMonthlyVolume(wallet.userId, providerId);
          const limitsCheck = this.mobileMoneyService.validateTransactionLimits(
            providerId,
            request.amount,
            userDailyVolume,
            userMonthlyVolume
          );
          if (!limitsCheck.isValid) {
            throw new Error(`Transaction limits exceeded: ${limitsCheck.error}`);
          }
          const fees = this.mobileMoneyService.calculateFees(providerId, "deposit", request.amount);
          const mobileMoneyRequest = {
            providerId,
            accountId: `${wallet.userId}_${providerId}`,
            type: "deposit",
            amount: request.amount,
            currency: request.currency,
            description: request.description,
            metadata: {
              transactionId,
              userId: wallet.userId,
              propertyId: request.propertyId,
              reservationId: request.reservationId
            }
          };
          const mobileMoneyResponse = await this.mobileMoneyService.processTransaction(mobileMoneyRequest);
          await this.updateTransactionWithMobileMoneyData(
            wallet,
            transactionId,
            mobileMoneyResponse
          );
          if (mobileMoneyResponse.confirmationRequired) {
            await this.updateTransactionStatus(wallet, transactionId, "pending");
            return {
              success: true,
              transactionId,
              status: "pending",
              estimatedConfirmationTime: 300,
              // 5 minutes
              fees: {
                amount: fees.feeAmount,
                currency: request.currency,
                breakdown: {
                  service: fees.feeAmount
                }
              },
              confirmationRequired: true,
              confirmationCode: mobileMoneyResponse.confirmationCode,
              mobileMoneyData: {
                provider: provider.name,
                phoneNumber: validation.formattedNumber || phoneNumber,
                reference: mobileMoneyResponse.reference
              }
            };
          }
          if (mobileMoneyResponse.success && mobileMoneyResponse.status === "completed") {
            await this.updateTransactionStatus(wallet, transactionId, "completed");
            const currency = wallet.fiatCurrencies.find((c) => c.symbol === request.currency);
            if (currency) {
              currency.balance += request.amount;
              await wallet.save();
            }
            return {
              success: true,
              transactionId,
              status: "completed",
              fees: {
                amount: fees.feeAmount,
                currency: request.currency,
                breakdown: {
                  service: fees.feeAmount
                }
              },
              mobileMoneyData: {
                provider: provider.name,
                phoneNumber: validation.formattedNumber || phoneNumber,
                reference: mobileMoneyResponse.reference
              }
            };
          }
          await this.updateTransactionStatus(wallet, transactionId, "failed");
          return {
            success: false,
            transactionId,
            status: "failed",
            error: mobileMoneyResponse.error || "Mobile money payment failed",
            fees: {
              amount: 0,
              currency: request.currency,
              breakdown: {}
            }
          };
        } catch (error2) {
          console.error("Mobile money payment error:", error2);
          await this.updateTransactionStatus(wallet, transactionId, "failed");
          return {
            success: false,
            transactionId,
            status: "failed",
            error: error2 instanceof Error ? error2.message : "Mobile money payment failed",
            fees: {
              amount: 0,
              currency: request.currency,
              breakdown: {}
            }
          };
        }
      }
      async getUserDailyVolume(userId, providerId) {
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const wallet = await EnhancedWallet.findOne({ userId });
        if (!wallet) return 0;
        return wallet.transactions.filter(
          (tx) => tx.metadata?.mobileMoneyProviderId === providerId && new Date(tx.createdAt) >= today && tx.status === "completed"
        ).reduce((sum, tx) => sum + tx.amount, 0);
      }
      async getUserMonthlyVolume(userId, providerId) {
        const firstOfMonth = /* @__PURE__ */ new Date();
        firstOfMonth.setDate(1);
        firstOfMonth.setHours(0, 0, 0, 0);
        const wallet = await EnhancedWallet.findOne({ userId });
        if (!wallet) return 0;
        return wallet.transactions.filter(
          (tx) => tx.metadata?.mobileMoneyProviderId === providerId && new Date(tx.createdAt) >= firstOfMonth && tx.status === "completed"
        ).reduce((sum, tx) => sum + tx.amount, 0);
      }
      async updateTransactionWithMobileMoneyData(wallet, transactionId, mobileMoneyResponse) {
        const transaction = wallet.transactions.find((tx) => tx.id === transactionId);
        if (transaction) {
          transaction.metadata = {
            ...transaction.metadata,
            mobileMoneyProviderId: mobileMoneyResponse.providerId,
            mobileMoneyReference: mobileMoneyResponse.reference,
            mobileMoneyStatus: mobileMoneyResponse.status,
            externalTransactionId: mobileMoneyResponse.transactionId
          };
          await wallet.save();
        }
      }
      generateCryptoQRCode(address, amount, currency) {
        return `${currency.toLowerCase()}:${address}?amount=${amount}`;
      }
      generateWalletAddress(currency) {
        const prefix = currency === "BTC" ? "1" : "0x";
        const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        let result = prefix;
        for (let i = 0; i < (currency === "BTC" ? 33 : 40); i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }
      async sendPaymentNotification(wallet, request, result) {
      }
    };
    __publicField(_UnifiedPaymentService, "instance");
    UnifiedPaymentService = _UnifiedPaymentService;
  }
});

// src/notifications/models/Notification.ts
import mongoose26, { Schema as Schema24 } from "mongoose";
var NotificationSchema, Notification2;
var init_Notification2 = __esm({
  "src/notifications/models/Notification.ts"() {
    NotificationSchema = new Schema24({
      userId: { type: String, required: true, index: true },
      type: {
        type: String,
        required: true,
        enum: ["wallet", "property", "service", "general", "security", "reminder"]
      },
      category: {
        type: String,
        required: true,
        enum: ["transaction", "payment", "transfer", "rent", "reservation", "maintenance", "message", "alert"]
      },
      title: { type: String, required: true, maxlength: 100 },
      message: { type: String, required: true, maxlength: 500 },
      isRead: { type: Boolean, default: false, index: true },
      priority: {
        type: String,
        default: "medium",
        enum: ["low", "medium", "high", "urgent"]
      },
      channels: {
        inApp: { type: Boolean, default: true },
        push: { type: Boolean, default: true },
        email: { type: Boolean, default: false },
        sms: { type: Boolean, default: false }
      },
      metadata: { type: Schema24.Types.Mixed },
      scheduledFor: { type: Date },
      sentAt: {
        inApp: { type: Date },
        push: { type: Date },
        email: { type: Date },
        sms: { type: Date }
      },
      deliveryStatus: {
        inApp: { type: String, default: "pending", enum: ["pending", "delivered", "failed"] },
        push: { type: String, default: "not_sent", enum: ["pending", "delivered", "failed", "not_sent"] },
        email: { type: String, default: "not_sent", enum: ["pending", "delivered", "failed", "not_sent"] },
        sms: { type: String, default: "not_sent", enum: ["pending", "delivered", "failed", "not_sent"] }
      }
    }, {
      timestamps: true
    });
    NotificationSchema.index({ userId: 1, isRead: 1, createdAt: -1 });
    NotificationSchema.index({ type: 1, category: 1 });
    NotificationSchema.index({ scheduledFor: 1 });
    NotificationSchema.index({ "deliveryStatus.push": 1 });
    NotificationSchema.index({ "deliveryStatus.email": 1 });
    Notification2 = mongoose26.models.Notification || mongoose26.model("Notification", NotificationSchema);
  }
});

// src/notifications/models/NotificationPreference.ts
import mongoose27, { Schema as Schema25 } from "mongoose";
var channelPreferenceSchema, NotificationPreferenceSchema2, NotificationPreference2;
var init_NotificationPreference2 = __esm({
  "src/notifications/models/NotificationPreference.ts"() {
    channelPreferenceSchema = {
      inApp: { type: Boolean, default: true },
      push: { type: Boolean, default: true },
      email: { type: Boolean, default: false },
      sms: { type: Boolean, default: false }
    };
    NotificationPreferenceSchema2 = new Schema25({
      userId: { type: String, required: true, unique: true },
      preferences: {
        wallet: channelPreferenceSchema,
        property: channelPreferenceSchema,
        service: channelPreferenceSchema,
        general: channelPreferenceSchema,
        security: {
          inApp: { type: Boolean, default: true },
          push: { type: Boolean, default: true },
          email: { type: Boolean, default: true },
          sms: { type: Boolean, default: false }
        },
        reminder: channelPreferenceSchema
      },
      quietHours: {
        enabled: { type: Boolean, default: false },
        startTime: { type: String, default: "22:00" },
        endTime: { type: String, default: "08:00" },
        timezone: { type: String, default: "Europe/Paris" }
      },
      pushToken: { type: String },
      deviceInfo: {
        platform: { type: String, enum: ["ios", "android", "web"] },
        deviceId: { type: String },
        appVersion: { type: String }
      }
    }, {
      timestamps: true
    });
    NotificationPreference2 = mongoose27.models.NotificationPreference || mongoose27.model("NotificationPreference", NotificationPreferenceSchema2);
  }
});

// src/notifications/services/PushNotificationService.ts
var FCMProvider2, APNSProvider2, PushNotificationService2;
var init_PushNotificationService2 = __esm({
  "src/notifications/services/PushNotificationService.ts"() {
    init_NotificationPreference2();
    FCMProvider2 = class {
      constructor() {
        __publicField(this, "fcm");
        try {
          const admin2 = __require("firebase-admin");
          if (!admin2.apps.length) {
            const serviceAccount = __require(process.env.FIREBASE_SERVICE_ACCOUNT_PATH || "./firebase-service-account.json");
            admin2.initializeApp({
              credential: admin2.credential.cert(serviceAccount),
              projectId: process.env.FIREBASE_PROJECT_ID
            });
          }
          this.fcm = admin2.messaging();
        } catch (error2) {
          console.warn("Firebase not configured, push notifications disabled:", error2.message);
          this.fcm = null;
        }
      }
      async sendNotification(token, payload) {
        if (!this.fcm) {
          throw new Error("Firebase not configured");
        }
        try {
          const message = {
            token,
            notification: {
              title: payload.title,
              body: payload.body,
              ...payload.icon && { icon: payload.icon },
              ...payload.image && { image: payload.image }
            },
            data: payload.data ? this.stringifyData(payload.data) : {},
            android: {
              notification: {
                ...payload.sound && { sound: payload.sound },
                ...payload.clickAction && { clickAction: payload.clickAction },
                priority: "high"
              }
            },
            apns: {
              payload: {
                aps: {
                  ...payload.badge && { badge: payload.badge },
                  ...payload.sound && { sound: payload.sound },
                  "content-available": 1
                }
              }
            },
            webpush: {
              notification: {
                title: payload.title,
                body: payload.body,
                ...payload.icon && { icon: payload.icon },
                ...payload.image && { image: payload.image },
                requireInteraction: payload.title.includes("urgent"),
                actions: payload.clickAction ? [
                  {
                    action: "open",
                    title: "Ouvrir",
                    icon: "/icons/open.png"
                  }
                ] : void 0
              },
              fcmOptions: {
                link: payload.clickAction
              }
            }
          };
          const response = await this.fcm.send(message);
          console.log("Push notification sent successfully:", response);
          return true;
        } catch (error2) {
          console.error("Erreur envoi push FCM:", error2);
          if (error2.code === "messaging/registration-token-not-registered" || error2.code === "messaging/invalid-registration-token") {
            await this.cleanupInvalidToken(token);
          }
          return false;
        }
      }
      stringifyData(data) {
        const result = {};
        for (const [key, value] of Object.entries(data)) {
          result[key] = typeof value === "string" ? value : JSON.stringify(value);
        }
        return result;
      }
      async cleanupInvalidToken(token) {
        try {
          await NotificationPreference2.updateMany(
            { pushToken: token },
            { $unset: { pushToken: 1 } }
          );
          console.log("Invalid push token removed:", token);
        } catch (error2) {
          console.error("Erreur suppression token invalide:", error2);
        }
      }
    };
    APNSProvider2 = class {
      async sendNotification(token, payload) {
        console.warn("APNS provider not implemented");
        return false;
      }
    };
    PushNotificationService2 = class {
      constructor() {
        __publicField(this, "providers", /* @__PURE__ */ new Map());
        this.providers.set("fcm", new FCMProvider2());
        this.providers.set("apns", new APNSProvider2());
      }
      async sendNotification(notification) {
        try {
          const preferences = await NotificationPreference2.findOne({
            userId: notification.userId,
            pushToken: { $exists: true, $ne: null }
          });
          if (!preferences?.pushToken) {
            throw new Error("No push token found for user");
          }
          const payload = this.buildPayload(notification);
          const platform = preferences.deviceInfo?.platform || "android";
          const provider = this.getProvider(platform);
          const success = await provider.sendNotification(preferences.pushToken, payload);
          if (!success) {
            throw new Error("Push notification failed");
          }
        } catch (error2) {
          console.error("Erreur PushNotificationService:", error2);
          throw error2;
        }
      }
      buildPayload(notification) {
        const payload = {
          title: notification.title,
          body: notification.message,
          data: {
            notificationId: notification._id.toString(),
            type: notification.type,
            category: notification.category,
            priority: notification.priority,
            ...notification.metadata
          }
        };
        switch (notification.type) {
          case "wallet":
            payload.icon = "/icons/wallet.png";
            payload.sound = "default";
            break;
          case "property":
            payload.icon = "/icons/property.png";
            payload.sound = "default";
            break;
          case "service":
            payload.icon = "/icons/service.png";
            break;
          case "security":
            payload.icon = "/icons/security.png";
            payload.sound = "alert";
            break;
          default:
            payload.icon = "/icons/default.png";
        }
        switch (notification.priority) {
          case "urgent":
            payload.sound = "alert";
            payload.badge = 1;
            break;
          case "high":
            payload.sound = "default";
            payload.badge = 1;
            break;
          default:
            payload.sound = notification.type === "security" ? "default" : void 0;
        }
        if (notification.metadata?.actionUrl) {
          payload.clickAction = notification.metadata.actionUrl;
        }
        if (notification.metadata?.imageUrl) {
          payload.image = notification.metadata.imageUrl;
        }
        return payload;
      }
      getProvider(platform) {
        switch (platform) {
          case "ios":
            return this.providers.get("apns") || this.providers.get("fcm");
          case "android":
          case "web":
          default:
            return this.providers.get("fcm");
        }
      }
      // Méthode pour envoyer des notifications push en masse
      async sendBulkNotifications(notifications) {
        const batchSize = 100;
        for (let i = 0; i < notifications.length; i += batchSize) {
          const batch = notifications.slice(i, i + batchSize);
          const promises = batch.map(
            (notification) => this.sendNotification(notification).catch((error2) => {
              console.error(`Erreur envoi notification ${notification._id}:`, error2);
              return null;
            })
          );
          await Promise.allSettled(promises);
          if (i + batchSize < notifications.length) {
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
        }
      }
      // Méthode pour tester le token push
      async testPushToken(token, platform = "android") {
        try {
          const provider = this.getProvider(platform);
          const testPayload = {
            title: "Test de notification",
            body: "Votre token push fonctionne correctement !",
            data: { test: "true" }
          };
          return await provider.sendNotification(token, testPayload);
        } catch (error2) {
          console.error("Erreur test token push:", error2);
          return false;
        }
      }
    };
  }
});

// src/notifications/services/EmailNotificationService.ts
var NodemailerProvider, SendGridProvider, EmailNotificationService2;
var init_EmailNotificationService2 = __esm({
  "src/notifications/services/EmailNotificationService.ts"() {
    init_userModel();
    NodemailerProvider = class {
      constructor() {
        __publicField(this, "transporter");
        this.initializeTransporter();
      }
      async initializeTransporter() {
        try {
          const nodemailer2 = __require("nodemailer");
          if (process.env.EMAIL_SERVICE === "gmail") {
            this.transporter = nodemailer2.createTransporter({
              service: "gmail",
              auth: {
                user: process.env.EMAIL_USER,
                pass: process.env.EMAIL_PASSWORD
              }
            });
          } else if (process.env.EMAIL_SERVICE === "sendgrid") {
            this.transporter = nodemailer2.createTransporter({
              host: "smtp.sendgrid.net",
              port: 587,
              secure: false,
              auth: {
                user: "apikey",
                pass: process.env.SENDGRID_API_KEY
              }
            });
          } else if (process.env.EMAIL_SERVICE === "smtp") {
            this.transporter = nodemailer2.createTransporter({
              host: process.env.SMTP_HOST,
              port: parseInt(process.env.SMTP_PORT || "587"),
              secure: process.env.SMTP_SECURE === "true",
              auth: {
                user: process.env.SMTP_USER,
                pass: process.env.SMTP_PASSWORD
              }
            });
          } else {
            this.transporter = nodemailer2.createTransporter({
              host: "localhost",
              port: 1025,
              ignoreTLS: true,
              auth: false
            });
          }
        } catch (error2) {
          console.warn("Email transporter not configured:", error2.message);
          this.transporter = null;
        }
      }
      async sendEmail(to, subject, html, text) {
        if (!this.transporter) {
          throw new Error("Email transporter not configured");
        }
        try {
          const mailOptions = {
            from: process.env.EMAIL_FROM || "noreply@easyrent.com",
            to,
            subject,
            html,
            text: text || this.htmlToText(html)
          };
          const result = await this.transporter.sendMail(mailOptions);
          console.log("Email sent successfully:", result.messageId);
          return true;
        } catch (error2) {
          console.error("Erreur envoi email:", error2);
          return false;
        }
      }
      htmlToText(html) {
        return html.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
      }
    };
    SendGridProvider = class {
      constructor() {
        __publicField(this, "sgMail");
        try {
          this.sgMail = __require("@sendgrid/mail");
          this.sgMail.setApiKey(process.env.SENDGRID_API_KEY);
        } catch (error2) {
          console.warn("SendGrid not configured:", error2.message);
          this.sgMail = null;
        }
      }
      async sendEmail(to, subject, html, text) {
        if (!this.sgMail) {
          throw new Error("SendGrid not configured");
        }
        try {
          const msg = {
            to,
            from: process.env.EMAIL_FROM || "noreply@easyrent.com",
            subject,
            html,
            text: text || this.htmlToText(html)
          };
          await this.sgMail.send(msg);
          console.log("Email sent via SendGrid");
          return true;
        } catch (error2) {
          console.error("Erreur SendGrid:", error2);
          return false;
        }
      }
      htmlToText(html) {
        return html.replace(/<[^>]*>/g, "").replace(/\s+/g, " ").trim();
      }
    };
    EmailNotificationService2 = class {
      constructor() {
        __publicField(this, "provider");
        __publicField(this, "templates", /* @__PURE__ */ new Map());
        const emailService = process.env.EMAIL_SERVICE || "nodemailer";
        switch (emailService) {
          case "sendgrid":
            this.provider = new SendGridProvider();
            break;
          case "nodemailer":
          default:
            this.provider = new NodemailerProvider();
            break;
        }
        this.initializeTemplates();
      }
      async sendNotification(notification) {
        try {
          const user = await userModel_default.findById(notification.userId);
          if (!user?.email) {
            throw new Error("User email not found");
          }
          const { subject, html, text } = this.buildEmail(notification, user);
          const success = await this.provider.sendEmail(user.email, subject, html, text);
          if (!success) {
            throw new Error("Email sending failed");
          }
        } catch (error2) {
          console.error("Erreur EmailNotificationService:", error2);
          throw error2;
        }
      }
      buildEmail(notification, user) {
        const template = this.getTemplate(notification.type, notification.category);
        const templateData = {
          user: {
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email
          },
          notification: {
            title: notification.title,
            message: notification.message,
            type: notification.type,
            category: notification.category,
            priority: notification.priority,
            metadata: notification.metadata || {},
            createdAt: notification.createdAt
          },
          app: {
            name: process.env.APP_NAME || "EasyRent",
            url: process.env.APP_URL || "https://easyrent.com",
            supportEmail: process.env.SUPPORT_EMAIL || "support@easyrent.com"
          }
        };
        return {
          subject: this.renderTemplate(template.subject, templateData),
          html: this.renderTemplate(template.html, templateData),
          text: this.renderTemplate(template.text, templateData)
        };
      }
      getTemplate(type, category) {
        const key = `${type}_${category}`;
        return this.templates.get(key) || this.templates.get("default");
      }
      renderTemplate(template, data) {
        return template.replace(/\{\{([^}]+)\}\}/g, (match, path4) => {
          const value = this.getNestedProperty(data, path4.trim());
          return value !== void 0 ? String(value) : match;
        });
      }
      getNestedProperty(obj, path4) {
        return path4.split(".").reduce((current, key) => current?.[key], obj);
      }
      initializeTemplates() {
        this.templates.set("default", {
          subject: "{{notification.title}} - {{app.name}}",
          html: `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{{notification.title}}</title>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: #007bff; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f8f9fa; }
              .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
              .button { display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>{{app.name}}</h1>
              </div>
              <div class="content">
                <h2>{{notification.title}}</h2>
                <p>Bonjour {{user.firstName}},</p>
                <p>{{notification.message}}</p>
                {{#if notification.metadata.actionUrl}}
                <p><a href="{{app.url}}{{notification.metadata.actionUrl}}" class="button">Voir les d\xE9tails</a></p>
                {{/if}}
              </div>
              <div class="footer">
                <p>{{app.name}} - <a href="mailto:{{app.supportEmail}}">Support</a></p>
              </div>
            </div>
          </body>
        </html>
      `,
          text: `
        {{notification.title}}

        Bonjour {{user.firstName}},

        {{notification.message}}

        {{#if notification.metadata.actionUrl}}
        Voir les d\xE9tails: {{app.url}}{{notification.metadata.actionUrl}}
        {{/if}}

        ---
        {{app.name}}
        Support: {{app.supportEmail}}
      `
        });
        this.templates.set("wallet_transaction", {
          subject: "Transaction {{notification.metadata.amount}} {{notification.metadata.currency}} - {{app.name}}",
          html: `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{{notification.title}}</title>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: #28a745; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f8f9fa; }
              .transaction-details { background: white; padding: 15px; border-left: 4px solid #28a745; margin: 20px 0; }
              .amount { font-size: 24px; font-weight: bold; color: #28a745; }
              .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
              .button { display: inline-block; padding: 10px 20px; background: #28a745; color: white; text-decoration: none; border-radius: 5px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>\u{1F4B0} {{notification.title}}</h1>
              </div>
              <div class="content">
                <p>Bonjour {{user.firstName}},</p>
                <p>{{notification.message}}</p>

                <div class="transaction-details">
                  <h3>D\xE9tails de la transaction</h3>
                  <p><strong>Montant:</strong> <span class="amount">{{notification.metadata.amount}} {{notification.metadata.currency}}</span></p>
                  <p><strong>Date:</strong> {{notification.createdAt}}</p>
                  {{#if notification.metadata.transactionId}}
                  <p><strong>ID Transaction:</strong> {{notification.metadata.transactionId}}</p>
                  {{/if}}
                </div>

                {{#if notification.metadata.actionUrl}}
                <p><a href="{{app.url}}{{notification.metadata.actionUrl}}" class="button">Voir la transaction</a></p>
                {{/if}}
              </div>
              <div class="footer">
                <p>{{app.name}} - <a href="mailto:{{app.supportEmail}}">Support</a></p>
              </div>
            </div>
          </body>
        </html>
      `,
          text: `
        {{notification.title}}

        Bonjour {{user.firstName}},

        {{notification.message}}

        D\xE9tails de la transaction:
        - Montant: {{notification.metadata.amount}} {{notification.metadata.currency}}
        - Date: {{notification.createdAt}}
        {{#if notification.metadata.transactionId}}
        - ID Transaction: {{notification.metadata.transactionId}}
        {{/if}}

        {{#if notification.metadata.actionUrl}}
        Voir la transaction: {{app.url}}{{notification.metadata.actionUrl}}
        {{/if}}

        ---
        {{app.name}}
        Support: {{app.supportEmail}}
      `
        });
        this.templates.set("security_alert", {
          subject: "\u{1F512} Alerte de s\xE9curit\xE9 - {{app.name}}",
          html: `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{{notification.title}}</title>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
              .container { max-width: 600px; margin: 0 auto; padding: 20px; }
              .header { background: #dc3545; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f8f9fa; }
              .alert-box { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 20px 0; }
              .footer { text-align: center; padding: 20px; font-size: 12px; color: #666; }
              .button { display: inline-block; padding: 10px 20px; background: #dc3545; color: white; text-decoration: none; border-radius: 5px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>\u{1F512} {{notification.title}}</h1>
              </div>
              <div class="content">
                <p>Bonjour {{user.firstName}},</p>

                <div class="alert-box">
                  <p><strong>\u26A0\uFE0F Alerte de s\xE9curit\xE9</strong></p>
                  <p>{{notification.message}}</p>
                </div>

                <p>Si cette action n'a pas \xE9t\xE9 effectu\xE9e par vous, veuillez imm\xE9diatement:</p>
                <ul>
                  <li>Changer votre mot de passe</li>
                  <li>V\xE9rifier les connexions r\xE9centes</li>
                  <li>Contacter notre support</li>
                </ul>

                {{#if notification.metadata.actionUrl}}
                <p><a href="{{app.url}}{{notification.metadata.actionUrl}}" class="button">S\xE9curiser mon compte</a></p>
                {{/if}}
              </div>
              <div class="footer">
                <p>{{app.name}} - <a href="mailto:{{app.supportEmail}}">Support</a></p>
              </div>
            </div>
          </body>
        </html>
      `,
          text: `
        \u{1F512} {{notification.title}}

        Bonjour {{user.firstName}},

        \u26A0\uFE0F ALERTE DE S\xC9CURIT\xC9

        {{notification.message}}

        Si cette action n'a pas \xE9t\xE9 effectu\xE9e par vous, veuillez imm\xE9diatement:
        - Changer votre mot de passe
        - V\xE9rifier les connexions r\xE9centes
        - Contacter notre support

        {{#if notification.metadata.actionUrl}}
        S\xE9curiser mon compte: {{app.url}}{{notification.metadata.actionUrl}}
        {{/if}}

        ---
        {{app.name}}
        Support: {{app.supportEmail}}
      `
        });
      }
    };
  }
});

// src/notifications/services/InAppNotificationService.ts
import { EventEmitter as EventEmitter2 } from "events";
var InAppNotificationService2;
var init_InAppNotificationService2 = __esm({
  "src/notifications/services/InAppNotificationService.ts"() {
    InAppNotificationService2 = class extends EventEmitter2 {
      constructor() {
        super();
        __publicField(this, "connectedUsers", /* @__PURE__ */ new Map());
      }
      // Méthode pour connecter un utilisateur via WebSocket
      connectUser(userId, socket) {
        if (!this.connectedUsers.has(userId)) {
          this.connectedUsers.set(userId, /* @__PURE__ */ new Set());
        }
        this.connectedUsers.get(userId)?.add(socket);
        socket.on("disconnect", () => {
          this.disconnectUser(userId, socket);
        });
        socket.on("close", () => {
          this.disconnectUser(userId, socket);
        });
      }
      // Méthode pour déconnecter un utilisateur
      disconnectUser(userId, socket) {
        const userSockets = this.connectedUsers.get(userId);
        if (userSockets) {
          userSockets.delete(socket);
          if (userSockets.size === 0) {
            this.connectedUsers.delete(userId);
          }
        }
      }
      // Envoyer une notification in-app
      async sendNotification(notification) {
        try {
          const userSockets = this.connectedUsers.get(notification.userId);
          if (!userSockets || userSockets.size === 0) {
            return;
          }
          const notificationData = {
            id: notification._id,
            type: notification.type,
            category: notification.category,
            title: notification.title,
            message: notification.message,
            priority: notification.priority,
            metadata: notification.metadata,
            createdAt: notification.createdAt,
            isRead: notification.isRead
          };
          userSockets.forEach((socket) => {
            try {
              if (socket.readyState === 1) {
                socket.send(JSON.stringify({
                  type: "notification",
                  data: notificationData
                }));
              }
            } catch (error2) {
              console.error("Erreur envoi notification WebSocket:", error2);
              this.disconnectUser(notification.userId, socket);
            }
          });
          this.emit("notificationSent", {
            userId: notification.userId,
            notification: notificationData
          });
        } catch (error2) {
          console.error("Erreur dans sendNotification:", error2);
          throw error2;
        }
      }
      // Envoyer une notification de mise à jour de statut
      async sendStatusUpdate(userId, type, data) {
        const userSockets = this.connectedUsers.get(userId);
        if (!userSockets || userSockets.size === 0) {
          return;
        }
        const updateData = {
          type: "status_update",
          statusType: type,
          data,
          timestamp: /* @__PURE__ */ new Date()
        };
        userSockets.forEach((socket) => {
          try {
            if (socket.readyState === 1) {
              socket.send(JSON.stringify(updateData));
            }
          } catch (error2) {
            console.error("Erreur envoi mise \xE0 jour statut:", error2);
            this.disconnectUser(userId, socket);
          }
        });
      }
      // Obtenir le nombre d'utilisateurs connectés
      getConnectedUsersCount() {
        return this.connectedUsers.size;
      }
      // Obtenir la liste des utilisateurs connectés
      getConnectedUsers() {
        return Array.from(this.connectedUsers.keys());
      }
      // Vérifier si un utilisateur est connecté
      isUserConnected(userId) {
        const userSockets = this.connectedUsers.get(userId);
        return userSockets !== void 0 && userSockets.size > 0;
      }
      // Diffuser un message à tous les utilisateurs connectés
      broadcast(message) {
        this.connectedUsers.forEach((sockets, userId) => {
          sockets.forEach((socket) => {
            try {
              if (socket.readyState === 1) {
                socket.send(JSON.stringify(message));
              }
            } catch (error2) {
              console.error("Erreur broadcast:", error2);
              this.disconnectUser(userId, socket);
            }
          });
        });
      }
      // Diffuser un message à des utilisateurs spécifiques
      broadcastToUsers(userIds, message) {
        userIds.forEach((userId) => {
          const userSockets = this.connectedUsers.get(userId);
          if (userSockets) {
            userSockets.forEach((socket) => {
              try {
                if (socket.readyState === 1) {
                  socket.send(JSON.stringify(message));
                }
              } catch (error2) {
                console.error("Erreur broadcast sp\xE9cifique:", error2);
                this.disconnectUser(userId, socket);
              }
            });
          }
        });
      }
    };
  }
});

// src/notifications/services/NotificationService.ts
var NotificationService2;
var init_NotificationService = __esm({
  "src/notifications/services/NotificationService.ts"() {
    init_Notification2();
    init_NotificationPreference2();
    init_PushNotificationService2();
    init_EmailNotificationService2();
    init_InAppNotificationService2();
    NotificationService2 = class {
      constructor() {
        __publicField(this, "pushService");
        __publicField(this, "emailService");
        __publicField(this, "inAppService");
        this.pushService = new PushNotificationService2();
        this.emailService = new EmailNotificationService2();
        this.inAppService = new InAppNotificationService2();
      }
      async createNotification(input) {
        try {
          const preferences = await this.getUserPreferences(input.userId);
          const channels = this.determineChannels(input, preferences);
          const notification = new Notification2({
            userId: input.userId,
            type: input.type,
            category: input.category,
            title: input.title,
            message: input.message,
            priority: input.priority || "medium",
            channels,
            metadata: input.metadata,
            scheduledFor: input.scheduledFor,
            deliveryStatus: {
              inApp: channels.inApp ? "pending" : "not_sent",
              push: channels.push ? "pending" : "not_sent",
              email: channels.email ? "pending" : "not_sent",
              sms: channels.sms ? "pending" : "not_sent"
            }
          });
          await notification.save();
          if (!input.scheduledFor) {
            await this.sendNotification(notification);
          }
          return notification;
        } catch (error2) {
          throw new Error(`Erreur lors de la cr\xE9ation de la notification: ${error2.message}`);
        }
      }
      async sendNotification(notification) {
        try {
          const promises = [];
          if (notification.channels.inApp && notification.deliveryStatus.inApp === "pending") {
            promises.push(this.sendInAppNotification(notification));
          }
          if (notification.channels.push && notification.deliveryStatus.push === "pending") {
            promises.push(this.sendPushNotification(notification));
          }
          if (notification.channels.email && notification.deliveryStatus.email === "pending") {
            promises.push(this.sendEmailNotification(notification));
          }
          await Promise.allSettled(promises);
        } catch (error2) {
          console.error("Erreur lors de l'envoi de la notification:", error2);
        }
      }
      async sendInAppNotification(notification) {
        try {
          await this.inAppService.sendNotification(notification);
          await Notification2.updateOne(
            { _id: notification._id },
            {
              "deliveryStatus.inApp": "delivered",
              "sentAt.inApp": /* @__PURE__ */ new Date()
            }
          );
        } catch (error2) {
          await Notification2.updateOne(
            { _id: notification._id },
            { "deliveryStatus.inApp": "failed" }
          );
          throw error2;
        }
      }
      async sendPushNotification(notification) {
        try {
          await this.pushService.sendNotification(notification);
          await Notification2.updateOne(
            { _id: notification._id },
            {
              "deliveryStatus.push": "delivered",
              "sentAt.push": /* @__PURE__ */ new Date()
            }
          );
        } catch (error2) {
          await Notification2.updateOne(
            { _id: notification._id },
            { "deliveryStatus.push": "failed" }
          );
          console.error("Erreur envoi push:", error2);
        }
      }
      async sendEmailNotification(notification) {
        try {
          await this.emailService.sendNotification(notification);
          await Notification2.updateOne(
            { _id: notification._id },
            {
              "deliveryStatus.email": "delivered",
              "sentAt.email": /* @__PURE__ */ new Date()
            }
          );
        } catch (error2) {
          await Notification2.updateOne(
            { _id: notification._id },
            { "deliveryStatus.email": "failed" }
          );
          console.error("Erreur envoi email:", error2);
        }
      }
      async getUserNotifications(userId, options = {}) {
        const query2 = { userId };
        if (options.type) query2.type = options.type;
        if (typeof options.isRead === "boolean") query2.isRead = options.isRead;
        const limit = options.limit || 50;
        const offset = options.offset || 0;
        const [notifications, total] = await Promise.all([
          Notification2.find(query2).sort({ createdAt: -1 }).limit(limit).skip(offset),
          Notification2.countDocuments(query2)
        ]);
        return { notifications, total };
      }
      async markAsRead(userId, notificationId) {
        await Notification2.updateOne(
          { _id: notificationId, userId },
          { isRead: true }
        );
      }
      async markAllAsRead(userId) {
        await Notification2.updateMany(
          { userId, isRead: false },
          { isRead: true }
        );
      }
      async deleteNotification(userId, notificationId) {
        await Notification2.deleteOne({ _id: notificationId, userId });
      }
      async getUserPreferences(userId) {
        let preferences = await NotificationPreference2.findOne({ userId });
        if (!preferences) {
          preferences = new NotificationPreference2({
            userId,
            preferences: {
              wallet: { inApp: true, push: true, email: false, sms: false },
              property: { inApp: true, push: true, email: true, sms: false },
              service: { inApp: true, push: true, email: false, sms: false },
              general: { inApp: true, push: false, email: false, sms: false },
              security: { inApp: true, push: true, email: true, sms: false },
              reminder: { inApp: true, push: true, email: false, sms: false }
            }
          });
          await preferences.save();
        }
        return preferences;
      }
      async updateUserPreferences(userId, preferences) {
        return await NotificationPreference2.findOneAndUpdate(
          { userId },
          { $set: { preferences } },
          { new: true, upsert: true }
        );
      }
      async registerPushToken(userId, pushToken, deviceInfo) {
        await NotificationPreference2.updateOne(
          { userId },
          {
            $set: {
              pushToken,
              ...deviceInfo && { deviceInfo }
            }
          },
          { upsert: true }
        );
      }
      determineChannels(input, preferences) {
        if (input.forceChannels) {
          return {
            inApp: input.forceChannels.inApp ?? true,
            push: input.forceChannels.push ?? false,
            email: input.forceChannels.email ?? false,
            sms: input.forceChannels.sms ?? false
          };
        }
        const typePreferences = preferences.preferences[input.type];
        return {
          inApp: typePreferences.inApp,
          push: typePreferences.push && this.canSendPush(preferences),
          email: typePreferences.email,
          sms: typePreferences.sms
        };
      }
      canSendPush(preferences) {
        if (preferences.quietHours?.enabled) {
          const now = /* @__PURE__ */ new Date();
          const currentTime = now.toLocaleTimeString("en-GB", {
            hour: "2-digit",
            minute: "2-digit",
            timeZone: preferences.quietHours.timezone
          });
          const startTime = preferences.quietHours.startTime;
          const endTime = preferences.quietHours.endTime;
          if (this.isInQuietHours(currentTime, startTime, endTime)) {
            return false;
          }
        }
        return !!preferences.pushToken;
      }
      isInQuietHours(currentTime, startTime, endTime) {
        const current = this.timeToMinutes(currentTime);
        const start = this.timeToMinutes(startTime);
        const end = this.timeToMinutes(endTime);
        if (start <= end) {
          return current >= start && current <= end;
        } else {
          return current >= start || current <= end;
        }
      }
      timeToMinutes(time) {
        const [hours, minutes] = time.split(":").map(Number);
        return hours * 60 + minutes;
      }
      // Méthodes pour les notifications spécifiques au wallet
      async sendTransactionNotification(userId, transactionType, amount, currency, transactionId) {
        const titles = {
          "payment": "Paiement effectu\xE9",
          "received": "Paiement re\xE7u",
          "transfer": "Transfert effectu\xE9",
          "deposit": "D\xE9p\xF4t effectu\xE9",
          "withdrawal": "Retrait effectu\xE9"
        };
        const messages = {
          "payment": `Vous avez effectu\xE9 un paiement de ${amount} ${currency}`,
          "received": `Vous avez re\xE7u un paiement de ${amount} ${currency}`,
          "transfer": `Vous avez transf\xE9r\xE9 ${amount} ${currency}`,
          "deposit": `Votre compte a \xE9t\xE9 cr\xE9dit\xE9 de ${amount} ${currency}`,
          "withdrawal": `Votre compte a \xE9t\xE9 d\xE9bit\xE9 de ${amount} ${currency}`
        };
        await this.createNotification({
          userId,
          type: "wallet",
          category: "transaction",
          title: titles[transactionType] || "Transaction effectu\xE9e",
          message: messages[transactionType] || `Transaction de ${amount} ${currency}`,
          priority: amount > 1e3 ? "high" : "medium",
          metadata: {
            transactionId,
            amount,
            currency,
            actionUrl: `/wallet/transactions/${transactionId}`
          }
        });
      }
      async sendLowBalanceNotification(userId, balance, currency) {
        await this.createNotification({
          userId,
          type: "wallet",
          category: "alert",
          title: "Solde faible",
          message: `Votre solde est faible: ${balance} ${currency}`,
          priority: "high",
          metadata: {
            balance,
            currency,
            actionUrl: "/wallet/deposit"
          },
          forceChannels: {
            inApp: true,
            push: true,
            email: true
          }
        });
      }
    };
  }
});

// src/wallet/graphql/walletResolvers.ts
var notificationService2, inAppService, priceService, securityService, mobileMoneyService, walletResolvers;
var init_walletResolvers = __esm({
  "src/wallet/graphql/walletResolvers.ts"() {
    init_Wallet();
    init_EnhancedWallet();
    init_Transaction();
    init_PaymentMethod();
    init_walletService();
    init_paymentMethodService();
    init_cryptoService();
    init_UnifiedPaymentService();
    init_PriceService();
    init_SecurityService();
    init_MobileMoneyService();
    init_userModel();
    init_propertyModel();
    init_Service();
    init_Notification2();
    init_NotificationService();
    init_InAppNotificationService2();
    init_config();
    notificationService2 = new NotificationService2();
    inAppService = new InAppNotificationService2();
    priceService = new PriceService();
    securityService = new SecurityService();
    mobileMoneyService = new MobileMoneyService();
    walletResolvers = {
      Query: {
        wallet: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const walletService = new WalletService();
            let wallet = await walletService.getWallet(user.userId);
            if (!wallet) {
              wallet = await walletService.createWallet(user.userId);
            }
            return wallet;
          } catch (error2) {
            throw new Error(`Error fetching wallet: ${error2.message}`);
          }
        },
        transaction: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const walletService = new WalletService();
            const transaction = await walletService.getTransactionById(user.userId, id);
            if (!transaction) throw new Error("Transaction not found");
            return transaction;
          } catch (error2) {
            throw new Error(`Error fetching transaction: ${error2.message}`);
          }
        },
        transactions: async (_, { filters, pagination }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const limit = pagination?.limit || 50;
            const skip = ((pagination?.page || 1) - 1) * limit;
            const query2 = {
              $or: [{ userId: user.userId }, { recipientId: user.userId }]
            };
            if (filters?.type) query2.type = filters.type;
            if (filters?.status) query2.status = filters.status;
            if (filters?.currency) query2.currency = filters.currency;
            if (filters?.paymentMethodId) query2.paymentMethodId = filters.paymentMethodId;
            if (filters?.minAmount || filters?.maxAmount) {
              query2.amount = {};
              if (filters.minAmount) query2.amount.$gte = filters.minAmount;
              if (filters.maxAmount) query2.amount.$lte = filters.maxAmount;
            }
            if (filters?.dateFrom || filters?.dateTo) {
              query2.createdAt = {};
              if (filters.dateFrom) query2.createdAt.$gte = new Date(filters.dateFrom);
              if (filters.dateTo) query2.createdAt.$lte = new Date(filters.dateTo);
            }
            const [transactions, total] = await Promise.all([
              Transaction.find(query2).sort({ createdAt: -1 }).skip(skip).limit(limit),
              Transaction.countDocuments(query2)
            ]);
            const edges = transactions.map((transaction, index) => ({
              node: transaction,
              cursor: Buffer.from((skip + index).toString()).toString("base64")
            }));
            return {
              edges,
              pageInfo: {
                hasNextPage: skip + limit < total,
                hasPreviousPage: skip > 0,
                startCursor: edges[0]?.cursor,
                endCursor: edges[edges.length - 1]?.cursor
              },
              totalCount: total
            };
          } catch (error2) {
            throw new Error(`Error fetching transactions: ${error2.message}`);
          }
        },
        paymentMethods: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentMethodService = new PaymentMethodService();
            return await paymentMethodService.getPaymentMethods(user.userId);
          } catch (error2) {
            throw new Error(`Error fetching payment methods: ${error2.message}`);
          }
        },
        walletStats: async (_, { dateFrom, dateTo }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const query2 = { userId: user.userId };
            if (dateFrom || dateTo) {
              query2.createdAt = {};
              if (dateFrom) query2.createdAt.$gte = new Date(dateFrom);
              if (dateTo) query2.createdAt.$lte = new Date(dateTo);
            }
            const transactions = await Transaction.find(query2);
            const stats = {
              totalTransactions: transactions.length,
              totalVolume: transactions.reduce((sum, t) => sum + t.amount, 0),
              averageTransaction: transactions.length > 0 ? transactions.reduce((sum, t) => sum + t.amount, 0) / transactions.length : 0,
              transactionsByType: [],
              transactionsByStatus: [],
              monthlyVolume: [],
              topPaymentMethods: []
            };
            const typeStats = transactions.reduce((acc, t) => {
              acc[t.type] = (acc[t.type] || 0) + 1;
              return acc;
            }, {});
            stats.transactionsByType = Object.entries(typeStats).map(([type, count]) => ({
              type,
              count,
              volume: transactions.filter((t) => t.type === type).reduce((sum, t) => sum + t.amount, 0),
              percentage: count / transactions.length * 100
            }));
            const statusStats = transactions.reduce((acc, t) => {
              acc[t.status] = (acc[t.status] || 0) + 1;
              return acc;
            }, {});
            stats.transactionsByStatus = Object.entries(statusStats).map(([status, count]) => ({
              status,
              count,
              percentage: count / transactions.length * 100
            }));
            return stats;
          } catch (error2) {
            throw new Error(`Error fetching wallet stats: ${error2.message}`);
          }
        },
        // Notification queries
        notifications: async (_, { filters, pagination }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const limit = pagination?.limit || 50;
            const offset = ((pagination?.page || 1) - 1) * limit;
            const query2 = { userId: user.userId };
            if (filters?.type) query2.type = filters.type;
            if (filters?.category) query2.category = filters.category;
            if (filters?.priority) query2.priority = filters.priority;
            if (typeof filters?.isRead === "boolean") query2.isRead = filters.isRead;
            if (filters?.dateFrom || filters?.dateTo) {
              query2.createdAt = {};
              if (filters.dateFrom) query2.createdAt.$gte = new Date(filters.dateFrom);
              if (filters.dateTo) query2.createdAt.$lte = new Date(filters.dateTo);
            }
            const [notifications, total, unreadCount] = await Promise.all([
              Notification2.find(query2).sort({ createdAt: -1 }).skip(offset).limit(limit),
              Notification2.countDocuments(query2),
              Notification2.countDocuments({ userId: user.userId, isRead: false })
            ]);
            const edges = notifications.map((notification, index) => ({
              node: notification,
              cursor: Buffer.from((offset + index).toString()).toString("base64")
            }));
            return {
              edges,
              pageInfo: {
                hasNextPage: offset + limit < total,
                hasPreviousPage: offset > 0,
                startCursor: edges[0]?.cursor,
                endCursor: edges[edges.length - 1]?.cursor
              },
              totalCount: total,
              unreadCount
            };
          } catch (error2) {
            throw new Error(`Error fetching notifications: ${error2.message}`);
          }
        },
        notificationPreferences: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const preferences = await notificationService2.getUserPreferences(user.userId);
            return preferences;
          } catch (error2) {
            throw new Error(`Error fetching notification preferences: ${error2.message}`);
          }
        },
        unreadNotificationsCount: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            return await Notification2.countDocuments({
              userId: user.userId,
              isRead: false
            });
          } catch (error2) {
            throw new Error(`Error fetching unread count: ${error2.message}`);
          }
        },
        cryptoPrices: async (_, { currencies }) => {
          try {
            if (!config_default.features?.crypto?.enabled) {
              throw new Error("Crypto functionality is currently disabled");
            }
            const cryptoService = new CryptoService();
            return await cryptoService.getPrices(currencies);
          } catch (error2) {
            throw new Error(`Error fetching crypto prices: ${error2.message}`);
          }
        },
        cryptoPortfolio: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            if (!config_default.features?.crypto?.enabled) {
              throw new Error("Crypto functionality is currently disabled");
            }
            const wallet = await Wallet.findOne({ userId: user.userId });
            return wallet?.cryptoBalances || [];
          } catch (error2) {
            throw new Error(`Error fetching crypto portfolio: ${error2.message}`);
          }
        },
        cryptoConfig: async () => {
          return {
            enabled: config_default.features?.crypto?.enabled || false,
            supportedCurrencies: config_default.features?.crypto?.supportedCurrencies || [],
            minimumBuyAmount: config_default.features?.crypto?.minimumBuyAmount || 10,
            maximumBuyAmount: config_default.features?.crypto?.maximumBuyAmount || 1e4,
            transactionFeePercentage: config_default.features?.crypto?.transactionFeePercentage || 1
          };
        },
        // Enhanced wallet queries
        enhancedWallet: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            let wallet = await EnhancedWallet.findOne({ userId: user.userId });
            if (!wallet) {
              wallet = await EnhancedWallet.create({
                userId: user.userId,
                fiatCurrencies: [{
                  code: "EUR",
                  name: "Euro",
                  balance: 0,
                  isDefault: true,
                  lastUpdated: /* @__PURE__ */ new Date()
                }],
                cryptoCurrencies: [],
                paymentMethods: [],
                transactions: []
              });
            }
            return wallet;
          } catch (error2) {
            throw new Error(`Error fetching enhanced wallet: ${error2.message}`);
          }
        },
        convertCurrency: async (_, { fromCurrency, toCurrency, amount }) => {
          try {
            return await priceService.convertCurrency(fromCurrency, toCurrency, amount);
          } catch (error2) {
            throw new Error(`Error converting currency: ${error2.message}`);
          }
        },
        validateTransaction: async (_, { amount, currency, paymentMethod }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const wallet = await EnhancedWallet.findOne({ userId: user.userId });
            if (!wallet) throw new Error("Wallet not found");
            return await securityService.validateTransaction(
              user.userId,
              amount,
              currency,
              paymentMethod,
              wallet.transactions,
              wallet.security
            );
          } catch (error2) {
            throw new Error(`Error validating transaction: ${error2.message}`);
          }
        },
        // Mobile Money queries
        getMobileMoneyProviders: async (_, { countryCode }) => {
          try {
            if (countryCode) {
              return mobileMoneyService.getProvidersByCountry(countryCode);
            }
            return mobileMoneyService.getAllProviders();
          } catch (error2) {
            throw new Error(`Error fetching mobile money providers: ${error2.message}`);
          }
        },
        validatePhoneNumber: async (_, { phoneNumber, countryCode }) => {
          try {
            return mobileMoneyService.validatePhoneNumber(phoneNumber, countryCode);
          } catch (error2) {
            throw new Error(`Error validating phone number: ${error2.message}`);
          }
        },
        calculateMobileMoneyFees: async (_, { providerId, amount, type }) => {
          try {
            return mobileMoneyService.calculateFees(providerId, type, amount);
          } catch (error2) {
            throw new Error(`Error calculating mobile money fees: ${error2.message}`);
          }
        },
        getSupportedCountries: async () => {
          try {
            return mobileMoneyService.getSupportedCountries();
          } catch (error2) {
            throw new Error(`Error fetching supported countries: ${error2.message}`);
          }
        },
        getCountryInfo: async (_, { countryCode }) => {
          try {
            return mobileMoneyService.getCountryInfo(countryCode);
          } catch (error2) {
            throw new Error(`Error fetching country info: ${error2.message}`);
          }
        }
      },
      Mutation: {
        createTransaction: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const walletService = new WalletService();
            const transaction = await walletService.processPayment(user.userId, input);
            await notificationService2.sendTransactionNotification(
              user.userId,
              input.type,
              input.amount,
              input.currency || "EUR",
              transaction._id.toString()
            );
            if (inAppService.isUserConnected(user.userId)) {
              await inAppService.sendStatusUpdate(user.userId, "transaction_created", {
                transaction,
                wallet: await Wallet.findOne({ userId: user.userId })
              });
            }
            return transaction;
          } catch (error2) {
            throw new Error(`Error creating transaction: ${error2.message}`);
          }
        },
        // Enhanced unified payment processing
        processUnifiedPayment: async (_, { request }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentRequest = {
              ...request,
              userId: user.userId
            };
            const unifiedPaymentService = UnifiedPaymentService.getInstance();
            const response = await unifiedPaymentService.processPayment(paymentRequest);
            if (response.success) {
              await notificationService2.sendTransactionNotification(
                user.userId,
                request.type || "payment",
                request.amount,
                request.currency || "EUR",
                response.transactionId
              );
            }
            return response;
          } catch (error2) {
            throw new Error(`Error processing unified payment: ${error2.message}`);
          }
        },
        purchaseCryptoUnified: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentRequest = {
              amount: input.amount,
              currency: input.currency,
              paymentMethodId: input.paymentMethod,
              userId: user.userId,
              type: "purchase",
              description: `Purchase ${input.amount} ${input.cryptoCurrency}`,
              cryptoData: {
                network: input.cryptoCurrency,
                toAddress: user.userId
              }
            };
            const unifiedPaymentService = UnifiedPaymentService.getInstance();
            return await unifiedPaymentService.processPayment(paymentRequest);
          } catch (error2) {
            throw new Error(`Error purchasing crypto: ${error2.message}`);
          }
        },
        transferMoney: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const walletService = new WalletService();
            const transaction = await walletService.transferMoney(user.userId, input);
            await Promise.all([
              notificationService2.sendTransactionNotification(
                user.userId,
                "transfer",
                input.amount,
                input.currency || "EUR",
                transaction._id.toString()
              ),
              notificationService2.sendTransactionNotification(
                input.recipientId,
                "received",
                input.amount,
                input.currency || "EUR",
                transaction._id.toString()
              )
            ]);
            const [senderWallet, recipientWallet] = await Promise.all([
              Wallet.findOne({ userId: user.userId }),
              Wallet.findOne({ userId: input.recipientId })
            ]);
            if (inAppService.isUserConnected(user.userId)) {
              await inAppService.sendStatusUpdate(user.userId, "transfer_sent", {
                transaction,
                wallet: senderWallet
              });
            }
            if (inAppService.isUserConnected(input.recipientId)) {
              await inAppService.sendStatusUpdate(input.recipientId, "transfer_received", {
                transaction,
                wallet: recipientWallet
              });
            }
            return transaction;
          } catch (error2) {
            throw new Error(`Error transferring money: ${error2.message}`);
          }
        },
        addPaymentMethod: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentMethodService = new PaymentMethodService();
            const paymentMethod = await paymentMethodService.createPaymentMethod(user.userId, input);
            await notificationService2.createNotification({
              userId: user.userId,
              type: "security",
              category: "alert",
              title: "Nouvelle m\xE9thode de paiement ajout\xE9e",
              message: `Une nouvelle m\xE9thode de paiement "${input.name}" a \xE9t\xE9 ajout\xE9e \xE0 votre compte`,
              priority: "medium",
              metadata: {
                paymentMethodId: paymentMethod._id.toString(),
                actionUrl: "/wallet/payment-methods"
              }
            });
            return paymentMethod;
          } catch (error2) {
            throw new Error(`Error adding payment method: ${error2.message}`);
          }
        },
        updatePaymentMethod: async (_, { id, input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentMethodService = new PaymentMethodService();
            const paymentMethod = await PaymentMethod.findOne({ _id: id, userId: user.userId });
            if (!paymentMethod) throw new Error("Payment method not found");
            Object.assign(paymentMethod, input);
            await paymentMethod.save();
            return paymentMethod;
          } catch (error2) {
            throw new Error(`Error updating payment method: ${error2.message}`);
          }
        },
        deletePaymentMethod: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentMethodService = new PaymentMethodService();
            await paymentMethodService.deletePaymentMethod(user.userId, id);
            await notificationService2.createNotification({
              userId: user.userId,
              type: "security",
              category: "alert",
              title: "M\xE9thode de paiement supprim\xE9e",
              message: "Une m\xE9thode de paiement a \xE9t\xE9 supprim\xE9e de votre compte",
              priority: "medium",
              metadata: {
                actionUrl: "/wallet/payment-methods"
              }
            });
            return true;
          } catch (error2) {
            throw new Error(`Error deleting payment method: ${error2.message}`);
          }
        },
        setDefaultPaymentMethod: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            const paymentMethodService = new PaymentMethodService();
            await paymentMethodService.setDefaultPaymentMethod(user.userId, id);
            const paymentMethod = await PaymentMethod.findById(id);
            return paymentMethod;
          } catch (error2) {
            throw new Error(`Error setting default payment method: ${error2.message}`);
          }
        },
        buyCrypto: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            if (!config_default.features?.crypto?.enabled) {
              throw new Error("Crypto functionality is currently disabled");
            }
            if (!config_default.features?.crypto?.supportedCurrencies?.includes(input.currency)) {
              throw new Error(`Currency ${input.currency} is not supported`);
            }
            const cryptoService = new CryptoService();
            const walletService = new WalletService();
            const prices = await cryptoService.getPrices([input.currency]);
            const price = prices.find((p) => p.currency === input.currency);
            if (!price) throw new Error("Crypto price not available");
            const totalCost = input.amount * price.priceEUR;
            const minAmount = config_default.features?.crypto?.minimumBuyAmount || 10;
            const maxAmount = config_default.features?.crypto?.maximumBuyAmount || 1e4;
            if (totalCost < minAmount) {
              throw new Error(`Minimum buy amount is ${minAmount} EUR`);
            }
            if (totalCost > maxAmount) {
              throw new Error(`Maximum buy amount is ${maxAmount} EUR`);
            }
            await cryptoService.buyCrypto(user.userId, input.currency, input.amount, totalCost);
            const transaction = await walletService.createTransaction(user.userId, {
              type: "crypto",
              amount: totalCost,
              currency: "EUR",
              description: `Achat de ${input.amount} ${input.currency}`,
              paymentMethodId: input.paymentMethodId,
              cryptoCurrency: input.currency
            });
            await notificationService2.createNotification({
              userId: user.userId,
              type: "wallet",
              category: "transaction",
              title: `Achat de ${input.currency} effectu\xE9`,
              message: `Vous avez achet\xE9 ${input.amount} ${input.currency} pour ${totalCost} EUR`,
              metadata: {
                transactionId: transaction._id.toString(),
                amount: totalCost,
                currency: "EUR",
                cryptoAmount: input.amount,
                cryptoCurrency: input.currency,
                actionUrl: `/wallet/transactions/${transaction._id}`
              }
            });
            return transaction;
          } catch (error2) {
            throw new Error(`Error buying crypto: ${error2.message}`);
          }
        },
        sellCrypto: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            if (!config_default.features?.crypto?.enabled) {
              throw new Error("Crypto functionality is currently disabled");
            }
            if (!config_default.features?.crypto?.supportedCurrencies?.includes(input.currency)) {
              throw new Error(`Currency ${input.currency} is not supported`);
            }
            const cryptoService = new CryptoService();
            const walletService = new WalletService();
            const prices = await cryptoService.getPrices([input.currency]);
            const price = prices.find((p) => p.currency === input.currency);
            if (!price) throw new Error("Crypto price not available");
            const totalValue = input.amount * price.priceEUR;
            await cryptoService.sellCrypto(user.userId, input.currency, input.amount, totalValue);
            const transaction = await walletService.createTransaction(user.userId, {
              type: "crypto",
              amount: totalValue,
              currency: "EUR",
              description: `Vente de ${input.amount} ${input.currency}`,
              paymentMethodId: input.paymentMethodId,
              cryptoCurrency: input.currency
            });
            await notificationService2.createNotification({
              userId: user.userId,
              type: "wallet",
              category: "transaction",
              title: `Vente de ${input.currency} effectu\xE9e`,
              message: `Vous avez vendu ${input.amount} ${input.currency} pour ${totalValue} EUR`,
              metadata: {
                transactionId: transaction._id.toString(),
                amount: totalValue,
                currency: "EUR",
                cryptoAmount: input.amount,
                cryptoCurrency: input.currency,
                actionUrl: `/wallet/transactions/${transaction._id}`
              }
            });
            return transaction;
          } catch (error2) {
            throw new Error(`Error selling crypto: ${error2.message}`);
          }
        },
        // Notification mutations
        createNotification: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            return await notificationService2.createNotification({
              ...input,
              userId: user.userId
            });
          } catch (error2) {
            throw new Error(`Error creating notification: ${error2.message}`);
          }
        },
        markNotificationAsRead: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.markAsRead(user.userId, id);
            return await Notification2.findById(id);
          } catch (error2) {
            throw new Error(`Error marking notification as read: ${error2.message}`);
          }
        },
        markAllNotificationsAsRead: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.markAllAsRead(user.userId);
            return await Notification2.countDocuments({ userId: user.userId, isRead: false });
          } catch (error2) {
            throw new Error(`Error marking all notifications as read: ${error2.message}`);
          }
        },
        deleteNotification: async (_, { id }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.deleteNotification(user.userId, id);
            return true;
          } catch (error2) {
            throw new Error(`Error deleting notification: ${error2.message}`);
          }
        },
        updateNotificationPreferences: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.updateUserPreferences(user.userId, input);
            return await notificationService2.getUserPreferences(user.userId);
          } catch (error2) {
            throw new Error(`Error updating notification preferences: ${error2.message}`);
          }
        },
        registerPushToken: async (_, { input }, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.registerPushToken(
              user.userId,
              input.token,
              {
                platform: input.platform,
                deviceId: input.deviceId,
                appVersion: input.appVersion
              }
            );
            return true;
          } catch (error2) {
            throw new Error(`Error registering push token: ${error2.message}`);
          }
        },
        testPushNotification: async (_, __, { user }) => {
          try {
            if (!user) throw new Error("Authentication required");
            await notificationService2.createNotification({
              userId: user.userId,
              type: "general",
              category: "message",
              title: "Test de notification",
              message: "Ceci est un test de notification push",
              priority: "low",
              forceChannels: {
                inApp: true,
                push: true,
                email: false
              }
            });
            return true;
          } catch (error2) {
            throw new Error(`Error sending test notification: ${error2.message}`);
          }
        }
      },
      // Resolvers pour les types
      Wallet: {
        user: async (wallet) => {
          return await userModel_default.findById(wallet.userId);
        },
        transactions: async (wallet, { type, limit }) => {
          const query2 = {
            $or: [{ userId: wallet.userId }, { recipientId: wallet.userId }]
          };
          if (type) query2.type = type;
          return await Transaction.find(query2).sort({ createdAt: -1 }).limit(limit || 50);
        },
        paymentMethods: async (wallet) => {
          return await PaymentMethod.find({ userId: wallet.userId, isActive: true });
        },
        totalBalance: (wallet) => {
          return wallet.balance + wallet.pendingBalance;
        },
        formattedBalance: (wallet) => {
          return `${wallet.balance.toFixed(2)} ${wallet.currency}`;
        },
        recentTransactions: async (wallet, { limit }) => {
          return await Transaction.find({
            $or: [{ userId: wallet.userId }, { recipientId: wallet.userId }]
          }).sort({ createdAt: -1 }).limit(limit || 10);
        }
      },
      Transaction: {
        user: async (transaction) => {
          return await userModel_default.findById(transaction.userId);
        },
        recipient: async (transaction) => {
          if (!transaction.recipientId) return null;
          return await userModel_default.findById(transaction.recipientId);
        },
        paymentMethod: async (transaction) => {
          if (!transaction.paymentMethodId) return null;
          return await PaymentMethod.findById(transaction.paymentMethodId);
        },
        relatedProperty: async (transaction) => {
          if (!transaction.metadata?.propertyId) return null;
          return await propertyModel_default.findById(transaction.metadata.propertyId);
        },
        relatedService: async (transaction) => {
          if (!transaction.metadata?.serviceId) return null;
          return await Service.findById(transaction.metadata.serviceId);
        },
        formattedAmount: (transaction) => {
          return `${transaction.amount.toFixed(2)} ${transaction.currency}`;
        },
        isIncoming: (transaction, __, { user }) => {
          return transaction.recipientId === user?.userId;
        },
        statusColor: (transaction) => {
          const colors2 = {
            completed: "#28a745",
            pending: "#ffc107",
            failed: "#dc3545",
            cancelled: "#6c757d"
          };
          return colors2[transaction.status] || "#6c757d";
        }
      },
      PaymentMethod: {
        user: async (paymentMethod) => {
          return await userModel_default.findById(paymentMethod.userId);
        },
        displayName: (paymentMethod) => {
          if (paymentMethod.type === "card" && paymentMethod.details.last4) {
            return `**** ${paymentMethod.details.last4}`;
          }
          return paymentMethod.name;
        },
        maskedDetails: (paymentMethod) => {
          switch (paymentMethod.type) {
            case "card":
              return paymentMethod.details.last4 ? `**** ${paymentMethod.details.last4}` : "";
            case "bank":
              return paymentMethod.details.iban ? `****${paymentMethod.details.iban.slice(-4)}` : "";
            case "paypal":
              return paymentMethod.details.email || "";
            default:
              return "";
          }
        }
      },
      Notification: {
        user: async (notification) => {
          return await userModel_default.findById(notification.userId);
        }
      },
      CryptoBalance: {
        formattedValue: (balance) => {
          return `${balance.value.toFixed(2)} EUR`;
        }
      },
      // Subscriptions pour les mises à jour temps réel
      Subscription: {
        walletUpdated: {
          subscribe: async function* (_, __, { user }) {
            if (!user) throw new Error("Authentication required");
            yield {
              walletUpdated: await Wallet.findOne({ userId: user.userId })
            };
          }
        },
        transactionCreated: {
          subscribe: async function* (_, __, { user }) {
            if (!user) throw new Error("Authentication required");
            yield {
              transactionCreated: null
            };
          }
        },
        notificationReceived: {
          subscribe: async function* (_, __, { user }) {
            if (!user) throw new Error("Authentication required");
            yield {
              notificationReceived: null
            };
          }
        },
        balanceUpdated: {
          subscribe: async function* (_, __, { user }) {
            if (!user) throw new Error("Authentication required");
            yield {
              balanceUpdated: await Wallet.findOne({ userId: user.userId })
            };
          }
        }
      }
    };
  }
});

// src/chat/model/chatModel.ts
import mongoose28 from "mongoose";
var Schema26, MessageSchema, Message, chatModel_default;
var init_chatModel = __esm({
  "src/chat/model/chatModel.ts"() {
    Schema26 = mongoose28.Schema;
    MessageSchema = new Schema26({
      msgId: {
        type: mongoose28.Schema.Types.ObjectId,
        default: () => new mongoose28.Types.ObjectId(),
        required: true
      },
      senderId: {
        type: mongoose28.Schema.Types.ObjectId,
        ref: "User",
        required: true
      },
      conversationId: {
        type: mongoose28.Schema.Types.ObjectId,
        ref: "Conversation",
        required: true
      },
      messageType: {
        type: String,
        enum: ["text", "image", "video", "audio", "document", "location", "contact", "property", "voice_note", "ar_preview", "virtual_tour"],
        default: "text"
      },
      content: {
        type: String,
        required: true
      },
      mediaData: {
        filename: String,
        originalName: String,
        size: Number,
        mimetype: String,
        duration: Number,
        // pour audio/video
        thumbnail: String,
        // pour vidéos
        dimensions: { width: Number, height: Number },
        // pour images
        compressed: Boolean
      },
      // Réactions et interactions
      reactions: [{
        userId: {
          type: mongoose28.Schema.Types.ObjectId,
          ref: "User"
        },
        emoji: String,
        timestamp: { type: Date, default: Date.now }
      }],
      // Mentions
      mentions: [{ type: mongoose28.Schema.Types.ObjectId, ref: "User" }],
      // Statut du message
      status: {
        sent: { type: Date, default: Date.now },
        delivered: [{
          userId: { type: mongoose28.Schema.Types.ObjectId, ref: "User" },
          timestamp: { type: Date, default: Date.now }
        }],
        read: [{
          userId: { type: mongoose28.Schema.Types.ObjectId, ref: "User" },
          timestamp: { type: Date, default: Date.now }
        }]
      },
      // Message en réponse
      replyTo: { type: mongoose28.Schema.Types.ObjectId, ref: "Message" },
      // Message transféré
      forwardedFrom: {
        originalMessageId: { type: mongoose28.Schema.Types.ObjectId, ref: "Message" },
        originalSender: { type: mongoose28.Schema.Types.ObjectId, ref: "User" },
        forwardChain: Number
      },
      // Suppression et restauration
      isDeleted: { type: Boolean, default: false },
      deletedFor: [{ type: mongoose28.Schema.Types.ObjectId, ref: "User" }],
      deletedAt: Date,
      deletedBy: {
        type: mongoose28.Schema.Types.ObjectId,
        ref: "User"
      },
      canRestore: { type: Boolean, default: true },
      // Édition de message
      isEdited: { type: Boolean, default: false },
      editHistory: [{
        content: String,
        editedAt: { type: Date, default: Date.now }
      }],
      // Localisation
      location: {
        latitude: Number,
        longitude: Number,
        address: String,
        propertyId: { type: mongoose28.Schema.Types.ObjectId, ref: "Property" }
      },
      // Innovations uniques
      aiInsights: {
        sentiment: {
          score: Number,
          label: String
        },
        intentDetection: String,
        // achat, vente, visite, négociation
        autoSuggestions: [String],
        priority: { type: String, enum: ["low", "medium", "normal", "high", "urgent"] }
      },
      // Mode sombre/clair
      theme: { type: String, enum: ["light", "dark", "auto"], default: "auto" },
      // Programmation d'envoi
      scheduledFor: Date,
      isScheduled: { type: Boolean, default: false },
      // Signature temporaire pour la sécurité
      temporaryAccess: {
        expiresAt: Date,
        accessCode: String
      }
    }, {
      timestamps: true
    });
    MessageSchema.index({ content: "text" });
    Message = mongoose28.model("Message", MessageSchema);
    chatModel_default = Message;
  }
});

// src/chat/services/validationService.ts
var ValidationService, validationService_default;
var init_validationService = __esm({
  "src/chat/services/validationService.ts"() {
    init_config();
    ValidationService = class {
      static validateMessageInput(params) {
        const { conversationId, content, messageType, userId } = params;
        if (!conversationId?.trim()) {
          throw new Error("ID de conversation requis");
        }
        if (!content?.trim()) {
          throw new Error("Contenu du message requis");
        }
        if (content.length > config_default.messageMaxLength) {
          throw new Error(`Message trop long (maximum ${config_default.messageMaxLength} caract\xE8res)`);
        }
        const validMessageTypes = ["text", "image", "video", "audio", "file", "voice"];
        if (!validMessageTypes.includes(messageType)) {
          throw new Error(`Type de message invalide. Types autoris\xE9s: ${validMessageTypes.join(", ")}`);
        }
        if (!userId?.trim()) {
          throw new Error("ID utilisateur requis");
        }
      }
      static validatePagination(page, limit) {
        const validatedPage = Math.max(1, Math.floor(page) || 1);
        const validatedLimit = Math.min(config_default.pagination.maxLimit, Math.max(1, Math.floor(limit) || config_default.pagination.defaultLimit));
        return { page: validatedPage, limit: validatedLimit };
      }
    };
    validationService_default = ValidationService;
  }
});

// src/chat/services/encryptionService.ts
import crypto6 from "crypto";
var EncryptionService, encryptionService_default;
var init_encryptionService = __esm({
  "src/chat/services/encryptionService.ts"() {
    init_config();
    EncryptionService = class {
      static async encrypt(content) {
        try {
          const iv = crypto6.randomBytes(config_default.encryption.ivLength);
          const cipher = crypto6.createCipheriv(
            config_default.encryption.algorithm,
            config_default.encryption.secretKey,
            iv
          );
          let encrypted = cipher.update(content, "utf8", "hex");
          encrypted += cipher.final("hex");
          const authTag = cipher.getAuthTag().toString("hex");
          return `${iv.toString("hex")}:${authTag}:${encrypted}`;
        } catch (error2) {
          console.error("Erreur de chiffrement:", error2);
          throw new Error("\xC9chec du chiffrement");
        }
      }
      static async decrypt(encryptedContent) {
        try {
          const parts = encryptedContent.split(":");
          if (parts.length !== 3) {
            return encryptedContent;
          }
          const [ivHex, authTagHex, encrypted] = parts;
          const iv = Buffer.from(ivHex, "hex");
          const authTag = Buffer.from(authTagHex, "hex");
          const decipher = crypto6.createDecipheriv(
            config_default.encryption.algorithm,
            config_default.encryption.secretKey,
            iv
          );
          decipher.setAuthTag(authTag);
          let decrypted = decipher.update(encrypted, "hex", "utf8");
          decrypted += decipher.final("utf8");
          return decrypted;
        } catch (error2) {
          console.error("Erreur de d\xE9chiffrement:", error2);
          return encryptedContent;
        }
      }
    };
    encryptionService_default = EncryptionService;
  }
});

// src/lib/redisClient.ts
import Redis2 from "ioredis";
var redisForBullMQ;
var init_redisClient = __esm({
  "src/lib/redisClient.ts"() {
    init_config();
    redisForBullMQ = null;
    try {
      if (config_default.redis?.url) {
        redisForBullMQ = new Redis2(config_default.redis.url, {
          lazyConnect: true,
          // Ne pas se connecter immédiatement
          maxRetriesPerRequest: 3,
          retryStrategy: (times) => {
            if (times > 3) {
              console.warn("Redis connection failed after 3 attempts, giving up");
              return null;
            }
            return Math.min(times * 200, 2e3);
          },
          reconnectOnError: (err) => {
            const targetErrors = ["READONLY", "ECONNRESET", "ETIMEDOUT"];
            return targetErrors.some((target) => err.message.includes(target));
          }
        });
        redisForBullMQ.on("error", (err) => {
          console.error("Redis error for BullMQ:", err.message);
        });
        redisForBullMQ.on("connect", () => {
          console.log("\u2705 Redis for BullMQ connected successfully");
        });
        redisForBullMQ.connect().catch((err) => {
          console.warn("\u26A0\uFE0F Redis for BullMQ initial connection failed, will retry:", err.message);
        });
      } else {
        console.warn("\u26A0\uFE0F Redis URL not configured, BullMQ features will be limited");
      }
    } catch (error2) {
      console.error("Error initializing Redis client:", error2);
      redisForBullMQ = null;
    }
  }
});

// src/chat/utils/apiError.ts
var ApiError;
var init_apiError = __esm({
  "src/chat/utils/apiError.ts"() {
    ApiError = class _ApiError extends Error {
      constructor(statusCode, message, errors2) {
        super(message);
        __publicField(this, "statusCode");
        __publicField(this, "errors");
        this.statusCode = statusCode;
        this.errors = errors2;
        Object.setPrototypeOf(this, _ApiError.prototype);
        Error.captureStackTrace(this, this.constructor);
      }
    };
  }
});

// src/chat/services/AIAnalysis.ts
var AIAnalysisService, AIAnalysis_default;
var init_AIAnalysis = __esm({
  "src/chat/services/AIAnalysis.ts"() {
    AIAnalysisService = class {
      static async analyzeMessage(content, messageType, userId) {
        try {
          const [sentiment, language, topics, entities, intent] = await Promise.all([
            this.analyzeSentiment(content),
            this.detectLanguage(content),
            this.extractTopics(content),
            this.extractEntities(content),
            this.detectIntent(content)
          ]);
          return {
            sentiment,
            language,
            topics,
            entities,
            intent,
            urgency: this.assessUrgency(content, sentiment),
            confidence: this.calculateConfidence(content),
            processingTime: Date.now(),
            suggestions: this.generateSuggestions(content, intent)
          };
        } catch (error2) {
          console.error("Erreur analyse IA:", error2);
          return {
            sentiment: { score: 0, label: "neutral" },
            language: "unknown",
            topics: [],
            entities: [],
            intent: "unknown",
            urgency: "normal",
            confidence: 0,
            error: "Analysis failed"
          };
        }
      }
      static async analyzeSentiment(content) {
        const positiveWords = ["bon", "bien", "super", "g\xE9nial", "parfait", "excellent", "good", "great", "awesome", "love", "amazing"];
        const negativeWords = ["mauvais", "mal", "terrible", "horrible", "nul", "bad", "awful", "hate", "worst", "disgusting"];
        const contentLower = content.toLowerCase();
        const words = contentLower.split(/\W+/);
        const positiveCount = words.filter((word) => positiveWords.includes(word)).length;
        const negativeCount = words.filter((word) => negativeWords.includes(word)).length;
        const score = (positiveCount - negativeCount) / Math.max(words.length, 1);
        return {
          score: Math.max(-1, Math.min(1, score * 2)),
          // Normaliser entre -1 et 1
          label: score > 0.1 ? "positive" : score < -0.1 ? "negative" : "neutral"
        };
      }
      static async detectLanguage(content) {
        const languagePatterns = {
          fr: ["le", "la", "les", "de", "du", "des", "et", "ou", "dans", "avec", "pour", "sur", "ce", "cette", "ces"],
          en: ["the", "and", "or", "in", "with", "for", "on", "at", "by", "from", "this", "that", "these"],
          es: ["el", "la", "los", "las", "de", "del", "y", "o", "en", "con", "para", "sobre"],
          de: ["der", "die", "das", "und", "oder", "in", "mit", "f\xFCr", "auf", "von"]
        };
        const words = content.toLowerCase().split(/\W+/);
        const scores = {};
        Object.entries(languagePatterns).forEach(([lang, patterns]) => {
          scores[lang] = words.filter((word) => patterns.includes(word)).length;
        });
        const detectedLang = Object.entries(scores).reduce((a, b) => scores[a[0]] > scores[b[0]] ? a : b)[0];
        return scores[detectedLang] > 0 ? detectedLang : "unknown";
      }
      static async extractTopics(content) {
        const topicKeywords = {
          "technologie": ["code", "app", "web", "mobile", "tech", "software", "d\xE9veloppement", "programmation", "api"],
          "immobilier": ["maison", "appartement", "vente", "achat", "location", "propri\xE9t\xE9", "terrain", "investissement"],
          "travail": ["job", "travail", "emploi", "bureau", "meeting", "r\xE9union", "projet", "\xE9quipe"],
          "personnel": ["famille", "ami", "personnel", "priv\xE9", "vie", "relation", "amour"],
          "finance": ["argent", "prix", "co\xFBt", "budget", "investissement", "\xE9pargne", "banque"],
          "sant\xE9": ["sant\xE9", "m\xE9decin", "h\xF4pital", "maladie", "sport", "exercice", "nutrition"]
        };
        const contentLower = content.toLowerCase();
        const topics = [];
        Object.entries(topicKeywords).forEach(([topic, keywords]) => {
          const matchCount = keywords.filter((keyword) => contentLower.includes(keyword)).length;
          if (matchCount > 0) {
            topics.push(topic);
          }
        });
        return topics;
      }
      static extractEntities(content) {
        const entities = [];
        const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
        const emails = content.match(emailRegex);
        if (emails) {
          emails.forEach((email) => {
            entities.push({
              type: "email",
              value: email,
              confidence: email.includes(".") && email.includes("@") ? 0.9 : 0.6
            });
          });
        }
        const urlRegex = /(https?:\/\/[^\s]+|www\.[^\s]+)/g;
        const urls = content.match(urlRegex);
        if (urls) {
          urls.forEach((url2) => {
            entities.push({
              type: "url",
              value: url2,
              confidence: url2.startsWith("http") ? 0.9 : 0.7
            });
          });
        }
        const phoneRegex = /(\+?[1-9]\d{1,14}|\b\d{2}[-.\s]?\d{2}[-.\s]?\d{2}[-.\s]?\d{2}[-.\s]?\d{2}\b)/g;
        const phones = content.match(phoneRegex);
        if (phones) {
          phones.forEach((phone) => {
            entities.push({
              type: "phone",
              value: phone,
              confidence: phone.includes("+") ? 0.8 : 0.6
            });
          });
        }
        const dateRegex = /\b\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4}\b/g;
        const dates = content.match(dateRegex);
        if (dates) {
          dates.forEach((date) => {
            entities.push({
              type: "date",
              value: date,
              confidence: 0.7
            });
          });
        }
        return entities;
      }
      static detectIntent(content) {
        const intentPatterns = {
          question: [/\?/, /comment/, /pourquoi/, /quand/, /où/, /qui/, /how/, /why/, /when/, /where/, /who/],
          request: [/peux-tu/, /pouvez-vous/, /can you/, /could you/, /please/, /s'il vous plaît/],
          gratitude: [/merci/, /thanks/, /thank you/, /grazie/, /danke/],
          greeting: [/salut/, /hello/, /bonjour/, /hi/, /hey/, /bonsoir/],
          goodbye: [/au revoir/, /bye/, /goodbye/, /à bientôt/, /see you/],
          agreement: [/oui/, /yes/, /d'accord/, /ok/, /exactly/, /absolument/],
          disagreement: [/non/, /no/, /pas d'accord/, /disagree/, /absolutely not/],
          complaint: [/problème/, /bug/, /erreur/, /problem/, /issue/, /error/],
          compliment: [/bravo/, /félicitations/, /bien joué/, /great job/, /congratulations/]
        };
        const contentLower = content.toLowerCase();
        for (const [intent, patterns] of Object.entries(intentPatterns)) {
          if (patterns.some((pattern) => pattern.test(contentLower))) {
            return intent;
          }
        }
        return "statement";
      }
      static assessUrgency(content, sentiment) {
        const urgentKeywords = ["urgent", "emergency", "asap", "imm\xE9diat", "maintenant", "vite", "rapidement", "critical"];
        const contentLower = content.toLowerCase();
        if (urgentKeywords.some((keyword) => contentLower.includes(keyword))) {
          return "urgent";
        }
        if (sentiment?.score < -0.7) {
          return "high";
        }
        if (sentiment?.score < -0.3) {
          return "normal";
        }
        return "low";
      }
      static calculateConfidence(content) {
        const factors = {
          length: Math.min(content.length / 100, 1),
          complexity: (content.match(/[.!?]/g) || []).length / 10,
          vocabulary: new Set(content.toLowerCase().split(/\W+/)).size / content.split(/\W+/).length
        };
        return Math.min(0.9, (factors.length + factors.complexity + factors.vocabulary) / 3);
      }
      static generateSuggestions(content, intent) {
        const suggestions = [];
        if (intent === "question") {
          suggestions.push("Besoin de plus d'informations ?", "Je peux vous aider avec \xE7a");
        }
        if (intent === "complaint") {
          suggestions.push("D\xE9sol\xE9 pour ce probl\xE8me", "Puis-je vous aider \xE0 r\xE9soudre cela ?");
        }
        if (intent === "gratitude") {
          suggestions.push("De rien !", "Ravi d'avoir pu aider");
        }
        return suggestions;
      }
    };
    AIAnalysis_default = AIAnalysisService;
  }
});

// src/chat/services/chatService.ts
import { EventEmitter as EventEmitter3 } from "stream";
import { Types as Types2 } from "mongoose";
import sharp from "sharp";
import { Queue } from "bullmq";
var logger28, ChatService, chatService_default;
var init_chatService = __esm({
  "src/chat/services/chatService.ts"() {
    init_IntegratedNotificationService();
    init_redisInstance();
    init_config();
    init_validationService();
    init_encryptionService();
    init_chatModel();
    init_logger();
    init_redisClient();
    init_securityAuditServices();
    init_auditType();
    init_apiError();
    init_conversationModel();
    init_AIAnalysis();
    logger28 = createLogger2("chatservice");
    ChatService = class extends EventEmitter3 {
      // private  messageDeliveryQueue:Queue;
      constructor(io) {
        super();
        __publicField(this, "io");
        __publicField(this, "notificationService");
        __publicField(this, "cacheService");
        __publicField(this, "messageQueue", null);
        __publicField(this, "auditService");
        this.io = io;
        this.notificationService = new IntegratedNotificationService(io);
        this.cacheService = redisInstance_default;
        if (redisForBullMQ) {
          try {
            this.messageQueue = new Queue("message-delivery", {
              connection: redisForBullMQ
            });
            logger28.info("Message queue initialized successfully");
          } catch (error2) {
            logger28.error("Failed to initialize message queue:", error2);
            this.messageQueue = null;
          }
        } else {
          logger28.warn("Redis not available, message queue disabled");
        }
        this.setupErrorHandling();
        this.auditService = SecurityAuditService.getInstance();
      }
      setupErrorHandling() {
        this.on("error", (error2) => {
          logger28.error("ChatService Error:", error2);
        });
      }
      /**
       * Crée ou récupère une conversation existante (version améliorée)
       */
      async createOrGetConversation({
        participantId,
        type = "direct",
        propertyId,
        userId
      }) {
        try {
          if (!userId) {
            throw new Error("userId est requis");
          }
          if (type === "direct" && !participantId) {
            throw new Error("participantId est requis pour une conversation directe");
          }
          if (type === "direct" && userId === participantId) {
            throw new Error("Impossible de cr\xE9er une conversation avec soi-m\xEAme");
          }
          const participants = type === "direct" && participantId ? [userId, participantId] : [userId];
          const ids = participants.sort();
          const cacheKey = `conversation:${ids[0]}:${ids[1]}:${type}`;
          let conversation = await this.cacheService.get(cacheKey);
          if (!conversation) {
            if (type === "direct" && participantId) {
              conversation = await conversationModel_default.findOne({
                participants: { $all: [userId, participantId], $size: 2 },
                type: "direct"
              }).populate("participants", "name avatar email isOnline lastSeen");
            }
            if (!conversation) {
              const conversationData = {
                participants: type === "direct" ? [userId, participantId] : [userId],
                type,
                propertyId,
                createdAt: /* @__PURE__ */ new Date(),
                createdBy: userId,
                settings: {
                  encryption: true,
                  disappearingMessages: {
                    enabled: false,
                    duration: 30
                  },
                  smartReply: true,
                  translation: true,
                  voiceTranscription: true,
                  readReceipts: true,
                  typingIndicators: true
                },
                analytics: {
                  messageCount: 0,
                  averageResponseTime: 0,
                  mostActiveHours: [],
                  engagement: {
                    reactionsCount: 0,
                    mediaSharedCount: 0
                  }
                }
              };
              const newConversation = new conversationModel_default(conversationData);
              await newConversation.save();
              conversation = await newConversation.populate("participants", "name avatar email isOnline lastSeen");
              this.emit("conversationCreated", conversation);
              this.notifyParticipants(conversation, "conversationCreated", {
                conversationId: conversation._id,
                createdBy: userId
              });
            }
            await this.cacheService.set(cacheKey, conversation, config_default.cacheTTL.conversation);
          }
          logger28.info("chat succefull created");
          return conversation;
        } catch (error2) {
          this.emit("error", { operation: "createOrGetConversation", error: error2, userId, participantId });
          throw error2;
        }
      }
      /**
       * Récupère les conversations d'un utilisateur 
       */
      async getUserConversations({
        userId,
        page = 1,
        limit = 20,
        filter: filter2 = "all",
        sortBy = "updatedAt",
        sortOrder = "desc"
      }) {
        try {
          const { page: validPage, limit: validLimit } = validationService_default.validatePagination(page, limit);
          const cacheKey = `user_conversations:${userId}:${validPage}:${validLimit}:${filter2}`;
          let cachedResult = await this.cacheService.get(cacheKey);
          if (cachedResult && Array.isArray(cachedResult)) {
            return cachedResult;
          }
          let query2 = { participants: userId };
          switch (filter2) {
            case "groups":
              query2.type = "group";
              break;
            case "direct":
              query2.type = "direct";
              break;
            case "archived":
              query2.isArchived = { $elemMatch: { userId } };
              break;
            case "unread":
              break;
          }
          const sortObj = {};
          sortObj[sortBy] = sortOrder === "desc" ? -1 : 1;
          const conversations = await conversationModel_default.find(query2).populate("participants", "name avatar email isOnline lastSeen").populate("propertyId", "title price images location").sort(sortObj).limit(validLimit).skip((validPage - 1) * validLimit).lean();
          const enrichedConversations = await Promise.allSettled(
            conversations.map(async (conv) => {
              try {
                const conversationId = conv._id;
                const [lastMessage, unreadCount, typingUsers] = await Promise.all([
                  this.getLastMessage(conversationId),
                  this.getUnreadCount(conversationId, userId),
                  this.getTypingUsers(conversationId, userId)
                ]);
                return {
                  ...conv,
                  lastMessage,
                  unreadCount,
                  typingUsers,
                  isOnline: this.getConversationOnlineStatus(conv.participants),
                  encryptionStatus: conv.settings?.encryption ? "enabled" : "disabled"
                };
              } catch (error2) {
                console.error(`Erreur enrichissement conversation ${conv._id}:`, error2);
                return {
                  ...conv,
                  lastMessage: null,
                  unreadCount: 0,
                  typingUsers: [],
                  isOnline: false,
                  encryptionStatus: "disabled",
                  error: "Enrichment failed"
                };
              }
            })
          );
          const validConversations = enrichedConversations.filter(
            (result2) => result2.status === "fulfilled"
          ).map((result2) => result2.value);
          const result = filter2 === "unread" ? validConversations.filter((conv) => conv.unreadCount > 0) : validConversations;
          await this.cacheService.set(cacheKey, result, config_default.cacheTTL.userConversations);
          return result;
        } catch (error2) {
          this.emit("error", { operation: "getUserConversations", error: error2, userId });
          throw error2;
        }
      }
      /**
       * Envoie un message avec traitement avancé (version améliorée)
       */
      async sendMessage(params, file) {
        const {
          conversationId,
          content,
          messageType = "text",
          replyTo,
          scheduleFor,
          userId,
          priority = "normal",
          mentions = []
        } = params;
        try {
          validationService_default.validateMessageInput({
            conversationId,
            content,
            messageType,
            userId
          });
          await this.validateUserPermissions(conversationId, userId);
          let mediaData = null;
          let processedContent = content;
          if (file) {
            mediaData = await this.processMediaFile(file);
          }
          const aiInsightsPromise = AIAnalysis_default.analyzeMessage(content, messageType, userId);
          const processedMentions = await this.processMentions(content, mentions, conversationId);
          const conversation = await conversationModel_default.findById(conversationId);
          if (!conversation) {
            throw new Error("Conversation non trouv\xE9e");
          }
          if (conversation.settings?.encryption) {
            processedContent = await encryptionService_default.encrypt(content);
          }
          const aiInsights = await aiInsightsPromise;
          const messageData = {
            conversationId: new Types2.ObjectId(conversationId),
            senderId: new Types2.ObjectId(userId),
            content: processedContent,
            messageType,
            mediaData,
            mentions: processedMentions,
            replyTo: replyTo ? new Types2.ObjectId(replyTo) : void 0,
            scheduledFor: scheduleFor ? new Date(scheduleFor) : void 0,
            isScheduled: !!scheduleFor,
            aiInsights: {
              priority: aiInsights.urgency,
              sentiment: aiInsights.sentiment,
              intentDetection: aiInsights.intent,
              autoSuggestions: aiInsights.suggestions || [],
              language: aiInsights.language,
              topics: aiInsights.topics,
              confidence: aiInsights.confidence
            },
            reactions: [],
            status: {
              sent: /* @__PURE__ */ new Date(),
              delivered: [],
              read: []
            },
            isDeleted: false,
            deletedFor: [],
            canRestore: true,
            isEdited: false,
            editHistory: []
          };
          if (scheduleFor) {
            return await this.scheduleMessage(messageData);
          }
          const message = new chatModel_default(messageData);
          await message.save();
          await this.populateMessage(message);
          await this.messageQueue.add("processMessage", {
            messageId: message._id.toString(),
            conversationId: conversation._id.toString(),
            priority: aiInsights.urgency
            // utile si tu veux utiliser les "priorités" BullMQ
          });
          await this.emitMessageEvents(message, conversation);
          await this.indexMessageForSearch(message);
          return message;
        } catch (error2) {
          this.emit("error", { operation: "sendMessage", error: error2, conversationId, userId });
          throw error2;
        }
      }
      /**
       * Validation des permissions utilisateur
       */
      async validateUserPermissions(conversationId, userId) {
        const conversation = await conversationModel_default.findById(conversationId);
        if (!conversation) {
          throw new Error("Conversation non trouv\xE9e");
        }
        if (!conversation.participants.some((p) => p.toString() === userId)) {
          throw new Error("Utilisateur non autoris\xE9 dans cette conversation");
        }
        if (conversation.isArchivedBy && conversation.isArchivedBy.length > 0 && !await this.userCanWriteToArchivedConversation(userId, conversationId)) {
          throw new Error("Impossible d'\xE9crire dans une conversation archiv\xE9e");
        }
      }
      /**
       * 
       * Archived  conversation 
       */
      // async  archivedConversation(userId:string,  conversationId:string,ipAddress:string = 'unknown',userAgent:string = "unknown"  ){
      //   const  conversation = await Conversation.findById(conversationId);
      //   if(!conversation){
      //    throw new ApiError(404, "Conversation not found")
      //    return
      //   }
      //   if (!conversation.isArchivedBy) {
      //   conversation.isArchivedBy = [];
      // }
      // if (conversation.isArchivedBy.some((entry:any) => entry.userId.toString() === userId.toString())) {
      //   return { message: "Already archived" };
      // }
      //   conversation.isArchivedBy.push({
      //     userId: new Types.ObjectId(userId),
      //     archivedAt:new  Date()
      //   })
      //   await conversation.save();
      //   await this.auditService.logEvent({
      //     eventType: SecurityEventType.CONVERSATION_ARCHIVED,
      //     userId,
      //     ipAddress,
      //     userAgent,
      //     severity: AuditEventSeverity.INFO,
      //     details: {
      //     conversationId:conversationId.toString(),
      //     }
      //   });
      //   return conversation;
      // }
      async archivedConversation(userId, conversationId, ipAddress = "unknown", userAgent = "unknown") {
        const conversation = await conversationModel_default.findById(conversationId);
        if (!conversation) {
          throw new ApiError(404, "Conversation not found");
        }
        if (!Array.isArray(conversation.isArchivedBy)) {
          conversation.isArchivedBy = [];
        }
        const alreadyArchived = conversation.isArchivedBy.some(
          (entry) => entry.userId.toString() === userId.toString()
        );
        if (alreadyArchived) {
          return { message: "Already archived" };
        }
        conversation.isArchivedBy.push({
          userId: new Types2.ObjectId(userId),
          archivedAt: /* @__PURE__ */ new Date()
        });
        await conversation.save();
        await this.auditService.logEvent({
          eventType: "CONVERSATION_ARCHIVED" /* CONVERSATION_ARCHIVED */,
          userId,
          ipAddress,
          userAgent,
          severity: "info" /* INFO */,
          details: {
            conversationId: conversationId.toString()
          }
        });
        return conversation;
      }
      //
      async unarchiveConversation(userId, conversationId, ipAddress = "unknown", userAgent = "unknown") {
        const conversation = await conversationModel_default.findById(conversationId);
        if (!conversation) {
          throw new ApiError(404, "Conversation not found");
        }
        if (!Array.isArray(conversation.isArchivedBy)) {
          conversation.isArchivedBy = [];
        }
        conversation.isArchivedBy = conversation.isArchivedBy.filter(
          (entry) => entry.userId.toString() !== userId.toString()
        );
        await conversation.save();
        await this.auditService.logEvent({
          eventType: "CONVERSATION_UNARCHIVED" /* CONVERSATION_UNARCHIVED */,
          userId,
          ipAddress,
          userAgent,
          severity: "info" /* INFO */,
          details: {
            conversationId: conversationId.toString()
          }
        });
        return conversation;
      }
      /**
       * Retourne des statistiques de conversation : nb messages, nb participants, etc.
       */
      async getConversationStats(conversationId) {
        const conversation = await conversationModel_default.findById(conversationId).populate("participants");
        if (!conversation) {
          throw new ApiError(404, "Conversation not found");
        }
        const messageCount = await chatModel_default.countDocuments({ conversation: conversationId });
        const reactionStats = await chatModel_default.aggregate([
          { $match: { conversation: conversation._id } },
          { $unwind: "$reactions" },
          { $group: { _id: null, totalReactions: { $sum: 1 } } }
        ]);
        return {
          conversationId,
          participantsCount: conversation.participants.length,
          messageCount,
          totalReactions: reactionStats[0]?.totalReactions || 0,
          lastActivity: conversation.updatedAt
        };
      }
      async userCanWriteToArchivedConversation(userId, conversationId) {
        const conversation = await conversationModel_default.findById(conversationId);
        if (!conversation) return false;
        if (!conversation.isArchivedBy) return true;
        const isAdmin = conversation.admins.some((adminId) => adminId.toString() === userId);
        if (isAdmin) return true;
        return false;
      }
      /**
       * Notification optimisée des participants
       */
      notifyParticipants(conversation, event, data) {
        conversation.participants.forEach((participantId) => {
          this.io.to(participantId.toString()).emit(event, {
            ...data,
            timestamp: /* @__PURE__ */ new Date()
          });
        });
      }
      // Méthodes utilitaires inchangées mais optimisées
      async processMediaFile(file) {
        try {
          const mediaData = {
            filename: file.filename,
            originalName: file.originalname,
            size: file.size,
            mimetype: file.mimetype,
            uploadedAt: /* @__PURE__ */ new Date()
          };
          if (file.mimetype.startsWith("image/")) {
            const imagePath = file.path;
            const metadata = await sharp(imagePath).metadata();
            mediaData.dimensions = {
              width: metadata.width,
              height: metadata.height
            };
            const variantPromises = Object.entries(config_default.imageVariants).map(async ([size, variantConfig]) => {
              const variantPath = `uploads/${size}_${file.filename}`;
              await sharp(imagePath).resize(variantConfig.width, variantConfig.height, { fit: "inside", withoutEnlargement: true }).jpeg({ quality: variantConfig.quality }).toFile(variantPath);
              return { size, path: variantPath };
            });
            mediaData.variants = await Promise.all(variantPromises);
          }
          return mediaData;
        } catch (error2) {
          console.error("Erreur traitement m\xE9dia:", error2);
          throw new Error("\xC9chec du traitement du fichier m\xE9dia");
        }
      }
      /**
       * Traitement des mentions dans le message
       */
      async processMentions(content, mentions, conversationId) {
        const processedMentions = [];
        const mentionRegex = /@(\w+)/g;
        let match;
        while ((match = mentionRegex.exec(content)) !== null) {
          const username = match[1];
          const position = match.index;
          const conversation = await conversationModel_default.findById(conversationId).populate("participants", "username");
          const mentionedUser = conversation?.participants.find((p) => p.username === username);
          if (mentionedUser) {
            processedMentions.push({
              userId: mentionedUser._id.toString(),
              username,
              position
            });
          }
        }
        return processedMentions;
      }
      /**
       * Planification d'un message pour envoi différé
       */
      async scheduleMessage(messageData) {
        const message = new chatModel_default({
          ...messageData,
          isScheduled: true,
          status: {
            scheduled: /* @__PURE__ */ new Date(),
            delivered: [],
            read: []
          }
        });
        await message.save();
        const delay = new Date(messageData.scheduledFor).getTime() - Date.now();
        if (delay > 0) {
          await this.messageQueue.add(
            "deliverScheduledMessage",
            {
              messageId: message._id.toString()
            },
            {
              delay,
              attempts: 3,
              backoff: {
                type: "exponential",
                delay: 1e3
              }
            }
          );
        }
        return message;
      }
      /**
       * Exécution d'un message programmé
       */
      async executeScheduledMessage(messageId) {
        const message = await chatModel_default.findById(messageId).populate("conversationId");
        if (!message || !message.isScheduled) return;
        message.isScheduled = false;
        message.status.sent = /* @__PURE__ */ new Date();
        await message.save();
        await this.processMessageAsync(message, message.conversationId);
      }
      /**
       * Traitement asynchrone du message après envoi
       */
      async processMessageAsync(message, conversation) {
        try {
          await this.updateConversationAfterMessage(conversation._id, message);
          await this.sendMessageNotifications(message, conversation);
          await this.invalidateRelatedCaches(conversation._id.toString(), message.senderId.toString());
          this.emitMessageEvents(message, conversation);
          await this.updateMessageAnalytics(message, conversation);
        } catch (error2) {
          console.error("Erreur traitement asynchrone message:", error2);
          this.emit("error", { operation: "processMessageAsync", error: error2, messageId: message._id });
        }
      }
      /**
       * Mise à jour de la conversation après envoi d'un message
       */
      async updateConversationAfterMessage(conversationId, message) {
        await conversationModel_default.findByIdAndUpdate(conversationId, {
          lastMessage: message._id,
          updatedAt: /* @__PURE__ */ new Date(),
          $inc: { "analytics.messageCount": 1 }
        });
      }
      /**
       * Envoi des notifications pour un nouveau message
       */
      async sendMessageNotifications(message, conversation) {
        try {
          await this.notificationService.onNewMessage(message, conversation);
        } catch (error2) {
          console.error("Erreur envoi notifications message:", error2);
        }
      }
      /**
       * Invalidation des caches liés
       */
      async invalidateRelatedCaches(conversationId, userId) {
        const cacheKeys = [
          `conversation:${conversationId}`,
          `user_conversations:${userId}:*`,
          `messages:${conversationId}:*`,
          `unread_count:${conversationId}:*`
        ];
        await Promise.all(
          cacheKeys.map((key) => this.cacheService.delete(key))
        );
      }
      /**
       * Émission des événements WebSocket
       */
      emitMessageEvents(message, conversation) {
        this.io.to(conversation._id.toString()).emit("newMessage", {
          message,
          conversationId: conversation._id,
          timestamp: /* @__PURE__ */ new Date()
        });
        conversation.participants.forEach((participant) => {
          if (participant._id.toString() !== message.senderId.toString()) {
            this.io.to(participant._id.toString()).emit("messageReceived", {
              message,
              conversationId: conversation._id,
              from: message.senderId
            });
          }
        });
      }
      /**
       * Mise à jour des analytics du message
       */
      async updateMessageAnalytics(message, conversation) {
        try {
          const analytics = {
            messageId: message._id,
            conversationId: conversation._id,
            senderId: message.senderId,
            messageType: message.content,
            timestamp: /* @__PURE__ */ new Date(),
            aiInsights: message.aiInsights,
            engagementScore: this.calculateEngagementScore(message),
            responseTime: await this.calculateResponseTime(conversation._id, message.senderId)
          };
          this.emit("messageAnalytics", analytics);
        } catch (error2) {
          console.error("Erreur analytics message:", error2);
        }
      }
      /**
       * Calcul du score d'engagement
       */
      calculateEngagementScore(message) {
        let score = 1;
        if (message.mentions && message.mentions.length > 0) score += 0.5;
        if (message.mediaData) score += 0.3;
        if (message.replyTo) score += 0.2;
        if (message.aiInsights?.sentiment?.score !== void 0 && message.aiInsights.sentiment.score > 0.5) {
          score += 0.3;
        }
        return Math.min(5, score);
      }
      /**
       * Calcul du temps de réponse
       */
      async calculateResponseTime(conversationId, senderId) {
        try {
          const lastMessage = await chatModel_default.findOne({
            conversationId,
            senderId: { $ne: senderId }
          }).sort({ createdAt: -1 });
          if (lastMessage) {
            return Date.now() - lastMessage.createdAt.getTime();
          }
          return null;
        } catch (error2) {
          console.error("Erreur calcul temps de r\xE9ponse:", error2);
          return null;
        }
      }
      /**
       * Récupération des messages avec pagination et filtres avancés
       */
      async getMessages({
        conversationId,
        page = 1,
        limit = 20,
        messageType,
        dateRange,
        searchQuery,
        userId
      }) {
        try {
          await this.validateUserPermissions(conversationId, userId);
          const { page: validPage, limit: validLimit } = validationService_default.validatePagination(page, limit);
          let query2 = {
            conversationId: new Types2.ObjectId(conversationId),
            isDeleted: false
          };
          if (messageType) query2.messageType = messageType;
          if (dateRange) {
            query2.createdAt = {};
            if (dateRange.start) query2.createdAt.$gte = new Date(dateRange.start);
            if (dateRange.end) query2.createdAt.$lte = new Date(dateRange.end);
          }
          if (searchQuery) {
            query2.$text = { $search: searchQuery };
          }
          const messages = await chatModel_default.find(query2).populate("senderId", "name avatar").populate("replyTo").sort({ createdAt: -1 }).limit(validLimit).skip((validPage - 1) * validLimit);
          const decryptedMessages = await Promise.all(
            messages.map(async (msg) => {
              if (msg.content.includes(":")) {
                try {
                  msg.content = await encryptionService_default.decrypt(msg.content);
                } catch (error2) {
                  console.error("Erreur d\xE9chiffrement message:", error2);
                }
              }
              return msg;
            })
          );
          const analytics = await this.generateMessageAnalytics(conversationId, query2);
          const totalMessages = await chatModel_default.countDocuments(query2);
          const pagination = {
            currentPage: validPage,
            totalPages: Math.ceil(totalMessages / validLimit),
            totalMessages,
            hasNext: validPage * validLimit < totalMessages,
            hasPrev: validPage > 1
          };
          return {
            messages: decryptedMessages,
            pagination,
            analytics
          };
        } catch (error2) {
          this.emit("error", { operation: "getMessages", error: error2, conversationId });
          throw error2;
        }
      }
      /**
       * Génération d'analytics pour les messages
       */
      async generateMessageAnalytics(conversationId, query2) {
        try {
          const [
            messageTypeDistribution,
            sentimentAnalysis,
            activityPattern,
            topSenders
          ] = await Promise.all([
            this.getMessageTypeDistribution(conversationId),
            this.getSentimentAnalysis(conversationId),
            this.getActivityPattern(conversationId),
            this.getTopSenders(conversationId)
          ]);
          return {
            messageTypeDistribution,
            sentimentAnalysis,
            activityPattern,
            topSenders,
            generatedAt: /* @__PURE__ */ new Date()
          };
        } catch (error2) {
          console.error("Erreur g\xE9n\xE9ration analytics:", error2);
          return {};
        }
      }
      /**
       * Distribution des types de messages
       */
      async getMessageTypeDistribution(conversationId) {
        return await chatModel_default.aggregate([
          { $match: { conversationId: new Types2.ObjectId(conversationId), isDeleted: false } },
          { $group: { _id: "$messageType", count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ]);
      }
      /**
       * Analyse de sentiment
       */
      async getSentimentAnalysis(conversationId) {
        return await chatModel_default.aggregate([
          { $match: { conversationId: new Types2.ObjectId(conversationId), isDeleted: false } },
          { $group: {
            _id: "$aiInsights.sentiment.label",
            count: { $sum: 1 },
            avgScore: { $avg: "$aiInsights.sentiment.score" }
          } },
          { $sort: { count: -1 } }
        ]);
      }
      /**
       * Modèle d'activité
       */
      async getActivityPattern(conversationId) {
        return await chatModel_default.aggregate([
          { $match: { conversationId: new Types2.ObjectId(conversationId), isDeleted: false } },
          { $group: {
            _id: {
              hour: { $hour: "$createdAt" },
              dayOfWeek: { $dayOfWeek: "$createdAt" }
            },
            count: { $sum: 1 }
          } },
          { $sort: { count: -1 } }
        ]);
      }
      /**
       * Top expéditeurs
       */
      async getTopSenders(conversationId) {
        return await chatModel_default.aggregate([
          { $match: { conversationId: new Types2.ObjectId(conversationId), isDeleted: false } },
          { $group: { _id: "$senderId", count: { $sum: 1 } } },
          { $lookup: {
            from: "users",
            localField: "_id",
            foreignField: "_id",
            as: "sender"
          } },
          { $unwind: "$sender" },
          { $project: {
            senderId: "$_id",
            senderName: "$sender.name",
            messageCount: "$count"
          } },
          { $sort: { messageCount: -1 } },
          { $limit: 10 }
        ]);
      }
      /**
       * Réaction à un message
       */
      async reactToMessage({
        messageId,
        userId,
        reactionType,
        conversationId
      }) {
        try {
          await this.validateUserPermissions(conversationId, userId);
          const message = await chatModel_default.findById(messageId);
          if (!message) {
            throw new Error("Message non trouv\xE9");
          }
          const existingReactionIndex = message.reactions.findIndex(
            (reaction) => reaction.userId.toString() === userId && reaction.type === reactionType
          );
          if (existingReactionIndex > -1) {
            message.reactions.splice(existingReactionIndex, 1);
          } else {
            message.reactions.push({
              userId: new Types2.ObjectId(userId),
              emoji: reactionType,
              timestamp: /* @__PURE__ */ new Date()
            });
          }
          const conversation = await conversationModel_default.findById(conversationId);
          if (!conversation) throw new Error("Conversation non trouv\xE9e");
          await message.save();
          if (message.senderId.toString() !== userId) {
            await this.notificationService.onMessageReaction(message, userId, reactionType, conversation);
          }
          this.emitReactionToParticipants(messageId, message.reactions, conversation);
          return message;
        } catch (error2) {
          this.emit("error", { operation: "reactToMessage", error: error2, messageId, userId });
          throw error2;
        }
      }
      /**
       * Suppression d'un message
       */
      async deleteMessage(params) {
        const {
          messageId,
          userId,
          deleteType = "soft",
          deleteFor = "me",
          conversationId
        } = params;
        try {
          await this.validateUserPermissions(conversationId, userId);
          const hasPermission = await this.userHasDeletePermission(userId, new Types2.ObjectId(conversationId));
          if (!hasPermission) {
            throw new Error("Utilisateur non autoris\xE9 \xE0 supprimer ce message");
          }
          const message = await chatModel_default.findById(messageId);
          if (!message) {
            throw new Error("Message non trouv\xE9");
          }
          const conversation = await conversationModel_default.findById(conversationId);
          if (!conversation) return false;
          if (message.senderId.toString() !== userId) {
            throw new Error("Pas autoris\xE9 \xE0 supprimer ce message");
          }
          if (deleteType === "soft") {
            message.deletedAt = /* @__PURE__ */ new Date();
            message.deletedBy = new Types2.ObjectId(userId);
            if (deleteFor === "me") {
              if (!message.deletedFor.some((id) => id.toString() === userId)) {
                message.deletedFor.push(new Types2.ObjectId(userId));
              }
            } else if (deleteFor === "everyone") {
              message.isDeleted = true;
            }
            await message.save();
          } else {
            await chatModel_default.findByIdAndDelete(messageId);
          }
          this.emitMessageDeletion(messageId, deleteFor, userId, conversation);
          await this.createDeleteAuditLog(
            message,
            userId,
            deleteFor,
            null
          );
          await this.invalidateRelatedCaches(conversationId, userId);
          return true;
        } catch (error2) {
          this.emit("error", { operation: "deleteMessage", error: error2, messageId, userId });
          throw error2;
        }
      }
      async restoreMessage(messageId, userId, ipAddress = "unknown", userAgent = "unknown") {
        try {
          const message = await chatModel_default.findById(messageId);
          if (!message) {
            logger28.warn(`Message ${messageId} introuvable pour restauration.`);
            throw new Error("Message non trouv\xE9");
          }
          const conversation = await conversationModel_default.findById(message.conversationId);
          if (!conversation) {
            logger28.warn(`Conversation ${message.conversationId} introuvable pour restauration.`);
            throw new Error("Conversation introuvable");
          }
          const isParticipant = conversation.participants.some(
            (participantId) => participantId.toString() === userId
          );
          if (!isParticipant) {
            logger28.warn(`L'utilisateur ${userId} ne fait pas partie de la conversation.`);
            throw new Error("Vous n'avez pas acc\xE8s \xE0 cette conversation");
          }
          const wasDeletedForUser = message.deletedFor.some(
            (id) => id.toString() === userId
          );
          if (!wasDeletedForUser) {
            logger28.info(`Message ${messageId} d\xE9j\xE0 visible pour l'utilisateur ${userId}`);
            return true;
          }
          message.deletedFor = message.deletedFor.filter(
            (id) => id.toString() !== userId
          );
          await message.save();
          await this.auditService.logEvent({
            eventType: "MESSAGE RESTORE" /* RESTORE_MESSAGE */,
            userId,
            targetResource: `message:${message._id}`,
            ipAddress,
            userAgent,
            severity: "info" /* INFO */,
            details: {
              conversationId: message.conversationId.toString(),
              restoredBy: userId
            }
          });
          await this.invalidateRelatedCaches?.(message.conversationId.toString(), userId);
          this.emitToParticipants(conversation, "messageRestored", {
            messageId,
            restoredBy: userId
          });
          logger28.info(`Message ${messageId} restaur\xE9 avec succ\xE8s pour l'utilisateur ${userId}`);
          return true;
        } catch (error2) {
          logger28.error(`Erreur restauration message ${messageId} par ${userId}`, error2);
          this.emit?.("error", {
            operation: "restoreMessage",
            error: error2,
            messageId,
            userId
          });
          return false;
        }
      }
      /**
       * Recherche de messages avec indexation full-text
       */
      async searchMessages({
        userId,
        query: query2,
        conversationId,
        messageType,
        dateRange,
        limit = 10
      }) {
        try {
          let searchQuery = {
            isDeleted: false,
            $text: { $search: query2 }
          };
          if (conversationId) {
            await this.validateUserPermissions(conversationId, userId);
            searchQuery.conversationId = new Types2.ObjectId(conversationId);
          } else {
            const userConversations = await conversationModel_default.find({
              participants: userId
            }).select("_id");
            searchQuery.conversationId = {
              $in: userConversations.map((c) => c._id)
            };
          }
          if (messageType) searchQuery.messageType = messageType;
          if (dateRange) {
            searchQuery.createdAt = {};
            if (dateRange.start) searchQuery.createdAt.$gte = new Date(dateRange.start);
            if (dateRange.end) searchQuery.createdAt.$lte = new Date(dateRange.end);
          }
          const messages = await chatModel_default.find(searchQuery).populate("senderId", "name avatar").populate("conversationId", "participants type").sort({ score: { $meta: "textScore" } }).limit(limit);
          const decryptedMessages = await Promise.all(
            messages.map(async (msg) => {
              if (msg.content.includes(":")) {
                try {
                  msg.content = await encryptionService_default.decrypt(msg.content);
                } catch (error2) {
                  console.error("Erreur d\xE9chiffrement message recherche:", error2);
                }
              }
              return msg;
            })
          );
          return decryptedMessages;
        } catch (error2) {
          this.emit("error", { operation: "searchMessages", error: error2, userId });
          throw error2;
        }
      }
      /**
       * Gestion des indicateurs de frappe
       */
      async setTypingStatus(conversationId, userId, isTyping) {
        try {
          const cacheKey = `typing:${conversationId}`;
          let typingUsers = await this.cacheService.get(cacheKey) || [];
          if (isTyping) {
            if (!typingUsers.includes(userId)) {
              typingUsers.push(userId);
            }
            setTimeout(async () => {
              await this.setTypingStatus(conversationId, userId, false);
            }, config_default.typingTimeout);
          } else {
            typingUsers = typingUsers.filter((id) => id !== userId);
          }
          const conversation = await conversationModel_default.findById(conversationId);
          if (!conversation) {
            console.warn(`Conversation ${conversationId} non trouv\xE9e pour \xE9mission typingStatus`);
            return;
          }
          await this.cacheService.set(cacheKey, typingUsers, 30);
          this.emitToParticipants(conversation, "typingStatus", {
            userId,
            isTyping,
            typingUsers: typingUsers.filter((id) => id !== userId)
            // Exclure l'utilisateur actuel
          });
        } catch (error2) {
          console.error("Erreur gestion typing status:", error2);
        }
      }
      //handletyping
      async handleTypingStatus(conversationId, userId, isTyping) {
        await this.setTypingStatus(conversationId, userId, isTyping);
        const conversation = await conversationModel_default.findById(conversationId);
        if (!conversation) throw new Error("Conversation non trouv\xE9e");
        this.emitToParticipants(conversation, "typingStatusUpdated", {
          userId,
          isTyping
        });
      }
      // Méthodes utilitaires privées
      async getLastMessage(conversationId) {
        return await chatModel_default.findOne({
          conversationId,
          isDeleted: false
        }).populate("senderId", "name avatar").sort({ createdAt: -1 });
      }
      async getUnreadCount(conversationId, userId) {
        const cacheKey = `unread_count:${conversationId}:${userId}`;
        let count = await this.cacheService.get(cacheKey);
        if (count === null) {
          count = await chatModel_default.countDocuments({
            conversationId,
            senderId: { $ne: new Types2.ObjectId(userId) },
            "status.read": { $not: { $elemMatch: { userId: new Types2.ObjectId(userId) } } },
            isDeleted: false
          });
          await this.cacheService.set(cacheKey, count, 300);
        }
        return count;
      }
      /**
       * Marquage des messages comme lus
       */
      async markMessagesAsRead(conversationId, userId, messageIds) {
        try {
          await this.validateUserPermissions(conversationId, userId);
          let query2 = {
            conversationId: new Types2.ObjectId(conversationId),
            senderId: { $ne: new Types2.ObjectId(userId) },
            "status.read": { $not: { $elemMatch: { userId: new Types2.ObjectId(userId) } } }
          };
          if (messageIds && messageIds.length > 0) {
            query2._id = { $in: messageIds.map((id) => new Types2.ObjectId(id)) };
          }
          const result = await chatModel_default.updateMany(query2, {
            $push: {
              "status.read": {
                userId: new Types2.ObjectId(userId),
                readAt: /* @__PURE__ */ new Date()
              }
            }
          });
          logger28.info(`Lecture marqu\xE9e sur ${result.modifiedCount} messages pour l'utilisateur ${userId}`);
          await this.cacheService.delete(`unread_count:${conversationId}:${userId}`);
          await this.auditService.logEvent({
            eventType: "API_ACCESS" /* API_ACCESS */,
            userId,
            targetResource: `conversation:${conversationId}`,
            severity: "info" /* INFO */,
            details: {
              action: "markAsRead",
              modifiedMessages: result.modifiedCount
            }
          });
          const conversation = await conversationModel_default.findById(conversationId);
          this.emitToParticipants(conversation, "conversationMarkedAsRead", {
            userId
          });
        } catch (error2) {
          this.emit("error", { operation: "markMessagesAsRead", error: error2, conversationId, userId });
          throw error2;
        }
      }
      async getTypingUsers(conversationId, userId) {
        const cacheKey = `typing:${conversationId}`;
        const typingUsers = await this.cacheService.get(cacheKey) || [];
        return typingUsers.filter((id) => id !== userId);
      }
      getConversationOnlineStatus(participants) {
        return participants.some((p) => p.isOnline);
      }
      async populateMessage(message) {
        await message.populate([
          { path: "senderId", select: "name avatar email" },
          { path: "replyTo", populate: { path: "senderId", select: "name avatar" } },
          { path: "mentions.userId", select: "name username avatar" }
        ]);
      }
      // private emitMessageToParticipants(message: IMessage, conversation: IConversation): void {
      //     conversation.participants.forEach(participantId => {
      //       if (participantId.toString() !== message.senderId.toString()) {
      //         this.io.to(participantId.toString()).emit('newMessage', {
      //           ...message.toObject(),
      //           conversationId: conversation._id,
      //           conversationType: conversation.type
      //         });
      //       }
      //     });
      //   }
      async invalidateConversationCache(conversationId) {
        const conversation = await conversationModel_default.findById(conversationId);
        if (conversation) {
          for (const participantId of conversation.participants) {
            await this.cacheService.deletePattern(`user_conversations:${participantId}:*`);
          }
        }
      }
      async indexMessageForSearch(message) {
        try {
          const searchIndex = {
            messageId: message._id,
            conversationId: message.conversationId,
            content: message.content,
            senderId: message.senderId,
            createdAt: message.createdAt,
            keywords: this.extractKeywords(message.content || ""),
            searchText: `${message.content}`.toLowerCase()
          };
          await this.cacheService.set(
            `search_index:${message._id}`,
            searchIndex,
            3600 * 24 * 7
          );
        } catch (error2) {
          console.error("Erreur d'indexation:", error2);
        }
      }
      emitReactionToParticipants(messageId, reactions, conversation) {
        if (!conversation) return;
        conversation.participants.forEach((participantId) => {
          this.io.to(participantId.toString()).emit("messageReaction", {
            messageId,
            reactions,
            conversationId: conversation._id,
            timestamp: /* @__PURE__ */ new Date()
          });
        });
      }
      emitToParticipants(conversation, event, payload) {
        if (!conversation) return;
        conversation.participants.forEach((participantId) => {
          this.io.to(participantId.toString()).emit(event, {
            ...payload,
            conversationId: conversation._id,
            timestamp: /* @__PURE__ */ new Date()
          });
        });
      }
      async userHasDeletePermission(userId, conversationId) {
        try {
          const conversation = await conversationModel_default.findById(conversationId);
          if (!conversation) return false;
          if (conversation.type === "group") {
            const userPermissions = await this.cacheService.get(
              `permissions:${userId}:${conversationId}`
            );
            return userPermissions?.canDeleteMessages || false;
          }
          return conversation.participants.some(
            (participant) => participant.toString() === userId
          );
        } catch (error2) {
          console.error("Error checking delete permissions:", error2);
          return false;
        }
      }
      async createDeleteAuditLog(message, userId, deleteFor, reason) {
        try {
          const auditLog = {
            messageId: message._id,
            conversationId: message.conversationId,
            originalSenderId: message.senderId,
            deletedBy: userId,
            deleteFor,
            reason,
            // originalContent: message.originalContent || message.content,
            messageType: message.content,
            deletedAt: /* @__PURE__ */ new Date(),
            metadata: {
              userAgent: "ChatService",
              ipAddress: "server"
            }
          };
          await this.cacheService.set(
            `audit:delete:${message._id}:${Date.now()}`,
            auditLog,
            3600 * 24 * 365
            // 1 an
          );
          this.emit("auditLog", {
            type: "message_deletion",
            data: auditLog
          });
        } catch (error2) {
          console.error("Erreur cr\xE9ation log audit:", error2);
        }
      }
      emitMessageDeletion(messageId, deleteFor, userId, conversation) {
        if (!conversation) return;
        const deletionEvent = {
          messageId,
          deleteFor,
          deletedBy: userId,
          conversationId: conversation._id,
          timestamp: /* @__PURE__ */ new Date()
        };
        if (deleteFor === "everyone") {
          conversation.participants.forEach((participantId) => {
            this.io.to(participantId.toString()).emit("messageDeleted", deletionEvent);
          });
        } else {
          this.io.to(userId).emit("messageDeleted", deletionEvent);
        }
      }
      extractKeywords(content) {
        return content.toLowerCase().split(/\s+/).filter((word) => word.length > 3).filter((word) => !/^(le|la|les|de|du|des|et|ou|dans|avec|pour|sur|the|and|or|in|with|for|on|at|by|from)$/.test(word)).slice(0, 10);
      }
      async findUserInConversation(username, conversationId) {
        try {
          const conversation = await conversationModel_default.findById(conversationId).populate("participants", "username name email avatar");
          if (!conversation) return null;
          return conversation.participants.find(
            (user) => user.username?.toLowerCase() === username.toLowerCase()
          );
        } catch (error2) {
          console.error("Erreur recherche utilisateur:", error2);
          return null;
        }
      }
      calculateAverageResponseTime(messages) {
        if (messages.length < 2) return 0;
        const times = messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime()).slice(1).map(
          (msg, index) => msg.createdAt.getTime() - messages[index].createdAt.getTime()
        );
        return times.reduce((sum, time) => sum + time, 0) / times.length;
      }
      findPeakHours(messages) {
        const hourCounts = new Array(24).fill(0);
        messages.forEach((msg) => {
          const hour = msg.createdAt.getHours();
          hourCounts[hour]++;
        });
        const maxCount = Math.max(...hourCounts);
        return hourCounts.map((count, hour) => ({ hour, count })).filter(({ count }) => count === maxCount).map(({ hour }) => hour);
      }
    };
    chatService_default = ChatService;
  }
});

// src/chat/graphql/chatResolvers.ts
var chatResolvers;
var init_chatResolvers = __esm({
  "src/chat/graphql/chatResolvers.ts"() {
    init_chatModel();
    init_conversationModel();
    init_userModel();
    init_propertyModel();
    init_chatService();
    init_encryptionService();
    init_AIAnalysis();
    chatResolvers = {
      Query: {
        conversation: async (_, { id }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const conversation = await conversationModel_default.findById(id).populate("participants", "firstName lastName profilePicture presenceStatus lastActive").populate("propertyId", "title address images ownerCriteria");
          if (!conversation) throw new Error("Conversation not found");
          const isParticipant = conversation.participants.some(
            (p) => p._id.toString() === user.userId
          );
          if (!isParticipant) throw new Error("Access denied");
          return conversation;
        },
        conversations: async (_, { pagination }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          const conversations = await chatService.getUserConversations({
            userId: user.userId,
            page: pagination?.first ? Math.ceil(pagination.first / 20) : 1,
            limit: pagination?.first || 20
          });
          const edges = conversations.map((conversation, index) => ({
            node: conversation,
            cursor: Buffer.from(index.toString()).toString("base64")
          }));
          return {
            edges,
            pageInfo: {
              hasNextPage: conversations.length === (pagination?.first || 20),
              hasPreviousPage: false,
              startCursor: edges[0]?.cursor,
              endCursor: edges[edges.length - 1]?.cursor
            },
            totalCount: conversations.length
          };
        },
        searchConversations: async (_, { query: query2, filters }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const searchQuery = {
            participants: user.userId,
            $or: [
              { "participants.firstName": new RegExp(query2, "i") },
              { "participants.lastName": new RegExp(query2, "i") },
              { "propertyId.title": new RegExp(query2, "i") }
            ]
          };
          if (filters?.type) searchQuery.type = filters.type;
          return await conversationModel_default.find(searchQuery).populate("participants", "firstName lastName profilePicture").populate("propertyId", "title images").sort({ updatedAt: -1 }).limit(20);
        },
        conversationAnalytics: async (_, { conversationId }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          return await chatService.getConversationStats(conversationId);
        }
      },
      Mutation: {
        sendMessage: async (_, { input }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          const messageData = {
            userId: user.userId,
            conversationId: input.conversationId,
            content: input.content,
            messageType: input.messageType || "text",
            replyTo: input.replyToId,
            mentions: input.mentions || [],
            scheduleFor: input.scheduleFor,
            priority: input.priority || "normal"
          };
          return await chatService.sendMessage(messageData);
        },
        reactToMessage: async (_, { input }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          return await chatService.reactToMessage({
            messageId: input.messageId,
            userId: user.userId,
            reactionType: input.reactionType,
            conversationId: input.conversationId
          });
        },
        markMessagesAsRead: async (_, { conversationId, messageIds }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          await chatService.markMessagesAsRead(conversationId, user.userId, messageIds);
          return true;
        },
        deleteMessage: async (_, { input }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          return await chatService.deleteMessage({
            messageId: input.messageId,
            userId: user.userId,
            conversationId: input.conversationId,
            deleteType: input.deleteType || "soft",
            deleteFor: input.deleteFor || "me"
          });
        },
        archiveConversation: async (_, { conversationId }, { user, req }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          return await chatService.archivedConversation(
            user.userId,
            conversationId,
            req.ip,
            req.headers["user-agent"]
          );
        },
        createOrGetConversation: async (_, { input }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const chatService = new chatService_default(null);
          return await chatService.createOrGetConversation({
            userId: user.userId,
            participantId: input.participantId,
            type: input.type || "direct",
            propertyId: input.propertyId
          });
        }
      },
      Conversation: {
        participants: async (conversation) => {
          return await userModel_default.find({ _id: { $in: conversation.participants } }).select("firstName lastName profilePicture presenceStatus lastActive email");
        },
        lastMessage: async (conversation) => {
          return await chatModel_default.findOne({ conversationId: conversation._id }).sort({ createdAt: -1 });
        },
        unreadCount: async (conversation, { userId }) => {
          return await chatModel_default.countDocuments({
            conversationId: conversation._id,
            senderId: { $ne: userId },
            "status.read": { $not: { $elemMatch: { userId } } }
          });
        },
        messages: async (conversation, { limit, offset, filters }) => {
          const query2 = { conversationId: conversation._id, isDeleted: false };
          if (filters?.messageType) query2.messageType = filters.messageType;
          if (filters?.senderId) query2.senderId = filters.senderId;
          if (filters?.dateRange) {
            query2.createdAt = {};
            if (filters.dateRange.start) query2.createdAt.$gte = new Date(filters.dateRange.start);
            if (filters.dateRange.end) query2.createdAt.$lte = new Date(filters.dateRange.end);
          }
          const messages = await chatModel_default.find(query2).populate("senderId", "firstName lastName profilePicture").populate("replyTo").populate("mentions.userId", "firstName lastName username").sort({ createdAt: -1 }).skip(offset || 0).limit(limit || 50);
          for (const message of messages) {
            if (message.content && typeof message.content === "string" && message.content.includes(":")) {
              try {
                message.content = await encryptionService_default.decrypt(message.content);
              } catch (error2) {
                console.error("Erreur d\xE9chiffrement:", error2);
              }
            }
          }
          return messages;
        },
        property: async (conversation) => {
          if (!conversation.propertyId) return null;
          return await propertyModel_default.findById(conversation.propertyId);
        },
        stats: async (conversation) => {
          const chatService = new chatService_default(null);
          return await chatService.getConversationStats(conversation._id.toString());
        },
        onlineParticipants: async (conversation) => {
          return await userModel_default.find({
            _id: { $in: conversation.participants },
            presenceStatus: "online"
          }).select("firstName lastName profilePicture");
        },
        isArchivedFor: (conversation, { userId }) => {
          if (!conversation.isArchivedBy) return false;
          return conversation.isArchivedBy.some(
            (entry) => entry.userId.toString() === userId
          );
        }
      },
      Message: {
        sender: async (message) => {
          return await userModel_default.findById(message.senderId);
        },
        conversation: async (message) => {
          return await conversationModel_default.findById(message.conversationId);
        },
        replyTo: async (message) => {
          if (!message.replyTo) return null;
          return await chatModel_default.findById(message.replyTo);
        },
        property: async (message) => {
          if (!message.location?.propertyId) return null;
          return await propertyModel_default.findById(message.location.propertyId);
        },
        aiInsights: (message) => {
          return message.aiInsights || null;
        },
        reactions: (message) => {
          return message.reactions || [];
        },
        mentions: async (message) => {
          if (!message.mentions || message.mentions.length === 0) return [];
          return await userModel_default.find({
            _id: { $in: message.mentions.map((m) => m.userId) }
          }).select("firstName lastName username profilePicture");
        },
        readStatus: (message, { userId }) => {
          if (!message.status?.read) return null;
          const readEntry = message.status.read.find(
            (entry) => entry.userId.toString() === userId
          );
          return readEntry ? readEntry.timestamp : null;
        },
        isEdited: (message) => {
          return message.isEdited || false;
        },
        editHistory: (message) => {
          return message.editHistory || [];
        },
        sentimentAnalysis: async (message) => {
          if (message.aiInsights?.sentiment) {
            return message.aiInsights.sentiment;
          }
          const analysis = await AIAnalysis_default.analyzeMessage(
            message.content,
            message.messageType,
            message.senderId.toString()
          );
          return analysis.sentiment;
        }
      },
      Subscription: {
        messageAdded: {
          subscribe: async function* (_, { conversationId }, { user }) {
            if (!user) throw new Error("Authentication required");
            const conversation = await conversationModel_default.findById(conversationId);
            if (!conversation || !conversation.participants.includes(user.userId)) {
              throw new Error("Access denied");
            }
            const message = await chatModel_default.findOne({ conversationId }).sort({ createdAt: -1 });
            yield { messageAdded: message };
          }
        },
        conversationUpdated: {
          subscribe: async function* (_, { userId }, { user }) {
            if (!user || user.userId !== userId) throw new Error("Access denied");
            yield { conversationUpdated: null };
          }
        },
        typingStatus: {
          subscribe: async function* (_, { conversationId }, { user }) {
            if (!user) throw new Error("Authentication required");
            const conversation = await conversationModel_default.findById(conversationId);
            if (!conversation || !conversation.participants.includes(user.userId)) {
              throw new Error("Access denied");
            }
            yield { typingStatus: { userId: user.userId, isTyping: false } };
          }
        }
      },
      AIInsight: {
        sentiment: (aiInsight) => aiInsight.sentiment,
        intentDetection: (aiInsight) => aiInsight.intentDetection,
        autoSuggestions: (aiInsight) => aiInsight.autoSuggestions || [],
        priority: (aiInsight) => aiInsight.priority || "normal",
        confidence: (aiInsight) => aiInsight.confidence || 0,
        language: (aiInsight) => aiInsight.language || "unknown",
        topics: (aiInsight) => aiInsight.topics || [],
        entities: (aiInsight) => aiInsight.entities || []
      },
      SentimentAnalysis: {
        score: (sentiment) => sentiment.score || 0,
        label: (sentiment) => sentiment.label || "neutral"
      }
    };
  }
});

// src/activity/utils/errors.ts
function isActivityError(error2) {
  return error2 instanceof ActivityError;
}
function logActivityError(error2, context = {}) {
  return {
    level: "error",
    message: error2.message,
    code: error2.code,
    statusCode: error2.statusCode,
    details: error2.details,
    context,
    stack: error2.stack,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
}
var ActivityError, PropertyNotFoundError, PropertyNotAvailableError, UserNotFoundError, ConversationCreationError;
var init_errors2 = __esm({
  "src/activity/utils/errors.ts"() {
    ActivityError = class extends Error {
      constructor(message, statusCode = 500, code, details) {
        super(message);
        __publicField(this, "statusCode");
        __publicField(this, "code");
        __publicField(this, "details");
        this.name = "ActivityError";
        this.statusCode = statusCode;
        this.code = code || "ACTIVITY_ERROR";
        this.details = details;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    PropertyNotFoundError = class extends ActivityError {
      constructor(propertyId) {
        super(`Property with ID ${propertyId} not found`, 404, "PROPERTY_NOT_FOUND", { propertyId });
        this.name = "PropertyNotFoundError";
      }
    };
    PropertyNotAvailableError = class extends ActivityError {
      constructor(propertyId, currentStatus) {
        super(
          `Property with ID ${propertyId} is not available. Current status: ${currentStatus}`,
          400,
          "PROPERTY_NOT_AVAILABLE",
          { propertyId, currentStatus }
        );
        this.name = "PropertyNotAvailableError";
      }
    };
    UserNotFoundError = class extends ActivityError {
      constructor(userId) {
        super(`User with ID ${userId} not found`, 404, "USER_NOT_FOUND", { userId });
        this.name = "UserNotFoundError";
      }
    };
    ConversationCreationError = class extends ActivityError {
      constructor(participants, details) {
        super(
          `Failed to create conversation between participants`,
          500,
          "CONVERSATION_CREATION_ERROR",
          { participants, ...details }
        );
        this.name = "ConversationCreationError";
      }
    };
  }
});

// src/activity/utils/validation.ts
import { Types as Types3 } from "mongoose";
var ActivityValidator;
var init_validation = __esm({
  "src/activity/utils/validation.ts"() {
    init_errors2();
    ActivityValidator = class {
      /**
       * Valide les données de visite
       */
      static validateVisitData(data) {
        if (!data.propertyId || !Types3.ObjectId.isValid(data.propertyId)) {
          throw new ActivityError("PropertyId is required and must be a valid ObjectId", 400, "INVALID_PROPERTY_ID");
        }
        if (!data.clientId || !Types3.ObjectId.isValid(data.clientId)) {
          throw new ActivityError("ClientId is required and must be a valid ObjectId", 400, "INVALID_CLIENT_ID");
        }
        if (!data.message || typeof data.message !== "string" || data.message.trim().length === 0) {
          throw new ActivityError("Message is required and must be a non-empty string", 400, "INVALID_MESSAGE");
        }
        if (data.message.length > 500) {
          throw new ActivityError("Message must not exceed 500 characters", 400, "MESSAGE_TOO_LONG");
        }
        if (data.visitDate) {
          const visitDate = new Date(data.visitDate);
          const now = /* @__PURE__ */ new Date();
          if (isNaN(visitDate.getTime())) {
            throw new ActivityError("Invalid visit date format", 400, "INVALID_VISIT_DATE");
          }
          if (visitDate < new Date(now.getTime() - 60 * 60 * 1e3)) {
            throw new ActivityError("Visit date cannot be in the past", 400, "VISIT_DATE_IN_PAST");
          }
          const sixMonthsFromNow = new Date(now.getTime() + 6 * 30 * 24 * 60 * 60 * 1e3);
          if (visitDate > sixMonthsFromNow) {
            throw new ActivityError("Visit date cannot be more than 6 months in the future", 400, "VISIT_DATE_TOO_FAR");
          }
        }
      }
      /**
       * Valide les données de réservation
       */
      static validateReservationData(data) {
        if (!data.activityId || !Types3.ObjectId.isValid(data.activityId)) {
          throw new ActivityError("ActivityId is required and must be a valid ObjectId", 400, "INVALID_ACTIVITY_ID");
        }
        if (data.reservationDate) {
          const reservationDate = new Date(data.reservationDate);
          const now = /* @__PURE__ */ new Date();
          if (isNaN(reservationDate.getTime())) {
            throw new ActivityError("Invalid reservation date format", 400, "INVALID_RESERVATION_DATE");
          }
          if (reservationDate < new Date(now.getTime() - 60 * 60 * 1e3)) {
            throw new ActivityError("Reservation date cannot be in the past", 400, "RESERVATION_DATE_IN_PAST");
          }
        }
        if (data.uploadedFiles) {
          if (!Array.isArray(data.uploadedFiles)) {
            throw new ActivityError("UploadedFiles must be an array", 400, "INVALID_UPLOADED_FILES");
          }
          data.uploadedFiles.forEach((file, index) => {
            if (!file.fileName || typeof file.fileName !== "string") {
              throw new ActivityError(`File at index ${index} must have a valid fileName`, 400, "INVALID_FILE_NAME");
            }
            if (!file.fileUrl || typeof file.fileUrl !== "string") {
              throw new ActivityError(`File at index ${index} must have a valid fileUrl`, 400, "INVALID_FILE_URL");
            }
            if (!file.uploadedAt || isNaN(new Date(file.uploadedAt).getTime())) {
              throw new ActivityError(`File at index ${index} must have a valid uploadedAt date`, 400, "INVALID_FILE_DATE");
            }
          });
        }
      }
      /**
       * Valide les données d'acceptation de réservation
       */
      static validateAcceptReservation(data) {
        if (!data.activityId || !Types3.ObjectId.isValid(data.activityId)) {
          throw new ActivityError("ActivityId is required and must be a valid ObjectId", 400, "INVALID_ACTIVITY_ID");
        }
        if (data.acceptedDate) {
          const acceptedDate = new Date(data.acceptedDate);
          if (isNaN(acceptedDate.getTime())) {
            throw new ActivityError("Invalid accepted date format", 400, "INVALID_ACCEPTED_DATE");
          }
        }
      }
      /**
       * Valide les données de refus de réservation
       */
      static validateRefuseReservation(data) {
        if (!data.activityId || !Types3.ObjectId.isValid(data.activityId)) {
          throw new ActivityError("ActivityId is required and must be a valid ObjectId", 400, "INVALID_ACTIVITY_ID");
        }
        if (!data.reason || typeof data.reason !== "string" || data.reason.trim().length === 0) {
          throw new ActivityError("Reason is required for reservation refusal", 400, "REASON_REQUIRED");
        }
        if (data.reason.length > 1e3) {
          throw new ActivityError("Reason must not exceed 1000 characters", 400, "REASON_TOO_LONG");
        }
        if (data.refusDate) {
          const refusDate = new Date(data.refusDate);
          if (isNaN(refusDate.getTime())) {
            throw new ActivityError("Invalid refusal date format", 400, "INVALID_REFUSAL_DATE");
          }
        }
      }
      /**
       * Valide les données de paiement
       */
      static validatePaymentData(data) {
        if (!data.activityId || !Types3.ObjectId.isValid(data.activityId)) {
          throw new ActivityError("ActivityId is required and must be a valid ObjectId", 400, "INVALID_ACTIVITY_ID");
        }
        if (!data.amount || typeof data.amount !== "number" || data.amount <= 0) {
          throw new ActivityError("Amount is required and must be a positive number", 400, "INVALID_AMOUNT");
        }
        if (data.amount > 1e6) {
          throw new ActivityError("Amount cannot exceed 1,000,000", 400, "AMOUNT_TOO_HIGH");
        }
        if (Number.isInteger(data.amount * 100) === false) {
          throw new ActivityError("Amount can have at most 2 decimal places", 400, "INVALID_AMOUNT_PRECISION");
        }
        if (data.paymentDate) {
          const paymentDate = new Date(data.paymentDate);
          if (isNaN(paymentDate.getTime())) {
            throw new ActivityError("Invalid payment date format", 400, "INVALID_PAYMENT_DATE");
          }
        }
      }
      /**
       * Valide les paramètres de pagination
       */
      static validatePagination(page, limit) {
        let validPage = parseInt(String(page), 10);
        let validLimit = parseInt(String(limit), 10);
        if (isNaN(validPage) || validPage < 1) {
          validPage = 1;
        }
        if (isNaN(validLimit) || validLimit < 1) {
          validLimit = 10;
        }
        if (validLimit > 100) {
          validLimit = 100;
        }
        return { page: validPage, limit: validLimit };
      }
      /**
       * Valide un ObjectId MongoDB
       */
      static validateObjectId(id, fieldName = "id") {
        if (!id || !Types3.ObjectId.isValid(id)) {
          throw new ActivityError(`${fieldName} must be a valid ObjectId`, 400, "INVALID_OBJECT_ID");
        }
      }
      /**
       * Valide une date
       */
      static validateDate(date, fieldName = "date", required = true) {
        if (!date) {
          if (required) {
            throw new ActivityError(`${fieldName} is required`, 400, "DATE_REQUIRED");
          }
          return null;
        }
        const parsedDate = new Date(date);
        if (isNaN(parsedDate.getTime())) {
          throw new ActivityError(`${fieldName} must be a valid date`, 400, "INVALID_DATE");
        }
        return parsedDate;
      }
      /**
       * Valide une chaîne de caractères
       */
      static validateString(value, fieldName, required = true, minLength = 0, maxLength = Infinity) {
        if (!value || typeof value !== "string") {
          if (required) {
            throw new ActivityError(`${fieldName} is required and must be a string`, 400, "STRING_REQUIRED");
          }
          return null;
        }
        const trimmedValue = value.trim();
        if (trimmedValue.length < minLength) {
          throw new ActivityError(
            `${fieldName} must be at least ${minLength} characters long`,
            400,
            "STRING_TOO_SHORT"
          );
        }
        if (trimmedValue.length > maxLength) {
          throw new ActivityError(
            `${fieldName} must not exceed ${maxLength} characters`,
            400,
            "STRING_TOO_LONG"
          );
        }
        return trimmedValue;
      }
      /**
       * Valide un nombre
       */
      static validateNumber(value, fieldName, required = true, min = -Infinity, max = Infinity) {
        if (value === null || value === void 0) {
          if (required) {
            throw new ActivityError(`${fieldName} is required`, 400, "NUMBER_REQUIRED");
          }
          return null;
        }
        const numValue = Number(value);
        if (isNaN(numValue)) {
          throw new ActivityError(`${fieldName} must be a valid number`, 400, "INVALID_NUMBER");
        }
        if (numValue < min) {
          throw new ActivityError(`${fieldName} must be at least ${min}`, 400, "NUMBER_TOO_LOW");
        }
        if (numValue > max) {
          throw new ActivityError(`${fieldName} must not exceed ${max}`, 400, "NUMBER_TOO_HIGH");
        }
        return numValue;
      }
    };
  }
});

// src/activity/utils/optimization.ts
import { Types as Types4 } from "mongoose";
var ActivityOptimization;
var init_optimization = __esm({
  "src/activity/utils/optimization.ts"() {
    init_activitySchema2();
    ActivityOptimization = class {
      /**
       * Crée les index recommandés pour optimiser les performances
       */
      static async createIndexes() {
        try {
          await activitySchema_default.collection.createIndex({ clientId: 1, createdAt: -1 });
          await activitySchema_default.collection.createIndex({ propertyId: 1, createdAt: -1 });
          await activitySchema_default.collection.createIndex({
            propertyId: 1,
            clientId: 1,
            isVisitAccepted: 1
          });
          await activitySchema_default.collection.createIndex({
            isReservation: 1,
            isReservationAccepted: 1,
            createdAt: -1
          });
          await activitySchema_default.collection.createIndex({
            isPayment: 1,
            paymentDate: -1
          });
          await activitySchema_default.collection.createIndex({ conversationId: 1 });
          await activitySchema_default.collection.createIndex(
            { createdAt: 1 },
            { expireAfterSeconds: 2 * 365 * 24 * 60 * 60 }
            // 2 ans
          );
          console.log("Activity indexes created successfully");
        } catch (error2) {
          console.error("Error creating activity indexes:", error2);
          throw error2;
        }
      }
      /**
       * Pipeline d'agrégation optimisé pour obtenir les statistiques d'un utilisateur
       */
      static getUserActivityStatsPipeline(userId) {
        return [
          {
            $match: { clientId: new Types4.ObjectId(userId) }
          },
          {
            $group: {
              _id: null,
              totalActivities: { $sum: 1 },
              totalVisits: {
                $sum: {
                  $cond: [{ $ne: ["$visitDate", null] }, 1, 0]
                }
              },
              acceptedVisits: {
                $sum: {
                  $cond: [{ $eq: ["$isVisitAccepted", true] }, 1, 0]
                }
              },
              totalReservations: {
                $sum: {
                  $cond: [{ $eq: ["$isReservation", true] }, 1, 0]
                }
              },
              acceptedReservations: {
                $sum: {
                  $cond: [{ $eq: ["$isReservationAccepted", true] }, 1, 0]
                }
              },
              totalPayments: {
                $sum: {
                  $cond: [{ $eq: ["$isPayment", true] }, 1, 0]
                }
              },
              totalAmountPaid: {
                $sum: {
                  $cond: [{ $eq: ["$isPayment", true] }, "$amount", 0]
                }
              }
            }
          }
        ];
      }
      /**
       * Pipeline d'agrégation pour obtenir les statistiques d'un propriétaire
       */
      static getOwnerActivityStatsPipeline(ownerId) {
        return [
          {
            $lookup: {
              from: "properties",
              localField: "propertyId",
              foreignField: "_id",
              as: "property"
            }
          },
          {
            $unwind: "$property"
          },
          {
            $match: { "property.ownerId": new Types4.ObjectId(ownerId) }
          },
          {
            $group: {
              _id: null,
              totalActivities: { $sum: 1 },
              totalVisitRequests: {
                $sum: {
                  $cond: [{ $ne: ["$visitDate", null] }, 1, 0]
                }
              },
              pendingVisits: {
                $sum: {
                  $cond: [
                    {
                      $and: [
                        { $ne: ["$visitDate", null] },
                        { $eq: ["$isVisitAccepted", null] }
                      ]
                    },
                    1,
                    0
                  ]
                }
              },
              totalReservationRequests: {
                $sum: {
                  $cond: [{ $eq: ["$isReservation", true] }, 1, 0]
                }
              },
              pendingReservations: {
                $sum: {
                  $cond: [
                    {
                      $and: [
                        { $eq: ["$isReservation", true] },
                        { $eq: ["$isReservationAccepted", null] }
                      ]
                    },
                    1,
                    0
                  ]
                }
              },
              totalRevenue: {
                $sum: {
                  $cond: [{ $eq: ["$isPayment", true] }, "$amount", 0]
                }
              }
            }
          }
        ];
      }
      /**
       * Requête optimisée pour obtenir les activités avec pagination et filtres
       */
      static buildOptimizedQuery(filters) {
        const pipeline = [];
        const matchStage = {};
        if (filters.userId) {
          matchStage.clientId = new Types4.ObjectId(filters.userId);
        }
        if (filters.propertyId) {
          matchStage.propertyId = new Types4.ObjectId(filters.propertyId);
        }
        if (filters.dateRange) {
          matchStage.createdAt = {
            $gte: filters.dateRange.start,
            $lte: filters.dateRange.end
          };
        }
        if (filters.type) {
          switch (filters.type) {
            case "visit":
              matchStage.visitDate = { $ne: null };
              break;
            case "reservation":
              matchStage.isReservation = true;
              break;
            case "payment":
              matchStage.isPayment = true;
              break;
          }
        }
        if (filters.status) {
          switch (filters.status) {
            case "pending":
              matchStage.$or = [
                { isVisitAccepted: null },
                { isReservationAccepted: null }
              ];
              break;
            case "accepted":
              matchStage.$or = [
                { isVisitAccepted: true },
                { isReservationAccepted: true }
              ];
              break;
            case "rejected":
              matchStage.$or = [
                { isVisitAccepted: false },
                { isReservationAccepted: false }
              ];
              break;
            case "completed":
              matchStage.isPayment = true;
              break;
          }
        }
        pipeline.push({ $match: matchStage });
        if (filters.ownerId) {
          pipeline.push(
            {
              $lookup: {
                from: "properties",
                localField: "propertyId",
                foreignField: "_id",
                as: "property"
              }
            },
            {
              $unwind: "$property"
            },
            {
              $match: { "property.ownerId": new Types4.ObjectId(filters.ownerId) }
            }
          );
        }
        return pipeline;
      }
      /**
       * Met en cache le résultat d'une requête
       */
      static setCacheResult(key, data, ttlSeconds = 300) {
        this.cache.set(key, {
          data,
          timestamp: Date.now(),
          ttl: ttlSeconds * 1e3
        });
      }
      /**
       * Récupère un résultat du cache
       */
      static getCacheResult(key) {
        const cached = this.cache.get(key);
        if (!cached) return null;
        if (Date.now() - cached.timestamp > cached.ttl) {
          this.cache.delete(key);
          return null;
        }
        return cached.data;
      }
      /**
       * Vide le cache
       */
      static clearCache() {
        this.cache.clear();
      }
      /**
       * Génère une clé de cache pour les statistiques utilisateur
       */
      static getUserStatsCacheKey(userId) {
        return `user_stats_${userId}`;
      }
      /**
       * Génère une clé de cache pour les statistiques propriétaire
       */
      static getOwnerStatsCacheKey(ownerId) {
        return `owner_stats_${ownerId}`;
      }
      /**
       * Nettoie périodiquement le cache
       */
      static startCacheCleanup(intervalMinutes = 15) {
        return setInterval(() => {
          const now = Date.now();
          for (const [key, value] of this.cache.entries()) {
            if (now - value.timestamp > value.ttl) {
              this.cache.delete(key);
            }
          }
        }, intervalMinutes * 60 * 1e3);
      }
      /**
       * Batch processing pour les mises à jour
       */
      static async batchUpdateActivities(updates) {
        const bulkOps = updates.map(({ filter: filter2, update }) => ({
          updateOne: {
            filter: filter2,
            update,
            upsert: false
          }
        }));
        if (bulkOps.length > 0) {
          await activitySchema_default.bulkWrite(bulkOps);
        }
      }
      /**
       * Pagination efficace avec cursor
       */
      static async getCursorPaginatedActivities(filter2, lastId, limit = 20) {
        const query2 = { ...filter2 };
        if (lastId) {
          query2._id = { $gt: new Types4.ObjectId(lastId) };
        }
        const activities = await activitySchema_default.find(query2).sort({ _id: 1 }).limit(limit + 1);
        const hasNext = activities.length > limit;
        if (hasNext) {
          activities.pop();
        }
        return {
          activities,
          hasNext,
          nextCursor: hasNext ? activities[activities.length - 1]._id.toString() : null
        };
      }
    };
    /**
     * Cache des requêtes fréquentes
     */
    __publicField(ActivityOptimization, "cache", /* @__PURE__ */ new Map());
  }
});

// src/activity/service/ActivityServices.ts
import mongoose29 from "mongoose";
import { Types as Types5 } from "mongoose";
var logger29, ActivityServices, ActivityServices_default;
var init_ActivityServices = __esm({
  "src/activity/service/ActivityServices.ts"() {
    init_activitySchema2();
    init_IntegratedNotificationService();
    init_propertyModel();
    init_logger();
    init_propertyType();
    init_chatService();
    init_userModel();
    init_conversationModel();
    init_validation();
    init_optimization();
    init_errors2();
    logger29 = createLogger2("ActivityLogger");
    ActivityServices = class {
      constructor(io) {
        __publicField(this, "notificationService");
        __publicField(this, "chatService");
        this.notificationService = new IntegratedNotificationService(io);
        this.chatService = new chatService_default(io);
      }
      async createVisite(visitData) {
        ActivityValidator.validateVisitData(visitData);
        const session = await mongoose29.startSession();
        session.startTransaction();
        const { propertyId, visitDate, message, clientId } = visitData;
        try {
          const property2 = await propertyModel_default.findById(propertyId).session(session);
          if (!property2) {
            throw new PropertyNotFoundError(propertyId.toString());
          }
          if (property2.status !== "disponible" /* AVAILABLE */) {
            throw new PropertyNotAvailableError(propertyId.toString(), property2.status);
          }
          const user = await userModel_default.findById(clientId).session(session);
          if (!user) {
            throw new UserNotFoundError(clientId?.toString() || "unknown");
          }
          if (property2.ownerId.toString() === clientId?.toString()) {
            throw new ActivityError("Cannot create visit for your own property", 400, "CANNOT_VISIT_OWN_PROPERTY");
          }
          const existingVisit = await activitySchema_default.findOne({
            propertyId,
            clientId,
            isVisitAccepted: { $ne: false },
            // Pas encore refusée
            $or: [
              { isVisitAccepted: { $exists: false } },
              // En attente
              { isVisitAccepted: true }
              // Acceptée
            ]
          }).session(session);
          if (existingVisit) {
            throw new ActivityError("A visit request already exists for this property", 400, "VISIT_REQUEST_EXISTS");
          }
          const now = visitDate ? new Date(visitDate) : /* @__PURE__ */ new Date();
          const createVisite = new activitySchema_default({
            propertyId,
            visitDate: now,
            clientId,
            message,
            isVisited: false,
            isVisitAccepted: void 0
            // En attente
          });
          await createVisite.save({ session });
          let conversation = await conversationModel_default.findOne({
            participants: { $all: [clientId, property2.ownerId] }
          }).session(session);
          if (!conversation) {
            try {
              conversation = new conversationModel_default({
                participants: [clientId, property2.ownerId],
                type: "property_discussion",
                propertyId: property2._id
              });
              await conversation.save({ session });
            } catch (convError) {
              throw new ConversationCreationError([clientId?.toString() || "", property2.ownerId.toString()], convError);
            }
          }
          try {
            await this.notificationService.onVisitRequested(createVisite);
          } catch (notifError) {
            logger29.warn("Failed to send visit notification", notifError);
          }
          try {
            const messageParams = {
              conversationId: conversation._id.toString(),
              content: `\u{1F3E0} Demande de visite pour "${property2.title}"
\u{1F4C5} Date souhait\xE9e: ${now.toLocaleDateString()}
\u{1F4AC} Message: ${message}

\u{1F464} Demand\xE9 par ${user.firstName} ${user.lastName}`,
              messageType: "text",
              userId: clientId.toString()
            };
            await this.chatService.sendMessage(messageParams);
          } catch (chatError) {
            logger29.warn("Failed to send chat message", chatError);
          }
          await session.commitTransaction();
          session.endSession();
          logger29.info("Visit created successfully", {
            activityId: createVisite._id,
            propertyId,
            clientId
          });
          return {
            success: true,
            data: createVisite,
            message: "Demande de visite cr\xE9\xE9e avec succ\xE8s",
            conversationId: conversation._id.toString(),
            propertyDetails: {
              title: property2.title,
              location: property2.address
            }
          };
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          if (isActivityError(error2)) {
            logger29.error("Activity error during visit creation", logActivityError(error2, { propertyId, clientId }));
          } else {
            logger29.error("Unexpected error during visit creation", {
              error: error2 instanceof Error ? error2.message : error2,
              propertyId,
              clientId,
              stack: error2 instanceof Error ? error2.stack : void 0
            });
          }
          throw error2;
        }
      }
      async createReservation(activity) {
        const { activityId, reservationDate, uploadedFiles, documentsUploaded } = activity;
        const session = await mongoose29.startSession();
        session.startTransaction();
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2 || property2.status !== "disponible" /* AVAILABLE */) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("you can't make the reservation");
            return;
          }
          logger29.info("tentative de reservation");
          let files = void 0;
          let isdocumentUpload = false;
          if (property2.ownerCriteria?.isDocumentRequired) {
            files = uploadedFiles;
            if (files && files.length > 0) {
              isdocumentUpload = true;
            }
          }
          const reservation = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isReservation: true,
              clientId: activityDoc.clientId,
              propertyId: activityDoc.propertyId,
              documentsUploaded: isdocumentUpload,
              uploadedFiles: files,
              reservationDate: reservationDate ? new Date(reservationDate) : /* @__PURE__ */ new Date()
            },
            { new: true, session }
          );
          await this.notificationService.onReservationRequested(reservation);
          if (!activityDoc.conversationId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            await session.commitTransaction();
            session.endSession();
            return savedConv;
          }
          const user = await userModel_default.findById(activityDoc.clientId).session(session);
          if (!user) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no user found");
            return;
          }
          const messageParams = {
            conversationId: activityDoc.conversationId.toString(),
            content: `R\xE9servation demand\xE9e par ${user.firstName} ${user.lastName} pour la propri\xE9t\xE9 ${property2.title} le ${reservationDate ? new Date(reservationDate).toLocaleDateString() : (/* @__PURE__ */ new Date()).toLocaleDateString()}`,
            messageType: "text",
            userId: activityDoc.clientId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return reservation;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async acceptReservation(activity) {
        const session = await mongoose29.startSession();
        session.startTransaction();
        const { activityId } = activity;
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const reservation = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isReservationAccepted: true,
              acceptDate: /* @__PURE__ */ new Date()
            },
            { new: true, session }
          );
          await propertyModel_default.findByIdAndUpdate(
            activityDoc.propertyId,
            { status: "reserver" /* RESERVED */ },
            { new: true, session }
          );
          await this.notificationService.onReservationResponseGiven(reservation, true);
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no property found");
            return;
          }
          const acceptDate = reservation?.acceptedDate ?? /* @__PURE__ */ new Date();
          let convId = activityDoc.conversationId;
          if (!convId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            convId = savedConv._id;
          }
          const messageParams = {
            conversationId: convId.toString(),
            content: `R\xE9servation accept\xE9e pour la propri\xE9t\xE9 ${property2.title} le ${acceptDate.toLocaleDateString()} \u2014 vous pouvez continuer pour le paiement.`,
            messageType: "text",
            userId: property2.ownerId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return reservation;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async refuseReservation(activity) {
        const session = await mongoose29.startSession();
        session.startTransaction();
        const { activityId, reason } = activity;
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const reservation = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isReservationAccepted: false,
              refusDate: /* @__PURE__ */ new Date(),
              reason
            },
            { new: true, session }
          );
          await propertyModel_default.findByIdAndUpdate(
            activityDoc.propertyId,
            { status: "disponible" /* AVAILABLE */ },
            { new: true, session }
          );
          await this.notificationService.onReservationResponseGiven(reservation, false, reason);
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no property found");
            return;
          }
          let convId = activityDoc.conversationId;
          if (!convId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            convId = savedConv._id;
          }
          const messageParams = {
            conversationId: convId.toString(),
            content: `R\xE9servation refus\xE9e pour la propri\xE9t\xE9 ${property2.title}. La raison : ${reason}`,
            messageType: "text",
            userId: property2.ownerId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return reservation;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async payReservation(activity) {
        const session = await mongoose29.startSession();
        session.startTransaction();
        const { activityId, amount } = activity;
        const pdate = /* @__PURE__ */ new Date();
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2 || property2.status !== "disponible" /* AVAILABLE */) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no property found or not available");
            return;
          }
          if (amount !== property2?.ownerCriteria.depositAmount) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("the amount is not correct");
            return;
          }
          const payement = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isPayment: true,
              amount,
              paymentDate: pdate
            },
            { new: true, session }
          );
          const newStatus = property2.actionType === "rent" ? "lou\xE9" /* RENTED */ : "sold" /* SOLD */;
          await propertyModel_default.findByIdAndUpdate(
            activityDoc.propertyId,
            { status: newStatus, acquiredBy: activityDoc.clientId },
            { new: true, session }
          );
          await this.notificationService.onPaymentCompleted(payement);
          let convId = activityDoc.conversationId;
          if (!convId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            convId = savedConv._id;
          }
          const messageParams = {
            conversationId: convId.toString(),
            content: `Paiement effectu\xE9 pour la propri\xE9t\xE9 ${property2.title} le ${pdate.toLocaleDateString()}`,
            messageType: "text",
            userId: activityDoc.clientId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return payement;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async acceptVisit(activityId) {
        const session = await mongoose29.startSession();
        session.startTransaction();
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no property found");
            return;
          }
          const acceptVisit = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isVisitAccepted: true
            },
            { new: true, session }
          );
          await this.notificationService.onVisitResponseGiven(acceptVisit, true);
          let convId = activityDoc.conversationId;
          if (!convId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            convId = savedConv._id;
          }
          const messageParams = {
            conversationId: convId.toString(),
            content: `Visite accept\xE9e pour la propri\xE9t\xE9 ${property2.title}`,
            messageType: "text",
            userId: property2.ownerId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return acceptVisit;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async refusVisit(activityId) {
        const session = await mongoose29.startSession();
        session.startTransaction();
        try {
          const activityDoc = await activitySchema_default.findById(activityId).session(session);
          if (!activityDoc) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no activity found");
            return;
          }
          const property2 = await propertyModel_default.findById(activityDoc.propertyId).session(session);
          if (!property2) {
            await session.abortTransaction();
            session.endSession();
            logger29.warn("no property found");
            return;
          }
          const refusVisit = await activitySchema_default.findByIdAndUpdate(
            activityId,
            {
              isVisitAccepted: false
            },
            { new: true, session }
          );
          await this.notificationService.onVisitResponseGiven(refusVisit, false);
          let convId = activityDoc.conversationId;
          if (!convId) {
            const newConversation = new conversationModel_default({
              participants: [activityDoc.clientId, property2.ownerId]
            });
            const savedConv = await newConversation.save({ session });
            convId = savedConv._id;
          }
          const messageParams = {
            conversationId: convId.toString(),
            content: `Visite refus\xE9e pour la propri\xE9t\xE9 ${property2.title}`,
            messageType: "text",
            userId: property2.ownerId.toString()
          };
          const chat = await this.chatService.sendMessage(messageParams);
          if (!chat) {
            logger29.warn("no chat sent");
          }
          await session.commitTransaction();
          session.endSession();
          return refusVisit;
        } catch (error2) {
          await session.abortTransaction();
          session.endSession();
          logger29.error("error during the reservation", error2);
          throw error2;
        }
      }
      async getUserActivities(userId, options = {}) {
        try {
          ActivityValidator.validateObjectId(userId, "userId");
          const { page: validPage, limit: validLimit } = ActivityValidator.validatePagination(
            options.page || 1,
            options.limit || 20
          );
          const cacheKey = `user_activities_${userId}_${JSON.stringify(options)}`;
          if (options.useCache !== false) {
            const cachedResult = ActivityOptimization.getCacheResult(cacheKey);
            if (cachedResult) {
              return cachedResult;
            }
          }
          if (options.cursor) {
            const result2 = await ActivityOptimization.getCursorPaginatedActivities(
              { clientId: new Types5.ObjectId(userId) },
              options.cursor,
              validLimit
            );
            const populatedActivities = await activitySchema_default.populate(result2.activities, [
              { path: "propertyId", select: "title images location price ownerCriteria" },
              { path: "conversationId", select: "participants type" }
            ]);
            const finalResult = {
              activities: populatedActivities,
              hasNext: result2.hasNext,
              nextCursor: result2.nextCursor,
              total: null
              // Non disponible avec la pagination par cursor
            };
            if (options.useCache !== false) {
              ActivityOptimization.setCacheResult(cacheKey, finalResult, 300);
            }
            return finalResult;
          }
          const pipeline = ActivityOptimization.buildOptimizedQuery({
            userId,
            status: options.status,
            type: options.type,
            dateRange: options.dateRange
          });
          pipeline.push(
            {
              $lookup: {
                from: "properties",
                localField: "propertyId",
                foreignField: "_id",
                as: "propertyDetails"
              }
            },
            {
              $unwind: {
                path: "$propertyDetails",
                preserveNullAndEmptyArrays: true
              }
            },
            {
              $lookup: {
                from: "conversations",
                localField: "conversationId",
                foreignField: "_id",
                as: "conversationDetails"
              }
            },
            {
              $unwind: {
                path: "$conversationDetails",
                preserveNullAndEmptyArrays: true
              }
            },
            {
              $sort: { createdAt: -1 }
            }
          );
          const skip = (validPage - 1) * validLimit;
          const paginatedPipeline = [
            ...pipeline,
            { $skip: skip },
            { $limit: validLimit }
          ];
          const [activities, totalCount] = await Promise.all([
            activitySchema_default.aggregate(paginatedPipeline),
            activitySchema_default.aggregate([...pipeline, { $count: "total" }])
          ]);
          const total = totalCount[0]?.total || 0;
          const result = {
            activities,
            pagination: {
              page: validPage,
              limit: validLimit,
              total,
              pages: Math.ceil(total / validLimit),
              hasNext: validPage * validLimit < total,
              hasPrev: validPage > 1
            }
          };
          if (options.useCache !== false) {
            ActivityOptimization.setCacheResult(cacheKey, result, 300);
          }
          return result;
        } catch (error2) {
          logger29.error("Error getting user activities", {
            error: error2 instanceof Error ? error2.message : error2,
            userId,
            options
          });
          throw error2;
        }
      }
      async getActivityById(activityId) {
        try {
          const activity = await activitySchema_default.findById(activityId).populate("propertyId").populate("clientId");
          return activity;
        } catch (error2) {
          logger29.error("error getting activity by id", error2);
          throw error2;
        }
      }
      async getOwnerActivities(ownerId, options) {
        try {
          const { page, limit } = options;
          const skip = (page - 1) * limit;
          const properties = await propertyModel_default.find({ ownerId }).select("_id");
          const propertyIds = properties.map((p) => p._id);
          const activities = await activitySchema_default.find({ propertyId: { $in: propertyIds } }).populate("propertyId").populate("clientId").sort({ createdAt: -1 }).skip(skip).limit(limit);
          const total = await activitySchema_default.countDocuments({ propertyId: { $in: propertyIds } });
          return {
            activities,
            pagination: {
              page,
              limit,
              total,
              pages: Math.ceil(total / limit)
            }
          };
        } catch (error2) {
          logger29.error("error getting owner activities", error2);
          throw error2;
        }
      }
      async processPayment(paymentData) {
        try {
          const result = await this.payReservation(paymentData);
          return result;
        } catch (error2) {
          logger29.error("error processing payment", error2);
          throw error2;
        }
      }
      async acceptVisitRequest(activityId) {
        try {
          const result = await this.acceptVisit(activityId);
          return result;
        } catch (error2) {
          logger29.error("error accepting visit", error2);
          throw error2;
        }
      }
      async refuseVisitRequest(activityId) {
        try {
          const result = await this.refusVisit(activityId);
          return result;
        } catch (error2) {
          logger29.error("error refusing visit", error2);
          throw error2;
        }
      }
    };
    ActivityServices_default = ActivityServices;
  }
});

// src/activity/graphql/activityResolvers.ts
import { Types as Types6 } from "mongoose";
var activityResolvers;
var init_activityResolvers = __esm({
  "src/activity/graphql/activityResolvers.ts"() {
    init_activitySchema2();
    init_propertyModel();
    init_userModel();
    init_IntegratedNotificationService();
    init_Transaction();
    init_conversationModel();
    init_chatModel();
    init_ActivityServices();
    activityResolvers = {
      Query: {
        activities: async (_, { propertyId, userId, pagination, filters }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const query2 = {};
          if (propertyId) {
            const property2 = await propertyModel_default.findById(propertyId);
            const propertyOwnerId = property2?.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2?.ownerId);
            if (!property2 || propertyOwnerId !== user.userId && userId !== user.userId) {
              throw new Error("Access denied");
            }
            query2.propertyId = propertyId;
          }
          if (userId) {
            if (userId !== user.userId && user.role !== "ADMIN") {
              throw new Error("Access denied");
            }
            query2.clientId = userId;
          }
          if (filters?.status) {
            switch (filters.status) {
              case "PENDING":
                query2.$or = [
                  { isVisited: true, isVisiteAcccepted: { $ne: true } },
                  { isReservation: true, isReservationAccepted: { $ne: true } }
                ];
                break;
              case "ACCEPTED":
                query2.$or = [
                  { isVisiteAcccepted: true },
                  { isReservationAccepted: true }
                ];
                break;
              case "COMPLETED":
                query2.isPayment = true;
                break;
            }
          }
          if (filters?.type) {
            if (filters.type === "VISIT") query2.isVisited = true;
            if (filters.type === "RESERVATION") query2.isReservation = true;
          }
          if (filters?.dateRange) {
            query2.createdAt = {};
            if (filters.dateRange.start) query2.createdAt.$gte = new Date(filters.dateRange.start);
            if (filters.dateRange.end) query2.createdAt.$lte = new Date(filters.dateRange.end);
          }
          const limit = pagination?.first || 20;
          const skip = pagination?.after ? parseInt(Buffer.from(pagination.after, "base64").toString()) : 0;
          const activities = await activitySchema_default.find(query2).populate("propertyId").populate("clientId", "firstName lastName profilePicture email").sort({ createdAt: -1 }).skip(skip).limit(limit + 1);
          const hasNextPage = activities.length > limit;
          const nodes = hasNextPage ? activities.slice(0, -1) : activities;
          const edges = nodes.map((activity, index) => ({
            node: activity,
            cursor: Buffer.from((skip + index).toString()).toString("base64")
          }));
          const totalCount = await activitySchema_default.countDocuments(query2);
          return {
            edges,
            pageInfo: {
              hasNextPage,
              hasPreviousPage: skip > 0,
              startCursor: edges[0]?.cursor,
              endCursor: edges[edges.length - 1]?.cursor
            },
            totalCount
          };
        },
        activity: async (_, { id }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activity = await activitySchema_default.findById(id).populate("propertyId").populate("clientId", "firstName lastName profilePicture email");
          if (!activity) throw new Error("Activity not found");
          const property2 = await propertyModel_default.findById(activity.propertyId);
          const propertyOwnerId = property2?.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2?.ownerId);
          const activityClientId = activity.clientId instanceof Types6.ObjectId ? activity.clientId.toString() : activity.clientId?._id?.toString() || String(activity.clientId);
          if (!property2 || propertyOwnerId !== user.userId && activityClientId !== user.userId) {
            throw new Error("Access denied");
          }
          return activity;
        },
        // Statistiques des activités
        activityStats: async (_, { propertyId, userId, timeRange }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const query2 = {};
          if (propertyId) {
            const property2 = await propertyModel_default.findById(propertyId);
            const propertyOwnerId = property2?.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2?.ownerId);
            if (!property2 || propertyOwnerId !== user.userId) {
              throw new Error("Access denied");
            }
            query2.propertyId = propertyId;
          }
          if (userId && userId === user.userId) {
            query2.clientId = userId;
          }
          if (timeRange) {
            query2.createdAt = {};
            if (timeRange.start) query2.createdAt.$gte = new Date(timeRange.start);
            if (timeRange.end) query2.createdAt.$lte = new Date(timeRange.end);
          }
          const [
            totalActivities,
            visitRequests,
            reservationRequests,
            acceptedVisits,
            acceptedReservations,
            completedPayments,
            averageResponseTime
          ] = await Promise.all([
            activitySchema_default.countDocuments(query2),
            activitySchema_default.countDocuments({ ...query2, isVisited: true }),
            activitySchema_default.countDocuments({ ...query2, isReservation: true }),
            activitySchema_default.countDocuments({ ...query2, isVisiteAcccepted: true }),
            activitySchema_default.countDocuments({ ...query2, isReservationAccepted: true }),
            activitySchema_default.countDocuments({ ...query2, isPayment: true }),
            activitySchema_default.aggregate([
              { $match: query2 },
              { $group: { _id: null, avgTime: { $avg: { $subtract: ["$updatedAt", "$createdAt"] } } } }
            ])
          ]);
          return {
            totalActivities,
            visitRequests,
            reservationRequests,
            acceptedVisits,
            acceptedReservations,
            completedPayments,
            acceptanceRate: visitRequests > 0 ? acceptedVisits / visitRequests * 100 : 0,
            conversionRate: visitRequests > 0 ? completedPayments / visitRequests * 100 : 0,
            averageResponseTime: averageResponseTime[0]?.avgTime || 0
          };
        },
        // Activités par propriétaire
        ownerActivities: async (_, { pagination, filters }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activityService = new ActivityServices_default(null);
          return await activityService.getOwnerActivities(user.userId, {
            page: pagination?.page || 1,
            limit: pagination?.limit || 20
          });
        }
      },
      Mutation: {
        createActivity: async (_, { input }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activityService = new ActivityServices_default(null);
          if (input.isVisited) {
            return await activityService.createVisite({
              propertyId: input.propertyId,
              clientId: user.userId,
              message: input.message,
              visitDate: input.visitDate
            });
          }
          if (input.isReservation) {
            const activity2 = new activitySchema_default({
              propertyId: input.propertyId,
              clientId: user.userId,
              message: input.message,
              isReservation: true,
              reservationDate: input.reservationDate || /* @__PURE__ */ new Date()
            });
            await activity2.save();
            return await activityService.createReservation({
              activityId: activity2._id,
              reservationDate: input.reservationDate || /* @__PURE__ */ new Date(),
              documentsUploaded: !!input.uploadedFiles && input.uploadedFiles.length > 0,
              uploadedFiles: input.uploadedFiles
            });
          }
          const activity = new activitySchema_default({
            propertyId: input.propertyId,
            clientId: user.userId,
            message: input.message,
            isVisited: input.isVisited || false,
            visitDate: input.visitDate,
            isReservation: input.isReservation || false
          });
          return await activity.save();
        },
        updateActivityStatus: async (_, { id, status, reason }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activity = await activitySchema_default.findById(id);
          if (!activity) throw new Error("Activity not found");
          const property2 = await propertyModel_default.findById(activity.propertyId);
          const propertyOwnerId = property2?.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2?.ownerId);
          if (!property2 || propertyOwnerId !== user.userId) {
            throw new Error("Unauthorized");
          }
          const activityService = new ActivityServices_default(null);
          switch (status) {
            case "ACCEPTED":
              if (activity.isVisited) {
                return await activityService.acceptVisitRequest(id);
              } else if (activity.isReservation) {
                return await activityService.acceptReservation({
                  activityId: new Types6.ObjectId(id)
                });
              }
              break;
            case "REFUSED":
              if (activity.isVisited) {
                return await activityService.refuseVisitRequest(id);
              } else if (activity.isReservation) {
                return await activityService.refuseReservation({
                  activityId: new Types6.ObjectId(id),
                  reason: reason || "Refus\xE9 par le propri\xE9taire"
                });
              }
              break;
            case "COMPLETED":
              if (activity.isReservation && activity.isReservationAccepted) {
                return await activityService.processPayment({
                  activityId: new Types6.ObjectId(id),
                  amount: property2.ownerCriteria?.depositAmount || 0,
                  isBookingAccepted: true,
                  paymentDate: /* @__PURE__ */ new Date()
                });
              }
              break;
          }
          return await activitySchema_default.findById(id);
        },
        // Traiter un paiement
        processPayment: async (_, { activityId, amount }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activity = await activitySchema_default.findById(activityId);
          const activityClientId = activity?.clientId instanceof Types6.ObjectId ? activity.clientId.toString() : String(activity?.clientId);
          if (!activity || activityClientId !== user.userId) {
            throw new Error("Activity not found or unauthorized");
          }
          const activityService = new ActivityServices_default(null);
          return await activityService.processPayment({
            activityId: new Types6.ObjectId(activityId),
            amount,
            isBookingAccepted: true,
            paymentDate: /* @__PURE__ */ new Date()
          });
        },
        // Annuler une activité
        cancelActivity: async (_, { id, reason }, { user }) => {
          if (!user) throw new Error("Authentication required");
          const activity = await activitySchema_default.findById(id);
          if (!activity) throw new Error("Activity not found");
          const activityClientId = activity.clientId instanceof Types6.ObjectId ? activity.clientId.toString() : String(activity.clientId);
          if (activityClientId !== user.userId) {
            throw new Error("Unauthorized");
          }
          activity.isCancelled = true;
          activity.cancelReason = reason;
          activity.cancelDate = /* @__PURE__ */ new Date();
          await activity.save();
          const property2 = await propertyModel_default.findById(activity.propertyId);
          if (property2) {
            const propertyOwnerId = property2.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2.ownerId);
            try {
              const notificationService3 = new IntegratedNotificationService(null);
              console.log("Activity cancelled notification:", {
                userId: propertyOwnerId,
                activityId: id,
                propertyId: String(property2._id),
                reason
              });
            } catch (err) {
              console.error("Failed to send cancellation notification:", err);
            }
          }
          return activity;
        }
      },
      Activity: {
        property: async (activity) => {
          return await propertyModel_default.findById(activity.propertyId);
        },
        client: async (activity) => {
          return await userModel_default.findById(activity.clientId);
        },
        uploadedFiles: (activity) => {
          return activity.uploadedFiles || [];
        },
        // Conversation liée à l'activité
        conversation: async (activity) => {
          const property2 = await propertyModel_default.findById(activity.propertyId);
          if (!property2) return null;
          return await conversationModel_default.findOne({
            participants: { $all: [activity.clientId, property2.ownerId] }
          });
        },
        // Messages liés à l'activité
        messages: async (activity) => {
          const property2 = await propertyModel_default.findById(activity.propertyId);
          if (!property2) return [];
          const conversation = await conversationModel_default.findOne({
            participants: { $all: [activity.clientId, property2.ownerId] }
          });
          if (!conversation) return [];
          return await chatModel_default.find({ conversationId: conversation._id }).populate("senderId", "firstName lastName").sort({ createdAt: -1 }).limit(10);
        },
        // Transactions liées
        relatedTransactions: async (activity) => {
          return await Transaction.find({
            "metadata.activityId": activity._id.toString()
          }).sort({ createdAt: -1 });
        },
        // Statut global de l'activité
        status: (activity) => {
          if (activity.isCancelled) return "CANCELLED";
          if (activity.isPayment) return "COMPLETED";
          if (activity.isReservationAccepted || activity.isVisiteAcccepted) return "ACCEPTED";
          if (activity.isReservation || activity.isVisited) return "PENDING";
          return "DRAFT";
        },
        // Type d'activité
        type: (activity) => {
          if (activity.isReservation) return "RESERVATION";
          if (activity.isVisited) return "VISIT";
          return "INQUIRY";
        },
        // Durée depuis la création
        duration: (activity) => {
          const now = /* @__PURE__ */ new Date();
          const created = new Date(activity.createdAt);
          return Math.floor((now.getTime() - created.getTime()) / (1e3 * 60 * 60 * 24));
        },
        // Prochaine étape suggérée
        nextStep: async (activity) => {
          if (activity.isCancelled) return null;
          if (activity.isPayment) return "COMPLETED";
          if (activity.isReservation && activity.isReservationAccepted && !activity.isPayment) {
            return "PAYMENT_REQUIRED";
          }
          if (activity.isReservation && !activity.isReservationAccepted) {
            return "AWAITING_RESERVATION_APPROVAL";
          }
          if (activity.isVisited && !activity.isVisiteAcccepted) {
            return "AWAITING_VISIT_APPROVAL";
          }
          if (activity.isVisited && activity.isVisiteAcccepted) {
            return "VISIT_SCHEDULED";
          }
          return "AWAITING_RESPONSE";
        },
        // Score de priorité
        priorityScore: async (activity) => {
          let score = 0;
          const daysSinceCreation = Math.floor((Date.now() - activity.createdAt.getTime()) / (1e3 * 60 * 60 * 24));
          score += Math.max(0, 10 - daysSinceCreation);
          if (activity.isReservation) score += 5;
          if (activity.isVisited) score += 3;
          if (activity.isReservationAccepted && !activity.isPayment) score += 8;
          return Math.min(10, score);
        }
      },
      // Subscriptions pour les mises à jour en temps réel
      Subscription: {
        activityUpdated: {
          subscribe: async function* (_, { propertyId, userId }, { user }) {
            if (!user) throw new Error("Authentication required");
            if (propertyId) {
              const property2 = await propertyModel_default.findById(propertyId);
              const propertyOwnerId = property2?.ownerId instanceof Types6.ObjectId ? property2.ownerId.toString() : String(property2?.ownerId);
              if (!property2 || propertyOwnerId !== user.userId) {
                throw new Error("Access denied");
              }
            }
            if (userId && userId !== user.userId) {
              throw new Error("Access denied");
            }
            const activity = await activitySchema_default.findOne({
              $or: [
                { propertyId },
                { clientId: userId }
              ]
            }).sort({ createdAt: -1 });
            yield { activityUpdated: activity };
          }
        }
      },
      // Resolvers pour les types complexes
      ActivityStats: {
        totalActivities: (stats) => stats.totalActivities || 0,
        visitRequests: (stats) => stats.visitRequests || 0,
        reservationRequests: (stats) => stats.reservationRequests || 0,
        acceptedVisits: (stats) => stats.acceptedVisits || 0,
        acceptedReservations: (stats) => stats.acceptedReservations || 0,
        completedPayments: (stats) => stats.completedPayments || 0,
        acceptanceRate: (stats) => stats.acceptanceRate || 0,
        conversionRate: (stats) => stats.conversionRate || 0,
        averageResponseTime: (stats) => stats.averageResponseTime || 0
      }
    };
  }
});

// src/crypto/graphql/cryptoResolvers.ts
var notImplemented, cryptoResolvers;
var init_cryptoResolvers = __esm({
  "src/crypto/graphql/cryptoResolvers.ts"() {
    notImplemented = (name) => {
      throw new Error(`${name} is not yet implemented. Crypto features are under development.`);
    };
    cryptoResolvers = {
      Query: {
        // Crypto Payments
        getCryptoPayment: () => notImplemented("getCryptoPayment"),
        getUserCryptoPayments: () => ({ payments: [], total: 0, hasMore: false }),
        getPropertyCryptoPayments: () => [],
        // Property Tokens
        getPropertyToken: () => null,
        getPropertyTokens: () => [],
        getUserPropertyTokens: () => [],
        // Utility Tokens
        getUtilityToken: () => null,
        getUserUtilityTokens: () => [],
        getUtilityTokenProposals: () => [],
        // Smart Contracts
        getSmartContract: () => null,
        getPropertyContracts: () => [],
        getUserContracts: () => [],
        // Marketplace
        getMarketplaceListings: () => [],
        getUserTradingHistory: () => [],
        getMarketplaceListing: () => null,
        // DeFi
        getYieldFarmingPools: () => [],
        getLendingPools: () => [],
        getUserDeFiPositions: () => ({ totalValue: 0, totalRewards: 0, positionsCount: 0, yieldFarming: 0, lending: 0, positions: [] }),
        // Price Data
        getCryptoPrices: () => [],
        getExchangeRate: () => ({ from: "", to: "", rate: 0, timestamp: (/* @__PURE__ */ new Date()).toISOString(), source: "N/A" }),
        getMarketIndicators: () => ({
          cryptoMarket: { totalMarketCap: 0, fearGreedIndex: 50, dominance: 0 },
          realEstateMarket: { averageCapRate: 0, priceAppreciation: 0, rentalYield: 0 },
          defiMetrics: { totalValueLocked: 0, averageApy: 0, liquidityIndex: 0 }
        }),
        getHistoricalData: () => [],
        getPropertyValuation: () => 0,
        // Analytics
        getCryptoAnalytics: () => ({
          totalPortfolioValue: 0,
          totalPayments: 0,
          totalRevenue: 0,
          activeTokens: 0,
          stakingRewards: 0,
          portfolioBreakdown: []
        }),
        // New DeFi Queries
        getDynamicPricing: () => null,
        getMultiAssetStaking: () => null,
        getFractionalOwnership: () => null,
        getLoyaltyMining: () => null,
        getAIRiskAssessment: () => null,
        getInsuranceDAO: () => null,
        getInsuranceClaims: () => [],
        getUserLoyaltyPrograms: () => [],
        getPropertyStakingPerformance: () => [],
        getUserRiskAssessments: () => [],
        getInsuranceStatistics: () => ({
          totalClaims: 0,
          approvedClaims: 0,
          totalPaidOut: 0,
          successRate: 0,
          averageClaimAmount: 0,
          averageProcessingTime: 0
        })
      },
      Mutation: {
        // Crypto Payments
        createCryptoPayment: () => notImplemented("createCryptoPayment"),
        processCryptoPayment: () => notImplemented("processCryptoPayment"),
        confirmCryptoPayment: () => notImplemented("confirmCryptoPayment"),
        refundCryptoPayment: () => notImplemented("refundCryptoPayment"),
        releaseEscrow: () => notImplemented("releaseEscrow"),
        // Property Tokens
        tokenizeProperty: () => notImplemented("tokenizeProperty"),
        buyPropertyTokens: () => notImplemented("buyPropertyTokens"),
        sellPropertyTokens: () => notImplemented("sellPropertyTokens"),
        distributeRevenue: () => notImplemented("distributeRevenue"),
        // Utility Tokens
        createUtilityToken: () => notImplemented("createUtilityToken"),
        mintUtilityTokens: () => notImplemented("mintUtilityTokens"),
        stakeUtilityTokens: () => notImplemented("stakeUtilityTokens"),
        claimStakingRewards: () => notImplemented("claimStakingRewards"),
        // Governance
        createGovernanceProposal: () => notImplemented("createGovernanceProposal"),
        voteOnProposal: () => notImplemented("voteOnProposal"),
        // Marketplace
        listTokensForSale: () => notImplemented("listTokensForSale"),
        placeBid: () => notImplemented("placeBid"),
        acceptBid: () => notImplemented("acceptBid"),
        cancelListing: () => notImplemented("cancelListing"),
        // DeFi
        stakeInYieldFarm: () => notImplemented("stakeInYieldFarm"),
        claimYieldFarmingRewards: () => notImplemented("claimYieldFarmingRewards"),
        supplyToLendingPool: () => notImplemented("supplyToLendingPool"),
        borrowFromLendingPool: () => notImplemented("borrowFromLendingPool"),
        repayLoan: () => notImplemented("repayLoan"),
        liquidatePosition: () => notImplemented("liquidatePosition"),
        // Price Alerts
        subscribeToPriceAlerts: () => notImplemented("subscribeToPriceAlerts"),
        // New DeFi Mutations
        setupDynamicPricing: () => notImplemented("setupDynamicPricing"),
        updateRentPricing: () => notImplemented("updateRentPricing"),
        processRentPayment: () => notImplemented("processRentPayment"),
        setupMultiAssetStaking: () => notImplemented("setupMultiAssetStaking"),
        rebalancePortfolio: () => notImplemented("rebalancePortfolio"),
        tokenizePropertyAdvanced: () => notImplemented("tokenizePropertyAdvanced"),
        purchasePropertyShares: () => notImplemented("purchasePropertyShares"),
        enableTenantTransition: () => notImplemented("enableTenantTransition"),
        initializeLoyalty: () => notImplemented("initializeLoyalty"),
        updateLoyalty: () => notImplemented("updateLoyalty"),
        processReferral: () => notImplemented("processReferral"),
        createRiskAssessment: () => notImplemented("createRiskAssessment"),
        updateRiskAssessment: () => notImplemented("updateRiskAssessment"),
        submitInsuranceClaim: () => notImplemented("submitInsuranceClaim"),
        voteOnInsuranceClaim: () => notImplemented("voteOnInsuranceClaim")
      },
      Subscription: {
        cryptoPaymentUpdates: {
          subscribe: () => notImplemented("cryptoPaymentUpdates subscription")
        },
        priceUpdates: {
          subscribe: () => notImplemented("priceUpdates subscription")
        },
        tokenTransfers: {
          subscribe: () => notImplemented("tokenTransfers subscription")
        },
        governanceUpdates: {
          subscribe: () => notImplemented("governanceUpdates subscription")
        },
        marketplaceUpdates: {
          subscribe: () => notImplemented("marketplaceUpdates subscription")
        },
        deFiPositionUpdates: {
          subscribe: () => notImplemented("deFiPositionUpdates subscription")
        }
      }
    };
  }
});

// src/graphql/resolvers/index.ts
import { GraphQLScalarType as GraphQLScalarType5 } from "graphql";
import { Kind as Kind29 } from "graphql/language";
var scalarResolvers, resolvers;
var init_resolvers = __esm({
  "src/graphql/resolvers/index.ts"() {
    init_propertyResolvers();
    init_serviceResolvers();
    init_userResolvers();
    init_walletResolvers();
    init_chatResolvers();
    init_activityResolvers();
    init_cryptoResolvers();
    scalarResolvers = {
      Date: new GraphQLScalarType5({
        name: "Date",
        description: "Date custom scalar type",
        serialize(value) {
          return value instanceof Date ? value.toISOString() : null;
        },
        parseValue(value) {
          return new Date(value);
        },
        parseLiteral(ast) {
          if (ast.kind === Kind29.STRING) {
            return new Date(ast.value);
          }
          return null;
        }
      }),
      Upload: new GraphQLScalarType5({
        name: "Upload",
        description: "The `Upload` scalar type represents a file upload.",
        serialize: () => {
          throw new Error("Upload serialization unsupported.");
        },
        parseValue: (value) => value,
        parseLiteral: () => {
          throw new Error("Upload literal unsupported.");
        }
      })
    };
    resolvers = {
      ...scalarResolvers,
      Query: {
        ...propertyResolvers.Query,
        ...serviceResolvers.Query,
        ...userResolvers.Query,
        ...walletResolvers.Query,
        ...chatResolvers.Query,
        ...activityResolvers.Query,
        ...cryptoResolvers.Query
      },
      Mutation: {
        ...propertyResolvers.Mutation,
        ...serviceResolvers.Mutation,
        ...walletResolvers.Mutation,
        ...chatResolvers.Mutation,
        ...activityResolvers.Mutation,
        ...cryptoResolvers.Mutation
      },
      Subscription: {
        ...walletResolvers.Subscription,
        ...chatResolvers.Subscription,
        ...activityResolvers.Subscription,
        ...cryptoResolvers.Subscription
      },
      // Types
      Property: propertyResolvers.Property,
      Service: serviceResolvers.Service,
      ServiceProvider: serviceResolvers.ServiceProvider,
      ServiceSubscription: serviceResolvers.ServiceSubscription,
      ServiceRecommendation: serviceResolvers.ServiceRecommendation,
      User: userResolvers.User,
      Wallet: walletResolvers.Wallet,
      Transaction: walletResolvers.Transaction,
      Conversation: chatResolvers.Conversation,
      Message: chatResolvers.Message,
      Activity: activityResolvers.Activity,
      // Complex types
      PropertyStats: propertyResolvers.PropertyStats,
      PropertyFinancialStats: propertyResolvers.PropertyFinancialStats,
      PropertyMarketAnalysis: propertyResolvers.PropertyMarketAnalysis,
      AIInsight: chatResolvers.AIInsight,
      SentimentAnalysis: chatResolvers.SentimentAnalysis,
      ActivityStats: activityResolvers.ActivityStats
    };
  }
});

// src/graphql/middleware/authMiddleware.ts
import { GraphQLError as GraphQLError2 } from "graphql";
var logger30, authService3, getAuthService, createGraphQLContext;
var init_authMiddleware = __esm({
  "src/graphql/middleware/authMiddleware.ts"() {
    init_authService();
    init_userService();
    init_logger();
    logger30 = createLogger2("GraphQLAuth");
    authService3 = null;
    getAuthService = () => {
      if (!authService3) {
        authService3 = new AuthService(new UserService());
      }
      return authService3;
    };
    createGraphQLContext = async ({ req, res }) => {
      const context = { req, res };
      try {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith("Bearer ")) {
          const token = authHeader.split(" ")[1];
          if (token) {
            const service = getAuthService();
            const decoded = service.validateToken(token);
            if (decoded && decoded.userId) {
              const user = await service["userService"].getUserById(decoded.userId);
              if (user && user.isActive) {
                context.user = {
                  userId: user._id?.toString(),
                  email: user.email,
                  username: user.username,
                  firstName: user.firstName,
                  lastName: user.lastName,
                  role: user.role,
                  isActive: user.isActive
                };
                logger30.info("GraphQL Authentication successful", {
                  userId: user._id?.toString(),
                  email: user.email?.substring(0, 5) + "***"
                });
              }
            }
          }
        }
      } catch (error2) {
        logger30.error("GraphQL Authentication error", {
          error: error2 instanceof Error ? error2.message : "Unknown error"
        });
      }
      return context;
    };
  }
});

// src/graphql/server.ts
var server_exports = {};
__export(server_exports, {
  apolloServer: () => apolloServer,
  createApolloServer: () => createApolloServer,
  initializeGraphQLServer: () => initializeGraphQLServer
});
import { ApolloServer } from "@apollo/server";
import { ApolloServerPluginDrainHttpServer } from "@apollo/server/plugin/drainHttpServer";
import cors2 from "cors";
import { json } from "body-parser";
import { DateTimeResolver, JSONResolver } from "graphql-scalars";
var logger31, createApolloServer, apolloServer, initializeGraphQLServer;
var init_server = __esm({
  "src/graphql/server.ts"() {
    init_esm5();
    init_types3();
    init_resolvers();
    init_authMiddleware();
    init_logger();
    logger31 = createLogger2("GraphQLServer");
    createApolloServer = (httpServer) => {
      try {
        logger31.info("Creating GraphQL schema...");
        const scalarResolvers2 = {
          DateTime: DateTimeResolver,
          JSON: JSONResolver
        };
        logger31.info("Merging resolvers...");
        const schema = makeExecutableSchema({
          typeDefs,
          resolvers: {
            ...resolvers,
            ...scalarResolvers2
          }
        });
        logger31.info("Schema created successfully");
        return new ApolloServer({
          schema,
          // Gestion des erreurs
          formatError: (formattedError, error2) => {
            logger31.error("GraphQL Error", {
              message: formattedError.message,
              path: formattedError.path,
              locations: formattedError.locations,
              extensions: formattedError.extensions
            });
            if (process.env.NODE_ENV === "production") {
              if (formattedError.message.includes("Database") || formattedError.message.includes("Internal")) {
                return {
                  message: "Internal server error",
                  locations: formattedError.locations,
                  path: formattedError.path
                };
              }
            }
            return {
              message: formattedError.message,
              locations: formattedError.locations,
              path: formattedError.path,
              extensions: {
                code: formattedError.extensions?.code,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              }
            };
          },
          // Configuration introspection
          introspection: process.env.NODE_ENV !== "production",
          //Plugins pour le monitoring et la performance
          plugins: [
            ApolloServerPluginDrainHttpServer({ httpServer }),
            {
              async requestDidStart() {
                return {
                  async didResolveOperation(requestContext) {
                    logger31.info("GraphQL Operation", {
                      operationName: requestContext.request.operationName,
                      query: requestContext.request.query?.substring(0, 200) + "..."
                    });
                  },
                  async didEncounterErrors(requestContext) {
                    logger31.error("GraphQL Request Errors", {
                      operationName: requestContext.request.operationName,
                      errors: requestContext.errors?.map((err) => err.message)
                    });
                  },
                  async willSendResponse(requestContext) {
                    logger31.info("GraphQL Response", {
                      operationName: requestContext.request.operationName,
                      success: !requestContext.errors?.length
                    });
                  }
                };
              }
            }
          ]
        });
      } catch (error2) {
        logger31.error("Error creating Apollo Server:", {
          error: error2 instanceof Error ? error2.message : "Unknown error",
          stack: error2 instanceof Error ? error2.stack : void 0
        });
        throw error2;
      }
    };
    apolloServer = null;
    initializeGraphQLServer = async (app2, httpServer) => {
      try {
        const server2 = createApolloServer(httpServer);
        await server2.start();
        app2.use(
          "/graphql",
          cors2(),
          json(),
          async (req, res) => {
            const context = await createGraphQLContext({ req, res });
            return server2.executeHTTPGraphQLRequest({
              httpGraphQLRequest: {
                body: req.body,
                headers: req.headers,
                method: req.method,
                search: req.url.split("?")[1] || ""
              },
              context: () => context
            }).then((result) => {
              res.status(result.status || 200);
              for (const [key, value] of result.headers) {
                res.setHeader(key, value);
              }
              res.send(result.body);
            });
          }
        );
        logger31.info("GraphQL Server initialized", {
          endpoint: "/graphql",
          introspection: process.env.NODE_ENV !== "production" ? "enabled" : "disabled"
        });
        return server2;
      } catch (error2) {
        logger31.error("Failed to initialize GraphQL Server", {
          error: error2 instanceof Error ? error2.message : "Unknown error"
        });
        throw error2;
      }
    };
  }
});

// server.ts
init_config();
import http3 from "http";

// src/utils/normalize/normalizePort.ts
function normalizePort(val) {
  const port = typeof val === "string" ? parseInt(val, 10) : val;
  if (isNaN(port) || port < 0) {
    throw new Error("Port invalide");
  }
  return port;
}
var normalizePort_default = normalizePort;

// src/utils/normalize/onError.ts
init_logger();
var onError = (error2) => {
  if (error2.syscall !== "listen") {
    throw error2;
  }
  const bind2 = typeof normalizePort_default === "string" ? `Pipe ${normalizePort_default}` : `Port ${normalizePort_default}`;
  switch (error2.code) {
    case "EACCES":
      logger_default.error(`${bind2} n\xE9cessite des privil\xE8ges \xE9lev\xE9s`);
      process.exit(1);
      break;
    case "EADDRINUSE":
      logger_default.error(`${bind2} est d\xE9j\xE0 utilis\xE9`);
      process.exit(1);
      break;
    default:
      throw error2;
  }
};
var onError_default = onError;

// server.ts
init_logger();

// src/utils/socket/webSocket.ts
init_presenceType();
init_logger();
init_config();
init_redisInstance();
import { Server as SocketIOServer } from "socket.io";
import jwt from "jsonwebtoken";
var logger3 = createLogger2("PresenceWebSocket");
var PresenceWebSocketHandler = class {
  /**
   * Crée une nouvelle instance du gestionnaire WebSocket
   */
  constructor(server2, options = {}) {
    __publicField(this, "io");
    // private presenceService: UserPresenceService |AppCacheAndPresenceService
    __publicField(this, "connectedUsers", /* @__PURE__ */ new Map());
    // userId -> Map<socketId, info>
    __publicField(this, "socketToUser", /* @__PURE__ */ new Map());
    // socketId -> userId
    __publicField(this, "startTime", /* @__PURE__ */ new Date());
    // Rate limiting
    __publicField(this, "userRateLimit", /* @__PURE__ */ new Map());
    // Options de configuration
    __publicField(this, "options");
    // Intervalle de nettoyage
    __publicField(this, "cleanupInterval");
    __publicField(this, "pingCheckInterval");
    this.options = {
      pingInterval: options.pingInterval || 25e3,
      // 25 secondes
      pingTimeout: options.pingTimeout || 3e4,
      // 30 secondes
      maxConnections: options.maxConnections || 1e4,
      rateLimitPerMinute: options.rateLimitPerMinute || 100
    };
    this.io = new SocketIOServer(server2, {
      cors: {
        origin: config_default.cors?.origin || "*",
        methods: config_default.cors?.methods || ["GET", "POST"],
        credentials: true
      },
      pingInterval: this.options.pingInterval,
      pingTimeout: this.options.pingTimeout,
      maxHttpBufferSize: 1e6,
      // 1MB
      allowEIO3: true,
      transports: ["websocket", "polling"],
      upgradeTimeout: 3e4,
      connectionStateRecovery: {
        maxDisconnectionDuration: 2 * 60 * 1e3,
        // 2 minutes
        skipMiddlewares: true
      }
    });
    this.setupSocketHandlers();
    this.startMaintenanceTasks();
    logger3.info("WebSocket server for presence tracking initialized", {
      maxConnections: this.options.maxConnections,
      pingInterval: this.options.pingInterval,
      rateLimitPerMinute: this.options.rateLimitPerMinute
    });
  }
  /**
   * Configure les gestionnaires d'événements pour les sockets
   */
  setupSocketHandlers() {
    this.io.use(async (socket, next) => {
      try {
        const clientIp = socket.handshake.address;
        if (this.isRateLimited(clientIp)) {
          logger3.warn("Rate limit exceeded for WebSocket connection", { ip: clientIp });
          return next(new Error("Rate limit exceeded"));
        }
        if (this.io.engine.clientsCount >= this.options.maxConnections) {
          logger3.warn("Maximum connections reached", {
            current: this.io.engine.clientsCount,
            max: this.options.maxConnections
          });
          return next(new Error("Server at capacity"));
        }
        const token = this.extractToken(socket);
        if (!token) {
          logger3.warn("WebSocket connection attempt without token", {
            ip: clientIp,
            userAgent: socket.handshake.headers["user-agent"]
          });
          return next(new Error("Authentication required"));
        }
        const userData = await this.verifyToken(token);
        if (!userData) {
          logger3.warn("Invalid token provided for WebSocket connection", { ip: clientIp });
          return next(new Error("Invalid authentication"));
        }
        socket.data.user = userData;
        socket.data.connectedAt = /* @__PURE__ */ new Date();
        socket.data.ip = clientIp;
        next();
      } catch (error2) {
        logger3.error("WebSocket authentication error", {
          error: error2 instanceof Error ? error2.message : "Unknown error",
          socketId: socket.id,
          ip: socket.handshake.address
        });
        next(new Error("Authentication failed"));
      }
    });
    this.io.on("connection", (socket) => {
      this.handleSocketConnection(socket);
    });
    this.io.engine.on("connection_error", (err) => {
      logger3.error("Socket.IO connection error", { error: err.message });
    });
  }
  /**
   * Extrait le token d'authentification des headers
   */
  extractToken(socket) {
    const authHeader = socket.handshake.headers.authorization;
    const authQuery = socket.handshake.auth.token;
    const authCookie = socket.handshake.headers.cookie;
    if (authQuery) return authQuery;
    if (authHeader?.startsWith("Bearer ")) return authHeader.split(" ")[1];
    if (authCookie) {
      const match = authCookie.match(/token=([^;]+)/);
      if (match) return match[1];
    }
    return null;
  }
  /**
   * Vérifie et décode le token JWT
   */
  async verifyToken(token) {
    try {
      if (!config_default.auth?.jwtSecret) {
        logger3.error("JWT secret not configured");
        return null;
      }
      const decoded = jwt.verify(token, config_default.auth.jwtSecret);
      if (!decoded?.userId || !decoded?.email) {
        logger3.warn("Invalid token structure");
        return null;
      }
      return {
        userId: decoded.userId,
        email: decoded.email,
        role: decoded.role || "user",
        sessionId: decoded.sessionId,
        deviceId: decoded.deviceId
      };
    } catch (error2) {
      logger3.warn("Token verification failed", {
        error: error2 instanceof Error ? error2.message : "Unknown error"
      });
      return null;
    }
  }
  /**
   * Vérifie si une IP est rate limitée
   */
  isRateLimited(ip) {
    const now = Date.now();
    const windowStart = now - 6e4;
    const limitInfo = this.userRateLimit.get(ip);
    if (!limitInfo || limitInfo.resetTime < windowStart) {
      this.userRateLimit.set(ip, { count: 1, resetTime: now });
      return false;
    }
    if (limitInfo.count >= this.options.rateLimitPerMinute) {
      return true;
    }
    limitInfo.count++;
    return false;
  }
  /**
   * Gère une nouvelle connexion socket avec robustesse
   */
  handleSocketConnection(socket) {
    try {
      const userData = socket.data.user;
      const { userId } = userData;
      const connectionInfo = {
        socketId: socket.id,
        connectedAt: socket.data.connectedAt,
        lastPing: /* @__PURE__ */ new Date(),
        deviceId: userData.deviceId || socket.handshake.headers["x-device-id"],
        userAgent: socket.handshake.headers["user-agent"],
        ip: socket.data.ip
      };
      logger3.info("User connected via WebSocket", {
        userId,
        socketId: socket.id,
        deviceId: connectionInfo.deviceId,
        totalConnections: this.io.engine.clientsCount
      });
      this.addUserConnection(userId, connectionInfo);
      this.updateUserPresenceStatus(userId, socket, "online" /* ONLINE */);
      this.setupSocketEvents(socket, userData);
      this.sendInitialData(socket, userId);
    } catch (error2) {
      logger3.error("Error handling socket connection", {
        error: error2 instanceof Error ? error2.message : "Unknown error",
        socketId: socket.id
      });
      socket.disconnect(true);
    }
  }
  /**
   * Configure tous les événements d'un socket
   */
  setupSocketEvents(socket, userData) {
    const { userId } = userData;
    socket.on("status:change", async (data) => {
      try {
        if (!Object.values(PresenceStatus).includes(data.status)) {
          socket.emit("error", { message: "Invalid status" });
          return;
        }
        await this.updateUserPresenceStatus(userId, socket, data.status);
        logger3.info("User changed status", { userId, newStatus: data.status });
        socket.emit("status:changed", { status: data.status, timestamp: /* @__PURE__ */ new Date() });
      } catch (error2) {
        logger3.error("Error changing user status", { userId, error: error2 });
        socket.emit("error", { message: "Failed to change status" });
      }
    });
    socket.on("presence:ping", async () => {
      try {
        this.updateConnectionPing(userId, socket.id);
        await this.updateUserPresenceStatus(userId, socket, "online" /* ONLINE */);
        socket.emit("presence:pong", { timestamp: /* @__PURE__ */ new Date() });
      } catch (error2) {
        logger3.error("Error handling ping", { userId, socketId: socket.id, error: error2 });
      }
    });
    socket.on("users:request", async () => {
      try {
        await this.sendOnlineUsersList(socket);
      } catch (error2) {
        logger3.error("Error sending users list", { userId, error: error2 });
      }
    });
    socket.on("room:join", (data) => {
      if (this.isValidRoomId(data.roomId)) {
        socket.join(data.roomId);
        logger3.info("User joined room", { userId, roomId: data.roomId });
      }
    });
    socket.on("room:leave", (data) => {
      socket.leave(data.roomId);
      logger3.info("User left room", { userId, roomId: data.roomId });
    });
    socket.on("disconnect", async (reason) => {
      await this.handleSocketDisconnection(socket, userData, reason);
    });
    socket.on("error", (error2) => {
      logger3.error("Socket error", { userId, socketId: socket.id, error: error2 });
    });
    socket.join("presence-updates");
  }
  /**
   * Valide un ID de room
   */
  isValidRoomId(roomId) {
    return /^[a-zA-Z0-9_-]+$/.test(roomId) && roomId.length <= 50;
  }
  /**
   * Ajoute une connexion utilisateur
   */
  addUserConnection(userId, connectionInfo) {
    if (!this.connectedUsers.has(userId)) {
      this.connectedUsers.set(userId, /* @__PURE__ */ new Map());
    }
    this.connectedUsers.get(userId).set(connectionInfo.socketId, connectionInfo);
    this.socketToUser.set(connectionInfo.socketId, userId);
  }
  /**
   * Met à jour le ping d'une connexion
   */
  updateConnectionPing(userId, socketId) {
    const userConnections = this.connectedUsers.get(userId);
    const connection = userConnections?.get(socketId);
    if (connection) {
      connection.lastPing = /* @__PURE__ */ new Date();
    }
  }
  /**
   * Met à jour le statut de présence d'un utilisateur
   */
  async updateUserPresenceStatus(userId, socket, status) {
    try {
      const connectionInfo = this.connectedUsers.get(userId)?.get(socket.id);
      await redisInstance_default.updatePresence(userId, status, {
        deviceId: connectionInfo?.deviceId,
        userAgent: connectionInfo?.userAgent,
        ip: connectionInfo?.ip || socket.handshake.address
      });
      this.broadcastUserStatus(userId, status, socket.id);
    } catch (error2) {
      logger3.error("Error updating user presence", { userId, status, error: error2 });
    }
  }
  /**
   * Diffuse le changement de statut (exclut l'expéditeur)
   */
  broadcastUserStatus(userId, status, excludeSocketId) {
    const eventData = {
      userId,
      status,
      timestamp: /* @__PURE__ */ new Date(),
      connectionCount: this.connectedUsers.get(userId)?.size || 0
    };
    if (excludeSocketId) {
      this.io.to("presence-updates").except(excludeSocketId).emit("user:status", eventData);
    } else {
      this.io.to("presence-updates").emit("user:status", eventData);
    }
  }
  /**
   * Envoie les données initiales à un socket
   */
  async sendInitialData(socket, userId) {
    try {
      await this.sendOnlineUsersList(socket);
      socket.emit("connection:info", {
        connectedAt: /* @__PURE__ */ new Date(),
        serverMetrics: this.getConnectionMetrics()
      });
    } catch (error2) {
      logger3.error("Error sending initial data", { userId, error: error2 });
    }
  }
  /**
   * Envoie la liste des utilisateurs en ligne
   */
  async sendOnlineUsersList(socket) {
    try {
      const onlineUsers = await redisInstance_default.getOnlineUsers();
      const usersList = Array.from(onlineUsers.values()).map((user) => ({
        userId: user.userId,
        status: user.status,
        lastActive: user.lastActive,
        connectionCount: this.connectedUsers.get(user.userId)?.size || 0
      }));
      socket.emit("online:users", {
        users: usersList,
        totalCount: usersList.length,
        timestamp: /* @__PURE__ */ new Date()
      });
    } catch (error2) {
      logger3.error("Error sending online users list", {
        error: error2 instanceof Error ? error2.message : "Unknown error",
        socketId: socket.id
      });
    }
  }
  /**
   * Gère la déconnexion d'un socket
   */
  async handleSocketDisconnection(socket, userData, reason) {
    const { userId } = userData;
    logger3.info("User disconnected from WebSocket", {
      userId,
      socketId: socket.id,
      reason,
      duration: Date.now() - socket.data.connectedAt?.getTime()
    });
    try {
      const userConnections = this.connectedUsers.get(userId);
      if (userConnections) {
        userConnections.delete(socket.id);
        if (userConnections.size === 0) {
          this.connectedUsers.delete(userId);
          await redisInstance_default.setUserOffline(userId);
          this.broadcastUserStatus(userId, "offline" /* OFFLINE */);
        }
      }
      this.socketToUser.delete(socket.id);
    } catch (error2) {
      logger3.error("Error handling socket disconnection", { userId, socketId: socket.id, error: error2 });
    }
  }
  /**
   * Démarre les tâches de maintenance
   */
  startMaintenanceTasks() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupInactiveConnections();
      this.cleanupRateLimit();
    }, 6e4);
    this.pingCheckInterval = setInterval(() => {
      this.checkStaleConnections();
    }, 3e4);
  }
  /**
   * Nettoie les connexions inactives
   */
  cleanupInactiveConnections() {
    const now = /* @__PURE__ */ new Date();
    const timeout = this.options.pingTimeout;
    let cleanedCount = 0;
    for (const [userId, connections] of this.connectedUsers.entries()) {
      const socketsToRemove = [];
      for (const [socketId, connection] of connections.entries()) {
        if (now.getTime() - connection.lastPing.getTime() > timeout) {
          socketsToRemove.push(socketId);
        }
      }
      socketsToRemove.forEach((socketId) => {
        connections.delete(socketId);
        this.socketToUser.delete(socketId);
        cleanedCount++;
      });
      if (connections.size === 0) {
        this.connectedUsers.delete(userId);
      }
    }
    if (cleanedCount > 0) {
      logger3.info("Cleaned up inactive connections", { count: cleanedCount });
    }
  }
  /**
   * Vérifie les connexions obsolètes
   */
  checkStaleConnections() {
    const now = /* @__PURE__ */ new Date();
    const staleThreshold = 6e4;
    for (const [userId, connections] of this.connectedUsers.entries()) {
      for (const [socketId, connection] of connections.entries()) {
        if (now.getTime() - connection.lastPing.getTime() > staleThreshold) {
          const socket = this.io.sockets.sockets.get(socketId);
          if (socket) {
            socket.emit("ping");
          } else {
            connections.delete(socketId);
            this.socketToUser.delete(socketId);
          }
        }
      }
    }
  }
  /**
   * Nettoie les données de rate limiting
   */
  cleanupRateLimit() {
    const now = Date.now();
    const windowStart = now - 6e4;
    for (const [ip, limitInfo] of this.userRateLimit.entries()) {
      if (limitInfo.resetTime < windowStart) {
        this.userRateLimit.delete(ip);
      }
    }
  }
  /**
   * Obtient les métriques de connexion
   */
  getConnectionMetrics() {
    const totalConnections = this.io.engine.clientsCount;
    const uniqueUsers = this.connectedUsers.size;
    const averageConnectionsPerUser = uniqueUsers > 0 ? totalConnections / uniqueUsers : 0;
    const uptimeSeconds = Math.floor((Date.now() - this.startTime.getTime()) / 1e3);
    return {
      totalConnections,
      uniqueUsers,
      averageConnectionsPerUser: Math.round(averageConnectionsPerUser * 100) / 100,
      uptimeSeconds
    };
  }
  /**
   * Force la déconnexion d'un utilisateur (API publique)
   */
  async disconnectUser(userId, reason = "forced_disconnect") {
    try {
      const userConnections = this.connectedUsers.get(userId);
      if (!userConnections || userConnections.size === 0) {
        return false;
      }
      const disconnectPromises = Array.from(userConnections.keys()).map((socketId) => {
        const socket = this.io.sockets.sockets.get(socketId);
        if (socket) {
          socket.emit("force:disconnect", { reason });
          socket.disconnect(true);
        }
      });
      await Promise.all(disconnectPromises);
      this.connectedUsers.delete(userId);
      await redisInstance_default.setUserOffline(userId);
      this.broadcastUserStatus(userId, "offline" /* OFFLINE */);
      logger3.info("User forcibly disconnected", { userId, reason });
      return true;
    } catch (error2) {
      logger3.error("Error force disconnecting user", { userId, error: error2 });
      return false;
    }
  }
  /**
   * Envoie une notification à un utilisateur spécifique
   */
  sendToUser(userId, eventName, data) {
    try {
      const userConnections = this.connectedUsers.get(userId);
      if (!userConnections || userConnections.size === 0) {
        return false;
      }
      let sentCount = 0;
      userConnections.forEach((_, socketId) => {
        const socket = this.io.sockets.sockets.get(socketId);
        if (socket) {
          socket.emit(eventName, { ...data, timestamp: /* @__PURE__ */ new Date() });
          sentCount++;
        }
      });
      logger3.debug("Message sent to user", { userId, eventName, socketCount: sentCount });
      return sentCount > 0;
    } catch (error2) {
      logger3.error("Error sending message to user", { userId, eventName, error: error2 });
      return false;
    }
  }
  /**
   * Diffuse un message à tous les utilisateurs connectés
   */
  broadcast(eventName, data, excludeUserId) {
    try {
      const eventData = { ...data, timestamp: /* @__PURE__ */ new Date() };
      if (excludeUserId) {
        const excludeConnections = this.connectedUsers.get(excludeUserId);
        const excludeSocketIds = excludeConnections ? Array.from(excludeConnections.keys()) : [];
        this.io.except(excludeSocketIds).emit(eventName, eventData);
      } else {
        this.io.emit(eventName, eventData);
      }
    } catch (error2) {
      logger3.error("Error broadcasting message", { eventName, error: error2 });
    }
  }
  /**
   * Obtient les utilisateurs connectés
   */
  getConnectedUsers() {
    return Array.from(this.connectedUsers.keys());
  }
  /**
   * Vérifie si un utilisateur est connecté
   */
  isUserConnected(userId) {
    return this.connectedUsers.has(userId) && this.connectedUsers.get(userId).size > 0;
  }
  /**
   * Ferme proprement le serveur WebSocket
   */
  async shutdown() {
    logger3.info("Shutting down WebSocket server");
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    if (this.pingCheckInterval) {
      clearInterval(this.pingCheckInterval);
    }
    this.io.emit("server:shutdown", { message: "Server is shutting down" });
    await new Promise((resolve) => {
      this.io.close(() => {
        logger3.info("WebSocket server shut down successfully");
        resolve();
      });
    });
  }
};

// src/app.ts
import express3 from "express";
import mongoose20 from "mongoose";
import morgan from "morgan";
import helmet from "helmet";
import cors from "cors";
import compression from "compression";

// node_modules/express-rate-limit/dist/index.mjs
import { Buffer as Buffer2 } from "buffer";
import { createHash } from "crypto";
import { isIP } from "net";
var SUPPORTED_DRAFT_VERSIONS = ["draft-6", "draft-7", "draft-8"];
var getResetSeconds = (resetTime, windowMs) => {
  let resetSeconds = void 0;
  if (resetTime) {
    const deltaSeconds = Math.ceil((resetTime.getTime() - Date.now()) / 1e3);
    resetSeconds = Math.max(0, deltaSeconds);
  } else if (windowMs) {
    resetSeconds = Math.ceil(windowMs / 1e3);
  }
  return resetSeconds;
};
var getPartitionKey = (key) => {
  const hash = createHash("sha256");
  hash.update(key);
  const partitionKey = hash.digest("hex").slice(0, 12);
  return Buffer2.from(partitionKey).toString("base64");
};
var setLegacyHeaders = (response, info) => {
  if (response.headersSent)
    return;
  response.setHeader("X-RateLimit-Limit", info.limit.toString());
  response.setHeader("X-RateLimit-Remaining", info.remaining.toString());
  if (info.resetTime instanceof Date) {
    response.setHeader("Date", (/* @__PURE__ */ new Date()).toUTCString());
    response.setHeader(
      "X-RateLimit-Reset",
      Math.ceil(info.resetTime.getTime() / 1e3).toString()
    );
  }
};
var setDraft6Headers = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1e3);
  const resetSeconds = getResetSeconds(info.resetTime);
  response.setHeader("RateLimit-Policy", `${info.limit};w=${windowSeconds}`);
  response.setHeader("RateLimit-Limit", info.limit.toString());
  response.setHeader("RateLimit-Remaining", info.remaining.toString());
  if (resetSeconds)
    response.setHeader("RateLimit-Reset", resetSeconds.toString());
};
var setDraft7Headers = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1e3);
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  response.setHeader("RateLimit-Policy", `${info.limit};w=${windowSeconds}`);
  response.setHeader(
    "RateLimit",
    `limit=${info.limit}, remaining=${info.remaining}, reset=${resetSeconds}`
  );
};
var setDraft8Headers = (response, info, windowMs, name, key) => {
  if (response.headersSent)
    return;
  const windowSeconds = Math.ceil(windowMs / 1e3);
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  const partitionKey = getPartitionKey(key);
  const policy = `q=${info.limit}; w=${windowSeconds}; pk=:${partitionKey}:`;
  const header = `r=${info.remaining}; t=${resetSeconds}`;
  response.append("RateLimit-Policy", `"${name}"; ${policy}`);
  response.append("RateLimit", `"${name}"; ${header}`);
};
var setRetryAfterHeader = (response, info, windowMs) => {
  if (response.headersSent)
    return;
  const resetSeconds = getResetSeconds(info.resetTime, windowMs);
  response.setHeader("Retry-After", resetSeconds.toString());
};
var ValidationError = class extends Error {
  /**
   * The code must be a string, in snake case and all capital, that starts with
   * the substring `ERR_ERL_`.
   *
   * The message must be a string, starting with an uppercase character,
   * describing the issue in detail.
   */
  constructor(code, message) {
    const url2 = `https://express-rate-limit.github.io/${code}/`;
    super(`${message} See ${url2} for more information.`);
    this.name = this.constructor.name;
    this.code = code;
    this.help = url2;
  }
};
var ChangeWarning = class extends ValidationError {
};
var usedStores = /* @__PURE__ */ new Set();
var singleCountKeys = /* @__PURE__ */ new WeakMap();
var validations = {
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
  enabled: {
    default: true
  },
  // Should be EnabledValidations type, but that's a circular reference
  disable() {
    for (const k of Object.keys(this.enabled))
      this.enabled[k] = false;
  },
  /**
   * Checks whether the IP address is valid, and that it does not have a port
   * number in it.
   *
   * See https://github.com/express-rate-limit/express-rate-limit/wiki/Error-Codes#err_erl_invalid_ip_address.
   *
   * @param ip {string | undefined} - The IP address provided by Express as request.ip.
   *
   * @returns {void}
   */
  ip(ip) {
    if (ip === void 0) {
      throw new ValidationError(
        "ERR_ERL_UNDEFINED_IP_ADDRESS",
        `An undefined 'request.ip' was detected. This might indicate a misconfiguration or the connection being destroyed prematurely.`
      );
    }
    if (!isIP(ip)) {
      throw new ValidationError(
        "ERR_ERL_INVALID_IP_ADDRESS",
        `An invalid 'request.ip' (${ip}) was detected. Consider passing a custom 'keyGenerator' function to the rate limiter.`
      );
    }
  },
  /**
   * Makes sure the trust proxy setting is not set to `true`.
   *
   * See https://github.com/express-rate-limit/express-rate-limit/wiki/Error-Codes#err_erl_permissive_trust_proxy.
   *
   * @param request {Request} - The Express request object.
   *
   * @returns {void}
   */
  trustProxy(request) {
    if (request.app.get("trust proxy") === true) {
      throw new ValidationError(
        "ERR_ERL_PERMISSIVE_TRUST_PROXY",
        `The Express 'trust proxy' setting is true, which allows anyone to trivially bypass IP-based rate limiting.`
      );
    }
  },
  /**
   * Makes sure the trust proxy setting is set in case the `X-Forwarded-For`
   * header is present.
   *
   * See https://github.com/express-rate-limit/express-rate-limit/wiki/Error-Codes#err_erl_unset_trust_proxy.
   *
   * @param request {Request} - The Express request object.
   *
   * @returns {void}
   */
  xForwardedForHeader(request) {
    if (request.headers["x-forwarded-for"] && request.app.get("trust proxy") === false) {
      throw new ValidationError(
        "ERR_ERL_UNEXPECTED_X_FORWARDED_FOR",
        `The 'X-Forwarded-For' header is set but the Express 'trust proxy' setting is false (default). This could indicate a misconfiguration which would prevent express-rate-limit from accurately identifying users.`
      );
    }
  },
  /**
   * Ensures totalHits value from store is a positive integer.
   *
   * @param hits {any} - The `totalHits` returned by the store.
   */
  positiveHits(hits) {
    if (typeof hits !== "number" || hits < 1 || hits !== Math.round(hits)) {
      throw new ValidationError(
        "ERR_ERL_INVALID_HITS",
        `The totalHits value returned from the store must be a positive integer, got ${hits}`
      );
    }
  },
  /**
   * Ensures a single store instance is not used with multiple express-rate-limit instances
   */
  unsharedStore(store) {
    if (usedStores.has(store)) {
      const maybeUniquePrefix = store?.localKeys ? "" : " (with a unique prefix)";
      throw new ValidationError(
        "ERR_ERL_STORE_REUSE",
        `A Store instance must not be shared across multiple rate limiters. Create a new instance of ${store.constructor.name}${maybeUniquePrefix} for each limiter instead.`
      );
    }
    usedStores.add(store);
  },
  /**
   * Ensures a given key is incremented only once per request.
   *
   * @param request {Request} - The Express request object.
   * @param store {Store} - The store class.
   * @param key {string} - The key used to store the client's hit count.
   *
   * @returns {void}
   */
  singleCount(request, store, key) {
    let storeKeys = singleCountKeys.get(request);
    if (!storeKeys) {
      storeKeys = /* @__PURE__ */ new Map();
      singleCountKeys.set(request, storeKeys);
    }
    const storeKey = store.localKeys ? store : store.constructor.name;
    let keys = storeKeys.get(storeKey);
    if (!keys) {
      keys = [];
      storeKeys.set(storeKey, keys);
    }
    const prefixedKey = `${store.prefix ?? ""}${key}`;
    if (keys.includes(prefixedKey)) {
      throw new ValidationError(
        "ERR_ERL_DOUBLE_COUNT",
        `The hit count for ${key} was incremented more than once for a single request.`
      );
    }
    keys.push(prefixedKey);
  },
  /**
   * Warns the user that the behaviour for `max: 0` / `limit: 0` is
   * changing in the next major release.
   *
   * @param limit {number} - The maximum number of hits per client.
   *
   * @returns {void}
   */
  limit(limit) {
    if (limit === 0) {
      throw new ChangeWarning(
        "WRN_ERL_MAX_ZERO",
        `Setting limit or max to 0 disables rate limiting in express-rate-limit v6 and older, but will cause all requests to be blocked in v7`
      );
    }
  },
  /**
   * Warns the user that the `draft_polli_ratelimit_headers` option is deprecated
   * and will be removed in the next major release.
   *
   * @param draft_polli_ratelimit_headers {any | undefined} - The now-deprecated setting that was used to enable standard headers.
   *
   * @returns {void}
   */
  draftPolliHeaders(draft_polli_ratelimit_headers) {
    if (draft_polli_ratelimit_headers) {
      throw new ChangeWarning(
        "WRN_ERL_DEPRECATED_DRAFT_POLLI_HEADERS",
        `The draft_polli_ratelimit_headers configuration option is deprecated and has been removed in express-rate-limit v7, please set standardHeaders: 'draft-6' instead.`
      );
    }
  },
  /**
   * Warns the user that the `onLimitReached` option is deprecated and
   * will be removed in the next major release.
   *
   * @param onLimitReached {any | undefined} - The maximum number of hits per client.
   *
   * @returns {void}
   */
  onLimitReached(onLimitReached) {
    if (onLimitReached) {
      throw new ChangeWarning(
        "WRN_ERL_DEPRECATED_ON_LIMIT_REACHED",
        `The onLimitReached configuration option is deprecated and has been removed in express-rate-limit v7.`
      );
    }
  },
  /**
   * Warns the user when an invalid/unsupported version of the draft spec is passed.
   *
   * @param version {any | undefined} - The version passed by the user.
   *
   * @returns {void}
   */
  headersDraftVersion(version) {
    if (typeof version !== "string" || !SUPPORTED_DRAFT_VERSIONS.includes(version)) {
      const versionString = SUPPORTED_DRAFT_VERSIONS.join(", ");
      throw new ValidationError(
        "ERR_ERL_HEADERS_UNSUPPORTED_DRAFT_VERSION",
        `standardHeaders: only the following versions of the IETF draft specification are supported: ${versionString}.`
      );
    }
  },
  /**
   * Warns the user when the selected headers option requires a reset time but
   * the store does not provide one.
   *
   * @param resetTime {Date | undefined} - The timestamp when the client's hit count will be reset.
   *
   * @returns {void}
   */
  headersResetTime(resetTime) {
    if (!resetTime) {
      throw new ValidationError(
        "ERR_ERL_HEADERS_NO_RESET",
        `standardHeaders:  'draft-7' requires a 'resetTime', but the store did not provide one. The 'windowMs' value will be used instead, which may cause clients to wait longer than necessary.`
      );
    }
  },
  /**
   * Checks the options.validate setting to ensure that only recognized
   * validations are enabled or disabled.
   *
   * If any unrecognized values are found, an error is logged that
   * includes the list of supported vaidations.
   */
  validationsConfig() {
    const supportedValidations = Object.keys(this).filter(
      (k) => !["enabled", "disable"].includes(k)
    );
    supportedValidations.push("default");
    for (const key of Object.keys(this.enabled)) {
      if (!supportedValidations.includes(key)) {
        throw new ValidationError(
          "ERR_ERL_UNKNOWN_VALIDATION",
          `options.validate.${key} is not recognized. Supported validate options are: ${supportedValidations.join(
            ", "
          )}.`
        );
      }
    }
  },
  /**
   * Checks to see if the instance was created inside of a request handler,
   * which would prevent it from working correctly, with the default memory
   * store (or any other store with localKeys.)
   */
  creationStack(store) {
    const { stack } = new Error(
      "express-rate-limit validation check (set options.validate.creationStack=false to disable)"
    );
    if (stack?.includes("Layer.handle [as handle_request]")) {
      if (!store.localKeys) {
        throw new ValidationError(
          "ERR_ERL_CREATED_IN_REQUEST_HANDLER",
          "express-rate-limit instance should *usually* be created at app initialization, not when responding to a request."
        );
      }
      throw new ValidationError(
        "ERR_ERL_CREATED_IN_REQUEST_HANDLER",
        `express-rate-limit instance should be created at app initialization, not when responding to a request.`
      );
    }
  }
};
var getValidations = (_enabled) => {
  let enabled;
  if (typeof _enabled === "boolean") {
    enabled = {
      default: _enabled
    };
  } else {
    enabled = {
      default: true,
      ..._enabled
    };
  }
  const wrappedValidations = {
    enabled
  };
  for (const [name, validation] of Object.entries(validations)) {
    if (typeof validation === "function")
      wrappedValidations[name] = (...args) => {
        if (!(enabled[name] ?? enabled.default)) {
          return;
        }
        try {
          ;
          validation.apply(
            wrappedValidations,
            args
          );
        } catch (error2) {
          if (error2 instanceof ChangeWarning)
            console.warn(error2);
          else
            console.error(error2);
        }
      };
  }
  return wrappedValidations;
};
var MemoryStore = class {
  constructor() {
    this.previous = /* @__PURE__ */ new Map();
    this.current = /* @__PURE__ */ new Map();
    this.localKeys = true;
  }
  /**
   * Method that initializes the store.
   *
   * @param options {Options} - The options used to setup the middleware.
   */
  init(options) {
    this.windowMs = options.windowMs;
    if (this.interval)
      clearInterval(this.interval);
    this.interval = setInterval(() => {
      this.clearExpired();
    }, this.windowMs);
    if (this.interval.unref)
      this.interval.unref();
  }
  /**
   * Method to fetch a client's hit count and reset time.
   *
   * @param key {string} - The identifier for a client.
   *
   * @returns {ClientRateLimitInfo | undefined} - The number of hits and reset time for that client.
   *
   * @public
   */
  async get(key) {
    return this.current.get(key) ?? this.previous.get(key);
  }
  /**
   * Method to increment a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @returns {ClientRateLimitInfo} - The number of hits and reset time for that client.
   *
   * @public
   */
  async increment(key) {
    const client = this.getClient(key);
    const now = Date.now();
    if (client.resetTime.getTime() <= now) {
      this.resetClient(client, now);
    }
    client.totalHits++;
    return client;
  }
  /**
   * Method to decrement a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @public
   */
  async decrement(key) {
    const client = this.getClient(key);
    if (client.totalHits > 0)
      client.totalHits--;
  }
  /**
   * Method to reset a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @public
   */
  async resetKey(key) {
    this.current.delete(key);
    this.previous.delete(key);
  }
  /**
   * Method to reset everyone's hit counter.
   *
   * @public
   */
  async resetAll() {
    this.current.clear();
    this.previous.clear();
  }
  /**
   * Method to stop the timer (if currently running) and prevent any memory
   * leaks.
   *
   * @public
   */
  shutdown() {
    clearInterval(this.interval);
    void this.resetAll();
  }
  /**
   * Recycles a client by setting its hit count to zero, and reset time to
   * `windowMs` milliseconds from now.
   *
   * NOT to be confused with `#resetKey()`, which removes a client from both the
   * `current` and `previous` maps.
   *
   * @param client {Client} - The client to recycle.
   * @param now {number} - The current time, to which the `windowMs` is added to get the `resetTime` for the client.
   *
   * @return {Client} - The modified client that was passed in, to allow for chaining.
   */
  resetClient(client, now = Date.now()) {
    client.totalHits = 0;
    client.resetTime.setTime(now + this.windowMs);
    return client;
  }
  /**
   * Retrieves or creates a client, given a key. Also ensures that the client being
   * returned is in the `current` map.
   *
   * @param key {string} - The key under which the client is (or is to be) stored.
   *
   * @returns {Client} - The requested client.
   */
  getClient(key) {
    if (this.current.has(key))
      return this.current.get(key);
    let client;
    if (this.previous.has(key)) {
      client = this.previous.get(key);
      this.previous.delete(key);
    } else {
      client = { totalHits: 0, resetTime: /* @__PURE__ */ new Date() };
      this.resetClient(client);
    }
    this.current.set(key, client);
    return client;
  }
  /**
   * Move current clients to previous, create a new map for current.
   *
   * This function is called every `windowMs`.
   */
  clearExpired() {
    this.previous = this.current;
    this.current = /* @__PURE__ */ new Map();
  }
};
var isLegacyStore = (store) => (
  // Check that `incr` exists but `increment` does not - store authors might want
  // to keep both around for backwards compatibility.
  typeof store.incr === "function" && typeof store.increment !== "function"
);
var promisifyStore = (passedStore) => {
  if (!isLegacyStore(passedStore)) {
    return passedStore;
  }
  const legacyStore = passedStore;
  class PromisifiedStore {
    async increment(key) {
      return new Promise((resolve, reject) => {
        legacyStore.incr(
          key,
          (error2, totalHits, resetTime) => {
            if (error2)
              reject(error2);
            resolve({ totalHits, resetTime });
          }
        );
      });
    }
    async decrement(key) {
      return legacyStore.decrement(key);
    }
    async resetKey(key) {
      return legacyStore.resetKey(key);
    }
    /* istanbul ignore next */
    async resetAll() {
      if (typeof legacyStore.resetAll === "function")
        return legacyStore.resetAll();
    }
  }
  return new PromisifiedStore();
};
var getOptionsFromConfig = (config3) => {
  const { validations: validations22, ...directlyPassableEntries } = config3;
  return {
    ...directlyPassableEntries,
    validate: validations22.enabled
  };
};
var omitUndefinedOptions = (passedOptions) => {
  const omittedOptions = {};
  for (const k of Object.keys(passedOptions)) {
    const key = k;
    if (passedOptions[key] !== void 0) {
      omittedOptions[key] = passedOptions[key];
    }
  }
  return omittedOptions;
};
var parseOptions = (passedOptions) => {
  const notUndefinedOptions = omitUndefinedOptions(passedOptions);
  const validations22 = getValidations(notUndefinedOptions?.validate ?? true);
  validations22.validationsConfig();
  validations22.draftPolliHeaders(
    // @ts-expect-error see the note above.
    notUndefinedOptions.draft_polli_ratelimit_headers
  );
  validations22.onLimitReached(notUndefinedOptions.onLimitReached);
  let standardHeaders = notUndefinedOptions.standardHeaders ?? false;
  if (standardHeaders === true)
    standardHeaders = "draft-6";
  const config3 = {
    windowMs: 60 * 1e3,
    limit: passedOptions.max ?? 5,
    // `max` is deprecated, but support it anyways.
    message: "Too many requests, please try again later.",
    statusCode: 429,
    legacyHeaders: passedOptions.headers ?? true,
    identifier(request, _response) {
      let duration = "";
      const property2 = config3.requestPropertyName;
      const { limit } = request[property2];
      const seconds = config3.windowMs / 1e3;
      const minutes = config3.windowMs / (1e3 * 60);
      const hours = config3.windowMs / (1e3 * 60 * 60);
      const days = config3.windowMs / (1e3 * 60 * 60 * 24);
      if (seconds < 60)
        duration = `${seconds}sec`;
      else if (minutes < 60)
        duration = `${minutes}min`;
      else if (hours < 24)
        duration = `${hours}hr${hours > 1 ? "s" : ""}`;
      else
        duration = `${days}day${days > 1 ? "s" : ""}`;
      return `${limit}-in-${duration}`;
    },
    requestPropertyName: "rateLimit",
    skipFailedRequests: false,
    skipSuccessfulRequests: false,
    requestWasSuccessful: (_request, response) => response.statusCode < 400,
    skip: (_request, _response) => false,
    keyGenerator(request, _response) {
      validations22.ip(request.ip);
      validations22.trustProxy(request);
      validations22.xForwardedForHeader(request);
      return request.ip;
    },
    async handler(request, response, _next, _optionsUsed) {
      response.status(config3.statusCode);
      const message = typeof config3.message === "function" ? await config3.message(
        request,
        response
      ) : config3.message;
      if (!response.writableEnded) {
        response.send(message);
      }
    },
    passOnStoreError: false,
    // Allow the default options to be overriden by the passed options.
    ...notUndefinedOptions,
    // `standardHeaders` is resolved into a draft version above, use that.
    standardHeaders,
    // Note that this field is declared after the user's options are spread in,
    // so that this field doesn't get overriden with an un-promisified store!
    store: promisifyStore(notUndefinedOptions.store ?? new MemoryStore()),
    // Print an error to the console if a few known misconfigurations are detected.
    validations: validations22
  };
  if (typeof config3.store.increment !== "function" || typeof config3.store.decrement !== "function" || typeof config3.store.resetKey !== "function" || config3.store.resetAll !== void 0 && typeof config3.store.resetAll !== "function" || config3.store.init !== void 0 && typeof config3.store.init !== "function") {
    throw new TypeError(
      "An invalid store was passed. Please ensure that the store is a class that implements the `Store` interface."
    );
  }
  return config3;
};
var handleAsyncErrors = (fn) => async (request, response, next) => {
  try {
    await Promise.resolve(fn(request, response, next)).catch(next);
  } catch (error2) {
    next(error2);
  }
};
var rateLimit = (passedOptions) => {
  const config3 = parseOptions(passedOptions ?? {});
  const options = getOptionsFromConfig(config3);
  config3.validations.creationStack(config3.store);
  config3.validations.unsharedStore(config3.store);
  if (typeof config3.store.init === "function")
    config3.store.init(options);
  const middleware = handleAsyncErrors(
    async (request, response, next) => {
      const skip = await config3.skip(request, response);
      if (skip) {
        next();
        return;
      }
      const augmentedRequest = request;
      const key = await config3.keyGenerator(request, response);
      let totalHits = 0;
      let resetTime;
      try {
        const incrementResult = await config3.store.increment(key);
        totalHits = incrementResult.totalHits;
        resetTime = incrementResult.resetTime;
      } catch (error2) {
        if (config3.passOnStoreError) {
          console.error(
            "express-rate-limit: error from store, allowing request without rate-limiting.",
            error2
          );
          next();
          return;
        }
        throw error2;
      }
      config3.validations.positiveHits(totalHits);
      config3.validations.singleCount(request, config3.store, key);
      const retrieveLimit = typeof config3.limit === "function" ? config3.limit(request, response) : config3.limit;
      const limit = await retrieveLimit;
      config3.validations.limit(limit);
      const info = {
        limit,
        used: totalHits,
        remaining: Math.max(limit - totalHits, 0),
        resetTime
      };
      Object.defineProperty(info, "current", {
        configurable: false,
        enumerable: false,
        value: totalHits
      });
      augmentedRequest[config3.requestPropertyName] = info;
      if (config3.legacyHeaders && !response.headersSent) {
        setLegacyHeaders(response, info);
      }
      if (config3.standardHeaders && !response.headersSent) {
        switch (config3.standardHeaders) {
          case "draft-6": {
            setDraft6Headers(response, info, config3.windowMs);
            break;
          }
          case "draft-7": {
            config3.validations.headersResetTime(info.resetTime);
            setDraft7Headers(response, info, config3.windowMs);
            break;
          }
          case "draft-8": {
            const retrieveName = typeof config3.identifier === "function" ? config3.identifier(request, response) : config3.identifier;
            const name = await retrieveName;
            config3.validations.headersResetTime(info.resetTime);
            setDraft8Headers(response, info, config3.windowMs, name, key);
            break;
          }
          default: {
            config3.validations.headersDraftVersion(config3.standardHeaders);
            break;
          }
        }
      }
      if (config3.skipFailedRequests || config3.skipSuccessfulRequests) {
        let decremented = false;
        const decrementKey = async () => {
          if (!decremented) {
            await config3.store.decrement(key);
            decremented = true;
          }
        };
        if (config3.skipFailedRequests) {
          response.on("finish", async () => {
            if (!await config3.requestWasSuccessful(request, response))
              await decrementKey();
          });
          response.on("close", async () => {
            if (!response.writableEnded)
              await decrementKey();
          });
          response.on("error", async () => {
            await decrementKey();
          });
        }
        if (config3.skipSuccessfulRequests) {
          response.on("finish", async () => {
            if (await config3.requestWasSuccessful(request, response))
              await decrementKey();
          });
        }
      }
      config3.validations.disable();
      if (totalHits > limit) {
        if (config3.legacyHeaders || config3.standardHeaders) {
          setRetryAfterHeader(response, info, config3.windowMs);
        }
        config3.handler(request, response, next, options);
        return;
      }
      next();
    }
  );
  const getThrowFn = () => {
    throw new Error("The current store does not support the get/getKey method");
  };
  middleware.resetKey = config3.store.resetKey.bind(config3.store);
  middleware.getKey = typeof config3.store.get === "function" ? config3.store.get.bind(config3.store) : getThrowFn;
  return middleware;
};
var lib_default = rateLimit;

// src/app.ts
init_config();
import path3 from "path";

// src/auth/routers/authrouters.ts
import express from "express";

// src/auth/middlewares/authenticate.ts
init_logger();
init_authService();
init_userService();
var logger10 = createLogger2("AuthMiddleware");
var authService = new AuthService(new UserService());
var authenticate = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    logger10.debug("Authorization header debug", {
      hasAuthHeader: !!authHeader,
      authHeaderLength: authHeader?.length,
      authHeaderStart: authHeader?.substring(0, 20),
      ip: req.ip,
      path: req.path
    });
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      logger10.warn("Missing or invalid authorization header", {
        authHeader: authHeader || "undefined",
        ip: req.ip,
        path: req.path
      });
      res.status(401).json({
        success: false,
        message: "Acc\xE8s non autoris\xE9 : token manquant"
      });
      return;
    }
    const token = authHeader.split(" ")[1];
    logger10.debug("Token extraction debug", {
      tokenLength: token?.length,
      tokenStart: token?.substring(0, 20),
      tokenEnd: token?.substring(token.length - 20),
      isValidJWTFormat: token?.split(".").length === 3
    });
    if (!token) {
      logger10.warn("Token extraction failed", {
        authHeader: authHeader.substring(0, 50) + "...",
        ip: req.ip
      });
      res.status(401).json({
        success: false,
        message: "Acc\xE8s non autoris\xE9 : token invalide"
      });
      return;
    }
    const tokenParts = token.split(".");
    if (tokenParts.length !== 3) {
      logger10.warn("Invalid JWT format", {
        tokenParts: tokenParts.length,
        token: token.substring(0, 50) + "...",
        ip: req.ip
      });
      res.status(401).json({
        success: false,
        message: "Acc\xE8s non autoris\xE9 : format de token invalide"
      });
      return;
    }
    const decoded = authService.validateToken(token);
    if (!decoded || !decoded.userId) {
      logger10.warn("Token validation failed", {
        hasDecoded: !!decoded,
        hasUserId: decoded?.userId,
        decodedData: decoded ? Object.keys(decoded) : "null",
        ip: req.ip
      });
      res.status(401).json({
        success: false,
        message: "Acc\xE8s non autoris\xE9 : token invalide"
      });
      return;
    }
    logger10.debug("Token decoded successfully", {
      userId: decoded.userId,
      tokenExp: decoded.exp,
      tokenIat: decoded.iat,
      currentTime: Math.floor(Date.now() / 1e3)
    });
    const user = await authService["userService"].getUserById(decoded.userId);
    if (!user) {
      logger10.warn("User not found", {
        userId: decoded.userId,
        ip: req.ip
      });
      res.status(403).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
      return;
    }
    if (!user.isActive) {
      logger10.warn("Inactive user attempted access", {
        userId: user._id?.toString(),
        email: user.email?.substring(0, 5) + "***",
        ip: req.ip
      });
      res.status(403).json({
        success: false,
        message: "Utilisateur inactif"
      });
      return;
    }
    req.user = {
      userId: user._id?.toString(),
      // Convert MongoDB ObjectId to string
      email: user.email,
      // Add other properties you need in controllers
      username: user.username,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      isActive: user.isActive
    };
    logger10.info("Authentication successful", {
      userId: user._id?.toString(),
      email: user.email?.substring(0, 5) + "***",
      path: req.path
    });
    next();
  } catch (error2) {
    logger10.error("Erreur d'authentification", {
      error: error2 instanceof Error ? error2.message : "Erreur inconnue",
      stack: error2 instanceof Error ? error2.stack : void 0,
      ip: req.ip,
      path: req.path
    });
    res.status(401).json({
      success: false,
      message: "Acc\xE8s non autoris\xE9"
    });
    return;
  }
};
var authenticate_default = authenticate;

// src/auth/middlewares/validate.ts
import { body, param, validationResult } from "express-validator";
import { query } from "express-validator";
var PASSWORD_MIN_LENGTH = 8;
var PASSWORD_MAX_LENGTH = 128;
var USERNAME_MIN_LENGTH = 3;
var USERNAME_MAX_LENGTH = 30;
var TOKEN_REGEX = /^[a-zA-Z0-9_-]+$/;
var TWO_FA_CODE_REGEX = /^\d{6}$/;
var handleValidationErrors = (req, res, next) => {
  const errors2 = validationResult(req);
  if (!errors2.isEmpty()) {
    res.status(400).json({
      success: false,
      message: "Erreurs de validation",
      errors: errors2.array().map((error2) => ({
        field: error2.type === "field" ? error2.path : void 0,
        message: error2.msg
      }))
    });
    return;
  }
  next();
};
var validate = {
  email: () => body("email").trim().toLowerCase().isEmail().withMessage("Format d'email invalide").isLength({ max: 320 }).withMessage("Email trop long"),
  password: (isRequired = true) => {
    let validator2 = body("password");
    if (isRequired) {
      validator2 = validator2.notEmpty().withMessage("Le mot de passe est requis");
    }
    return validator2.isLength({ min: PASSWORD_MIN_LENGTH, max: PASSWORD_MAX_LENGTH }).withMessage(`Le mot de passe doit contenir entre ${PASSWORD_MIN_LENGTH} et ${PASSWORD_MAX_LENGTH} caract\xE8res`).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])/).withMessage("Le mot de passe doit contenir au moins une minuscule, une majuscule, un chiffre et un caract\xE8re sp\xE9cial");
  },
  username: () => body("username").trim().toLowerCase().isLength({ min: USERNAME_MIN_LENGTH, max: USERNAME_MAX_LENGTH }).withMessage(`Le nom d'utilisateur doit contenir entre ${USERNAME_MIN_LENGTH} et ${USERNAME_MAX_LENGTH} caract\xE8res`).matches(/^[a-zA-Z0-9_.-]+$/).withMessage("Le nom d'utilisateur ne peut contenir que des lettres, chiffres, tirets et points"),
  firstName: () => body("firstName").trim().notEmpty().withMessage("Le pr\xE9nom est requis").isLength({ min: 2, max: 50 }).withMessage("Le pr\xE9nom doit contenir entre 2 et 50 caract\xE8res").matches(/^[a-zA-ZÀ-ÿ\s\-']+$/).withMessage("Le pr\xE9nom contient des caract\xE8res invalides"),
  lastName: () => body("lastName").trim().notEmpty().withMessage("Le nom est requis").isLength({ min: 2, max: 50 }).withMessage("Le nom doit contenir entre 2 et 50 caract\xE8res").matches(/^[a-zA-ZÀ-ÿ\s\-']+$/).withMessage("Le nom contient des caract\xE8res invalides"),
  phoneNumber: () => body("phoneNumber").optional().trim().isMobilePhone("any").withMessage("Num\xE9ro de t\xE9l\xE9phone invalide"),
  token: (paramName = "token") => param(paramName).notEmpty().withMessage("Token manquant").matches(TOKEN_REGEX).withMessage("Format de token invalide").isLength({ min: 16, max: 256 }).withMessage("Token invalide"),
  twoFactorCode: () => body("code").trim().matches(TWO_FA_CODE_REGEX).withMessage("Le code 2FA doit contenir exactement 6 chiffres"),
  refreshToken: () => body("refreshToken").notEmpty().withMessage("Token de rafra\xEEchissement requis").isJWT().withMessage("Format de token invalide"),
  sessionId: () => param("id").isMongoId().withMessage("ID de session invalide"),
  // Ajout d'un validateur pour la photo de profil
  profilePicture: () => body("profilePicture").notEmpty().withMessage("Photo de profil requise").isString().withMessage("La photo doit \xEAtre une cha\xEEne de caract\xE8res").custom((value) => {
    const urlRegex = /^https?:\/\/.+/;
    const base64Regex = /^data:image\/(jpeg|jpg|png|gif);base64,/;
    if (!urlRegex.test(value) && !base64Regex.test(value)) {
      throw new Error("La photo doit \xEAtre une URL valide ou une image en base64");
    }
    return true;
  }),
  tokenFromQuery: () => query("token").notEmpty().withMessage("Token manquant").matches(TOKEN_REGEX).withMessage("Format de token invalide").isLength({ min: 16, max: 256 }).withMessage("Token invalide"),
  forgotPasswordValidation: () => body("email").trim().toLowerCase().isEmail().withMessage("Format d'email invalide").isLength({ max: 320 }).withMessage("Email trop long")
};
var validationRules = {
  // Inscription
  register: [
    validate.username(),
    validate.email(),
    validate.password(),
    validate.firstName(),
    validate.lastName(),
    validate.phoneNumber(),
    handleValidationErrors
  ],
  // Connexion
  login: [
    validate.email(),
    validate.password(),
    handleValidationErrors
  ],
  // Mise à jour de photo de profil
  updateProfilePicture: [
    validate.profilePicture(),
    handleValidationErrors
  ],
  // Vérification email
  verifyEmail: [
    validate.tokenFromQuery(),
    handleValidationErrors
  ],
  // Code 2FA
  twoFactor: [
    validate.twoFactorCode(),
    handleValidationErrors
  ],
  // Refresh token
  refreshToken: [
    validate.refreshToken(),
    handleValidationErrors
  ],
  password: [
    validate.password(),
    handleValidationErrors
  ],
  resetPassword: [
    validate.token(),
    validate.password(),
    handleValidationErrors
  ],
  verifyTwoFactor: [
    validate.twoFactorCode(),
    validate.token()
  ],
  forgotpassword: [
    validate.forgotPasswordValidation(),
    handleValidationErrors
  ]
};
var validate_default = validationRules;

// src/auth/middlewares/sensitiveRequestLogger.ts
init_logger();
var logger11 = createLogger2("AuthMiddleware");
var sensitiveRequestLogger = (req, res, next) => {
  const sensitiveFields = ["password", "token", "secret", "credit_card", "cardNumber"];
  const safeBody = { ...req.body };
  sensitiveFields.forEach((field) => {
    if (field in safeBody) {
      safeBody[field] = "********";
    }
  });
  logger11.info("Requ\xEAte sensible re\xE7ue", {
    requestId: req.requestId,
    method: req.method,
    path: req.originalUrl,
    body: safeBody,
    userId: req.user?.userId
  });
  next();
};
var sensitiveRequestLogger_default = sensitiveRequestLogger;

// src/auth/controllers/authControllers.ts
init_authService();
init_userService();
init_notificationServices();
init_securityAuditServices();
init_AppError();
init_logger();
import mongoose2 from "mongoose";
var logger12 = createLogger2("AuthController");
var AuthControllers = class {
  constructor() {
    __publicField(this, "authService");
    __publicField(this, "userService");
    __publicField(this, "notificationService");
    __publicField(this, "securityAuditService");
    this.authService = new AuthService();
    this.userService = new UserService();
    this.notificationService = new NotificationService();
    this.securityAuditService = new SecurityAuditService();
    logger12.info("AuthController initialis\xE9 avec succ\xE8s");
  }
  // Méthode utilitaire pour extraire l'userId
  extractUserId(user) {
    if (user.user) {
      return user.user.id || user.user._id;
    }
    return user.userId || user.id || user._id;
  }
  /**
   * Upload profile picture during registration
   */
  async uploadProfilePicture(req, res, next) {
    try {
      const { profilePicture } = req.body;
      if (!profilePicture) {
        res.status(400).json({
          success: false,
          message: "Photo de profil requise"
        });
        return;
      }
      if (typeof profilePicture !== "string" || profilePicture.trim() === "") {
        res.status(400).json({
          success: false,
          message: "Format de photo de profil invalide"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Photo de profil valid\xE9e avec succ\xE8s",
        data: { profilePicture }
      });
    } catch (error2) {
      logger12.error("Erreur lors de l'upload de la photo de profil", {
        error: error2.message
      });
      next(error2);
    }
  }
  /**
   * Inscription d'un nouvel utilisateur
   */
  async register(req, res, next) {
    const startTime = Date.now();
    logger12.info("D\xE9but de la tentative d'inscription", {
      ip: req.ip,
      userAgent: req.headers["user-agent"],
      email: req.body.email?.substring(0, 5) + "***"
    });
    try {
      const { firstName, lastName, username, email, password, phoneNumber, dateOfBirth, address, profilePicture, ...userData } = req.body;
      if (!email || !password || !username) {
        logger12.warn("Tentative d'inscription avec donn\xE9es manquantes", {
          hasEmail: !!email,
          hasPassword: !!password,
          hasUsername: !!username,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: "Email, mot de passe et nom d'utilisateur sont requis"
        });
        return;
      }
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        res.status(400).json({
          success: false,
          message: "Format d'email invalide"
        });
        return;
      }
      if (password.length < 8) {
        res.status(400).json({
          success: false,
          message: "Le mot de passe doit contenir au moins 8 caract\xE8res"
        });
        return;
      }
      const [existingUserByEmail, existingUserByUsername] = await Promise.all([
        this.userService.getUserByEmail(email),
        this.userService.getUserByUsername(username)
      ]);
      if (existingUserByEmail) {
        logger12.warn("Tentative d'inscription avec email d\xE9j\xE0 utilis\xE9", {
          email: email.substring(0, 5) + "***",
          ip: req.ip
        });
        res.status(409).json({
          success: false,
          message: "Cet email est d\xE9j\xE0 utilis\xE9"
        });
        return;
      }
      if (existingUserByUsername) {
        logger12.warn("Tentative d'inscription avec nom d'utilisateur d\xE9j\xE0 utilis\xE9", {
          username: username.substring(0, 3) + "***",
          ip: req.ip
        });
        res.status(409).json({
          success: false,
          message: "Ce nom d'utilisateur est d\xE9j\xE0 utilis\xE9"
        });
        return;
      }
      console.log(password, firstName);
      const user = await this.userService.createUser({
        firstName,
        lastName,
        username,
        email,
        password,
        phoneNumber,
        dateOfBirth,
        address,
        profilePicture,
        ...userData
      }, false);
      if (!user || !user.id && !user._id) {
        logger12.error("\xC9chec de la cr\xE9ation de l'utilisateur - utilisateur null ou sans ID", {
          email: email.substring(0, 5) + "***",
          username: username.substring(0, 3) + "***"
        });
        throw new AppError("\xC9chec de la cr\xE9ation de l'utilisateur", 500);
      }
      const userId = user._id || user.id;
      logger12.info("the  user  id  is  ", userId);
      const verificationToken = await this.authService.generateVerificationToken(userId.toString());
      if (verificationToken) {
        logger12.info("\u{1F4E8} token generate :", {
          email: user.email.substring(0, 5) + "***",
          firstName: user.firstName,
          token: verificationToken.substring(0, 10) + "...",
          tokenLength: verificationToken.length
        });
      } else {
        logger12.warn("verification code  has  not  been   generated");
      }
      const emailSent = await this.notificationService.sendVerificationEmail(
        user.email,
        user.firstName || "",
        verificationToken
      );
      if (emailSent) {
        logger12.info("email  has  successfully sent");
      } else {
        logger12.warn("email  has not  been sent ");
      }
      try {
        await this.securityAuditService.logEvent({
          eventType: "USER_REGISTERED",
          userId: userId.toString(),
          ipAddress: req.ip || "unknown",
          userAgent: req.headers["user-agent"] || "unknown",
          details: {
            email: email.substring(0, 5) + "***",
            username: username.substring(0, 3) + "***",
            emailSent
          }
        });
      } catch (auditError) {
        logger12.warn("Erreur lors de la journalisation d'inscription", {
          error: auditError instanceof Error ? auditError.message : "Erreur inconnue",
          userId: userId.toString()
        });
      }
      const executionTime = Date.now() - startTime;
      logger12.info("Nouvel utilisateur inscrit avec succ\xE8s", {
        userId: userId.toString(),
        email: email.substring(0, 5) + "***",
        username: username.substring(0, 3) + "***",
        executionTime: `${executionTime}ms`,
        verificationTokenGenerated: !!verificationToken,
        emailSent,
        token: verificationToken
      });
      res.status(201).json({
        success: true,
        message: "Inscription r\xE9ussie. Un code de v\xE9rification a \xE9t\xE9 envoy\xE9 \xE0 votre email",
        data: {
          userId: userId.toString(),
          email: user.email,
          username: user.username,
          requiresEmailVerification: true,
          emailSent
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de l'inscription", {
        error: error2.message,
        stack: error2.stack,
        email: req.body.email?.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Connexion d'un utilisateur
   */
  async login(req, res, next) {
    const startTime = Date.now();
    const { email, password, rememberMe, deviceInfo } = req.body;
    logger12.info("Tentative de connexion", {
      email: email?.substring(0, 5) + "***",
      ip: req.ip,
      userAgent: req.headers["user-agent"]?.substring(0, 50) + "...",
      hasPassword: !!password
    });
    console.log(password, email);
    try {
      if (!email || !password) {
        logger12.warn("Tentative de connexion avec des donn\xE9es manquantes", {
          hasEmail: !!email,
          hasPassword: !!password,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: "Email et mot de passe requis"
        });
        return;
      }
      const tokens = await this.authService.authenticate(email, password, req, {
        rememberMe,
        deviceInfo
      });
      if (!tokens) {
        const executionTime2 = Date.now() - startTime;
        logger12.warn("\xC9chec de connexion - identifiants invalides", {
          email: email.substring(0, 5) + "***",
          ip: req.ip,
          executionTime: `${executionTime2}ms`
        });
        res.status(401).json({
          success: false,
          message: "Email ou mot de passe incorrect"
        });
        return;
      }
      const user = await this.userService.getUserByEmailWithRefreshTokens(email);
      if (!user) {
        throw new Error("Utilisateur non trouv\xE9 apr\xE8s authentification");
      }
      if (!user.isEmailVerified) {
        res.status(403).json({
          success: false,
          requiresEmailVerification: true,
          message: "Veuillez v\xE9rifier votre email avant de vous connecter"
        });
        return;
      }
      if (user.preferences?.twoFactorEnabled) {
        logger12.info("Connexion r\xE9ussie - 2FA requis", {
          userId: user._id?.toString(),
          email: email.substring(0, 5) + "***"
        });
        res.status(200).json({
          success: true,
          message: "Authentification r\xE9ussie, validation 2FA requise",
          requireTwoFactor: true,
          temporaryToken: tokens.accessToken
        });
        return;
      }
      logger12.info("\xC9tat des refresh tokens apr\xE8s authentification", {
        userId: user._id?.toString(),
        refreshTokensCount: user.refreshTokens?.length || 0,
        hasTokensInResponse: !!tokens.refreshToken
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Connexion r\xE9ussie", {
        userId: user._id?.toString(),
        email: email.substring(0, 5) + "***",
        rememberMe,
        executionTime: `${executionTime}ms`,
        refreshTokensInDB: user.refreshTokens?.length || 0
      });
      this.notificationService.sendWelcomeEmail(email, user.firstName);
      res.status(200).json({
        success: true,
        message: "Connexion r\xE9ussie",
        requireTwoFactor: user.preferences?.twoFactorEnabled || false,
        data: {
          ...tokens,
          user: {
            id: user._id,
            email: user.email,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName,
            role: user.role,
            profilePicture: user.profilePicture
          }
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la connexion", {
        error: error2 instanceof Error ? error2.message : "Erreur inconnue",
        email: email?.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Vérification avec code à 6 chiffres
   */
  async verifyEmailCode(req, res, next) {
    const startTime = Date.now();
    try {
      const { email, code } = req.body;
      if (!email || !code) {
        logger12.warn("Tentative de v\xE9rification sans email ou code", {
          hasEmail: !!email,
          hasCode: !!code,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: "Email et code de v\xE9rification requis"
        });
        return;
      }
      if (!/^\d{6}$/.test(code)) {
        res.status(400).json({
          success: false,
          message: "Le code doit contenir exactement 6 chiffres"
        });
        return;
      }
      logger12.info("Tentative de v\xE9rification avec code", {
        email: email.substring(0, 5) + "***",
        code: code.substring(0, 3) + "***",
        ip: req.ip
      });
      const result = await this.userService.verifyUserWithCode(email, code);
      if (!result.success) {
        logger12.warn("\xC9chec de v\xE9rification avec code", {
          reason: result.message,
          email: email.substring(0, 5) + "***",
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: result.message || "Code invalide ou expir\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "EMAIL_VERIFIED",
        userId: result.userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { verificationMethod: "email_code" }
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Email v\xE9rifi\xE9 avec succ\xE8s via code", {
        userId: result.userId,
        email: email.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Email v\xE9rifi\xE9 avec succ\xE8s",
        data: {
          userId: result.userId,
          isVerified: true
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la v\xE9rification avec code", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Vérification de compte utilisateur (ancienne méthode avec token)
   */
  async verifyAccount(req, res, next) {
    const startTime = Date.now();
    try {
      const token = req.query.token;
      if (!token) {
        logger12.warn("Tentative de v\xE9rification de compte sans token", { ip: req.ip });
        res.status(400).json({
          success: false,
          message: "Token de v\xE9rification manquant dans la requ\xEAte"
        });
        return;
      }
      logger12.info("Tentative de v\xE9rification de compte", {
        tokenLength: token.length,
        ip: req.ip
      });
      const tokenData = await this.authService.validateVerificationToken(token);
      if (!tokenData) {
        logger12.warn("\xC9chec de v\xE9rification de compte", {
          reason: "Token invalide ou expir\xE9",
          ip: req.ip
        });
        res.status(404).json({
          success: false,
          message: "Token invalide ou expir\xE9"
        });
        return;
      }
      const updateResult = await this.userService.verifyUser(token);
      if (!updateResult.success) {
        logger12.error("Erreur lors de la mise \xE0 jour du statut de v\xE9rification", {
          userId: tokenData.userId,
          error: updateResult.message
        });
        res.status(500).json({
          success: false,
          message: "Erreur lors de la v\xE9rification du compte"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "ACCOUNT_VERIFIED",
        userId: updateResult.userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { verificationMethod: "email_token" }
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Compte v\xE9rifi\xE9 avec succ\xE8s", {
        userId: updateResult.userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Compte v\xE9rifi\xE9 avec succ\xE8s",
        data: {
          userId: updateResult.userId,
          isVerified: true
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la v\xE9rification de compte", {
        error: error2.message,
        stack: error2.stack,
        token: req.query.token ? "pr\xE9sent" : "absent",
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Déconnexion d'un utilisateur
   */
  async logout(req, res, next) {
    const startTime = Date.now();
    try {
      const { userId } = req.user;
      const { allDevices } = req.body;
      logger12.info("Tentative de d\xE9connexion", {
        userId,
        allDevices: !!allDevices,
        ip: req.ip
      });
      await this.authService.logout(userId);
      await this.securityAuditService.logEvent({
        eventType: allDevices ? "USER_LOGOUT_ALL_DEVICES" : "USER_LOGOUT",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { allDevices }
      });
      const executionTime = Date.now() - startTime;
      logger12.info("D\xE9connexion r\xE9ussie", {
        userId,
        allDevices: !!allDevices,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: allDevices ? "D\xE9connexion de tous les appareils r\xE9ussie" : "D\xE9connexion r\xE9ussie"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la d\xE9connexion", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Rafraîchir le token d'accès
   */
  async refreshToken(req, res, next) {
    const startTime = Date.now();
    try {
      const { refreshToken } = req.body;
      if (!refreshToken) {
        logger12.warn("Tentative de rafra\xEEchissement sans token", { ip: req.ip });
        res.status(400).json({
          success: false,
          message: "Token de rafra\xEEchissement requis"
        });
        return;
      }
      logger12.info("Tentative de rafra\xEEchissement de token", {
        tokenLength: refreshToken.length,
        ip: req.ip
      });
      const newTokens = await this.authService.refreshAccessToken(refreshToken);
      if (!newTokens) {
        logger12.warn("\xC9chec du rafra\xEEchissement - token invalide", { ip: req.ip });
        res.status(401).json({
          success: false,
          message: "Token de rafra\xEEchissement invalide ou expir\xE9"
        });
        return;
      }
      const executionTime = Date.now() - startTime;
      logger12.info("Token rafra\xEEchi avec succ\xE8s", {
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      res.status(200).json({
        success: true,
        message: "Token rafra\xEEchi avec succ\xE8s",
        data: newTokens
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors du rafra\xEEchissement du token", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Demande de réinitialisation de mot de passe
   */
  async forgotPassword(req, res, next) {
    const startTime = Date.now();
    try {
      const { email, redirectUrl } = req.body;
      if (!email) {
        logger12.warn("Demande de r\xE9initialisation sans email", { ip: req.ip });
        res.status(400).json({
          success: false,
          message: "Email requis"
        });
        return;
      }
      logger12.info("Demande de r\xE9initialisation de mot de passe", {
        email: email.substring(0, 5) + "***",
        ip: req.ip
      });
      const success = await this.userService.initiatePasswordReset(email, redirectUrl);
      if (success) {
        const user = await this.userService.getUserByEmail(email);
        if (user) {
          const userId = user._id || user.id;
          await this.securityAuditService.logEvent({
            eventType: "PASSWORD_RESET_REQUESTED",
            userId: userId.toString(),
            ipAddress: req.ip,
            userAgent: req.headers["user-agent"],
            details: { email: email.substring(0, 5) + "***" }
          });
        }
      }
      const executionTime = Date.now() - startTime;
      logger12.info("Demande de r\xE9initialisation trait\xE9e", {
        email: email.substring(0, 5) + "***",
        success,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Si un compte existe avec cet email, un lien de r\xE9initialisation vous sera envoy\xE9"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la demande de r\xE9initialisation", {
        error: error2.message,
        stack: error2.stack,
        email: req.body.email?.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Réinitialisation de mot de passe
   */
  async resetPassword(req, res, next) {
    const startTime = Date.now();
    try {
      const token = req.query.token;
      const { password } = req.body;
      if (!token || !password) {
        logger12.warn("Tentative de r\xE9initialisation avec donn\xE9es manquantes", {
          hasToken: !!token,
          hasPassword: !!password,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: "Token et nouveau mot de passe requis"
        });
        return;
      }
      logger12.info("Tentative de r\xE9initialisation de mot de passe", {
        tokenLength: token.length,
        ip: req.ip
      });
      const result = await this.userService.resetPassword(token, password);
      if (!result.success) {
        logger12.warn("\xC9chec de r\xE9initialisation", {
          reason: result.message,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: result.message || "Token invalide ou expir\xE9"
        });
        return;
      }
      if (!result.userId) {
        logger12.error("R\xE9initialisation r\xE9ussie mais userId manquant", { ip: req.ip });
        res.status(500).json({
          success: false,
          message: "Erreur interne : ID utilisateur manquant apr\xE8s r\xE9initialisation"
        });
        return;
      }
      const user = await this.userService.getUserById(result.userId);
      if (!user) {
        logger12.error("Utilisateur non trouv\xE9 apr\xE8s r\xE9initialisation", {
          userId: result.userId
        });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const asyncOperations = [
        this.securityAuditService.logEvent({
          eventType: "PASSWORD_RESET_COMPLETED",
          userId: result.userId,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        })
        // this.notificationService.sendPasswordChangeConfirmationEmail(user.email, user.firstName || '')
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Mot de passe r\xE9initialis\xE9 avec succ\xE8s", {
        userId: result.userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Mot de passe r\xE9initialis\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la r\xE9initialisation du mot de passe", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Vérification d'email
   */
  async verifyEmail(req, res, next) {
    const startTime = Date.now();
    try {
      const token = req.query.token;
      logger12.warn("le token de verification est donc:", { token });
      if (!token) {
        logger12.warn("Tentative de v\xE9rification sans token", { ip: req.ip });
        res.status(400).json({
          success: false,
          message: "Token de v\xE9rification requis"
        });
        return;
      }
      logger12.info("Tentative de v\xE9rification d'email", {
        tokenLength: token.length,
        ip: req.ip
      });
      const result = await this.userService.verifyUser(token);
      if (!result.success) {
        logger12.warn("\xC9chec de v\xE9rification d'email", {
          reason: result.message,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: result.message || "Token invalide ou expir\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "EMAIL_VERIFIED",
        userId: result.userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Email v\xE9rifi\xE9 avec succ\xE8s", {
        userId: result.userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Email v\xE9rifi\xE9 avec succ\xE8s",
        data: {
          userId: result.userId
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la v\xE9rification d'email", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Renvoyer l'email de vérification
   */
  async resendVerificationEmail(req, res, next) {
    const startTime = Date.now();
    try {
      const { email } = req.body;
      if (!email) {
        logger12.warn("Demande de renvoi de v\xE9rification sans email", { ip: req.ip });
        res.status(400).json({
          success: false,
          message: "Email requis"
        });
        return;
      }
      logger12.info("Demande de renvoi d'email de v\xE9rification", {
        email: email.substring(0, 5) + "***",
        ip: req.ip
      });
      const user = await this.userService.getUserByEmail(email);
      if (!user) {
        logger12.info("Demande de renvoi pour email inexistant", {
          email: email.substring(0, 5) + "***",
          ip: req.ip
        });
        res.status(200).json({
          success: true,
          message: "Si un compte existe avec cet email et n'est pas encore v\xE9rifi\xE9, un nouvel email de v\xE9rification sera envoy\xE9"
        });
        return;
      }
      if (user.emailVerified) {
        logger12.warn("Tentative de renvoi pour compte d\xE9j\xE0 v\xE9rifi\xE9", {
          userId: (user._id || user.id).toString(),
          email: email.substring(0, 5) + "***"
        });
        res.status(400).json({
          success: false,
          message: "Ce compte est d\xE9j\xE0 v\xE9rifi\xE9"
        });
        return;
      }
      const userId = user._id || user.id;
      const verificationToken = await this.authService.generateVerificationToken(userId.toString());
      const asyncOperations = [
        this.notificationService.sendVerificationEmail(
          user.email,
          user.firstName || "",
          verificationToken
        ),
        this.securityAuditService.logEvent({
          eventType: "VERIFICATION_EMAIL_RESENT",
          userId: userId.toString(),
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        })
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Email de v\xE9rification renvoy\xE9 avec succ\xE8s", {
        userId: userId.toString(),
        email: email.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Email de v\xE9rification renvoy\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors du renvoi d'email de v\xE9rification", {
        error: error2.message,
        stack: error2.stack,
        email: req.body.email?.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Changement de mot de passe
  */
  async changePassword(req, res, next) {
    const startTime = Date.now();
    try {
      const user = req.user;
      const userId = user._id || user.id || user.userId;
      const { currentPassword, password } = req.body;
      logger12.debug("User ID extraction debug:", {
        userId,
        userIdType: typeof userId,
        availableFields: Object.keys(user || {}),
        isValidObjectId: mongoose2.Types.ObjectId.isValid(userId),
        sessionId: req.sessionId
      });
      if (!userId) {
        logger12.error("No user ID found in request", { reqUser: user });
        res.status(400).json({
          success: false,
          message: "User ID manquant"
        });
        return;
      }
      if (!currentPassword || !password) {
        logger12.warn("Tentative de changement de mot de passe avec donn\xE9es manquantes", {
          userId,
          hasCurrentPassword: !!currentPassword,
          hasNewPassword: !!password
        });
        res.status(400).json({
          success: false,
          message: "Mot de passe actuel et nouveau mot de passe requis"
        });
        return;
      }
      logger12.info("Tentative de changement de mot de passe", {
        userId,
        ip: req.ip,
        sessionId: req.sessionId
      });
      const isCurrentPasswordValid = await this.userService.verifyPassword(userId, currentPassword);
      logger12.debug("le mot de passe est :", { isCurrentPasswordValid });
      if (!isCurrentPasswordValid) {
        logger12.warn("Changement de mot de passe \xE9chou\xE9 - mot de passe actuel incorrect", {
          userId
        });
        res.status(401).json({
          success: false,
          message: "Mot de passe actuel incorrect"
        });
        return;
      }
      await this.userService.changePassword(userId, currentPassword, password);
      if (req.sessionId) {
        try {
          await this.authService.invalidateOtherSessions(userId, req.sessionId);
          logger12.info("Autres sessions invalid\xE9es avec succ\xE8s", { userId, sessionId: req.sessionId });
        } catch (sessionError) {
          logger12.warn("Erreur lors de l'invalidation des sessions", {
            userId,
            sessionId: req.sessionId,
            error: sessionError.message
          });
        }
      } else {
        logger12.warn("Session ID manquant - invalidation des sessions ignor\xE9e", {
          userId
        });
      }
      const userRecord = await this.userService.getUserById(userId);
      if (!userRecord) {
        logger12.error("Utilisateur non trouv\xE9 apr\xE8s changement de mot de passe", {
          userId
        });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const asyncOperations = [
        this.securityAuditService.logEvent({
          eventType: "PASSWORD_CHANGED",
          userId,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        }),
        this.notificationService.sendSecurityNotification(
          userRecord.email,
          userRecord.firstName || "",
          "password_changed"
        )
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Mot de passe chang\xE9 avec succ\xE8s", {
        userId,
        executionTime: `${executionTime}ms`,
        sessionInvalidated: !!req.sessionId
      });
      res.status(200).json({
        success: true,
        message: "Mot de passe chang\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors du changement de mot de passe", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
     * Configuration de l'authentification à deux facteurs
  */
  async setupTwoFactor(req, res, next) {
    const startTime = Date.now();
    try {
      if (!req.user) {
        logger12.warn("Tentative de configuration 2FA sans utilisateur authentifi\xE9");
        res.status(401).json({
          success: false,
          message: "Utilisateur non authentifi\xE9"
        });
        return;
      }
      let userId;
      let userEmail;
      if (req.user.user) {
        const userObj = req.user.user;
        userId = userObj.id || userObj._id;
        userEmail = userObj.email;
      } else {
        userId = req.user.userId || req.user.id || req.user._id;
        userEmail = req.user.email;
      }
      if (!userId) {
        logger12.warn("Tentative de configuration 2FA sans userId valide", {
          userStructure: Object.keys(req.user || {}),
          nestedUserStructure: Object.keys(req.user?.user || {})
        });
        res.status(401).json({
          success: false,
          message: "Utilisateur non authentifi\xE9 - ID manquant"
        });
        return;
      }
      logger12.info("Configuration de l'authentification \xE0 deux facteurs", {
        userId,
        email: userEmail,
        ip: req.ip
      });
      const { password } = req.body;
      if (!password) {
        logger12.warn("Tentative de configuration 2FA sans mot de passe", { userId });
        res.status(400).json({
          success: false,
          message: "Mot de passe requis pour configurer l'authentification \xE0 deux facteurs"
        });
        return;
      }
      logger12.info("Configuration de l'authentification \xE0 deux facteurs", { userId, ip: req.ip });
      let isPasswordValid;
      try {
        isPasswordValid = await this.userService.verifyPassword(userId, password);
      } catch (error2) {
        logger12.error("Erreur lors de la v\xE9rification du mot de passe", {
          userId,
          error: error2.message
        });
        res.status(500).json({
          success: false,
          message: "Erreur interne lors de la v\xE9rification"
        });
        return;
      }
      if (!isPasswordValid) {
        logger12.warn("Configuration 2FA \xE9chou\xE9e - mot de passe incorrect", { userId });
        res.status(401).json({
          success: false,
          message: "Mot de passe incorrect"
        });
        return;
      }
      const twoFactorData = await this.authService.generateTwoFactorSecret(userId);
      if (!twoFactorData) {
        logger12.error("\xC9chec de la g\xE9n\xE9ration du secret 2FA", { userId });
        res.status(500).json({
          success: false,
          message: "Erreur lors de la g\xE9n\xE9ration du secret 2FA"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "TWO_FACTOR_SETUP_INITIATED",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Secret 2FA g\xE9n\xE9r\xE9 avec succ\xE8s", {
        userId,
        backupCodesCount: twoFactorData.backupCodes?.length || 0,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Configuration 2FA initi\xE9e avec succ\xE8s",
        data: {
          qrCodeData: twoFactorData.otpauthUrl,
          manualEntryKey: twoFactorData.tempTwoFactorSecret,
          backupCodes: twoFactorData.backupCodes
        },
        instructions: {
          step1: "Scannez le QR code avec votre application d'authentification",
          step2: "Ou entrez manuellement la cl\xE9 fournie",
          step3: "Sauvegardez pr\xE9cieusement vos codes de sauvegarde",
          step4: "Confirmez la configuration avec un code de votre application"
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la configuration 2FA", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  // Nouvelle méthode pour confirmer la configuration 2FA
  async confirmTwoFactorSetup(req, res, next) {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          message: "Utilisateur non authentifi\xE9"
        });
        return;
      }
      const userId = this.extractUserId(req.user);
      const { token } = req.body;
      if (!token) {
        res.status(400).json({
          success: false,
          message: "Code de v\xE9rification requis"
        });
        return;
      }
      const confirmed = await this.authService.confirmTwoFactorSetup(userId, token);
      if (!confirmed) {
        res.status(400).json({
          success: false,
          message: "Code de v\xE9rification invalide ou expir\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "TWO_FACTOR_ENABLED",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      logger12.info("2FA activ\xE9 avec succ\xE8s", { userId });
      res.status(200).json({
        success: true,
        message: "Authentification \xE0 deux facteurs activ\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      logger12.error("Erreur lors de la confirmation 2FA", {
        error: error2.message,
        userId: req.user?.userId
      });
      next(error2);
    }
  }
  // Méthode pour régénérer les codes de sauvegarde
  async regenerateBackupCodes(req, res, next) {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          message: "Utilisateur non authentifi\xE9"
        });
        return;
      }
      const userId = this.extractUserId(req.user);
      const { password } = req.body;
      if (!password) {
        res.status(400).json({
          success: false,
          message: "Mot de passe requis"
        });
        return;
      }
      const isPasswordValid = await this.userService.verifyPassword(userId, password);
      if (!isPasswordValid) {
        res.status(401).json({
          success: false,
          message: "Mot de passe incorrect"
        });
        return;
      }
      const newCodes = await this.authService.regenerateBackupCodes(userId);
      if (!newCodes) {
        res.status(500).json({
          success: false,
          message: "Erreur lors de la g\xE9n\xE9ration des nouveaux codes"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "BACKUP_CODES_REGENERATED",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      res.status(200).json({
        success: true,
        message: "Nouveaux codes de sauvegarde g\xE9n\xE9r\xE9s",
        data: { backupCodes: newCodes }
      });
    } catch (error2) {
      logger12.error("Erreur lors de la r\xE9g\xE9n\xE9ration des codes de sauvegarde", {
        error: error2.message,
        userId: req.user?.userId
      });
      next(error2);
    }
  }
  /**
   * Validation de l'authentification à deux facteurs
   */
  async verifyTwoFactor(req, res, next) {
    const startTime = Date.now();
    try {
      if (!req.user) {
        logger12.error("req.user is undefined - authentication middleware issue");
        res.status(401).json({
          success: false,
          message: "Non authentifi\xE9"
        });
        return;
      }
      logger12.info("req.user content", {
        reqUser: req.user,
        reqUserType: typeof req.user,
        reqUserKeys: req.user ? Object.keys(req.user) : "req.user is null/undefined"
      });
      const userId = req.user._id || req.user.id;
      if (!userId) {
        logger12.error("userId is undefined in req.user", { reqUser: req.user });
        res.status(401).json({
          success: false,
          message: "Utilisateur non identifi\xE9"
        });
        return;
      }
      logger12.info("Extracted userId", {
        userId,
        userIdType: typeof userId
      });
      const { token, password } = req.body;
      if (!token || !password) {
        logger12.warn("Tentative de v\xE9rification 2FA avec donn\xE9es manquantes", {
          userId,
          hasToken: !!token,
          hasPassword: !!password
        });
        res.status(400).json({
          success: false,
          message: "Code 2FA et mot de passe requis"
        });
        return;
      }
      logger12.info("V\xE9rification de l'authentification \xE0 deux facteurs", { userId, ip: req.ip });
      logger12.info("About to verify password", {
        userId,
        userIdType: typeof userId,
        userIdValue: userId
      });
      const isPasswordValid = await this.userService.verifyPassword(userId, password);
      if (!isPasswordValid) {
        logger12.warn("V\xE9rification 2FA \xE9chou\xE9e - mot de passe incorrect", { userId });
        res.status(401).json({
          success: false,
          message: "Mot de passe incorrect"
        });
        return;
      }
      const isValidToken = await this.authService.verifyTwoFactorCode(userId, token);
      logger12.debug("the return of the  validate function  is:", { isValidToken });
      if (!isValidToken) {
        logger12.warn("V\xE9rification 2FA \xE9chou\xE9e - code invalide", { userId });
        res.status(401).json({
          success: false,
          message: "Code 2FA invalide"
        });
        return;
      }
      await this.userService.enableTwoFactor(userId);
      const user = await this.userService.getUserById(userId);
      if (!user) {
        logger12.error("Utilisateur non trouv\xE9 apr\xE8s activation 2FA", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const asyncOperations = [
        this.securityAuditService.logEvent({
          eventType: "TWO_FACTOR_ENABLED",
          userId,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        }),
        this.notificationService.sendSecurityNotification(
          user.email,
          user.firstName || "",
          "two_factor_enabled"
        )
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Authentification \xE0 deux facteurs activ\xE9e avec succ\xE8s", {
        userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Authentification \xE0 deux facteurs activ\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la v\xE9rification 2FA", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Désactivation de l'authentification à deux facteurs
   */
  async disableTwoFactor(req, res, next) {
    const startTime = Date.now();
    try {
      const { userId } = req.user;
      const { password, token } = req.body;
      if (!password || !token) {
        logger12.warn("Tentative de d\xE9sactivation 2FA avec donn\xE9es manquantes", {
          userId,
          hasPassword: !!password,
          hasToken: !!token
        });
        res.status(400).json({
          success: false,
          message: "Mot de passe et code 2FA requis"
        });
        return;
      }
      logger12.info("D\xE9sactivation de l'authentification \xE0 deux facteurs", { userId, ip: req.ip });
      const isPasswordValid = await this.userService.verifyPassword(userId, password);
      if (!isPasswordValid) {
        logger12.warn("D\xE9sactivation 2FA \xE9chou\xE9e - mot de passe incorrect", { userId });
        res.status(401).json({
          success: false,
          message: "Mot de passe incorrect"
        });
        return;
      }
      const isValidToken = await this.authService.verifyTwoFactorToken(userId, token);
      if (!isValidToken) {
        logger12.warn("D\xE9sactivation 2FA \xE9chou\xE9e - code invalide", { userId });
        res.status(401).json({
          success: false,
          message: "Code 2FA invalide"
        });
        return;
      }
      await this.userService.disableTwoFactor(userId);
      const user = await this.userService.getUserById(userId);
      if (!user) {
        logger12.error("Utilisateur non trouv\xE9 apr\xE8s d\xE9sactivation 2FA", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const asyncOperations = [
        this.securityAuditService.logEvent({
          eventType: "TWO_FACTOR_DISABLED",
          userId,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        }),
        this.notificationService.sendSecurityNotification(
          user.email,
          user.firstName || "",
          "two_factor_disabled"
        )
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Authentification \xE0 deux facteurs d\xE9sactiv\xE9e avec succ\xE8s", {
        userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Authentification \xE0 deux facteurs d\xE9sactiv\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la d\xE9sactivation 2FA", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Vérification du code 2FA lors de la connexion
   */
  async validateTwoFactorLogin(req, res, next) {
    const startTime = Date.now();
    try {
      const { temporaryToken, token } = req.body;
      if (!temporaryToken || !token) {
        logger12.warn("Tentative de validation 2FA avec donn\xE9es manquantes", {
          hasTemporaryToken: !!temporaryToken,
          hasToken: !!token,
          ip: req.ip
        });
        res.status(400).json({
          success: false,
          message: "Token temporaire et code 2FA requis"
        });
        return;
      }
      logger12.info("Validation du code 2FA pour la connexion", {
        tokenLength: token.length,
        ip: req.ip
      });
      const authResult = await this.authService.validateTwoFactorLogin(temporaryToken, token);
      if (!authResult.success || !authResult.userId) {
        res.status(401).json({
          success: false,
          message: authResult.message || "Code 2FA invalide"
        });
        return;
      }
      const id = authResult.userId;
      const user = await this.userService.getUserById(id);
      if (!user) {
        logger12.error("Utilisateur non trouv\xE9 apr\xE8s validation 2FA", {
          userId: authResult.userId
        });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "TWO_FACTOR_LOGIN_SUCCESS",
        userId: authResult.userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Connexion 2FA valid\xE9e avec succ\xE8s", {
        userId: authResult.userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Connexion r\xE9ussie",
        data: {
          ...authResult.tokens,
          user: {
            id: user._id || user.id,
            email: user.email,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName
          }
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la validation 2FA", {
        error: error2.message,
        stack: error2.stack,
        executionTime: `${executionTime}ms`,
        ip: req.ip
      });
      next(error2);
    }
  }
  /**
   * Obtenir le profil de l'utilisateur connecté
   */
  async getProfile(req, res, next) {
    const startTime = Date.now();
    try {
      const userId = req.user?.userId;
      logger12.debug("userid  is  :", { userId });
      logger12.info("R\xE9cup\xE9ration du profil utilisateur", { userId });
      if (!userId) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      const user = await this.userService.getUserById(userId);
      if (!user) {
        logger12.warn("Profil non trouv\xE9", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const executionTime = Date.now() - startTime;
      logger12.info("Profil r\xE9cup\xE9r\xE9 avec succ\xE8s", {
        userId,
        executionTime: `${executionTime}ms`
      });
      const { password, ...userProfile } = user;
      res.status(200).json({
        success: true,
        message: "Profil r\xE9cup\xE9r\xE9 avec succ\xE8s",
        data: {
          user: {
            id: user._id || user.id,
            email: user.email,
            username: user.username,
            firstName: user.firstName,
            lastName: user.lastName,
            profilePicture: user.profilePicture,
            phoneNumber: user.phoneNumber,
            dateOfBirth: user.dateOfBirth,
            address: user.address,
            emailVerified: user.emailVerified,
            twoFactorEnabled: user.preferences?.twoFactorEnabled || false
          }
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la r\xE9cup\xE9ration du profil", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Mise à jour du profil utilisateur
   */
  async updateProfile(req, res, next) {
    const startTime = Date.now();
    try {
      const { userId } = req.user;
      const { firstName, lastName, phoneNumber, dateOfBirth, address } = req.body;
      logger12.info("Mise \xE0 jour du profil utilisateur", { userId, ip: req.ip });
      const updateData = {};
      if (firstName !== void 0) updateData.firstName = firstName;
      if (lastName !== void 0) updateData.lastName = lastName;
      if (phoneNumber !== void 0) updateData.phoneNumber = phoneNumber;
      if (dateOfBirth !== void 0) updateData.dateOfBirth = dateOfBirth;
      if (address !== void 0) updateData.address = address;
      if (Object.keys(updateData).length === 0) {
        logger12.warn("Tentative de mise \xE0 jour sans donn\xE9es", { userId });
        res.status(400).json({
          success: false,
          message: "Aucune donn\xE9e \xE0 mettre \xE0 jour"
        });
        return;
      }
      const updatedUser = await this.userService.updateUser(userId, updateData);
      if (!updatedUser) {
        logger12.error("\xC9chec de la mise \xE0 jour du profil", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "PROFILE_UPDATED",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { updatedFields: Object.keys(updateData) }
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Profil mis \xE0 jour avec succ\xE8s", {
        userId,
        updatedFields: Object.keys(updateData),
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Profil mis \xE0 jour avec succ\xE8s",
        data: {
          user: {
            id: updatedUser._id || updatedUser.id,
            email: updatedUser.email,
            username: updatedUser.username,
            firstName: updatedUser.firstName,
            lastName: updatedUser.lastName,
            profilePicture: updatedUser.profilePicture,
            phoneNumber: updatedUser.phoneNumber,
            dateOfBirth: updatedUser.dateOfBirth,
            address: updatedUser.address,
            emailVerified: updatedUser.emailVerified,
            twoFactorEnabled: updatedUser.preferences?.twoFactorEnabled || false
          }
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la mise \xE0 jour du profil", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  async updateProfilePicture(req, res, next) {
    const startTime = Date.now();
    try {
      const { userId } = req.user;
      const { profilePicture } = req.body;
      logger12.info("Mise \xE0 jour de la photo de profil utilisateur", { userId, ip: req.ip });
      if (!profilePicture) {
        logger12.warn("Tentative de mise \xE0 jour sans photo de profil", { userId });
        res.status(400).json({
          success: false,
          message: "Photo de profil requise"
        });
        return;
      }
      if (typeof profilePicture !== "string" || profilePicture.trim() === "") {
        res.status(400).json({
          success: false,
          message: "Format de photo de profil invalide"
        });
        return;
      }
      const updateData = { profilePicture };
      const updatedUser = await this.userService.updateUser(userId, updateData);
      if (!updatedUser) {
        logger12.error("\xC9chec de la mise \xE0 jour de la photo de profil", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      await this.securityAuditService.logEvent({
        eventType: "PROFILE_PICTURE_UPDATED",
        userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { updatedFields: ["profilePicture"] }
      });
      const executionTime = Date.now() - startTime;
      logger12.info("Photo de profil mise \xE0 jour avec succ\xE8s", {
        userId,
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Photo de profil mise \xE0 jour avec succ\xE8s",
        data: {
          user: {
            id: updatedUser._id || updatedUser.id,
            email: updatedUser.email,
            username: updatedUser.username,
            firstName: updatedUser.firstName,
            lastName: updatedUser.lastName,
            profilePicture: updatedUser.profilePicture,
            phoneNumber: updatedUser.phoneNumber,
            dateOfBirth: updatedUser.dateOfBirth,
            address: updatedUser.address,
            emailVerified: updatedUser.emailVerified,
            twoFactorEnabled: updatedUser.preferences?.twoFactorEnabled || false
          }
        }
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la mise \xE0 jour de la photo de profil", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
  /**
   * Suppression du compte utilisateur
   */
  async deleteAccount(req, res, next) {
    const startTime = Date.now();
    try {
      const { userId } = req.user;
      const { password, confirmationText } = req.body;
      if (!password || confirmationText !== "DELETE") {
        logger12.warn("Tentative de suppression de compte avec donn\xE9es manquantes", {
          userId,
          hasPassword: !!password,
          hasConfirmation: confirmationText === "DELETE"
        });
        res.status(400).json({
          success: false,
          message: 'Mot de passe et confirmation requis (tapez "DELETE")'
        });
        return;
      }
      logger12.info("Tentative de suppression de compte", { userId, ip: req.ip });
      const isPasswordValid = await this.userService.verifyPassword(userId, password);
      if (!isPasswordValid) {
        logger12.warn("Suppression de compte \xE9chou\xE9e - mot de passe incorrect", { userId });
        res.status(401).json({
          success: false,
          message: "Mot de passe incorrect"
        });
        return;
      }
      const user = await this.userService.getUserById(userId);
      if (!user) {
        logger12.error("Utilisateur non trouv\xE9 lors de la suppression", { userId });
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      await this.userService.deleteUser(userId);
      await this.authService.logout(userId);
      const asyncOperations = [
        this.securityAuditService.logEvent({
          eventType: "ACCOUNT_DELETED",
          userId,
          ipAddress: req.ip,
          userAgent: req.headers["user-agent"]
        }),
        this.notificationService.sendAccountDeletedEmail(
          user.email,
          user.firstName || ""
        )
      ];
      await Promise.all(asyncOperations);
      const executionTime = Date.now() - startTime;
      logger12.info("Compte supprim\xE9 avec succ\xE8s", {
        userId,
        email: user.email.substring(0, 5) + "***",
        executionTime: `${executionTime}ms`
      });
      res.status(200).json({
        success: true,
        message: "Compte supprim\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      const executionTime = Date.now() - startTime;
      logger12.error("Erreur lors de la suppression du compte", {
        error: error2.message,
        stack: error2.stack,
        userId: req.user?.userId,
        executionTime: `${executionTime}ms`
      });
      next(error2);
    }
  }
};
var authControllers_default = AuthControllers;

// src/auth/routers/authrouters.ts
var authController = new authControllers_default();
var authRouter = express.Router();
authRouter.post(
  "/register",
  // apiLimiter,
  // authLimiter,
  sensitiveRequestLogger_default,
  validate_default.register,
  authController.register.bind(authController)
  // register
);
authRouter.post(
  "/verify-email",
  validate_default.twoFactor,
  authController.verifyEmailCode.bind(authController)
);
authRouter.post(
  "/verifyAccount",
  authController.verifyAccount.bind(authController)
);
authRouter.post(
  "/resend-verification",
  authController.resendVerificationEmail.bind(authController)
);
authRouter.post(
  "/login",
  // apiLimiter,
  // authLimiter,
  sensitiveRequestLogger_default,
  validate_default.login,
  authController.login.bind(authController)
);
authRouter.post(
  "/refresh-token",
  validate_default.refreshToken,
  // apiLimiter,
  authController.refreshToken.bind(authController)
);
authRouter.post(
  "/forgot-password",
  // apiLimiter,
  // authLimiter,
  sensitiveRequestLogger_default,
  validate_default.forgotpassword,
  authController.forgotPassword.bind(authController)
);
authRouter.post(
  "/reset-password",
  // apiLimiter,
  // sensitiveOperationLimiter,
  sensitiveRequestLogger_default,
  validate_default.resetPassword,
  authController.resetPassword.bind(authController)
);
authRouter.post("/change-Password", authenticate_default, authController.changePassword.bind(authController));
authRouter.get(
  "/verify-email/:token",
  // // apiLimiter,
  validate_default.verifyEmail,
  authController.verifyEmail.bind(authController)
);
authRouter.post("/resend-verification-email", authController.resendVerificationEmail.bind(authController));
authRouter.post(
  "/logout",
  authenticate_default,
  authController.logout.bind(authController)
);
authRouter.post(
  "/2fa/setup",
  authenticate_default,
  //   // sensitiveOperationLimiter,
  sensitiveRequestLogger_default,
  authController.setupTwoFactor.bind(authController)
);
authRouter.post(
  "/2fa/verify",
  authenticate_default,
  sensitiveRequestLogger_default,
  validate_default.verifyTwoFactor,
  authController.verifyTwoFactor.bind(authController)
);
authRouter.post(
  "/2fa/disable",
  authenticate_default,
  // requireTwoFactor,
  // sensitiveOperationLimiter,
  sensitiveRequestLogger_default,
  validate_default.password,
  authController.disableTwoFactor.bind(authController)
);
authRouter.get("/validateTwoFactorLogin", authController.validateTwoFactorLogin.bind(authController));
authRouter.get(
  "/get-profile",
  authenticate_default,
  authController.getProfile.bind(authController)
);
authRouter.put(
  "/update-profile",
  authenticate_default,
  validate_default.updateProfilePicture,
  authController.updateProfilePicture.bind(authController)
);
authRouter.patch("/updateProfile", authController.updateProfile.bind(authController));
authRouter.delete("/deleteAccount", authController.deleteAccount.bind(authController));
var authrouters_default = authRouter;

// src/property/propertyRoute/propertyrouters.ts
import express2 from "express";

// src/property/controllers/propertyControllers.ts
init_logger();
init_proprityServices();
var logger23 = createLogger2("propertyservices");
var PropertyController = class {
  constructor() {
    __publicField(this, "propertyServices");
    this.propertyServices = new proprityServices_default();
  }
  async createProperty(req, res, next) {
    try {
      const propertyData = req.body;
      const userId = req.user?.userId;
      const property2 = await this.propertyServices.createProperty(propertyData, userId);
      res.status(201).json({
        success: true,
        message: "property  created",
        data: property2
      });
    } catch (error2) {
      logger23.error("Erreur lors de la cr\xE9ation de la propri\xE9t\xE9:", error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la cr\xE9ation de la propri\xE9t\xE9",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async deletedProperty(req, res, next) {
    try {
      const { id } = req.params;
      const property2 = await this.propertyServices.deleteProperty(id);
      if (!property2) {
        res.status(404).json({
          success: false,
          message: "Propri\xE9t\xE9 non trouv\xE9e"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Propri\xE9t\xE9 supprim\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      logger23.error(`Erreur lors de la suppression de la propri\xE9t\xE9 ${req.params.id}:`, error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la suppression de la propri\xE9t\xE9",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async getProperties(req, res, next) {
    const filters = req.query;
    try {
      const properies = await this.propertyServices.getProperty(filters);
      if (!properies || properies.properties.length === 0) {
        logger23.error("properties not found");
        res.status(404).json({
          success: false,
          message: "properties not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "property found",
        data: properies
      });
    } catch (error2) {
      logger23.error("error fetching properties", error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des propri\xE9t\xE9s",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async getPropertyByOwner(req, res, next) {
    const { id } = req.params;
    const { page = 1, limit = 10, sortBy, sortOrder, status } = req.query;
    const filters = {
      ownerId: id,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        sortBy,
        sortOrder
      },
      status
    };
    try {
      const property2 = await this.propertyServices.getPropertyByOwner(filters);
      if (!property2) {
        res.status(404).json({
          success: false,
          message: "property not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Properties found",
        data: property2
      });
    } catch (error2) {
      logger23.error("error fetching properties", error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des propri\xE9t\xE9s",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async getPropertyByID(req, res, next) {
    const { id } = req.params;
    try {
      const property2 = await this.propertyServices.finPropertyById(id);
      if (!property2) {
        res.status(404).json({
          success: false,
          message: "property not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Property found",
        data: property2
      });
    } catch (error2) {
      logger23.error("error fetching property", error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration de la propri\xE9t\xE9",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async getPropertyState(req, res, next) {
    try {
      const stats = await this.propertyServices.getPropertyState();
      if (!stats) {
        logger23.warn("Statistics not found");
        res.status(404).json({
          success: false,
          message: "Statistics not found"
        });
        return;
      }
      logger23.info("Statistiques des propri\xE9t\xE9s r\xE9cup\xE9r\xE9es");
      res.status(200).json({
        success: true,
        data: stats
      });
    } catch (error2) {
      logger23.error("error fetching property state", error2);
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des statistiques",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async getSimilarProperty(req, res, next) {
    const { id } = req.params;
    const { limit = 10 } = req.query;
    const filter2 = {
      propertyId: id,
      pagination: {
        limit: Number(limit)
      }
    };
    try {
      const similarProperty = await this.propertyServices.getSImilarProperty(filter2);
      if (!similarProperty) {
        res.status(404).json({
          success: false,
          message: "similar properties not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Similar properties found",
        data: similarProperty
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des propri\xE9t\xE9s similaires",
        error: error2 instanceof Error ? error2.message : "Erreur inconnue"
      });
      next(error2);
    }
  }
  async permanentDeletion(req, res, next) {
    const { id } = req.params;
    try {
      const deletProperty = await this.propertyServices.permanentDeleteProperty(id);
      if (!deletProperty) {
        res.status(404).json({
          success: false,
          message: "property not found or not deleted"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "property permanently deleted"
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "error deleting property",
        error: error2 instanceof Error ? error2.message : "unknown error"
      });
      next(error2);
    }
  }
  async restoreProperty(req, res, next) {
    const { id } = req.params;
    try {
      const propertyRestore = await this.propertyServices.restoreProperty(id);
      if (!propertyRestore) {
        res.status(404).json({
          success: false,
          message: "property not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "property restored",
        data: propertyRestore
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "error restoring property",
        error: error2 instanceof Error ? error2.message : "unknown error"
      });
      next(error2);
    }
  }
  async searchProperty(req, res, next) {
    try {
      const q = req.query.q || "";
      const page = parseInt(req.query.page || "1", 10);
      const limit = parseInt(req.query.limit || "10", 10);
      const queryData = {
        q,
        pagination: { page, limit }
      };
      const searchProperty = await this.propertyServices.searchProperty(queryData);
      if (!searchProperty || searchProperty.property && searchProperty.property.length === 0) {
        res.status(404).json({
          success: false,
          message: "properties not found"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "properties found",
        data: searchProperty
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "error searching property",
        error: error2 instanceof Error ? error2.message : "unknown error"
      });
      next(error2);
    }
  }
  async updateProperty(req, res, next) {
    const { id } = req.params;
    const data = req.body;
    const propertyData = { propertyId: id, data };
    try {
      const updateProperty = await this.propertyServices.updateProperty(propertyData);
      if (!updateProperty) {
        res.status(404).json({
          success: false,
          message: "property not found or not updated"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "property updated",
        data: updateProperty
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "error updating property",
        error: error2 instanceof Error ? error2.message : "unknown error"
      });
      next(error2);
    }
  }
};
var propertyControllers_default = PropertyController;

// src/property/middlewares/checkOwnerAuthorization.ts
init_logger();
import mongoose8 from "mongoose";
var logger24 = createLogger2("propertyMiddleware");
var checkOwnerAuthorization = async (req, res, next) => {
  try {
    const propertyId = req.params.id;
    const userId = req.user?.userId;
    if (!userId) {
      res.status(401).json({
        success: false,
        message: "Authentification requise"
      });
      return;
    }
    const Property2 = mongoose8.model("Property");
    const property2 = await Property2.findById(propertyId);
    if (!property2) {
      res.status(404).json({
        success: false,
        message: "Propri\xE9t\xE9 non trouv\xE9e"
      });
      return;
    }
    if (property2.ownerId.toString() !== userId && req.user?.role !== "admin") {
      res.status(403).json({
        success: false,
        message: "Vous n'\xEAtes pas autoris\xE9 \xE0 effectuer cette action"
      });
      return;
    }
    next();
  } catch (error2) {
    logger24.error("Erreur lors de la v\xE9rification de l'autorisation:", error2);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la v\xE9rification de l'autorisation"
    });
  }
};
var checkOwnerAuthorization_default = checkOwnerAuthorization;

// src/property/middlewares/rateLimiter.ts
var rateLimiter = (windowMs, maxRequests) => {
  const requests = {};
  return (req, res, next) => {
    const now = Date.now();
    const ip = req.ip || req.headers["x-forwarded-for"] || req.socket.remoteAddress || "unknown";
    for (const key in requests) {
      if (now > requests[key].resetTime) {
        delete requests[key];
      }
    }
    if (!requests[ip]) {
      requests[ip] = {
        count: 0,
        resetTime: now + windowMs
      };
    }
    if (now > requests[ip].resetTime) {
      requests[ip].count = 0;
      requests[ip].resetTime = now + windowMs;
    }
    if (requests[ip].count >= maxRequests) {
      res.status(429).json({
        success: false,
        message: "Trop de requ\xEAtes, veuillez r\xE9essayer plus tard"
      });
      return;
    }
    requests[ip].count += 1;
    res.set({
      "X-RateLimit-Limit": maxRequests.toString(),
      "X-RateLimit-Remaining": (maxRequests - requests[ip].count).toString(),
      "X-RateLimit-Reset": Math.ceil(requests[ip].resetTime / 1e3).toString()
    });
    next();
  };
};
var rateLimiter_default = rateLimiter;

// src/property/propertyRoute/propertyrouters.ts
import asyncHandler from "express-async-handler";

// src/property/middlewares/validatePropertyId.ts
import { param as param2, validationResult as validationResult2 } from "express-validator";
import mongoose9 from "mongoose";
var validations2 = [
  param2("id").notEmpty().withMessage("L'ID de la propri\xE9t\xE9 est requis").bail().custom((value) => mongoose9.Types.ObjectId.isValid(value)).withMessage("L'ID de la propri\xE9t\xE9 n'est pas valide")
];
var validatePropertyId = async (req, res, next) => {
  for (const validation of validations2) {
    await validation.run(req);
  }
  const errors2 = validationResult2(req);
  if (!errors2.isEmpty()) {
    res.status(400).json({
      success: false,
      errors: errors2.array().map((err) => ({
        field: err.msg,
        message: err.msg
      }))
    });
    return;
  }
  next();
};
var validatePropertyId_default = validatePropertyId;

// src/property/controllers/updatePropertyStatus.ts
init_propertyModel();
init_propertyType();
init_logger();
var logger25 = createLogger2("propertyController");
var updatePropertyStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    if (!Object.values(PropertyStatus).includes(status)) {
      res.status(400).json({
        success: false,
        message: `Statut invalide. Les statuts valides sont: ${Object.values(PropertyStatus).join(", ")}`
      });
      return;
    }
    const property2 = await propertyModel_default.findByIdAndUpdate(
      id,
      { status },
      { new: true, runValidators: true }
    ).lean();
    if (!property2) {
      res.status(404).json({
        success: false,
        message: "Propri\xE9t\xE9 non trouv\xE9e"
      });
      return;
    }
    logger25.info(`Statut de la propri\xE9t\xE9 ${id} mis \xE0 jour: ${status}`);
    res.status(200).json({
      success: true,
      message: "Statut de la propri\xE9t\xE9 mis \xE0 jour avec succ\xE8s",
      data: property2
    });
  } catch (error2) {
    logger25.error(`Erreur lors de la mise \xE0 jour du statut de la propri\xE9t\xE9 ${req.params.id}:`, error2);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la mise \xE0 jour du statut de la propri\xE9t\xE9",
      error: error2 instanceof Error ? error2.message : "Erreur inconnue"
    });
  }
};
var updatePropertyStatus_default = updatePropertyStatus;

// src/property/middlewares/validateCreateProperty.ts
init_propertyType();
import { body as body2, validationResult as validationResult3 } from "express-validator";
import mongoose10 from "mongoose";
var validate2 = {
  property: () => [
    body2("title").notEmpty().withMessage("The title is required").isString().withMessage("The title must be a string").isLength({ max: 50 }).withMessage("Title must not have more than 50 characters").trim(),
    body2("description").notEmpty().withMessage("La description est requise").isString().withMessage("La description doit \xEAtre une cha\xEEne de caract\xE8res").isLength({ min: 80 }).withMessage("La description doit contenir au moins 80 caract\xE8res").trim(),
    body2("address").notEmpty().withMessage("L'adresse est requise").isString().withMessage("L'adresse doit \xEAtre une cha\xEEne de caract\xE8res").isLength({ min: 10 }).withMessage("L'adresse doit contenir au moins 10 caract\xE8res").trim(),
    body2("monthlyRent").notEmpty().withMessage("Le loyer mensuel est requis").isNumeric().withMessage("Le loyer mensuel doit \xEAtre un nombre").custom((value) => value >= 0).withMessage("Le loyer mensuel doit \xEAtre un nombre positif"),
    body2("depositAmount").optional().isNumeric().withMessage("Le montant de la caution doit \xEAtre un nombre").custom((value) => value >= 0).withMessage("Le montant de la caution doit \xEAtre un nombre positif"),
    body2("maxOccupants").optional().isInt({ min: 1 }).withMessage("Le nombre maximum d'occupants doit \xEAtre un entier positif"),
    body2("bedrooms").notEmpty().withMessage("Le nombre de chambres est requis").isInt({ min: 0 }).withMessage("Le nombre de chambres doit \xEAtre un entier positif ou nul"),
    body2("bathrooms").notEmpty().withMessage("Le nombre de salles de bain est requis").isInt({ min: 0 }).withMessage("Le nombre de salles de bain doit \xEAtre un entier positif ou nul"),
    body2("area").notEmpty().withMessage("La zone/quartier est requise").isString().withMessage("La zone/quartier doit \xEAtre une cha\xEEne de caract\xE8res").trim(),
    body2("ownerId").notEmpty().withMessage("L'identifiant du propri\xE9taire est requis").custom((value) => mongoose10.Types.ObjectId.isValid(value)).withMessage("L'identifiant du propri\xE9taire n'est pas valide"),
    body2("images").isArray({ min: 1 }).withMessage("Au moins une image est requise").custom((value) => {
      if (!Array.isArray(value)) return false;
      return value.every((item) => typeof item === "string" && item.trim().length > 0);
    }).withMessage("Toutes les images doivent \xEAtre des URLs valides"),
    body2("amenities").optional().isArray().withMessage("Les commodit\xE9s doivent \xEAtre un tableau").custom((value) => {
      if (!Array.isArray(value)) return true;
      return value.every((item) => typeof item === "string" && item.trim().length > 0);
    }).withMessage("Toutes les commodit\xE9s doivent \xEAtre des cha\xEEnes de caract\xE8res non vides"),
    body2("availableFrom").optional().isISO8601().withMessage("La date de disponibilit\xE9 doit \xEAtre une date ISO 8601 valide").toDate(),
    body2("surface").notEmpty().withMessage("La surface est requise").isNumeric().withMessage("La surface doit \xEAtre un nombre").custom((value) => value >= 1).withMessage("La surface doit \xEAtre un nombre positif"),
    body2("rooms").optional().isInt({ min: 1 }).withMessage("Le nombre de pi\xE8ces doit \xEAtre un entier positif"),
    body2("status").optional().isIn(Object.values(PropertyStatus)).withMessage(`Le statut doit \xEAtre l'un des suivants: ${Object.values(PropertyStatus).join(", ")}`),
    // Validation personnalisée pour vérifier que le nombre de chambres et de salles de bain ne dépasse pas le nombre de pièces
    body2().custom((value) => {
      const { bedrooms, bathrooms, rooms } = value;
      if (rooms !== void 0 && bedrooms + bathrooms > rooms) {
        throw new Error("Le nombre total de chambres et salles de bain ne peut pas d\xE9passer le nombre de pi\xE8ces");
      }
      return true;
    })
  ]
};
var validationRules2 = {
  validateProperty: validate2.property()
};
var validateCreateProperty_default = validationRules2;

// src/property/propertyRoute/propertyrouters.ts
var property = new propertyControllers_default();
var propertyRouter = express2.Router();
propertyRouter.use(rateLimiter_default(15 * 60 * 1e3, 100));
propertyRouter.get("/search", property.searchProperty.bind(property));
propertyRouter.post(
  "/",
  authenticate_default,
  validateCreateProperty_default.validateProperty,
  // checkOwnerAuthorization,
  property.createProperty.bind(property)
);
propertyRouter.patch("/:id", property.updateProperty.bind(property));
propertyRouter.get(
  "/",
  // authenticate,
  // checkOwnerAuthorization,
  asyncHandler(property.getProperties.bind(property))
);
propertyRouter.get("/owner/:ownerId", property.getPropertyByOwner.bind(property));
propertyRouter.get("/:id", validatePropertyId_default, property.getPropertyByID.bind(property));
propertyRouter.get("/:id/similar", property.getSimilarProperty.bind(property));
propertyRouter.get("/stats", property.getPropertyState.bind(property));
propertyRouter.delete("/:id", authenticate_default, checkOwnerAuthorization_default, property.deletedProperty.bind(property));
propertyRouter.delete("/permanent/:id", authenticate_default, checkOwnerAuthorization_default, validatePropertyId_default, property.permanentDeletion.bind(property));
propertyRouter.put("/restore/:id", authenticate_default, checkOwnerAuthorization_default, validatePropertyId_default, property.restoreProperty.bind(property));
propertyRouter.patch("/status/:id", updatePropertyStatus_default);
var propertyrouters_default = propertyRouter;

// src/app.ts
init_logger();

// src/users/routes/routes.ts
import { Router } from "express";

// src/users/controllers/userController.ts
init_userService();
init_securityAuditServices();
init_notificationServices();
init_logger();
var logger26 = createLogger2("UserController");
var userService = new UserService();
var securityAuditService = SecurityAuditService.getInstance();
var notificationService = new NotificationService();
var UserController = class {
  // ----------------------------
  // Méthode frontend : utilisateur connecté
  // ----------------------------
  async getCurrentUser(req, res, next) {
    try {
      const currentUserId = req.user.userId;
      const user = await userService.getUserById(currentUserId);
      if (!user) {
        res.status(404).json({ success: false, message: "Utilisateur non trouv\xE9" });
        return;
      }
      const userData = {
        id: user.id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        phoneNumber: user.phoneNumber,
        photo: user.profilePicture,
        role: user.role,
        isActive: user.isActive,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
        preferences: user.preferences,
        isEmailVerified: user.emailVerified,
        lasLogin: user.lastLogin
      };
      res.status(200).json({
        success: true,
        message: "Informations utilisateur r\xE9cup\xE9r\xE9es avec succ\xE8s",
        data: userData
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Obtenir la liste des utilisateurs avec pagination et filtres
   */
  async getUsers(req, res, next) {
    try {
      const { page = 1, limit = 10, sortBy = "createdAt", sortOrder = "desc", ...filters } = req.query;
      const validSortOrder = sortOrder === "asc" ? "asc" : "desc";
      const filterOptions = {
        page: Number(page),
        limit: Number(limit),
        sortBy: String(sortBy),
        sortOrder: validSortOrder,
        ...filters
      };
      const users = await userService.getUsers(filterOptions);
      res.status(200).json({
        success: true,
        message: "Utilisateurs r\xE9cup\xE9r\xE9s avec succ\xE8s",
        data: users.data,
        pagination: {
          total: users.total,
          page: users.page,
          limit: users.limit,
          totalPages: Math.ceil(users.total / users.limit)
        }
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Obtenir les détails d'un utilisateur spécifique
   */
  async getUserById(req, res, next) {
    try {
      const { id } = req.params;
      const user = await userService.getUserById(id);
      if (!user) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      res.status(200).json({
        success: true,
        message: "Utilisateur r\xE9cup\xE9r\xE9 avec succ\xE8s",
        data: user
      });
    } catch (error2) {
      next(error2);
    }
  }
  // handle user  notification  configuration 
  async configureNotification(req, res) {
    const userId = req.params.userId;
    const { email_activate, push_activate } = req.body;
    try {
      const updatedUser = await userService.configureNotification(userId, {
        email_activate,
        push_activate
      });
      if (!updatedUser) {
        return res.status(404).json({ message: "notification configuration  has  not  been  applyed" });
      }
      return res.status(200).json({
        message: "Notification settings updated",
        user: updatedUser
      });
    } catch (error2) {
      console.error(error2);
      return res.status(500).json({ message: "Internal server error" });
    }
  }
  /**
   * Recherche avancée d'utilisateurs
   */
  async searchUsers(req, res, next) {
    try {
      const {
        query: query2,
        page = 1,
        limit = 10,
        fields = [],
        filters = {},
        sortBy = "createdAt",
        sortOrder = "desc"
      } = req.body;
      const validSortOrder = sortOrder === "asc" ? "asc" : "desc";
      const searchOptions = {
        query: query2,
        page: Number(page),
        limit: Number(limit),
        fields: Array.isArray(fields) ? fields : [fields],
        filters,
        sortBy: String(sortBy),
        sortOrder: validSortOrder
      };
      const searchResults = await userService.searchUsers(searchOptions);
      res.status(200).json({
        success: true,
        message: "Recherche effectu\xE9e avec succ\xE8s",
        data: searchResults.data,
        pagination: {
          total: searchResults.total,
          page: searchResults.page,
          limit: searchResults.limit,
          totalPages: Math.ceil(searchResults.total / searchResults.limit)
        }
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Mettre à jour un utilisateur
   */
  async updateUser(req, res, next) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      const currentUserId = req.user.userId;
      const existingUser = await userService.getUserById(id);
      if (!existingUser) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const updatedUser = await userService.updateUser(id, updateData);
      const auditData = {
        eventType: "USER_UPDATED",
        userId: id,
        performedBy: currentUserId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { updatedFields: Object.keys(updateData) }
      };
      await securityAuditService.logEvent(auditData);
      logger26.info("Utilisateur mis \xE0 jour", {
        userId: id,
        updatedBy: currentUserId,
        updatedFields: Object.keys(updateData)
      });
      res.status(200).json({
        success: true,
        message: "Utilisateur mis \xE0 jour avec succ\xE8s",
        data: updatedUser
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Activer un compte utilisateur
   */
  async activateUser(req, res, next) {
    try {
      const { id } = req.params;
      const currentUserId = req.user.userId;
      const existingUser = await userService.getUserById(id);
      if (!existingUser) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const activatedUser = await userService.updateUser(id, { isActive: true });
      const auditData = {
        eventType: "USER_ACTIVATED",
        userId: id,
        performedBy: currentUserId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      };
      await securityAuditService.logEvent(auditData);
      await notificationService.sendAccountStatusNotification(
        existingUser.email,
        existingUser.firstName,
        "activated"
      );
      logger26.info("Utilisateur activ\xE9", {
        userId: id,
        activatedBy: currentUserId
      });
      res.status(200).json({
        success: true,
        message: "Utilisateur activ\xE9 avec succ\xE8s",
        data: activatedUser
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Désactiver un compte utilisateur
   */
  async deactivateUser(req, res, next) {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const currentUserId = req.user.userId;
      const existingUser = await userService.getUserById(id);
      if (!existingUser) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const updateData = {
        isActive: false,
        deactivationReason: reason,
        deactivatedAt: /* @__PURE__ */ new Date(),
        deactivatedBy: currentUserId
      };
      const deactivatedUser = await userService.updateUser(id, updateData);
      const auditData = {
        eventType: "USER_DEACTIVATED",
        userId: id,
        performedBy: currentUserId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        details: { reason }
      };
      await securityAuditService.logEvent(auditData);
      await notificationService.sendAccountStatusNotification(
        existingUser.email,
        existingUser.firstName,
        "deactivated",
        reason
        // Optional comment parameter
      );
      logger26.info("Utilisateur d\xE9sactiv\xE9", {
        userId: id,
        deactivatedBy: currentUserId,
        reason
      });
      res.status(200).json({
        success: true,
        message: "Utilisateur d\xE9sactiv\xE9 avec succ\xE8s",
        data: deactivatedUser
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Supprimer un utilisateur (soft delete)
   */
  async deleteUser(req, res, next) {
    try {
      const { id } = req.params;
      const currentUserId = req.user.userId;
      const existingUser = await userService.getUserById(id);
      if (!existingUser) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      await userService.softDeleteUser(id, currentUserId);
      const auditData = {
        eventType: "USER_DELETED",
        userId: id,
        performedBy: currentUserId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"]
      };
      await securityAuditService.logEvent(auditData);
      logger26.info("Utilisateur supprim\xE9", {
        userId: id,
        deletedBy: currentUserId
      });
      res.status(200).json({
        success: true,
        message: "Utilisateur supprim\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      next(error2);
    }
  }
  /**
   * Obtenir l'historique des activités d'un utilisateur
   */
  async getUserActivityLogs(req, res, next) {
    try {
      const { id } = req.params;
      const { page = 1, limit = 20, eventType } = req.query;
      const existingUser = await userService.getUserById(id);
      if (!existingUser) {
        res.status(404).json({
          success: false,
          message: "Utilisateur non trouv\xE9"
        });
        return;
      }
      const activityLogs = await securityAuditService.getUserActivityLogs(
        id,
        {
          page: Number(page),
          limit: Number(limit),
          eventType: eventType ? String(eventType) : void 0
        }
      );
      res.status(200).json({
        success: true,
        message: "Logs d'activit\xE9 r\xE9cup\xE9r\xE9s avec succ\xE8s",
        data: activityLogs.data,
        pagination: {
          total: activityLogs.total,
          page: activityLogs.page,
          limit: activityLogs.limit,
          totalPages: Math.ceil(activityLogs.total / activityLogs.limit)
        }
      });
    } catch (error2) {
      next(error2);
    }
  }
};

// src/users/middleware/authMiddleware.ts
init_authService();
init_userService();
init_config();
import jwt3 from "jsonwebtoken";
var authService2 = new AuthService(new UserService());
var authenticate2 = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(" ")[1];
  if (!token) {
    res.status(401).json({ message: "Token manquant" });
    return;
  }
  try {
    const decoded = jwt3.verify(token, config_default.auth.jwtSecret);
    const user = await authService2["userService"].getUserById(decoded.userId);
    if (!user || !user.isActive) {
      res.status(403).json({ message: "Utilisateur inactif ou non trouv\xE9" });
      return;
    }
    req.user = user;
    next();
  } catch (err) {
    res.status(401).json({ message: "Token invalide ou expir\xE9" });
    return;
  }
};

// src/users/routes/routes.ts
var userRouter = Router();
var userController = new UserController();
userRouter.get("/users", authenticate2, userController.getUsers.bind(userController));
userRouter.get("/users/me", authenticate2, userController.getCurrentUser.bind(userController));
userRouter.get("/users/:id", authenticate2, userController.getUserById.bind(userController));
userRouter.post("/users/search", authenticate2, userController.searchUsers.bind(userController));
userRouter.put("/users/:id", authenticate2, userController.updateUser.bind(userController));
userRouter.put("/users/:id/activate", authenticate2, userController.activateUser.bind(userController));
userRouter.put("/users/:id/deactivate", authenticate2, userController.deactivateUser.bind(userController));
userRouter.delete("/users/:id", authenticate2, userController.deleteUser.bind(userController));
userRouter.get("/users/:id/activity-logs", authenticate2, userController.getUserActivityLogs.bind(userController));
var routes_default = userRouter;

// src/wallet/routes/walletRoutes.ts
import { Router as Router2 } from "express";

// src/wallet/controllers/walletController.ts
init_walletService();
init_paymentMethodService();
init_cryptoService();
var WalletController = class {
  constructor() {
    __publicField(this, "walletService", new WalletService());
    __publicField(this, "paymentMethodService", new PaymentMethodService());
    __publicField(this, "cryptoService", new CryptoService());
  }
  async getWallet(req, res) {
    try {
      const userId = req.user?.userId;
      let wallet = await this.walletService.getWallet(userId);
      if (!wallet) {
        wallet = await this.walletService.createWallet(userId);
      }
      const paymentMethods = await this.paymentMethodService.getPaymentMethods(userId);
      res.json({
        success: true,
        data: {
          ...wallet,
          paymentMethods
        }
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration du portefeuille",
        error: error2.message
      });
    }
  }
  async getTransactions(req, res) {
    try {
      const userId = req.user?.userId;
      const limit = parseInt(req.query.limit) || 50;
      const transactions = await this.walletService.getTransactions(userId, limit);
      res.json({
        success: true,
        data: transactions
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des transactions",
        error: error2.message
      });
    }
  }
  async createTransaction(req, res) {
    try {
      const userId = req.user?.userId;
      const transactionData = req.body;
      const transaction = await this.walletService.processPayment(userId, transactionData);
      res.status(201).json({
        success: true,
        message: "Transaction cr\xE9\xE9e avec succ\xE8s",
        data: transaction
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la cr\xE9ation de la transaction",
        error: error2.message
      });
    }
  }
  async transferMoney(req, res) {
    try {
      const userId = req.user?.userId;
      const transferData = req.body;
      const transaction = await this.walletService.transferMoney(userId, transferData);
      res.json({
        success: true,
        message: "Transfert effectu\xE9 avec succ\xE8s",
        data: transaction
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors du transfert",
        error: error2.message
      });
    }
  }
  async addPaymentMethod(req, res) {
    try {
      const userId = req.user?.userId;
      const methodData = req.body;
      const paymentMethod = await this.paymentMethodService.createPaymentMethod(userId, methodData);
      res.status(201).json({
        success: true,
        message: "M\xE9thode de paiement ajout\xE9e avec succ\xE8s",
        data: paymentMethod
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de l'ajout de la m\xE9thode de paiement",
        error: error2.message
      });
    }
  }
  async deletePaymentMethod(req, res) {
    try {
      const userId = req.user?.userId;
      const { methodId } = req.params;
      await this.paymentMethodService.deletePaymentMethod(userId, methodId);
      res.json({
        success: true,
        message: "M\xE9thode de paiement supprim\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la suppression de la m\xE9thode de paiement",
        error: error2.message
      });
    }
  }
  async setDefaultPaymentMethod(req, res) {
    try {
      const userId = req.user?.userId;
      const { methodId } = req.params;
      await this.paymentMethodService.setDefaultPaymentMethod(userId, methodId);
      res.json({
        success: true,
        message: "M\xE9thode de paiement par d\xE9faut mise \xE0 jour"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la mise \xE0 jour de la m\xE9thode par d\xE9faut",
        error: error2.message
      });
    }
  }
  async getTransactionById(req, res) {
    try {
      const userId = req.user?.userId;
      const { transactionId } = req.params;
      const transaction = await this.walletService.getTransactionById(userId, transactionId);
      if (!transaction) {
        return res.status(404).json({
          success: false,
          message: "Transaction non trouv\xE9e"
        });
      }
      res.json({
        success: true,
        data: transaction
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration de la transaction",
        error: error2.message
      });
    }
  }
  async buyCrypto(req, res) {
    try {
      const userId = req.user?.userId;
      const { currency, amount, totalCost } = req.body;
      await this.cryptoService.buyCrypto(userId, currency, amount, totalCost);
      res.json({
        success: true,
        message: "Achat de crypto effectu\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de l'achat de crypto",
        error: error2.message
      });
    }
  }
  async sellCrypto(req, res) {
    try {
      const userId = req.user?.userId;
      const { currency, amount, totalValue } = req.body;
      await this.cryptoService.sellCrypto(userId, currency, amount, totalValue);
      res.json({
        success: true,
        message: "Vente de crypto effectu\xE9e avec succ\xE8s"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la vente de crypto",
        error: error2.message
      });
    }
  }
};

// src/wallet/routes/walletRoutes.ts
var router = Router2();
var walletController = new WalletController();
router.use(authenticate_default);
router.get("/", walletController.getWallet.bind(walletController));
router.get("/transactions", walletController.getTransactions.bind(walletController));
router.post("/transactions", walletController.createTransaction.bind(walletController));
router.get("/transactions/:transactionId", walletController.getTransactionById.bind(walletController));
router.post("/transfer", walletController.transferMoney.bind(walletController));
router.post("/payment-methods", walletController.addPaymentMethod.bind(walletController));
router.delete("/payment-methods/:methodId", walletController.deletePaymentMethod.bind(walletController));
router.patch("/payment-methods/:methodId/default", walletController.setDefaultPaymentMethod.bind(walletController));
router.post("/crypto/buy", walletController.buyCrypto.bind(walletController));
router.post("/crypto/sell", walletController.sellCrypto.bind(walletController));
var walletRoutes_default = router;

// src/service-marketplace/routes/serviceRoutes.ts
import { Router as Router3 } from "express";

// src/service-marketplace/controllers/ServiceController.ts
init_ServiceMarketplaceService();
init_RecommendationEngine();
import multer from "multer";
import path2 from "path";
var storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/services/");
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${Math.round(Math.random() * 1e9)}${path2.extname(file.originalname)}`);
  }
});
var upload = multer({ storage });
var ServiceController = class {
  constructor() {
    __publicField(this, "serviceMarketplace", new ServiceMarketplaceService());
    __publicField(this, "recommendationEngine", new RecommendationEngine());
  }
  async createServiceProvider(req, res) {
    try {
      const userId = req.user?.userId;
      const provider = await this.serviceMarketplace.createServiceProvider(userId, req.body);
      res.status(201).json({
        success: true,
        message: "Profil prestataire cr\xE9\xE9 avec succ\xE8s",
        data: provider
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la cr\xE9ation du profil prestataire",
        error: error2.message
      });
    }
  }
  async createService(req, res) {
    try {
      const userId = req.user?.userId;
      const photos = req.files?.map((file) => file.path) || [];
      const service = await this.serviceMarketplace.createService(userId, req.body, photos);
      res.status(201).json({
        success: true,
        message: "Service cr\xE9\xE9 avec succ\xE8s",
        data: service
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la cr\xE9ation du service",
        error: error2.message
      });
    }
  }
  async getServices(req, res) {
    try {
      const filters = {
        category: req.query.category,
        location: req.query.location,
        propertyType: req.query.propertyType,
        contractType: req.query.contractType,
        priceRange: req.query.minPrice && req.query.maxPrice ? [Number(req.query.minPrice), Number(req.query.maxPrice)] : void 0
      };
      const services = await this.serviceMarketplace.getServices(filters);
      res.json({
        success: true,
        data: services
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des services",
        error: error2.message
      });
    }
  }
  async subscribeToService(req, res) {
    try {
      const userId = req.user?.userId;
      const subscription = await this.serviceMarketplace.subscribeToService(userId, req.body);
      res.status(201).json({
        success: true,
        message: "Abonnement cr\xE9\xE9 avec succ\xE8s",
        data: subscription
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de l'abonnement au service",
        error: error2.message
      });
    }
  }
  async getUserSubscriptions(req, res) {
    try {
      const userId = req.user?.userId;
      const subscriptions = await this.serviceMarketplace.getUserSubscriptions(userId);
      res.json({
        success: true,
        data: subscriptions
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des abonnements",
        error: error2.message
      });
    }
  }
  async pauseSubscription(req, res) {
    try {
      const userId = req.user?.userId;
      const { subscriptionId } = req.params;
      await this.serviceMarketplace.pauseSubscription(userId, subscriptionId);
      res.json({
        success: true,
        message: "Abonnement mis en pause"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors de la mise en pause",
        error: error2.message
      });
    }
  }
  async shareService(req, res) {
    try {
      const userId = req.user?.userId;
      const { subscriptionId } = req.params;
      const { shareWithUserIds } = req.body;
      await this.serviceMarketplace.shareService(userId, subscriptionId, shareWithUserIds);
      res.json({
        success: true,
        message: "Service partag\xE9 avec succ\xE8s"
      });
    } catch (error2) {
      res.status(400).json({
        success: false,
        message: "Erreur lors du partage du service",
        error: error2.message
      });
    }
  }
  async getRecommendations(req, res) {
    try {
      const userId = req.user?.userId;
      const input = req.body;
      const recommendations = await this.recommendationEngine.getRecommendations({
        ...input,
        userProfile: {
          ...input.userProfile,
          userId
        }
      });
      res.json({
        success: true,
        data: recommendations
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la g\xE9n\xE9ration des recommandations",
        error: error2.message
      });
    }
  }
  async getProviderServices(req, res) {
    try {
      const providerId = req.user?.userId;
      const services = await this.serviceMarketplace.getProviderServices(providerId);
      res.json({
        success: true,
        data: services
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des services",
        error: error2.message
      });
    }
  }
  async getServiceStats(req, res) {
    try {
      const { serviceId } = req.params;
      const stats = await this.serviceMarketplace.getServiceStats(serviceId);
      res.json({
        success: true,
        data: stats
      });
    } catch (error2) {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la r\xE9cup\xE9ration des statistiques",
        error: error2.message
      });
    }
  }
};

// src/service-marketplace/routes/serviceRoutes.ts
var router2 = Router3();
var serviceController = new ServiceController();
router2.use(authenticate_default);
router2.post("/provider", serviceController.createServiceProvider.bind(serviceController));
router2.get("/provider/services", serviceController.getProviderServices.bind(serviceController));
router2.post("/", upload.array("photos", 5), serviceController.createService.bind(serviceController));
router2.get("/", serviceController.getServices.bind(serviceController));
router2.get("/:serviceId/stats", serviceController.getServiceStats.bind(serviceController));
router2.post("/subscribe", serviceController.subscribeToService.bind(serviceController));
router2.get("/subscriptions", serviceController.getUserSubscriptions.bind(serviceController));
router2.patch("/subscriptions/:subscriptionId/pause", serviceController.pauseSubscription.bind(serviceController));
router2.patch("/subscriptions/:subscriptionId/share", serviceController.shareService.bind(serviceController));
router2.post("/recommendations", serviceController.getRecommendations.bind(serviceController));
var serviceRoutes_default = router2;

// src/app.ts
var logger27 = createLogger2("app");
console.log("\u{1F4F1} Initialisation de l'application Express...");
logger27.info("\u{1F3D7}\uFE0F Cr\xE9ation de l'instance Express...");
var app = express3();
logger27.info("\u2705 Application Express cr\xE9\xE9e avec succ\xE8s");
app.use(helmet());
app.use(cors({
  origin: (origin2, callback) => {
    if (!origin2 || config_default.cors.origin.includes(origin2)) {
      return callback(null, true);
    }
    return callback(new Error("CORS non autoris\xE9"), false);
  },
  credentials: true,
  methods: config_default.cors.methods,
  optionsSuccessStatus: 204
}));
app.use(compression());
var limiter = lib_default({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: config_default.rateLimit?.max || 100,
  // limite par IP
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    status: "error",
    message: "Trop de requ\xEAtes, veuillez r\xE9essayer plus tard"
  }
});
app.use("/api/", limiter);
app.use(morgan(config_default.logging.format || "dev"));
app.use(express3.json({ limit: "10mb" }));
app.use(express3.urlencoded({ extended: true, limit: "10mb" }));
app.use(express3.static(path3.join(__dirname, "public")));
app.get("/verify-account", (req, res) => {
  res.sendFile(path3.join(__dirname, "public", "verify-account.html"));
});
app.get("/reset-password", (req, res) => {
  res.sendFile(__dirname + "/public/reset-password.html");
});
logger27.info("\u{1F331} Tentative de connexion \xE0 MongoDB...", {
  url: config_default.database.url?.replace(/\/\/([^:]+):([^@]+)@/, "//***:***@"),
  // Masquer les credentials
  options: config_default.database.options
});
mongoose20.connect(config_default.database.url).then(() => {
  console.log("\u2705 Connect\xE9 \xE0 MongoDB");
  logger27.info("\u2705 Connexion MongoDB \xE9tablie avec succ\xE8s", {
    readyState: mongoose20.connection.readyState,
    host: mongoose20.connection.host,
    port: mongoose20.connection.port,
    dbName: mongoose20.connection.name
  });
}).catch((err) => {
  console.error("\u274C Erreur de connexion MongoDB:", err);
  logger27.error("\u{1F4A5} \xC9chec de la connexion MongoDB", {
    error: err.message,
    stack: err.stack,
    code: err.code,
    codeName: err.codeName,
    url: config_default.database.url?.replace(/\/\/([^:]+):([^@]+)@/, "//***:***@")
  });
  process.exit(1);
});
mongoose20.connection.on("error", (err) => {
  logger27.error("\u274C Erreur MongoDB d\xE9tect\xE9e:", {
    error: err.message,
    stack: err.stack,
    code: err.code,
    readyState: mongoose20.connection.readyState,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
});
mongoose20.connection.on("connecting", () => {
  logger27.info("\u{1F504} Connexion \xE0 MongoDB en cours...");
});
mongoose20.connection.on("connected", () => {
  logger27.info("\u2705 MongoDB connect\xE9");
});
mongoose20.connection.on("reconnected", () => {
  logger27.info("\u{1F504} MongoDB reconnect\xE9");
});
mongoose20.connection.on("disconnected", () => {
  logger27.warn("\u26A0\uFE0F MongoDB d\xE9connect\xE9", {
    readyState: mongoose20.connection.readyState,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
});
mongoose20.connection.on("close", () => {
  logger27.info("\u{1F512} Connexion MongoDB ferm\xE9e");
});
process.on("SIGINT", async () => {
  await mongoose20.connection.close();
  logger27.info("\u{1F4F4} Connexion MongoDB ferm\xE9e suite \xE0 l'arr\xEAt de l'application");
  process.exit(0);
});
app.get("/", (req, res) => {
  res.status(200).json({
    status: "success",
    message: "Bienvenue sur l'API EasyRent",
    // version: config.version || '1.0.0',
    environment: config_default.app.env
  });
});
logger27.info("\u{1F6E3}\uFE0F Configuration des routes API...");
try {
  app.use("/api/v1/auth", authrouters_default);
  logger27.debug("\u2705 Route auth configur\xE9e");
  app.use("/api/properties", propertyrouters_default);
  logger27.debug("\u2705 Route properties configur\xE9e");
  app.use("/api", routes_default);
  logger27.debug("\u2705 Route users configur\xE9e");
  app.use("/api/wallet", walletRoutes_default);
  logger27.debug("\u2705 Route wallet configur\xE9e");
  app.use("/api/services", serviceRoutes_default);
  logger27.debug("\u2705 Route services configur\xE9e");
  logger27.info("\u2705 Toutes les routes API sont configur\xE9es");
} catch (error2) {
  logger27.error("\u{1F4A5} Erreur lors de la configuration des routes:", {
    error: error2 instanceof Error ? error2.message : String(error2),
    stack: error2 instanceof Error ? error2.stack : void 0
  });
  throw error2;
}
var app_default = app;

// server.ts
import { Server as IOServer } from "socket.io";
console.log("\n========================================");
console.log("\u{1F680} SERVEUR HTTP - D\xE9marrage");
console.log("========================================\n");
var logger32 = createLogger2("server");
var server;
try {
  console.log("1. Normalisation du port...");
  const port = normalizePort_default(config_default.app.port || process.env.PORT || "3000");
  console.log("\u2705 Port normalis\xE9:", port);
  console.log("2. Cr\xE9ation du serveur HTTP...");
  logger32.info("\u{1F3D7}\uFE0F Cr\xE9ation du serveur HTTP...");
  server = http3.createServer(app_default);
  logger32.info("\u2705 Serveur HTTP cr\xE9\xE9 avec succ\xE8s");
  console.log("\u2705 Serveur HTTP cr\xE9\xE9");
  console.log("3. Initialisation de Socket.io...");
  const io = new IOServer(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST", "PATCH", "DELETE"],
      credentials: true
    }
  });
  console.log("\u2705 Socket.io initialis\xE9");
  console.log("4. Ajout des routes chat...");
  console.log("\u2705 Routes chat ajout\xE9es (SKIPPED)");
  console.log("5. Initialisation WebSocket...");
  new PresenceWebSocketHandler(server);
  console.log("\u2705 WebSocket initialis\xE9");
  console.log("6. GraphQL sera charg\xE9 dynamiquement apr\xE8s le d\xE9marrage...");
  const onListening = () => {
    const addr = server.address();
    const bind2 = typeof addr === "string" ? `pipe ${addr}` : `port ${addr?.port}`;
    logger32.info(`\u{1F680} Serveur d\xE9marr\xE9 sur ${bind2} en mode ${config_default.app.env}`);
    logger32.info(`\u{1F310} URL locale: http://${config_default.network.host}:${port}`);
    logger32.info(`\u{1F680} GraphQL Playground: http://${config_default.network.host}:${port}/graphql`);
  };
  console.log("7. D\xE9marrage du serveur HTTP...");
  logger32.info("\u{1F680} D\xE9marrage du serveur HTTP...", { port, host: "0.0.0.0" });
  server.listen(port, "0.0.0.0", () => {
    console.log(`\u2705 Serveur pr\xEAt sur http://${config_default.network.host}:${port}`);
    logger32.info("\u{1F389} Serveur d\xE9marr\xE9 avec succ\xE8s!", {
      port,
      host: config_default.network.host,
      env: config_default.app.env,
      pid: process.pid
    });
    setTimeout(async () => {
      try {
        console.log("\u{1F680} Chargement dynamique de GraphQL...");
        logger32.info("\u{1F680} Chargement dynamique du serveur GraphQL...");
        const { initializeGraphQLServer: initializeGraphQLServer2 } = await Promise.resolve().then(() => (init_server(), server_exports));
        await initializeGraphQLServer2(app_default, server);
        logger32.info("\u2705 GraphQL Server ready at /graphql");
        console.log(`\u2705 GraphQL disponible sur http://${config_default.network.host}:${port}/graphql`);
      } catch (err) {
        logger32.error("\u274C Failed to initialize GraphQL Server:", {
          error: err.message,
          stack: err.stack
        });
        console.error("\u274C Erreur GraphQL:", err.message);
        console.log("\u26A0\uFE0F Le serveur continue sans GraphQL");
      }
    }, 2e3);
  });
  server.on("error", (error2) => {
    console.error("\u274C Erreur serveur d\xE9tect\xE9e :", error2);
    onError_default(error2);
  });
  server.on("listening", onListening);
  console.log("\u2705 Tous les gestionnaires d'erreurs configur\xE9s");
} catch (error2) {
  console.error("\u{1F4A5} ERREUR FATALE lors de l'initialisation:", error2);
  logger32.error("\u{1F4A5} Erreur fatale:", {
    error: error2 instanceof Error ? error2.message : String(error2),
    stack: error2 instanceof Error ? error2.stack : void 0
  });
  process.exit(1);
}
var gracefulShutdown = (signal) => {
  logger32.info(`${signal} re\xE7u. Arr\xEAt gracieux du serveur...`);
  if (server) {
    server.close(() => {
      logger32.info("\u2705 Serveur arr\xEAt\xE9 proprement");
      process.exit(0);
    });
    setTimeout(() => {
      logger32.error("\u23F0 Fermeture forc\xE9e apr\xE8s 10 secondes");
      process.exit(1);
    }, 1e4);
  } else {
    logger32.warn("\u26A0\uFE0F Serveur non initialis\xE9, arr\xEAt imm\xE9diat");
    process.exit(0);
  }
};
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));
process.on("SIGUSR2", () => {
  logger32.info("SIGUSR2 re\xE7u (nodemon). Red\xE9marrage propre...");
  server.close(() => process.exit(0));
});
process.on("unhandledRejection", (reason, promise) => {
  logger32.error("\u{1F4A5} UNHANDLED PROMISE REJECTION D\xC9TECT\xC9E !", {
    reason: reason instanceof Error ? reason.message : reason,
    stack: reason instanceof Error ? reason.stack : void 0,
    promise: promise.toString(),
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    pid: process.pid
  });
  if (reason instanceof Error) {
    logger32.error("D\xE9tails de l'erreur:", {
      name: reason.name,
      message: reason.message,
      stack: reason.stack
    });
  }
  logger32.info("\u{1F504} Tentative d'arr\xEAt gracieux du serveur...");
  if (server) {
    server.close(() => {
      logger32.error("\u{1F480} Serveur arr\xEAt\xE9 suite \xE0 une rejection non g\xE9r\xE9e");
      process.exit(1);
    });
  } else {
    logger32.error("\u{1F480} Serveur non initialis\xE9, arr\xEAt imm\xE9diat");
    process.exit(1);
  }
});
process.on("uncaughtException", (error2) => {
  logger32.error("\u{1F4A5} UNCAUGHT EXCEPTION D\xC9TECT\xC9E !", {
    name: error2.name,
    message: error2.message,
    stack: error2.stack,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    pid: process.pid
  });
  logger32.error("Contexte de l'exception:", {
    cwd: process.cwd(),
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    uptime: process.uptime()
  });
  onError_default(error2);
  logger32.error("\u{1F480} Arr\xEAt forc\xE9 du processus...");
  process.exit(1);
});
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=server.mjs.map